function _get(e, t, n) {
    return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, n) {
        var r = _superPropBase(e, t);
        if (r) {
            var i = Object.getOwnPropertyDescriptor(r, t);
            return i.get ? i.get.call(n) : i.value
        }
    })(e, t, n || e)
}

function _superPropBase(e, t) {
    for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _getPrototypeOf(e)););
    return e
}

function _possibleConstructorReturn(e, t) {
    return !t || "object" != typeof t && "function" != typeof t ? _assertThisInitialized(e) : t
}

function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function _getPrototypeOf(e) {
    return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e)
    })(e)
}

function _inherits(e, t) {
    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), t && _setPrototypeOf(e, t)
}

function _setPrototypeOf(e, t) {
    return (_setPrototypeOf = Object.setPrototypeOf || function (e, t) {
        return e.__proto__ = t, e
    })(e, t)
}

function _classCallCheck(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function _defineProperties(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
    }
}

function _createClass(e, t, n) {
    return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e
}

function _defineProperty(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}! function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).v3d = {})
}(this, function (t) {
    "use strict";
    var n;

    function o() {}
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }), void 0 === Math.sign && (Math.sign = function (e) {
        return e < 0 ? -1 : 0 < e ? 1 : +e
    }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function (e) {
        if (null == e) throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), n = 1; n < arguments.length; n++) {
            var r = arguments[n];
            if (null != r)
                for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
        }
        return t
    }), void 0 === Object.values && (Object.values = function (e) {
        var t = [];
        for (var n in e) e.hasOwnProperty(n) && t.push(e[n]);
        return t
    }), void 0 === Float32Array.prototype.slice && (Float32Array.prototype.slice = function (e, t) {
        return new this.constructor(this.subarray(e, t))
    }), String.prototype.endsWith || (String.prototype.endsWith = function (e, t) {
        return (void 0 === t || t > this.length) && (t = this.length), this.substring(t - e.length, t) === e
    }), Object.assign(o.prototype, {
        addEventListener: function (e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
        },
        hasEventListener: function (e, t) {
            if (void 0 === this._listeners) return !1;
            var n = this._listeners;
            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
        },
        removeEventListener: function (e, t) {
            if (void 0 !== this._listeners) {
                var n = this._listeners[e];
                if (void 0 !== n) {
                    var r = n.indexOf(t); - 1 !== r && n.splice(r, 1)
                }
            }
        },
        dispatchEvent: function (e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var n = t.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, e)
                }
            }
        }
    });
    for (var r = "3.0.1", Q = 0, K = 1, J = 2, q = 0, Z = 1, $ = 2, ee = 3, te = 4, ne = 5, re = 0, Pe = 1, ie = 2, s = 0, _ = 2, ae = 0, oe = 1, se = 2, le = 3, ce = 4, ue = 5, de = 100, he = 101, pe = 102, fe = 103, me = 104, ve = 200, ge = 201, _e = 202, ye = 203, xe = 204, be = 205, we = 206, Me = 207, Ae = 208, Se = 209, Te = 210, Ee = 0, Ce = 1, Le = 2, Re = 3, De = 4, Ie = 5, Ne = 6, Oe = 7, U = 0, V = 1, G = 2, k = 0, Fe = 1, j = 2, W = 3, X = 4, H = 5, Be = 6, ze = 7, Y = 8, Ue = 301, Ve = 302, Ge = 303, ke = 304, je = 305, We = 306, Xe = 307, He = 1e3, Ye = 1001, qe = 1002, Ze = 1003, Qe = 1004, Ke = 1005, Je = 1006, $e = 1007, et = 1008, tt = 1009, i = 1010, a = 1011, nt = 1012, l = 1013, rt = 1014, it = 1015, at = 1016, c = 1017, u = 1018, d = 1019, ot = 1020, h = 1021, st = 1022, lt = 1023, p = 1024, f = 1025, S = lt, ct = 1026, ut = 1027, dt = 1028, m = 1029, v = 1030, g = 1031, y = 1032, x = 1033, b = 33776, w = 33777, M = 33778, A = 33779, T = 35840, E = 35841, C = 35842, P = 35843, L = 36196, R = 37808, D = 37809, I = 37810, N = 37811, O = 37812, F = 37813, B = 37814, z = 37815, ht = 37816, pt = 37817, ft = 37818, mt = 37819, vt = 37820, gt = 37821, _t = 2300, yt = 2301, xt = 2302, bt = 2400, wt = 2401, Mt = 2402, At = 3e3, St = 3001, Tt = 3007, Et = 3002, Ct = 3003, Pt = 3004, Lt = 3005, Rt = 3006, Dt = 3200, It = 3201, Nt = 3301, Ot = 3302, Ft = 0, Bt = 1, zt = 7680, Ut = 519, Vt = 35044, Gt = 35048, kt = "__V3DL__0000000000", jt = 0, Wt = [], Xt = 0; Xt < 256; Xt++) Wt[Xt] = (Xt < 16 ? "0" : "") + Xt.toString(16);
    var Ht, Yt = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function () {
            var e = 4294967295 * Math.random() | 0,
                t = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                r = 4294967295 * Math.random() | 0;
            return (Wt[255 & e] + Wt[e >> 8 & 255] + Wt[e >> 16 & 255] + Wt[e >> 24 & 255] + "-" + Wt[255 & t] + Wt[t >> 8 & 255] + "-" + Wt[t >> 16 & 15 | 64] + Wt[t >> 24 & 255] + "-" + Wt[63 & n | 128] + Wt[n >> 8 & 255] + "-" + Wt[n >> 16 & 255] + Wt[n >> 24 & 255] + Wt[255 & r] + Wt[r >> 8 & 255] + Wt[r >> 16 & 255] + Wt[r >> 24 & 255]).toUpperCase()
        },
        clamp: function (e, t, n) {
            return Math.max(t, Math.min(n, e))
        },
        euclideanModulo: function (e, t) {
            return (e % t + t) % t
        },
        mapLinear: function (e, t, n, r, i) {
            return r + (e - t) * (i - r) / (n - t)
        },
        lerp: function (e, t, n) {
            return (1 - n) * e + n * t
        },
        smoothstep: function (e, t, n) {
            return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
        },
        smootherstep: function (e, t, n) {
            return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function (e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function (e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function (e) {
            return e * (.5 - Math.random())
        },
        degToRad: function (e) {
            return e * Yt.DEG2RAD
        },
        radToDeg: function (e) {
            return e * Yt.RAD2DEG
        },
        isPowerOfTwo: function (e) {
            return 0 == (e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function (e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function (e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        },
        setQuaternionFromProperEuler: function (e, t, n, r, i) {
            var a = Math.cos,
                o = Math.sin,
                s = a(n / 2),
                l = o(n / 2),
                c = a((t + r) / 2),
                u = o((t + r) / 2),
                d = a((t - r) / 2),
                h = o((t - r) / 2),
                p = a((r - t) / 2),
                f = o((r - t) / 2);
            "XYX" === i ? e.set(s * u, l * d, l * h, s * c) : "YZY" === i ? e.set(l * h, s * u, l * d, s * c) : "ZXZ" === i ? e.set(l * d, l * h, s * u, s * c) : "XZX" === i ? e.set(s * u, l * f, l * p, s * c) : "YXY" === i ? e.set(l * p, s * u, l * f, s * c) : "ZYZ" === i ? e.set(l * f, l * p, s * u, s * c) : console.warn("v3d.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.")
        },
        hashString: function (e) {
            for (var t = 5381, n = e.length; n;) t = 33 * t ^ e.charCodeAt(--n);
            return t >>> 0
        },
        expAverage: function (e, t, n, r) {
            var i = Math.exp(-n / r);
            return e * i + (1 - i) * t
        },
        angleToRange_0_2Pi: function (e) {
            return this.clamp(e - 2 * Math.PI * Math.floor(e / (2 * Math.PI)), 0, 2 * Math.PI)
        },
        angleToRange_mPi_Pi: function (e) {
            var t = e + Math.PI;
            return t %= 2 * Math.PI, t += 2 * Math.PI, t %= 2 * Math.PI, t -= Math.PI
        },
        clampAngle: function (e, t, n) {
            var r = this.angleToRange_0_2Pi(e - t),
                i = this.angleToRange_0_2Pi(n - t);
            return i < r && (r = r < i / 2 + Math.PI ? i : 0), r + t
        }
    };

    function qt(e, t) {
        this.x = e || 0, this.y = t || 0
    }

    function Zt() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("v3d.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.defineProperties(qt.prototype, {
        width: {
            get: function () {
                return this.x
            },
            set: function (e) {
                this.x = e
            }
        },
        height: {
            get: function () {
                return this.y
            },
            set: function (e) {
                this.y = e
            }
        }
    }), Object.assign(qt.prototype, {
        isVector2: !0,
        set: function (e, t) {
            return this.x = e, this.y = t, this
        },
        setScalar: function (e) {
            return this.x = e, this.y = e, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y)
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("v3d.Vector2: .add() now only accepts one argument. Use .addVectors(a, b) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        },
        addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("v3d.Vector2: .sub() now only accepts one argument. Use .subVectors(a, b) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        },
        subScalar: function (e) {
            return this.x -= e, this.y -= e, this
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        },
        multiply: function (e) {
            return this.x *= e.x, this.y *= e.y, this
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this
        },
        divide: function (e) {
            return this.x /= e.x, this.y /= e.y, this
        },
        divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        },
        applyMatrix3: function (e) {
            var t = this.x,
                n = this.y,
                r = e.elements;
            return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
        },
        min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        },
        max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        },
        clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        },
        clampScalar: function (e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
        },
        clampLength: function (e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function (e) {
            return this.x * e.y - this.y * e.x
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        angle: function () {
            var e = Math.atan2(this.y, this.x);
            return e < 0 && (e += 2 * Math.PI), e
        },
        distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function (e) {
            var t = this.x - e.x,
                n = this.y - e.y;
            return t * t + n * n
        },
        manhattanDistanceTo: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        },
        lerpVectors: function (e, t, n) {
            return this.subVectors(t, e).multiplyScalar(n).add(e)
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
        },
        fromBufferAttribute: function (e, t, n) {
            return void 0 !== n && console.warn("v3d.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
        },
        rotateAround: function (e, t) {
            var n = Math.cos(t),
                r = Math.sin(t),
                i = this.x - e.x,
                a = this.y - e.y;
            return this.x = i * n - a * r + e.x, this.y = i * r + a * n + e.y, this
        }
    }), Object.assign(Zt.prototype, {
        isMatrix3: !0,
        set: function (e, t, n, r, i, a, o, s, l) {
            var c = this.elements;
            return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = i, c[5] = s, c[6] = n, c[7] = a, c[8] = l, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function () {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function (e) {
            var t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
        },
        setFromMatrix4: function (e) {
            var t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        },
        multiply: function (e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function (e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function (e, t) {
            var n = e.elements,
                r = t.elements,
                i = this.elements,
                a = n[0],
                o = n[3],
                s = n[6],
                l = n[1],
                c = n[4],
                u = n[7],
                d = n[2],
                h = n[5],
                p = n[8],
                f = r[0],
                m = r[3],
                v = r[6],
                g = r[1],
                _ = r[4],
                y = r[7],
                x = r[2],
                b = r[5],
                w = r[8];
            return i[0] = a * f + o * g + s * x, i[3] = a * m + o * _ + s * b, i[6] = a * v + o * y + s * w, i[1] = l * f + c * g + u * x, i[4] = l * m + c * _ + u * b, i[7] = l * v + c * y + u * w, i[2] = d * f + h * g + p * x, i[5] = d * m + h * _ + p * b, i[8] = d * v + h * y + p * w, this
        },
        multiplyScalar: function (e) {
            var t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        },
        determinant: function () {
            var e = this.elements,
                t = e[0],
                n = e[1],
                r = e[2],
                i = e[3],
                a = e[4],
                o = e[5],
                s = e[6],
                l = e[7],
                c = e[8];
            return t * a * c - t * o * l - n * i * c + n * o * s + r * i * l - r * a * s
        },
        getInverse: function (e, t) {
            e && e.isMatrix4 && console.error("v3d.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var n = e.elements,
                r = this.elements,
                i = n[0],
                a = n[1],
                o = n[2],
                s = n[3],
                l = n[4],
                c = n[5],
                u = n[6],
                d = n[7],
                h = n[8],
                p = h * l - c * d,
                f = c * u - h * s,
                m = d * s - l * u,
                v = i * p + a * f + o * m;
            if (0 == v) {
                if (!0 === t) throw new Error("v3d.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return this.identity()
            }
            var g = 1 / v;
            return r[0] = p * g, r[1] = (o * d - h * a) * g, r[2] = (c * a - o * l) * g, r[3] = f * g, r[4] = (h * i - o * u) * g, r[5] = (o * s - c * i) * g, r[6] = m * g, r[7] = (a * u - d * i) * g, r[8] = (l * i - a * s) * g, this
        },
        transpose: function () {
            var e, t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        },
        getNormalMatrix: function (e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function (e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        },
        setUvTransform: function (e, t, n, r, i, a, o) {
            var s = Math.cos(i),
                l = Math.sin(i);
            this.set(n * s, n * l, -n * (s * a + l * o) + a + e, -r * l, r * s, -r * (-l * a + s * o) + o + t, 0, 0, 1)
        },
        scale: function (e, t) {
            var n = this.elements;
            return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
        },
        rotate: function (e) {
            var t = Math.cos(e),
                n = Math.sin(e),
                r = this.elements,
                i = r[0],
                a = r[3],
                o = r[6],
                s = r[1],
                l = r[4],
                c = r[7];
            return r[0] = t * i + n * s, r[3] = t * a + n * l, r[6] = t * o + n * c, r[1] = -n * i + t * s, r[4] = -n * a + t * l, r[7] = -n * o + t * c, this
        },
        translate: function (e, t) {
            var n = this.elements;
            return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
        },
        equals: function (e) {
            for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                if (t[r] !== n[r]) return !1;
            return !0
        },
        fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
            return this
        },
        toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
        }
    });
    var Qt = {
            getDataURL: function (e) {
                var t;
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                if (e instanceof HTMLCanvasElement) t = e;
                else {
                    void 0 === Ht && (Ht = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Ht.width = e.width, Ht.height = e.height;
                    var n = Ht.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Ht
                }
                return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
            }
        },
        Kt = 0;

    function Jt(e, t, n, r, i, a, o, s, l, c) {
        Object.defineProperty(this, "id", {
            value: Kt++
        }), this.uuid = Yt.generateUUID(), this.name = "", this.image = void 0 !== e ? e : Jt.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : Jt.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : Ye, this.wrapT = void 0 !== r ? r : Ye, this.magFilter = void 0 !== i ? i : Je, this.minFilter = void 0 !== a ? a : et, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== o ? o : lt, this.internalFormat = null, this.type = void 0 !== s ? s : tt, this.offset = new qt(0, 0), this.repeat = new qt(1, 1), this.center = new qt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Zt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== c ? c : At, this.version = 0, this.onUpdate = null
    }

    function $t(e, t, n, r) {
        this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
    }

    function en(e, t, n) {
        this.width = e, this.height = t, this.scissor = new $t(0, 0, e, t), this.scissorTest = !1, this.viewport = new $t(0, 0, e, t), n = n || {}, this.texture = new Jt(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Je, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }

    function tn(e, t, n) {
        en.call(this, e, t, n), this.samples = 4, this.disableBlit = !1
    }

    function nn(e, t, n, r) {
        this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
    }
    Jt.DEFAULT_IMAGE = void 0, Jt.DEFAULT_MAPPING = 300, Jt.prototype = Object.assign(Object.create(o.prototype), {
        constructor: Jt,
        isTexture: !0,
        updateMatrix: function () {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
        },
        toJSON: function (e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var r = this.image;
                if (void 0 === r.uuid && (r.uuid = Yt.generateUUID()), !t && void 0 === e.images[r.uuid]) {
                    var i;
                    if (Array.isArray(r)) {
                        i = [];
                        for (var a = 0, o = r.length; a < o; a++) i.push(Qt.getDataURL(r[a]))
                    } else i = Qt.getDataURL(r);
                    e.images[r.uuid] = {
                        uuid: r.uuid,
                        url: i
                    }
                }
                n.image = r.uuid
            }
            return t || (e.textures[this.uuid] = n), n
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function (e) {
            if (300 !== this.mapping) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || 1 < e.x) switch (this.wrapS) {
                case He:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case Ye:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case qe:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
            }
            if (e.y < 0 || 1 < e.y) switch (this.wrapT) {
                case He:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case Ye:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case qe:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
    }), Object.defineProperty(Jt.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.defineProperties($t.prototype, {
        width: {
            get: function () {
                return this.z
            },
            set: function (e) {
                this.z = e
            }
        },
        height: {
            get: function () {
                return this.w
            },
            set: function (e) {
                this.w = e
            }
        }
    }), Object.assign($t.prototype, {
        isVector4: !0,
        set: function (e, t, n, r) {
            return this.x = e, this.y = t, this.z = n, this.w = r, this
        },
        setScalar: function (e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setZ: function (e) {
            return this.z = e, this
        },
        setW: function (e) {
            return this.w = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("v3d.Vector4: .add() now only accepts one argument. Use .addVectors(a, b) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        },
        addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("v3d.Vector4: .sub() now only accepts one argument. Use .subVectors(a, b) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        },
        subScalar: function (e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        },
        applyMatrix4: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = this.w,
                a = e.elements;
            return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i, this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i, this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i, this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i, this
        },
        divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function (e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        },
        setAxisAngleFromRotationMatrix: function (e) {
            var t, n, r, i, a = e.elements,
                o = a[0],
                s = a[4],
                l = a[8],
                c = a[1],
                u = a[5],
                d = a[9],
                h = a[2],
                p = a[6],
                f = a[10];
            if (Math.abs(s - c) < .01 && Math.abs(l - h) < .01 && Math.abs(d - p) < .01) {
                if (Math.abs(s + c) < .1 && Math.abs(l + h) < .1 && Math.abs(d + p) < .1 && Math.abs(o + u + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                var m = (o + 1) / 2,
                    v = (u + 1) / 2,
                    g = (f + 1) / 2,
                    _ = (s + c) / 4,
                    y = (l + h) / 4,
                    x = (d + p) / 4;
                return v < m && g < m ? i = m < .01 ? (n = 0, r = .707106781) : (r = _ / (n = Math.sqrt(m)), y / n) : g < v ? i = v < .01 ? (r = 0, n = .707106781) : (n = _ / (r = Math.sqrt(v)), x / r) : g < .01 ? (r = n = .707106781, i = 0) : (n = y / (i = Math.sqrt(g)), r = x / i), this.set(n, r, i, t), this
            }
            var b = Math.sqrt((p - d) * (p - d) + (l - h) * (l - h) + (c - s) * (c - s));
            return Math.abs(b) < .001 && (b = 1), this.x = (p - d) / b, this.y = (l - h) / b, this.z = (c - s) / b, this.w = Math.acos((o + u + f - 1) / 2), this
        },
        min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        },
        max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        },
        clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        },
        clampScalar: function (e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
        },
        clampLength: function (e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        },
        lerpVectors: function (e, t, n) {
            return this.subVectors(t, e).multiplyScalar(n).add(e)
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        },
        fromBufferAttribute: function (e, t, n) {
            return void 0 !== n && console.warn("v3d.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
    }), en.prototype = Object.assign(Object.create(o.prototype), {
        constructor: en,
        isWebGLRenderTarget: !0,
        setSize: function (e, t) {
            this.width === e && this.height === t || (this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), tn.prototype = Object.assign(Object.create(en.prototype), {
        constructor: tn,
        isWebGLMultisampleRenderTarget: !0,
        copy: function (e) {
            return en.prototype.copy.call(this, e), this.samples = e.samples, this
        }
    }), Object.assign(nn, {
        slerp: function (e, t, n, r) {
            return n.copy(e).slerp(t, r)
        },
        slerpFlat: function (e, t, n, r, i, a, o) {
            var s = n[r + 0],
                l = n[r + 1],
                c = n[r + 2],
                u = n[r + 3],
                d = i[a + 0],
                h = i[a + 1],
                p = i[a + 2],
                f = i[a + 3];
            if (u !== f || s !== d || l !== h || c !== p) {
                var m = 1 - o,
                    v = s * d + l * h + c * p + u * f,
                    g = 0 <= v ? 1 : -1,
                    _ = 1 - v * v;
                if (_ > Number.EPSILON) {
                    var y = Math.sqrt(_),
                        x = Math.atan2(y, v * g);
                    m = Math.sin(m * x) / y, o = Math.sin(o * x) / y
                }
                var b = o * g;
                if (s = s * m + d * b, l = l * m + h * b, c = c * m + p * b, u = u * m + f * b, m === 1 - o) {
                    var w = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                    s *= w, l *= w, c *= w, u *= w
                }
            }
            e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
        }
    }), Object.defineProperties(nn.prototype, {
        x: {
            get: function () {
                return this._x
            },
            set: function (e) {
                this._x = e, this._onChangeCallback()
            }
        },
        y: {
            get: function () {
                return this._y
            },
            set: function (e) {
                this._y = e, this._onChangeCallback()
            }
        },
        z: {
            get: function () {
                return this._z
            },
            set: function (e) {
                this._z = e, this._onChangeCallback()
            }
        },
        w: {
            get: function () {
                return this._w
            },
            set: function (e) {
                this._w = e, this._onChangeCallback()
            }
        }
    }), Object.assign(nn.prototype, {
        isQuaternion: !0,
        set: function (e, t, n, r) {
            return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function (e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
        },
        setFromEuler: function (e, t) {
            if (!e || !e.isEuler) throw new Error("v3d.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var n = e._x,
                r = e._y,
                i = e._z,
                a = e.order,
                o = Math.cos,
                s = Math.sin,
                l = o(n / 2),
                c = o(r / 2),
                u = o(i / 2),
                d = s(n / 2),
                h = s(r / 2),
                p = s(i / 2);
            return "XYZ" === a ? (this._x = d * c * u + l * h * p, this._y = l * h * u - d * c * p, this._z = l * c * p + d * h * u, this._w = l * c * u - d * h * p) : "YXZ" === a ? (this._x = d * c * u + l * h * p, this._y = l * h * u - d * c * p, this._z = l * c * p - d * h * u, this._w = l * c * u + d * h * p) : "ZXY" === a ? (this._x = d * c * u - l * h * p, this._y = l * h * u + d * c * p, this._z = l * c * p + d * h * u, this._w = l * c * u - d * h * p) : "ZYX" === a ? (this._x = d * c * u - l * h * p, this._y = l * h * u + d * c * p, this._z = l * c * p - d * h * u, this._w = l * c * u + d * h * p) : "YZX" === a ? (this._x = d * c * u + l * h * p, this._y = l * h * u + d * c * p, this._z = l * c * p - d * h * u, this._w = l * c * u - d * h * p) : "XZY" === a && (this._x = d * c * u - l * h * p, this._y = l * h * u - d * c * p, this._z = l * c * p + d * h * u, this._w = l * c * u + d * h * p), !1 !== t && this._onChangeCallback(), this
        },
        setFromAxisAngle: function (e, t) {
            var n = t / 2,
                r = Math.sin(n);
            return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
        },
        setFromRotationMatrix: function (e) {
            var t, n = e.elements,
                r = n[0],
                i = n[4],
                a = n[8],
                o = n[1],
                s = n[5],
                l = n[9],
                c = n[2],
                u = n[6],
                d = n[10],
                h = r + s + d;
            return 0 < h ? (t = .5 / Math.sqrt(h + 1), this._w = .25 / t, this._x = (u - l) * t, this._y = (a - c) * t, this._z = (o - i) * t) : s < r && d < r ? (t = 2 * Math.sqrt(1 + r - s - d), this._w = (u - l) / t, this._x = .25 * t, this._y = (i + o) / t, this._z = (a + c) / t) : d < s ? (t = 2 * Math.sqrt(1 + s - r - d), this._w = (a - c) / t, this._x = (i + o) / t, this._y = .25 * t, this._z = (l + u) / t) : (t = 2 * Math.sqrt(1 + d - r - s), this._w = (o - i) / t, this._x = (a + c) / t, this._y = (l + u) / t, this._z = .25 * t), this._onChangeCallback(), this
        },
        setFromUnitVectors: function (e, t) {
            var n = e.dot(t) + 1;
            return n < 1e-6 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = n, this.normalize()
        },
        angleTo: function (e) {
            return 2 * Math.acos(Math.abs(Yt.clamp(this.dot(e), -1, 1)))
        },
        rotateTowards: function (e, t) {
            var n = this.angleTo(e);
            if (0 === n) return this;
            var r = Math.min(1, t / n);
            return this.slerp(e, r), this
        },
        inverse: function () {
            return this.conjugate()
        },
        conjugate: function () {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        },
        dot: function (e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function () {
            var e = this.length();
            return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
        },
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("v3d.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions(a, b) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function (e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function (e, t) {
            var n = e._x,
                r = e._y,
                i = e._z,
                a = e._w,
                o = t._x,
                s = t._y,
                l = t._z,
                c = t._w;
            return this._x = n * c + a * o + r * l - i * s, this._y = r * c + a * s + i * o - n * l, this._z = i * c + a * l + n * s - r * o, this._w = a * c - n * o - r * s - i * l, this._onChangeCallback(), this
        },
        slerp: function (e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var n = this._x,
                r = this._y,
                i = this._z,
                a = this._w,
                o = a * e._w + n * e._x + r * e._y + i * e._z;
            if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), 1 <= o) return this._w = a, this._x = n, this._y = r, this._z = i, this;
            var s = 1 - o * o;
            if (s <= Number.EPSILON) {
                var l = 1 - t;
                return this._w = l * a + t * this._w, this._x = l * n + t * this._x, this._y = l * r + t * this._y, this._z = l * i + t * this._z, this.normalize(), this._onChangeCallback(), this
            }
            var c = Math.sqrt(s),
                u = Math.atan2(c, o),
                d = Math.sin((1 - t) * u) / c,
                h = Math.sin(t * u) / c;
            return this._w = a * d + this._w * h, this._x = n * d + this._x * h, this._y = r * d + this._y * h, this._z = i * d + this._z * h, this._onChangeCallback(), this
        },
        equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        },
        _onChange: function (e) {
            return this._onChangeCallback = e, this
        },
        _onChangeCallback: function () {}
    });
    var rn = new on,
        an = new nn;

    function on(e, t, n) {
        this.x = e || 0, this.y = t || 0, this.z = n || 0
    }
    Object.assign(on.prototype, {
        isVector3: !0,
        set: function (e, t, n) {
            return this.x = e, this.y = t, this.z = n, this
        },
        setScalar: function (e) {
            return this.x = e, this.y = e, this.z = e, this
        },
        setX: function (e) {
            return this.x = e, this
        },
        setY: function (e) {
            return this.y = e, this
        },
        setZ: function (e) {
            return this.z = e, this
        },
        setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function (e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        },
        add: function (e, t) {
            return void 0 !== t ? (console.warn("v3d.Vector3: .add() now only accepts one argument. Use .addVectors(a, b) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        },
        addScalar: function (e) {
            return this.x += e, this.y += e, this.z += e, this
        },
        addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        },
        addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        },
        sub: function (e, t) {
            return void 0 !== t ? (console.warn("v3d.Vector3: .sub() now only accepts one argument. Use .subVectors(a, b) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        },
        subScalar: function (e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        },
        subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        },
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("v3d.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors(a, b) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        },
        multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        },
        multiplyVectors: function (e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        },
        applyEuler: function (e) {
            return e && e.isEuler || console.error("v3d.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(an.setFromEuler(e))
        },
        applyAxisAngle: function (e, t) {
            return this.applyQuaternion(an.setFromAxisAngle(e, t))
        },
        applyMatrix3: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
        },
        applyNormalMatrix: function (e) {
            return this.applyMatrix3(e).normalize()
        },
        applyMatrix4: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements,
                a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
            return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a, this
        },
        applyQuaternion: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.x,
                a = e.y,
                o = e.z,
                s = e.w,
                l = s * t + a * r - o * n,
                c = s * n + o * t - i * r,
                u = s * r + i * n - a * t,
                d = -i * t - a * n - o * r;
            return this.x = l * s + d * -i + c * -o - u * -a, this.y = c * s + d * -a + u * -i - l * -o, this.z = u * s + d * -o + l * -a - c * -i, this
        },
        project: function (e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        },
        unproject: function (e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        },
        transformDirection: function (e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements;
            return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
        },
        divide: function (e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        },
        divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        },
        min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        },
        max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        },
        clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        },
        clampScalar: function (e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
        },
        clampLength: function (e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        },
        lerpVectors: function (e, t, n) {
            return this.subVectors(t, e).multiplyScalar(n).add(e)
        },
        cross: function (e, t) {
            return void 0 !== t ? (console.warn("v3d.Vector3: .cross() now only accepts one argument. Use .crossVectors(a, b) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
        },
        crossVectors: function (e, t) {
            var n = e.x,
                r = e.y,
                i = e.z,
                a = t.x,
                o = t.y,
                s = t.z;
            return this.x = r * s - i * o, this.y = i * a - n * s, this.z = n * o - r * a, this
        },
        projectOnVector: function (e) {
            var t = e.lengthSq();
            if (0 === t) return this.set(0, 0, 0);
            var n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n)
        },
        projectOnPlane: function (e) {
            return rn.copy(this).projectOnVector(e), this.sub(rn)
        },
        reflect: function (e) {
            return this.sub(rn.copy(e).multiplyScalar(2 * this.dot(e)))
        },
        angleTo: function (e) {
            var t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (0 === t) return Math.PI / 2;
            var n = this.dot(e) / t;
            return Math.acos(Yt.clamp(n, -1, 1))
        },
        distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function (e) {
            var t = this.x - e.x,
                n = this.y - e.y,
                r = this.z - e.z;
            return t * t + n * n + r * r
        },
        manhattanDistanceTo: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function (e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        },
        setFromSphericalCoords: function (e, t, n) {
            var r = Math.sin(t) * e;
            return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
        },
        setFromCylindrical: function (e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        },
        setFromCylindricalCoords: function (e, t, n) {
            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
        },
        setFromMatrixPosition: function (e) {
            var t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this
        },
        setFromMatrixScale: function (e) {
            var t = this.setFromMatrixColumn(e, 0).length(),
                n = this.setFromMatrixColumn(e, 1).length(),
                r = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = r, this
        },
        setFromMatrixColumn: function (e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        setFromMatrix3Column: function (e, t) {
            return this.fromArray(e.elements, 3 * t)
        },
        equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        },
        fromBufferAttribute: function (e, t, n) {
            return void 0 !== n && console.warn("v3d.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
    });
    var sn = new on,
        ln = new fn,
        cn = new on(0, 0, 0),
        un = new on(1, 1, 1),
        dn = new on,
        hn = new on,
        pn = new on;

    function fn() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("v3d.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.assign(fn.prototype, {
        isMatrix4: !0,
        set: function (e, t, n, r, i, a, o, s, l, c, u, d, h, p, f, m) {
            var v = this.elements;
            return v[0] = e, v[4] = t, v[8] = n, v[12] = r, v[1] = i, v[5] = a, v[9] = o, v[13] = s, v[2] = l, v[6] = c, v[10] = u, v[14] = d, v[3] = h, v[7] = p, v[11] = f, v[15] = m, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function () {
            return (new fn).fromArray(this.elements)
        },
        copy: function (e) {
            var t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
        },
        copyPosition: function (e) {
            var t = this.elements,
                n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
        },
        extractBasis: function (e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function (e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function (e) {
            var t = this.elements,
                n = e.elements,
                r = 1 / sn.setFromMatrixColumn(e, 0).length(),
                i = 1 / sn.setFromMatrixColumn(e, 1).length(),
                a = 1 / sn.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        makeRotationFromEuler: function (e) {
            e && e.isEuler || console.error("v3d.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements,
                n = e.x,
                r = e.y,
                i = e.z,
                a = Math.cos(n),
                o = Math.sin(n),
                s = Math.cos(r),
                l = Math.sin(r),
                c = Math.cos(i),
                u = Math.sin(i);
            if ("XYZ" === e.order) {
                var d = a * c,
                    h = a * u,
                    p = o * c,
                    f = o * u;
                t[0] = s * c, t[4] = -s * u, t[8] = l, t[1] = h + p * l, t[5] = d - f * l, t[9] = -o * s, t[2] = f - d * l, t[6] = p + h * l, t[10] = a * s
            } else if ("YXZ" === e.order) {
                var m = s * c,
                    v = s * u,
                    g = l * c,
                    _ = l * u;
                t[0] = m + _ * o, t[4] = g * o - v, t[8] = a * l, t[1] = a * u, t[5] = a * c, t[9] = -o, t[2] = v * o - g, t[6] = _ + m * o, t[10] = a * s
            } else if ("ZXY" === e.order) {
                m = s * c, v = s * u, g = l * c, _ = l * u;
                t[0] = m - _ * o, t[4] = -a * u, t[8] = g + v * o, t[1] = v + g * o, t[5] = a * c, t[9] = _ - m * o, t[2] = -a * l, t[6] = o, t[10] = a * s
            } else if ("ZYX" === e.order) {
                d = a * c, h = a * u, p = o * c, f = o * u;
                t[0] = s * c, t[4] = p * l - h, t[8] = d * l + f, t[1] = s * u, t[5] = f * l + d, t[9] = h * l - p, t[2] = -l, t[6] = o * s, t[10] = a * s
            } else if ("YZX" === e.order) {
                var y = a * s,
                    x = a * l,
                    b = o * s,
                    w = o * l;
                t[0] = s * c, t[4] = w - y * u, t[8] = b * u + x, t[1] = u, t[5] = a * c, t[9] = -o * c, t[2] = -l * c, t[6] = x * u + b, t[10] = y - w * u
            } else if ("XZY" === e.order) {
                y = a * s, x = a * l, b = o * s, w = o * l;
                t[0] = s * c, t[4] = -u, t[8] = l * c, t[1] = y * u + w, t[5] = a * c, t[9] = x * u - b, t[2] = b * u - x, t[6] = o * c, t[10] = w * u + y
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        makeRotationFromQuaternion: function (e) {
            return this.compose(cn, e, un)
        },
        lookAt: function (e, t, n) {
            var r = this.elements;
            return pn.subVectors(e, t), 0 === pn.lengthSq() && (pn.z = 1), pn.normalize(), dn.crossVectors(n, pn), 0 === dn.lengthSq() && (1 === Math.abs(n.z) ? pn.x += 1e-4 : pn.z += 1e-4, pn.normalize(), dn.crossVectors(n, pn)), dn.normalize(), hn.crossVectors(pn, dn), r[0] = dn.x, r[4] = hn.x, r[8] = pn.x, r[1] = dn.y, r[5] = hn.y, r[9] = pn.y, r[2] = dn.z, r[6] = hn.z, r[10] = pn.z, this
        },
        multiply: function (e, t) {
            return void 0 !== t ? (console.warn("v3d.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices(a, b) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function (e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function (e, t) {
            var n = e.elements,
                r = t.elements,
                i = this.elements,
                a = n[0],
                o = n[4],
                s = n[8],
                l = n[12],
                c = n[1],
                u = n[5],
                d = n[9],
                h = n[13],
                p = n[2],
                f = n[6],
                m = n[10],
                v = n[14],
                g = n[3],
                _ = n[7],
                y = n[11],
                x = n[15],
                b = r[0],
                w = r[4],
                M = r[8],
                A = r[12],
                S = r[1],
                T = r[5],
                E = r[9],
                C = r[13],
                P = r[2],
                L = r[6],
                R = r[10],
                D = r[14],
                I = r[3],
                N = r[7],
                O = r[11],
                F = r[15];
            return i[0] = a * b + o * S + s * P + l * I, i[4] = a * w + o * T + s * L + l * N, i[8] = a * M + o * E + s * R + l * O, i[12] = a * A + o * C + s * D + l * F, i[1] = c * b + u * S + d * P + h * I, i[5] = c * w + u * T + d * L + h * N, i[9] = c * M + u * E + d * R + h * O, i[13] = c * A + u * C + d * D + h * F, i[2] = p * b + f * S + m * P + v * I, i[6] = p * w + f * T + m * L + v * N, i[10] = p * M + f * E + m * R + v * O, i[14] = p * A + f * C + m * D + v * F, i[3] = g * b + _ * S + y * P + x * I, i[7] = g * w + _ * T + y * L + x * N, i[11] = g * M + _ * E + y * R + x * O, i[15] = g * A + _ * C + y * D + x * F, this
        },
        multiplyScalar: function (e) {
            var t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        },
        determinant: function () {
            var e = this.elements,
                t = e[0],
                n = e[4],
                r = e[8],
                i = e[12],
                a = e[1],
                o = e[5],
                s = e[9],
                l = e[13],
                c = e[2],
                u = e[6],
                d = e[10],
                h = e[14];
            return e[3] * (i * s * u - r * l * u - i * o * d + n * l * d + r * o * h - n * s * h) + e[7] * (t * s * h - t * l * d + i * a * d - r * a * h + r * l * c - i * s * c) + e[11] * (t * l * u - t * o * h - i * a * u + n * a * h + i * o * c - n * l * c) + e[15] * (-r * o * c - t * s * u + t * o * d + r * a * u - n * a * d + n * s * c)
        },
        transpose: function () {
            var e, t = this.elements;
            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
        },
        setPosition: function (e, t, n) {
            var r = this.elements;
            return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
        },
        getInverse: function (e, t) {
            var n = this.elements,
                r = e.elements,
                i = r[0],
                a = r[1],
                o = r[2],
                s = r[3],
                l = r[4],
                c = r[5],
                u = r[6],
                d = r[7],
                h = r[8],
                p = r[9],
                f = r[10],
                m = r[11],
                v = r[12],
                g = r[13],
                _ = r[14],
                y = r[15],
                x = p * _ * d - g * f * d + g * u * m - c * _ * m - p * u * y + c * f * y,
                b = v * f * d - h * _ * d - v * u * m + l * _ * m + h * u * y - l * f * y,
                w = h * g * d - v * p * d + v * c * m - l * g * m - h * c * y + l * p * y,
                M = v * p * u - h * g * u - v * c * f + l * g * f + h * c * _ - l * p * _,
                A = i * x + a * b + o * w + s * M;
            if (0 == A) {
                if (!0 === t) throw new Error("v3d.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return this.identity()
            }
            var S = 1 / A;
            return n[0] = x * S, n[1] = (g * f * s - p * _ * s - g * o * m + a * _ * m + p * o * y - a * f * y) * S, n[2] = (c * _ * s - g * u * s + g * o * d - a * _ * d - c * o * y + a * u * y) * S, n[3] = (p * u * s - c * f * s - p * o * d + a * f * d + c * o * m - a * u * m) * S, n[4] = b * S, n[5] = (h * _ * s - v * f * s + v * o * m - i * _ * m - h * o * y + i * f * y) * S, n[6] = (v * u * s - l * _ * s - v * o * d + i * _ * d + l * o * y - i * u * y) * S, n[7] = (l * f * s - h * u * s + h * o * d - i * f * d - l * o * m + i * u * m) * S, n[8] = w * S, n[9] = (v * p * s - h * g * s - v * a * m + i * g * m + h * a * y - i * p * y) * S, n[10] = (l * g * s - v * c * s + v * a * d - i * g * d - l * a * y + i * c * y) * S, n[11] = (h * c * s - l * p * s - h * a * d + i * p * d + l * a * m - i * c * m) * S, n[12] = M * S, n[13] = (h * g * o - v * p * o + v * a * f - i * g * f - h * a * _ + i * p * _) * S, n[14] = (v * c * o - l * g * o - v * a * u + i * g * u + l * a * _ - i * c * _) * S, n[15] = (l * p * o - h * c * o + h * a * u - i * p * u - l * a * f + i * c * f) * S, this
        },
        scale: function (e) {
            var t = this.elements,
                n = e.x,
                r = e.y,
                i = e.z;
            return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
        },
        getMaxScaleOnAxis: function () {
            var e = this.elements,
                t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, r))
        },
        makeTranslation: function (e, t, n) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
        },
        makeRotationX: function (e) {
            var t = Math.cos(e),
                n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function (e) {
            var t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function (e) {
            var t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function (e, t) {
            var n = Math.cos(t),
                r = Math.sin(t),
                i = 1 - n,
                a = e.x,
                o = e.y,
                s = e.z,
                l = i * a,
                c = i * o;
            return this.set(l * a + n, l * o - r * s, l * s + r * o, 0, l * o + r * s, c * o + n, c * s - r * a, 0, l * s - r * o, c * s + r * a, i * s * s + n, 0, 0, 0, 0, 1), this
        },
        makeScale: function (e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        },
        makeShear: function (e, t, n) {
            return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
        },
        compose: function (e, t, n) {
            var r = this.elements,
                i = t._x,
                a = t._y,
                o = t._z,
                s = t._w,
                l = i + i,
                c = a + a,
                u = o + o,
                d = i * l,
                h = i * c,
                p = i * u,
                f = a * c,
                m = a * u,
                v = o * u,
                g = s * l,
                _ = s * c,
                y = s * u,
                x = n.x,
                b = n.y,
                w = n.z;
            return r[0] = (1 - (f + v)) * x, r[1] = (h + y) * x, r[2] = (p - _) * x, r[3] = 0, r[4] = (h - y) * b, r[5] = (1 - (d + v)) * b, r[6] = (m + g) * b, r[7] = 0, r[8] = (p + _) * w, r[9] = (m - g) * w, r[10] = (1 - (d + f)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
        },
        decompose: function (e, t, n) {
            var r = this.elements,
                i = sn.set(r[0], r[1], r[2]).length(),
                a = sn.set(r[4], r[5], r[6]).length(),
                o = sn.set(r[8], r[9], r[10]).length();
            this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], ln.copy(this);
            var s = 1 / i,
                l = 1 / a,
                c = 1 / o;
            return ln.elements[0] *= s, ln.elements[1] *= s, ln.elements[2] *= s, ln.elements[4] *= l, ln.elements[5] *= l, ln.elements[6] *= l, ln.elements[8] *= c, ln.elements[9] *= c, ln.elements[10] *= c, t.setFromRotationMatrix(ln), n.x = i, n.y = a, n.z = o, this
        },
        makePerspective: function (e, t, n, r, i, a) {
            void 0 === a && console.warn("v3d.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var o = this.elements,
                s = 2 * i / (t - e),
                l = 2 * i / (n - r),
                c = (t + e) / (t - e),
                u = (n + r) / (n - r),
                d = -(a + i) / (a - i),
                h = -2 * a * i / (a - i);
            return o[0] = s, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = d, o[14] = h, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
        },
        makeOrthographic: function (e, t, n, r, i, a) {
            var o = this.elements,
                s = 1 / (t - e),
                l = 1 / (n - r),
                c = 1 / (a - i),
                u = (t + e) * s,
                d = (n + r) * l,
                h = (a + i) * c;
            return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -d, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -h, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
        },
        equals: function (e) {
            for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
                if (t[r] !== n[r]) return !1;
            return !0
        },
        fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
            return this
        },
        toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
        }
    });
    var mn = new fn,
        vn = new nn;

    function gn(e, t, n, r) {
        this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || gn.DefaultOrder
    }

    function _n() {
        this.mask = 1
    }

    function yn(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
        return t
    }

    function xn(e) {
        return void 0 !== e
    }

    function bn(e, t, n) {
        for (var r = 0; r < e.length; r++) e[r] = Yt.clamp(e[r], t, n);
        return e
    }
    gn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], gn.DefaultOrder = "XYZ", Object.defineProperties(gn.prototype, {
        x: {
            get: function () {
                return this._x
            },
            set: function (e) {
                this._x = e, this._onChangeCallback()
            }
        },
        y: {
            get: function () {
                return this._y
            },
            set: function (e) {
                this._y = e, this._onChangeCallback()
            }
        },
        z: {
            get: function () {
                return this._z
            },
            set: function (e) {
                this._z = e, this._onChangeCallback()
            }
        },
        order: {
            get: function () {
                return this._order
            },
            set: function (e) {
                this._order = e, this._onChangeCallback()
            }
        }
    }), Object.assign(gn.prototype, {
        isEuler: !0,
        set: function (e, t, n, r) {
            return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this._onChangeCallback(), this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function (e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
        },
        setFromRotationMatrix: function (e, t, n) {
            var r = Yt.clamp,
                i = e.elements,
                a = i[0],
                o = i[4],
                s = i[8],
                l = i[1],
                c = i[5],
                u = i[9],
                d = i[2],
                h = i[6],
                p = i[10];
            return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(h, c), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-r(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, a), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(r(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-d, p), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, a))) : "ZYX" === t ? (this._y = Math.asin(-r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._x = Math.atan2(h, p), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, c))) : "YZX" === t ? (this._z = Math.asin(r(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-d, a)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === t ? (this._z = Math.asin(-r(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(h, c), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-u, p), this._y = 0)) : console.warn("v3d.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== n && this._onChangeCallback(), this
        },
        setFromQuaternion: function (e, t, n) {
            return mn.makeRotationFromQuaternion(e), this.setFromRotationMatrix(mn, t, n)
        },
        setFromVector3: function (e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: function (e) {
            return vn.setFromEuler(this), this.setFromQuaternion(vn, e)
        },
        equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function (e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        },
        toVector3: function (e) {
            return e ? e.set(this._x, this._y, this._z) : new on(this._x, this._y, this._z)
        },
        _onChange: function (e) {
            return this._onChangeCallback = e, this
        },
        _onChangeCallback: function () {},
        makeAlternative: function () {
            var e = "X" === this._order[1] ? -1 : 1,
                t = "Y" === this._order[1] ? -1 : 1,
                n = "Z" === this._order[1] ? -1 : 1;
            return this._x = Yt.angleToRange_mPi_Pi(e * (this._x + Math.PI)), this._y = Yt.angleToRange_mPi_Pi(t * (this._y + Math.PI)), this._z = Yt.angleToRange_mPi_Pi(n * (this._z + Math.PI)), this
        }
    }), Object.assign(_n.prototype, {
        set: function (e) {
            this.mask = 1 << e | 0
        },
        enable: function (e) {
            this.mask |= 1 << e | 0
        },
        enableAll: function () {
            this.mask = -1
        },
        toggle: function (e) {
            this.mask ^= 1 << e | 0
        },
        disable: function (e) {
            this.mask &= ~(1 << e | 0)
        },
        disableAll: function () {
            this.mask = 0
        },
        test: function (e) {
            return 0 != (this.mask & e.mask)
        }
    });
    var wn, Mn = 0,
        An = new on,
        Sn = new nn,
        Tn = new fn,
        En = new on,
        Cn = new on,
        Pn = new on,
        Ln = new nn,
        Rn = new on(1, 0, 0),
        Dn = new on(0, 1, 0),
        In = new on(0, 0, 1),
        Nn = {
            type: "added"
        },
        On = {
            type: "removed"
        };

    function Fn() {
        Object.defineProperty(this, "id", {
            value: Mn++
        }), this.uuid = Yt.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Fn.DefaultUp.clone();
        var e = new on,
            t = new gn,
            n = new nn,
            r = new on(1, 1, 1);
        t._onChange(function () {
            n.setFromEuler(t, !1)
        }), n._onChange(function () {
            t.setFromQuaternion(n, void 0, !1)
        }), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new fn
            },
            normalMatrix: {
                value: new Zt
            }
        }), this.matrix = new fn, this.matrixWorld = new fn, this.matrixAutoUpdate = Fn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new _n, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {
            v3d: {}
        }, this.constraints = [], this.disableChildRendering = !1
    }

    function Bn() {
        Fn.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __v3d_DEVTOOLS__ && __v3d_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        })), this.postprocessing = []
    }
    Fn.DefaultUp = new on(0, 1, 0), Fn.DefaultMatrixAutoUpdate = !0, Fn.prototype = Object.assign(Object.create(o.prototype), {
        constructor: Fn,
        isObject3D: !0,
        onBeforeRender: function () {},
        onAfterRender: function () {},
        applyMatrix4: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function (e) {
            return this.quaternion.premultiply(e), this
        },
        setRotationFromAxisAngle: function (e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function (e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function (e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function (e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function (e, t) {
            return Sn.setFromAxisAngle(e, t), this.quaternion.multiply(Sn), this
        },
        rotateOnWorldAxis: function (e, t) {
            return Sn.setFromAxisAngle(e, t), this.quaternion.premultiply(Sn), this
        },
        rotateX: function (e) {
            return this.rotateOnAxis(Rn, e)
        },
        rotateY: function (e) {
            return this.rotateOnAxis(Dn, e)
        },
        rotateZ: function (e) {
            return this.rotateOnAxis(In, e)
        },
        translateOnAxis: function (e, t) {
            return An.copy(e).applyQuaternion(this.quaternion), this.position.add(An.multiplyScalar(t)), this
        },
        translateX: function (e) {
            return this.translateOnAxis(Rn, e)
        },
        translateY: function (e) {
            return this.translateOnAxis(Dn, e)
        },
        translateZ: function (e) {
            return this.translateOnAxis(In, e)
        },
        localToWorld: function (e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function (e) {
            return e.applyMatrix4(Tn.getInverse(this.matrixWorld))
        },
        lookAt: function (e, t, n) {
            e.isVector3 ? En.copy(e) : En.set(e, t, n);
            var r = this.parent;
            this.updateWorldMatrix(!0, !1), Cn.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Tn.lookAt(Cn, En, this.up) : Tn.lookAt(En, Cn, this.up), this.quaternion.setFromRotationMatrix(Tn), r && (Tn.extractRotation(r.matrixWorld), Sn.setFromRotationMatrix(Tn), this.quaternion.premultiply(Sn.inverse()))
        },
        add: function (e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? console.error("v3d.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), (e.parent = this).children.push(e), e.dispatchEvent(Nn)) : console.error("v3d.Object3D.add: object not an instance of v3d.Object3D.", e), this
        },
        remove: function (e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                return this
            }
            var n = this.children.indexOf(e);
            return -1 !== n && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(On)), this
        },
        attach: function (e) {
            return this.updateWorldMatrix(!0, !1), Tn.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Tn.multiply(e.parent.matrixWorld)), e.applyMatrix4(Tn), e.updateWorldMatrix(!1, !1), this.add(e), this
        },
        getObjectById: function (e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function (e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function (e, t) {
            if (this[e] === t) return this;
            for (var n = 0, r = this.children.length; n < r; n++) {
                var i = this.children[n].getObjectByProperty(e, t);
                if (void 0 !== i) return i
            }
        },
        getWorldPosition: function (e) {
            return void 0 === e && (console.warn("v3d.Object3D: .getWorldPosition() target is now required"), e = new on), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function (e) {
            return void 0 === e && (console.warn("v3d.Object3D: .getWorldQuaternion() target is now required"), e = new nn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Cn, e, Pn), e
        },
        getWorldScale: function (e) {
            return void 0 === e && (console.warn("v3d.Object3D: .getWorldScale() target is now required"), e = new on), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Cn, Ln, e), e
        },
        getWorldDirection: function (e) {
            void 0 === e && (console.warn("v3d.Object3D: .getWorldDirection() target is now required"), e = new on), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[4], t[5], t[6]).normalize()
        },
        raycast: function () {},
        traverse: function (e) {
            e(this);
            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e)
        },
        traverseVisible: function (e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
            }
        },
        traverseAncestors: function (e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        },
        updateMatrix: function () {
            this.updateConstraints(), this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e = !(this.matrixWorldNeedsUpdate = !1));
            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
        },
        updateWorldMatrix: function (e, t) {
            var n = this.parent;
            if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                for (var r = this.children, i = 0, a = r.length; i < a; i++) r[i].updateWorldMatrix(!1, !0)
        },
        toJSON: function (n) {
            var e = void 0 === n || "string" == typeof n,
                t = {};
            e && (n = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, t.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var r = {};

            function i(e, t) {
                return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(n)), t.uuid
            }
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), !1 === this.disableChildRendering && (r.disableChildRendering = !1), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                r.geometry = i(n.geometries, this.geometry);
                var a = this.geometry.parameters;
                if (void 0 !== a && void 0 !== a.shapes) {
                    var o = a.shapes;
                    if (Array.isArray(o))
                        for (var s = 0, l = o.length; s < l; s++) {
                            var c = o[s];
                            i(n.shapes, c)
                        } else i(n.shapes, o)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var u = [];
                    for (s = 0, l = this.material.length; s < l; s++) u.push(i(n.materials, this.material[s]));
                    r.material = u
                } else r.material = i(n.materials, this.material);
            if (0 < this.children.length) {
                r.children = [];
                for (s = 0; s < this.children.length; s++) r.children.push(this.children[s].toJSON(n).object)
            }
            if (e) {
                var d = m(n.geometries),
                    h = m(n.materials),
                    p = m(n.textures),
                    f = m(n.images);
                o = m(n.shapes);
                0 < d.length && (t.geometries = d), 0 < h.length && (t.materials = h), 0 < p.length && (t.textures = p), 0 < f.length && (t.images = f), 0 < o.length && (t.shapes = o)
            }
            return t.object = r, t;

            function m(e) {
                var t = [];
                for (var n in e) {
                    var r = e[n];
                    delete r.metadata, t.push(r)
                }
                return t
            }
        },
        clone: function (e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function (e, t) {
            if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.disableChildRendering = e.disableChildRendering, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                for (var n = 0; n < e.children.length; n++) {
                    var r = e.children[n];
                    this.add(r.clone())
                }
            return this
        },
        copyTransform: (wn = new fn, function (e) {
            this.matrix.copy(e.matrixWorld), this.parent && this.matrix.multiplyMatrices(wn.getInverse(this.parent.matrixWorld), this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        }),
        isVisible: function () {
            return this.visible
        },
        updateConstraints: function () {
            for (var e = 0; e < this.constraints.length; e++) this.constraints[e].update(this)
        },
        getWorldPositionNU: function (e) {
            return e.setFromMatrixPosition(this.matrixWorld)
        },
        findRoot: function () {
            var t = this;
            return this.traverseAncestors(function (e) {
                t = e
            }), t
        },
        resolveMultiMaterial: function () {
            for (var e = [], t = 0; t < this.children.length; t++) {
                var n = this.children[t];
                n.isMesh && n.isMaterialGeneratedMesh && e.push(n)
            }
            return e.length || e.push(this), e
        }
    }), Bn.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: Bn,
        isScene: !0,
        copy: function (e, t) {
            return Fn.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
        },
        toJSON: function (e) {
            var t = Fn.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.environment && (t.object.environment = this.environment.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var zn = [new on, new on, new on, new on, new on, new on, new on, new on],
        Un = new on,
        Vn = new Kn,
        Gn = new on,
        kn = new on,
        jn = new on,
        Wn = new on,
        Xn = new on,
        Hn = new on,
        Yn = new on,
        qn = new on,
        Zn = new on,
        Qn = new on;

    function Kn(e, t) {
        this.min = void 0 !== e ? e : new on(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new on(-1 / 0, -1 / 0, -1 / 0)
    }

    function Jn(e, t, n, r, i) {
        var a, o;
        for (a = 0, o = e.length - 3; a <= o; a += 3) {
            Qn.fromArray(e, a);
            var s = i.x * Math.abs(Qn.x) + i.y * Math.abs(Qn.y) + i.z * Math.abs(Qn.z),
                l = t.dot(Qn),
                c = n.dot(Qn),
                u = r.dot(Qn);
            if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > s) return !1
        }
        return !0
    }
    Object.assign(Kn.prototype, {
        isBox3: !0,
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromArray: function (e) {
            for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.length; s < l; s += 3) {
                var c = e[s],
                    u = e[s + 1],
                    d = e[s + 2];
                c < t && (t = c), u < n && (n = u), d < r && (r = d), i < c && (i = c), a < u && (a = u), o < d && (o = d)
            }
            return this.min.set(t, n, r), this.max.set(i, a, o), this
        },
        setFromBufferAttribute: function (e) {
            for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.count; s < l; s++) {
                var c = e.getX(s),
                    u = e.getY(s),
                    d = e.getZ(s);
                c < t && (t = c), u < n && (n = u), d < r && (r = d), i < c && (i = c), a < u && (a = u), o < d && (o = d)
            }
            return this.min.set(t, n, r), this.max.set(i, a, o), this
        },
        setFromPoints: function (e) {
            this.makeEmpty();
            for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function (e, t) {
            var n = Un.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
        },
        setFromObject: function (e) {
            return this.makeEmpty(), this.expandByObject(e)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function (e) {
            return void 0 === e && (console.warn("v3d.Box3: .getCenter() target is now required"), e = new on), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function (e) {
            return void 0 === e && (console.warn("v3d.Box3: .getSize() target is now required"), e = new on), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        expandByObject: function (e) {
            e.updateWorldMatrix(!1, !1);
            var t = e.geometry;
            void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Vn.copy(t.boundingBox), Vn.applyMatrix4(e.matrixWorld), this.expandByPoint(Vn.min), this.expandByPoint(Vn.max));
            for (var n = e.children, r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
            return this
        },
        containsPoint: function (e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function (e, t) {
            return void 0 === t && (console.warn("v3d.Box3: .getParameter() target is now required"), t = new on), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function (e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: function (e) {
            return this.clampPoint(e.center, Un), Un.distanceToSquared(e.center) <= e.radius * e.radius
        },
        intersectsPlane: function (e) {
            var t, n;
            return n = 0 < e.normal.x ? (t = e.normal.x * this.min.x, e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, e.normal.x * this.min.x), 0 < e.normal.y ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
        },
        intersectsTriangle: function (e) {
            if (this.isEmpty()) return !1;
            this.getCenter(Yn), qn.subVectors(this.max, Yn), Gn.subVectors(e.a, Yn), kn.subVectors(e.b, Yn), jn.subVectors(e.c, Yn), Wn.subVectors(kn, Gn), Xn.subVectors(jn, kn), Hn.subVectors(Gn, jn);
            var t = [0, -Wn.z, Wn.y, 0, -Xn.z, Xn.y, 0, -Hn.z, Hn.y, Wn.z, 0, -Wn.x, Xn.z, 0, -Xn.x, Hn.z, 0, -Hn.x, -Wn.y, Wn.x, 0, -Xn.y, Xn.x, 0, -Hn.y, Hn.x, 0];
            return !!Jn(t, Gn, kn, jn, qn) && (!!Jn(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], Gn, kn, jn, qn) && (Zn.crossVectors(Wn, Xn), Jn(t = [Zn.x, Zn.y, Zn.z], Gn, kn, jn, qn)))
        },
        clampPoint: function (e, t) {
            return void 0 === t && (console.warn("v3d.Box3: .clampPoint() target is now required"), t = new on), t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function (e) {
            return Un.copy(e).clamp(this.min, this.max).sub(e).length()
        },
        getBoundingSphere: function (e) {
            return void 0 === e && console.error("v3d.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(Un).length(), e
        },
        intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        applyMatrix4: function (e) {
            return this.isEmpty() || (zn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), zn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), zn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), zn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), zn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), zn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), zn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), zn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(zn)), this
        },
        translate: function (e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    });
    var $n, er, tr = new Kn;

    function nr(e, t) {
        this.center = void 0 !== e ? e : new on, this.radius = void 0 !== t ? t : 0
    }
    Object.assign(nr.prototype, {
        set: function (e, t) {
            return this.center.copy(e), this.radius = t, this
        },
        setFromPoints: function (e, t) {
            var n = this.center;
            void 0 !== t ? n.copy(t) : tr.setFromPoints(e).getCenter(n);
            for (var r = 0, i = 0, a = e.length; i < a; i++) r = Math.max(r, n.distanceToSquared(e[i]));
            return this.radius = Math.sqrt(r), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        },
        empty: function () {
            return this.radius <= 0
        },
        containsPoint: function (e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function (e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function (e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function (e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function (e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function (e, t) {
            var n = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("v3d.Sphere: .clampPoint() target is now required"), t = new on), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        },
        getBoundingBox: function (e) {
            return void 0 === e && (console.warn("v3d.Sphere: .getBoundingBox() target is now required"), e = new Kn), e.set(this.center, this.center), e.expandByScalar(this.radius), e
        },
        applyMatrix4: function (e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
        },
        translate: function (e) {
            return this.center.add(e), this
        },
        equals: function (e) {
            return e.center.equals(this.center) && e.radius === this.radius
        },
        union: ($n = new on, er = new on, function (e) {
            var t = this.center,
                n = this.radius,
                r = e.center,
                i = e.radius;
            $n.subVectors(r, t);
            var a = $n.length();
            if (a + i <= n) return this;
            if (a + n <= i) return this.copy(e), this;
            var o = .5 * (n + a + i);
            return er.copy($n).multiplyScalar((o - n) / a), er.add(t), this.center.copy(er), this.radius = o, this
        })
    });
    var rr = new on,
        ir = new on,
        ar = new on,
        or = new on,
        sr = new on,
        lr = new on,
        cr = new on;

    function ur(e, t) {
        this.origin = void 0 !== e ? e : new on, this.direction = void 0 !== t ? t : new on(0, 0, -1)
    }
    Object.assign(ur.prototype, {
        set: function (e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        },
        at: function (e, t) {
            return void 0 === t && (console.warn("v3d.Ray: .at() target is now required"), t = new on), t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function (e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        },
        recast: function (e) {
            return this.origin.copy(this.at(e, rr)), this
        },
        closestPointToPoint: function (e, t) {
            void 0 === t && (console.warn("v3d.Ray: .closestPointToPoint() target is now required"), t = new on), t.subVectors(e, this.origin);
            var n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function (e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function (e) {
            var t = rr.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (rr.copy(this.direction).multiplyScalar(t).add(this.origin), rr.distanceToSquared(e))
        },
        distanceSqToSegment: function (e, t, n, r) {
            ir.copy(e).add(t).multiplyScalar(.5), ar.copy(t).sub(e).normalize(), or.copy(this.origin).sub(ir);
            var i, a, o, s, l = .5 * e.distanceTo(t),
                c = -this.direction.dot(ar),
                u = or.dot(this.direction),
                d = -or.dot(ar),
                h = or.lengthSq(),
                p = Math.abs(1 - c * c);
            if (0 < p)
                if (a = c * u - d, s = l * p, 0 <= (i = c * d - u))
                    if (-s <= a)
                        if (a <= s) {
                            var f = 1 / p;
                            o = (i *= f) * (i + c * (a *= f) + 2 * u) + a * (c * i + a + 2 * d) + h
                        } else a = l, o = -(i = Math.max(0, -(c * a + u))) * i + a * (a + 2 * d) + h;
            else a = -l, o = -(i = Math.max(0, -(c * a + u))) * i + a * (a + 2 * d) + h;
            else o = a <= -s ? -(i = Math.max(0, -(-c * l + u))) * i + (a = 0 < i ? -l : Math.min(Math.max(-l, -d), l)) * (a + 2 * d) + h : a <= s ? (i = 0, (a = Math.min(Math.max(-l, -d), l)) * (a + 2 * d) + h) : -(i = Math.max(0, -(c * l + u))) * i + (a = 0 < i ? l : Math.min(Math.max(-l, -d), l)) * (a + 2 * d) + h;
            else a = 0 < c ? -l : l, o = -(i = Math.max(0, -(c * a + u))) * i + a * (a + 2 * d) + h;
            return n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(ar).multiplyScalar(a).add(ir), o
        },
        intersectSphere: function (e, t) {
            rr.subVectors(e.center, this.origin);
            var n = rr.dot(this.direction),
                r = rr.dot(rr) - n * n,
                i = e.radius * e.radius;
            if (i < r) return null;
            var a = Math.sqrt(i - r),
                o = n - a,
                s = n + a;
            return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t)
        },
        intersectsSphere: function (e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        },
        distanceToPlane: function (e) {
            var t = e.normal.dot(this.direction);
            if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            var n = -(this.origin.dot(e.normal) + e.constant) / t;
            return 0 <= n ? n : null
        },
        intersectPlane: function (e, t) {
            var n = this.distanceToPlane(e);
            return null === n ? null : this.at(n, t)
        },
        intersectsPlane: function (e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        },
        intersectBox: function (e, t) {
            var n, r, i, a, o, s, l = 1 / this.direction.x,
                c = 1 / this.direction.y,
                u = 1 / this.direction.z,
                d = this.origin;
            return r = 0 <= l ? (n = (e.min.x - d.x) * l, (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l, (e.min.x - d.x) * l), (a = 0 <= c ? (i = (e.min.y - d.y) * c, (e.max.y - d.y) * c) : (i = (e.max.y - d.y) * c, (e.min.y - d.y) * c)) < n || r < i ? null : ((n < i || n != n) && (n = i), (a < r || r != r) && (r = a), (s = 0 <= u ? (o = (e.min.z - d.z) * u, (e.max.z - d.z) * u) : (o = (e.max.z - d.z) * u, (e.min.z - d.z) * u)) < n || r < o ? null : ((n < o || n != n) && (n = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(0 <= n ? n : r, t)))
        },
        intersectsBox: function (e) {
            return null !== this.intersectBox(e, rr)
        },
        intersectTriangle: function (e, t, n, r, i) {
            sr.subVectors(t, e), lr.subVectors(n, e), cr.crossVectors(sr, lr);
            var a, o = this.direction.dot(cr);
            if (0 < o) {
                if (r) return null;
                a = 1
            } else {
                if (!(o < 0)) return null;
                a = -1, o = -o
            }
            or.subVectors(this.origin, e);
            var s = a * this.direction.dot(lr.crossVectors(or, lr));
            if (s < 0) return null;
            var l = a * this.direction.dot(sr.cross(or));
            if (l < 0) return null;
            if (o < s + l) return null;
            var c = -a * or.dot(cr);
            return c < 0 ? null : this.at(c / o, i)
        },
        applyMatrix4: function (e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        },
        equals: function (e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    });
    var dr = new on,
        hr = new on,
        pr = new Zt;

    function fr(e, t) {
        this.normal = void 0 !== e ? e : new on(1, 0, 0), this.constant = void 0 !== t ? t : 0
    }
    Object.assign(fr.prototype, {
        isPlane: !0,
        set: function (e, t) {
            return this.normal.copy(e), this.constant = t, this
        },
        setComponents: function (e, t, n, r) {
            return this.normal.set(e, t, n), this.constant = r, this
        },
        setFromNormalAndCoplanarPoint: function (e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        },
        setFromCoplanarPoints: function (e, t, n) {
            var r = dr.subVectors(n, t).cross(hr.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(r, e), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        },
        normalize: function () {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        },
        negate: function () {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function (e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function (e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function (e, t) {
            return void 0 === t && (console.warn("v3d.Plane: .projectPoint() target is now required"), t = new on), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        },
        intersectLine: function (e, t) {
            void 0 === t && (console.warn("v3d.Plane: .intersectLine() target is now required"), t = new on);
            var n = e.delta(dr),
                r = this.normal.dot(n);
            if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
            var i = -(e.start.dot(this.normal) + this.constant) / r;
            return i < 0 || 1 < i ? void 0 : t.copy(n).multiplyScalar(i).add(e.start)
        },
        intersectsLine: function (e) {
            var t = this.distanceToPoint(e.start),
                n = this.distanceToPoint(e.end);
            return t < 0 && 0 < n || n < 0 && 0 < t
        },
        intersectsBox: function (e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function (e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function (e) {
            return void 0 === e && (console.warn("v3d.Plane: .coplanarPoint() target is now required"), e = new on), e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function (e, t) {
            var n = t || pr.getNormalMatrix(e),
                r = this.coplanarPoint(dr).applyMatrix4(e),
                i = this.normal.applyMatrix3(n).normalize();
            return this.constant = -r.dot(i), this
        },
        translate: function (e) {
            return this.constant -= e.dot(this.normal), this
        },
        equals: function (e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    });
    var mr = new on,
        vr = new on,
        gr = new on,
        _r = new on,
        yr = new on,
        xr = new on,
        br = new on,
        wr = new on,
        Mr = new on,
        Ar = new on;

    function Sr(e, t, n) {
        this.a = void 0 !== e ? e : new on, this.b = void 0 !== t ? t : new on, this.c = void 0 !== n ? n : new on
    }
    Object.assign(Sr, {
        getNormal: function (e, t, n, r) {
            void 0 === r && (console.warn("v3d.Triangle: .getNormal() target is now required"), r = new on), r.subVectors(n, t), mr.subVectors(e, t), r.cross(mr);
            var i = r.lengthSq();
            return 0 < i ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
        },
        getBarycoord: function (e, t, n, r, i) {
            mr.subVectors(r, t), vr.subVectors(n, t), gr.subVectors(e, t);
            var a = mr.dot(mr),
                o = mr.dot(vr),
                s = mr.dot(gr),
                l = vr.dot(vr),
                c = vr.dot(gr),
                u = a * l - o * o;
            if (void 0 === i && (console.warn("v3d.Triangle: .getBarycoord() target is now required"), i = new on), 0 == u) return i.set(-2, -1, -1);
            var d = 1 / u,
                h = (l * s - o * c) * d,
                p = (a * c - o * s) * d;
            return i.set(1 - h - p, p, h)
        },
        containsPoint: function (e, t, n, r) {
            return Sr.getBarycoord(e, t, n, r, _r), 0 <= _r.x && 0 <= _r.y && _r.x + _r.y <= 1
        },
        getUV: function (e, t, n, r, i, a, o, s) {
            return this.getBarycoord(e, t, n, r, _r), s.set(0, 0), s.addScaledVector(i, _r.x), s.addScaledVector(a, _r.y), s.addScaledVector(o, _r.z), s
        },
        isFrontFacing: function (e, t, n, r) {
            return mr.subVectors(n, t), vr.subVectors(e, t), mr.cross(vr).dot(r) < 0
        }
    }), Object.assign(Sr.prototype, {
        set: function (e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
        },
        setFromPointsAndIndices: function (e, t, n, r) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        },
        getArea: function () {
            return mr.subVectors(this.c, this.b), vr.subVectors(this.a, this.b), .5 * mr.cross(vr).length()
        },
        getMidpoint: function (e) {
            return void 0 === e && (console.warn("v3d.Triangle: .getMidpoint() target is now required"), e = new on), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function (e) {
            return Sr.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function (e) {
            return void 0 === e && (console.warn("v3d.Triangle: .getPlane() target is now required"), e = new fr), e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function (e, t) {
            return Sr.getBarycoord(e, this.a, this.b, this.c, t)
        },
        getUV: function (e, t, n, r, i) {
            return Sr.getUV(e, this.a, this.b, this.c, t, n, r, i)
        },
        containsPoint: function (e) {
            return Sr.containsPoint(e, this.a, this.b, this.c)
        },
        isFrontFacing: function (e) {
            return Sr.isFrontFacing(this.a, this.b, this.c, e)
        },
        intersectsBox: function (e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: function (e, t) {
            void 0 === t && (console.warn("v3d.Triangle: .closestPointToPoint() target is now required"), t = new on);
            var n, r, i = this.a,
                a = this.b,
                o = this.c;
            yr.subVectors(a, i), xr.subVectors(o, i), wr.subVectors(e, i);
            var s = yr.dot(wr),
                l = xr.dot(wr);
            if (s <= 0 && l <= 0) return t.copy(i);
            Mr.subVectors(e, a);
            var c = yr.dot(Mr),
                u = xr.dot(Mr);
            if (0 <= c && u <= c) return t.copy(a);
            var d = s * u - c * l;
            if (d <= 0 && 0 <= s && c <= 0) return n = s / (s - c), t.copy(i).addScaledVector(yr, n);
            Ar.subVectors(e, o);
            var h = yr.dot(Ar),
                p = xr.dot(Ar);
            if (0 <= p && h <= p) return t.copy(o);
            var f = h * l - s * p;
            if (f <= 0 && 0 <= l && p <= 0) return r = l / (l - p), t.copy(i).addScaledVector(xr, r);
            var m = c * p - h * u;
            if (m <= 0 && 0 <= u - c && 0 <= h - p) return br.subVectors(o, a), r = (u - c) / (u - c + (h - p)), t.copy(a).addScaledVector(br, r);
            var v = 1 / (m + f + d);
            return n = f * v, r = d * v, t.copy(i).addScaledVector(yr, n).addScaledVector(xr, r)
        },
        equals: function (e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    });
    var Tr = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        Er = {
            h: 0,
            s: 0,
            l: 0
        },
        Cr = {
            h: 0,
            s: 0,
            l: 0
        };

    function Pr(e, t, n) {
        return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
    }

    function Lr(e, t, n) {
        return n < 0 && (n += 1), 1 < n && --n, n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
    }

    function Rr(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
    }

    function Dr(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
    }

    function Ir(e, t, n, r, i, a) {
        this.a = e, this.b = t, this.c = n, this.normal = r && r.isVector3 ? r : new on, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new Pr, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== a ? a : 0
    }
    Object.assign(Pr.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function (e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        },
        setScalar: function (e) {
            return this.r = e, this.g = e, this.b = e, this
        },
        setHex: function (e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        },
        setRGB: function (e, t, n) {
            return this.r = e, this.g = t, this.b = n, this
        },
        setHSL: function (e, t, n) {
            if (e = Yt.euclideanModulo(e, 1), t = Yt.clamp(t, 0, 1), n = Yt.clamp(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
            else {
                var r = n <= .5 ? n * (1 + t) : n + t - n * t,
                    i = 2 * n - r;
                this.r = Lr(i, r, e + 1 / 3), this.g = Lr(i, r, e), this.b = Lr(i, r, e - 1 / 3)
            }
            return this
        },
        setStyle: function (t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("v3d.Color: Alpha component of " + t + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var r, i = n[1],
                    a = n[2];
                switch (i) {
                    case "rgb":
                    case "rgba":
                        if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, e(r[5]), this;
                        if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, e(r[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                            var o = parseFloat(r[1]) / 360,
                                s = parseInt(r[2], 10) / 100,
                                l = parseInt(r[3], 10) / 100;
                            return e(r[5]), this.setHSL(o, s, l)
                        }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                var c = n[1],
                    u = c.length;
                if (3 === u) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                if (6 === u) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
            }
            return t && 0 < t.length ? this.setColorName(t) : this
        },
        setColorName: function (e) {
            var t = Tr[e];
            return void 0 !== t ? this.setHex(t) : console.warn("v3d.Color: Unknown color " + e), this
        },
        clone: function () {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function (e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        },
        copyGammaToLinear: function (e, t) {
            return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        copyLinearToGamma: function (e, t) {
            void 0 === t && (t = 2);
            var n = 0 < t ? 1 / t : 1;
            return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
        },
        convertGammaToLinear: function (e) {
            return this.copyGammaToLinear(this, e), this
        },
        convertLinearToGamma: function (e) {
            return this.copyLinearToGamma(this, e), this
        },
        copySRGBToLinear: function (e) {
            return this.r = Rr(e.r), this.g = Rr(e.g), this.b = Rr(e.b), this
        },
        copyLinearToSRGB: function (e) {
            return this.r = Dr(e.r), this.g = Dr(e.g), this.b = Dr(e.b), this
        },
        convertSRGBToLinear: function () {
            return this.copySRGBToLinear(this), this
        },
        convertLinearToSRGB: function () {
            return this.copyLinearToSRGB(this), this
        },
        getHex: function () {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function (e) {
            void 0 === e && (console.warn("v3d.Color: .getHSL() target is now required"), e = {
                h: 0,
                s: 0,
                l: 0
            });
            var t, n, r = this.r,
                i = this.g,
                a = this.b,
                o = Math.max(r, i, a),
                s = Math.min(r, i, a),
                l = (s + o) / 2;
            if (s === o) n = t = 0;
            else {
                var c = o - s;
                switch (n = l <= .5 ? c / (o + s) : c / (2 - o - s), o) {
                    case r:
                        t = (i - a) / c + (i < a ? 6 : 0);
                        break;
                    case i:
                        t = (a - r) / c + 2;
                        break;
                    case a:
                        t = (r - i) / c + 4
                }
                t /= 6
            }
            return e.h = t, e.s = n, e.l = l, e
        },
        getStyle: function () {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function (e, t, n) {
            return this.getHSL(Er), Er.h += e, Er.s += t, Er.l += n, this.setHSL(Er.h, Er.s, Er.l), this
        },
        add: function (e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        },
        addColors: function (e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        },
        addScalar: function (e) {
            return this.r += e, this.g += e, this.b += e, this
        },
        sub: function (e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        },
        multiply: function (e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        },
        multiplyScalar: function (e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        },
        lerp: function (e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        },
        lerpHSL: function (e, t) {
            this.getHSL(Er), e.getHSL(Cr);
            var n = Yt.lerp(Er.h, Cr.h, t),
                r = Yt.lerp(Er.s, Cr.s, t),
                i = Yt.lerp(Er.l, Cr.l, t);
            return this.setHSL(n, r, i), this
        },
        equals: function (e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        },
        toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        },
        toJSON: function () {
            return this.getHex()
        }
    }), Pr.NAMES = Tr, Object.assign(Ir.prototype, {
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
            for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    });
    var Nr = 0;

    function Or() {
        Object.defineProperty(this, "id", {
            value: Nr++
        }), this.uuid = Yt.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = oe, this.side = re, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = s, this.opacity = 1, this.transparent = !1, this.blendSrc = xe, this.blendDst = be, this.blendEquation = de, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Re, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Ut, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = zt, this.stencilZFail = zt, this.stencilZPass = zt, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this.receiveShadow = !1, this.castShadow = !1, this.useHDR = !1, this.profile = ""
    }

    function Fr(e) {
        Or.call(this), this.type = "MeshBasicMaterial", this.color = new Pr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = U, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e)
    }
    Or.prototype = Object.assign(Object.create(o.prototype), {
        constructor: Or,
        isMaterial: !0,
        onBeforeCompile: function () {},
        setValues: function (e) {
            if (void 0 !== e)
                for (var t in e) {
                    var n = e[t];
                    if (void 0 !== n)
                        if ("shading" !== t) {
                            var r = this[t];
                            void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("v3d." + this.type + ": '" + t + "' is not a property of this material.")
                        } else console.warn("v3d." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                    else console.warn("v3d.Material: '" + t + "' parameter is undefined.")
                }
        },
        toJSON: function (e) {
            var t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function r(e) {
                var t = [];
                for (var n in e) {
                    var r = e[n];
                    delete r.metadata, t.push(r)
                }
                return t
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== oe && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== re && (n.side = this.side), this.vertexColors !== s && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                var i = r(e.textures),
                    a = r(e.images);
                0 < i.length && (n.textures = i), 0 < a.length && (n.images = a)
            }
            return n
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexTangents = e.vertexTangents, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
            var t = e.clippingPlanes,
                n = null;
            if (null !== t) {
                var r = t.length;
                n = new Array(r);
                for (var i = 0; i !== r; ++i) n[i] = t[i].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this.receiveShadow = e.receiveShadow, this.castShadow = e.castShadow, this.useHDR = e.useHDR, this.profile = e.profile, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(Or.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        },
        get: function () {
            return 0 != this.version
        }
    }), ((Fr.prototype = Object.create(Or.prototype)).constructor = Fr).prototype.isMeshBasicMaterial = !0, Fr.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
    };
    var Br = new on;

    function zr(e, t, n) {
        if (Array.isArray(e)) throw new TypeError("v3d.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = Vt, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function Ur(e, t, n) {
        zr.call(this, new Int8Array(e), t, n)
    }

    function Vr(e, t, n) {
        zr.call(this, new Uint8Array(e), t, n)
    }

    function Gr(e, t, n) {
        zr.call(this, new Uint8ClampedArray(e), t, n)
    }

    function kr(e, t, n) {
        zr.call(this, new Int16Array(e), t, n)
    }

    function jr(e, t, n) {
        zr.call(this, new Uint16Array(e), t, n)
    }

    function Wr(e, t, n) {
        zr.call(this, new Int32Array(e), t, n)
    }

    function Xr(e, t, n) {
        zr.call(this, new Uint32Array(e), t, n)
    }

    function Hr(e, t, n) {
        zr.call(this, new Float32Array(e), t, n)
    }

    function Yr(e, t, n) {
        zr.call(this, new Float64Array(e), t, n)
    }

    function qr() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }
    Object.defineProperty(zr.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(zr.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function () {},
        setUsage: function (e) {
            return this.usage = e, this
        },
        copy: function (e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
        },
        copyAt: function (e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
            return this
        },
        copyArray: function (e) {
            return this.array.set(e), this
        },
        copyColorsArray: function (e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var a = e[r];
                void 0 === a && (console.warn("v3d.BufferAttribute.copyColorsArray(): color is undefined", r), a = new Pr), t[n++] = a.r, t[n++] = a.g, t[n++] = a.b
            }
            return this
        },
        copyVector2sArray: function (e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var a = e[r];
                void 0 === a && (console.warn("v3d.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new qt), t[n++] = a.x, t[n++] = a.y
            }
            return this
        },
        copyVector3sArray: function (e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var a = e[r];
                void 0 === a && (console.warn("v3d.BufferAttribute.copyVector3sArray(): vector is undefined", r), a = new on), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z
            }
            return this
        },
        copyVector4sArray: function (e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var a = e[r];
                void 0 === a && (console.warn("v3d.BufferAttribute.copyVector4sArray(): vector is undefined", r), a = new $t), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z, t[n++] = a.w
            }
            return this
        },
        applyMatrix3: function (e) {
            for (var t = 0, n = this.count; t < n; t++) Br.x = this.getX(t), Br.y = this.getY(t), Br.z = this.getZ(t), Br.applyMatrix3(e), this.setXYZ(t, Br.x, Br.y, Br.z);
            return this
        },
        applyMatrix4: function (e) {
            for (var t = 0, n = this.count; t < n; t++) Br.x = this.getX(t), Br.y = this.getY(t), Br.z = this.getZ(t), Br.applyMatrix4(e), this.setXYZ(t, Br.x, Br.y, Br.z);
            return this
        },
        applyNormalMatrix: function (e) {
            for (var t = 0, n = this.count; t < n; t++) Br.x = this.getX(t), Br.y = this.getY(t), Br.z = this.getZ(t), Br.applyNormalMatrix(e), this.setXYZ(t, Br.x, Br.y, Br.z);
            return this
        },
        transformDirection: function (e) {
            for (var t = 0, n = this.count; t < n; t++) Br.x = this.getX(t), Br.y = this.getY(t), Br.z = this.getZ(t), Br.transformDirection(e), this.setXYZ(t, Br.x, Br.y, Br.z);
            return this
        },
        set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        getX: function (e) {
            return this.array[e * this.itemSize]
        },
        setX: function (e, t) {
            return this.array[e * this.itemSize] = t, this
        },
        getY: function (e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function (e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        },
        getZ: function (e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function (e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        },
        getW: function (e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function (e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        },
        setXY: function (e, t, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
        },
        setXYZ: function (e, t, n, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
        },
        setXYZW: function (e, t, n, r, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
        },
        onUpload: function (e) {
            return this.onUploadCallback = e, this
        },
        clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this)
        },
        toJSON: function () {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }), (Ur.prototype = Object.create(zr.prototype)).constructor = Ur, (Vr.prototype = Object.create(zr.prototype)).constructor = Vr, (Gr.prototype = Object.create(zr.prototype)).constructor = Gr, (kr.prototype = Object.create(zr.prototype)).constructor = kr, (jr.prototype = Object.create(zr.prototype)).constructor = jr, (Wr.prototype = Object.create(zr.prototype)).constructor = Wr, (Xr.prototype = Object.create(zr.prototype)).constructor = Xr, (Hr.prototype = Object.create(zr.prototype)).constructor = Hr, (Yr.prototype = Object.create(zr.prototype)).constructor = Yr, Object.assign(qr.prototype, {
        computeGroups: function (e) {
            for (var t, n = [], r = void 0, i = e.faces, a = 0; a < i.length; a++) {
                var o = i[a];
                o.materialIndex !== r && (r = o.materialIndex, void 0 !== t && (t.count = 3 * a - t.start, n.push(t)), t = {
                    start: 3 * a,
                    materialIndex: r
                })
            }
            void 0 !== t && (t.count = 3 * a - t.start, n.push(t)), this.groups = n
        },
        fromGeometry: function (e) {
            var t, n = e.faces,
                r = e.vertices,
                i = e.faceVertexUvs,
                a = i[0] && 0 < i[0].length,
                o = i[1] && 0 < i[1].length,
                s = e.morphTargets,
                l = s.length;
            if (0 < l) {
                t = [];
                for (var c = 0; c < l; c++) t[c] = {
                    name: s[c].name,
                    data: []
                };
                this.morphTargets.position = t
            }
            var u, d = e.morphNormals,
                h = d.length;
            if (0 < h) {
                u = [];
                for (c = 0; c < h; c++) u[c] = {
                    name: d[c].name,
                    data: []
                };
                this.morphTargets.normal = u
            }
            var p = e.skinIndices,
                f = e.skinWeights,
                m = p.length === r.length,
                v = f.length === r.length;
            0 < r.length && 0 === n.length && console.error("v3d.DirectGeometry: Faceless geometries are not supported.");
            for (c = 0; c < n.length; c++) {
                var g = n[c];
                this.vertices.push(r[g.a], r[g.b], r[g.c]);
                var _ = g.vertexNormals;
                if (3 === _.length) this.normals.push(_[0], _[1], _[2]);
                else {
                    var y = g.normal;
                    this.normals.push(y, y, y)
                }
                var x, b = g.vertexColors;
                if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                else {
                    var w = g.color;
                    this.colors.push(w, w, w)
                }
                if (!0 === a) void 0 !== (x = i[0][c]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("v3d.DirectGeometry.fromGeometry(): Undefined vertexUv ", c), this.uvs.push(new qt, new qt, new qt));
                if (!0 === o) void 0 !== (x = i[1][c]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("v3d.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", c), this.uvs2.push(new qt, new qt, new qt));
                for (var M = 0; M < l; M++) {
                    var A = s[M].vertices;
                    t[M].data.push(A[g.a], A[g.b], A[g.c])
                }
                for (M = 0; M < h; M++) {
                    var S = d[M].vertexNormals[c];
                    u[M].data.push(S.a, S.b, S.c)
                }
                m && this.skinIndices.push(p[g.a], p[g.b], p[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
            }
            return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        }
    });
    var Zr = 1,
        Qr = new fn,
        Kr = new Fn,
        Jr = new on,
        $r = new Kn,
        ei = new Kn,
        ti = new on;

    function ni() {
        Object.defineProperty(this, "id", {
            value: Zr += 2
        }), this.uuid = Yt.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    ni.prototype = Object.assign(Object.create(o.prototype), {
        constructor: ni,
        isBufferGeometry: !0,
        getIndex: function () {
            return this.index
        },
        setIndex: function (e) {
            Array.isArray(e) ? this.index = new(65535 < yn(e) ? Xr : jr)(e, 1) : this.index = e
        },
        getAttribute: function (e) {
            return this.attributes[e]
        },
        setAttribute: function (e, t) {
            return this.attributes[e] = t, this
        },
        deleteAttribute: function (e) {
            return delete this.attributes[e], this
        },
        addGroup: function (e, t, n) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function () {
            this.groups = []
        },
        setDrawRange: function (e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        },
        applyMatrix4: function (e) {
            var t = this.attributes.position;
            void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
            var n = this.attributes.normal;
            if (void 0 !== n) {
                var r = (new Zt).getNormalMatrix(e);
                n.applyNormalMatrix(r), n.needsUpdate = !0
            }
            var i = this.attributes.tangent;
            return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function (e) {
            return Qr.makeRotationX(e), this.applyMatrix4(Qr), this
        },
        rotateY: function (e) {
            return Qr.makeRotationY(e), this.applyMatrix4(Qr), this
        },
        rotateZ: function (e) {
            return Qr.makeRotationZ(e), this.applyMatrix4(Qr), this
        },
        translate: function (e, t, n) {
            return Qr.makeTranslation(e, t, n), this.applyMatrix4(Qr), this
        },
        scale: function (e, t, n) {
            return Qr.makeScale(e, t, n), this.applyMatrix4(Qr), this
        },
        lookAt: function (e) {
            return Kr.lookAt(e), Kr.updateMatrix(), this.applyMatrix4(Kr.matrix), this
        },
        center: function () {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Jr).negate(), this.translate(Jr.x, Jr.y, Jr.z), this
        },
        setFromObject: function (e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                var n = new Hr(3 * t.vertices.length, 3),
                    r = new Hr(3 * t.colors.length, 3);
                if (this.setAttribute("position", n.copyVector3sArray(t.vertices)), this.setAttribute("color", r.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                    var i = new Hr(t.lineDistances.length, 1);
                    this.setAttribute("lineDistance", i.copyArray(t.lineDistances))
                }
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        setFromPoints: function (e) {
            for (var t = [], n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                t.push(i.x, i.y, i.z || 0)
            }
            return this.setAttribute("position", new Hr(t, 3)), this
        },
        updateFromObject: function (e) {
            var t, n = e.geometry;
            if (e.isMesh) {
                var r = n.__directGeometry;
                if (!0 === n.elementsNeedUpdate && (r = void 0, n.elementsNeedUpdate = !1), void 0 === r) return this.fromGeometry(n);
                r.verticesNeedUpdate = n.verticesNeedUpdate, r.normalsNeedUpdate = n.normalsNeedUpdate, r.colorsNeedUpdate = n.colorsNeedUpdate, r.uvsNeedUpdate = n.uvsNeedUpdate, r.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = r
            }
            return !0 === n.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(n.vertices), t.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(n.normals), t.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(n.colors), t.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(n.uvs), t.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(n.lineDistances), t.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(e.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
        },
        fromGeometry: function (e) {
            return e.__directGeometry = (new qr).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function (e) {
            var t = new Float32Array(3 * e.vertices.length);
            if (this.setAttribute("position", new zr(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length) {
                var n = new Float32Array(3 * e.normals.length);
                this.setAttribute("normal", new zr(n, 3).copyVector3sArray(e.normals))
            }
            if (0 < e.colors.length) {
                var r = new Float32Array(3 * e.colors.length);
                this.setAttribute("color", new zr(r, 3).copyColorsArray(e.colors))
            }
            if (0 < e.uvs.length) {
                var i = new Float32Array(2 * e.uvs.length);
                this.setAttribute("uv", new zr(i, 2).copyVector2sArray(e.uvs))
            }
            if (0 < e.uvs2.length) {
                var a = new Float32Array(2 * e.uvs2.length);
                this.setAttribute("uv2", new zr(a, 2).copyVector2sArray(e.uvs2))
            }
            for (var o in this.groups = e.groups, e.morphTargets) {
                for (var s = [], l = e.morphTargets[o], c = 0, u = l.length; c < u; c++) {
                    var d = l[c],
                        h = new Hr(3 * d.data.length, 3);
                    h.name = d.name, s.push(h.copyVector3sArray(d.data))
                }
                this.morphAttributes[o] = s
            }
            if (0 < e.skinIndices.length) {
                var p = new Hr(4 * e.skinIndices.length, 4);
                this.setAttribute("skinIndex", p.copyVector4sArray(e.skinIndices))
            }
            if (0 < e.skinWeights.length) {
                var f = new Hr(4 * e.skinWeights.length, 4);
                this.setAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
            }
            return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new Kn);
            var e = this.attributes.position,
                t = this.morphAttributes.position;
            if (void 0 !== e) {
                if (this.boundingBox.setFromBufferAttribute(e), t)
                    for (var n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        $r.setFromBufferAttribute(i), this.morphTargetsRelative ? (ti.addVectors(this.boundingBox.min, $r.min), this.boundingBox.expandByPoint(ti), ti.addVectors(this.boundingBox.max, $r.max), this.boundingBox.expandByPoint(ti)) : (this.boundingBox.expandByPoint($r.min), this.boundingBox.expandByPoint($r.max))
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('v3d.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new nr);
            var e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e) {
                var n = this.boundingSphere.center;
                if ($r.setFromBufferAttribute(e), t)
                    for (var r = 0, i = t.length; r < i; r++) {
                        var a = t[r];
                        ei.setFromBufferAttribute(a), this.morphTargetsRelative ? (ti.addVectors($r.min, ei.min), $r.expandByPoint(ti), ti.addVectors($r.max, ei.max), $r.expandByPoint(ti)) : ($r.expandByPoint(ei.min), $r.expandByPoint(ei.max))
                    }
                $r.getCenter(n);
                var o = 0;
                for (r = 0, i = e.count; r < i; r++) ti.fromBufferAttribute(e, r), o = Math.max(o, n.distanceToSquared(ti));
                if (t)
                    for (r = 0, i = t.length; r < i; r++) {
                        a = t[r];
                        for (var s = this.morphTargetsRelative, l = 0, c = a.count; l < c; l++) ti.fromBufferAttribute(a, l), s && (Jr.fromBufferAttribute(e, l), ti.add(Jr)), o = Math.max(o, n.distanceToSquared(ti))
                    }
                this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('v3d.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function () {},
        computeVertexNormals: function () {
            var e = this.index,
                t = this.attributes;
            if (t.position) {
                var n = t.position.array;
                if (void 0 === t.normal) this.setAttribute("normal", new zr(new Float32Array(n.length), 3));
                else
                    for (var r = t.normal.array, i = 0, a = r.length; i < a; i++) r[i] = 0;
                var o, s, l, c = t.normal.array,
                    u = new on,
                    d = new on,
                    h = new on,
                    p = new on,
                    f = new on;
                if (e) {
                    var m = e.array;
                    for (i = 0, a = e.count; i < a; i += 3) o = 3 * m[i + 0], s = 3 * m[i + 1], l = 3 * m[i + 2], u.fromArray(n, o), d.fromArray(n, s), h.fromArray(n, l), p.subVectors(h, d), f.subVectors(u, d), p.cross(f), c[o] += p.x, c[1 + o] += p.y, c[2 + o] += p.z, c[s] += p.x, c[1 + s] += p.y, c[2 + s] += p.z, c[l] += p.x, c[1 + l] += p.y, c[2 + l] += p.z
                } else
                    for (i = 0, a = n.length; i < a; i += 9) u.fromArray(n, i), d.fromArray(n, i + 3), h.fromArray(n, i + 6), p.subVectors(h, d), f.subVectors(u, d), p.cross(f), c[i] = p.x, c[i + 1] = p.y, c[i + 2] = p.z, c[i + 3] = p.x, c[i + 4] = p.y, c[i + 5] = p.z, c[i + 6] = p.x, c[i + 7] = p.y, c[i + 8] = p.z;
                this.normalizeNormals(), t.normal.needsUpdate = !0
            }
        },
        merge: function (e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0, console.warn("v3d.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var n = this.attributes;
                for (var r in n)
                    if (void 0 !== e.attributes[r])
                        for (var i = n[r].array, a = e.attributes[r], o = a.array, s = a.itemSize * t, l = Math.min(o.length, i.length - s), c = 0, u = s; c < l; c++, u++) i[u] = o[c];
                return this
            }
            console.error("v3d.BufferGeometry.merge(): geometry not an instance of v3d.BufferGeometry.", e)
        },
        normalizeNormals: function () {
            for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) ti.x = e.getX(t), ti.y = e.getY(t), ti.z = e.getZ(t), ti.normalize(), e.setXYZ(t, ti.x, ti.y, ti.z)
        },
        toNonIndexed: function () {
            function e(e, t) {
                for (var n = e.array, r = e.itemSize, i = new n.constructor(t.length * r), a = 0, o = 0, s = 0, l = t.length; s < l; s++) {
                    a = t[s] * r;
                    for (var c = 0; c < r; c++) i[o++] = n[a++]
                }
                return new zr(i, r)
            }
            if (null === this.index) return console.warn("v3d.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var t = new ni,
                n = this.index.array,
                r = this.attributes;
            for (var i in r) {
                var a = e(r[i], n);
                t.setAttribute(i, a)
            }
            var o = this.morphAttributes;
            for (i in o) {
                for (var s = [], l = o[i], c = 0, u = l.length; c < u; c++) {
                    a = e(l[c], n);
                    s.push(a)
                }
                t.morphAttributes[i] = s
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            for (var d = this.groups, h = (c = 0, d.length); c < h; c++) {
                var p = d[c];
                t.addGroup(p.start, p.count, p.materialIndex)
            }
            return t
        },
        toJSON: function () {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) {
                var t = this.parameters;
                for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            e.data = {
                attributes: {}
            };
            var r = this.index;
            null !== r && (e.data.index = {
                type: r.array.constructor.name,
                array: Array.prototype.slice.call(r.array)
            });
            var i = this.attributes;
            for (var n in i) {
                var a = (h = i[n]).toJSON();
                "" !== h.name && (a.name = h.name), e.data.attributes[n] = a
            }
            var o = {},
                s = !1;
            for (var n in this.morphAttributes) {
                for (var l = this.morphAttributes[n], c = [], u = 0, d = l.length; u < d; u++) {
                    var h;
                    a = (h = l[u]).toJSON();
                    "" !== h.name && (a.name = h.name), c.push(a)
                }
                0 < c.length && (o[n] = c, s = !0)
            }
            s && (e.data.morphAttributes = o, e.data.morphTargetsRelative = this.morphTargetsRelative);
            var p = this.groups;
            0 < p.length && (e.data.groups = JSON.parse(JSON.stringify(p)));
            var f = this.boundingSphere;
            return null !== f && (e.data.boundingSphere = {
                center: f.center.toArray(),
                radius: f.radius
            }), e
        },
        clone: function () {
            return (new ni).copy(this)
        },
        copy: function (e) {
            var t, n, r;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
            var i = e.index;
            null !== i && this.setIndex(i.clone());
            var a = e.attributes;
            for (t in a) {
                var o = a[t];
                this.setAttribute(t, o.clone())
            }
            var s = e.morphAttributes;
            for (t in s) {
                var l = [],
                    c = s[t];
                for (n = 0, r = c.length; n < r; n++) l.push(c[n].clone());
                this.morphAttributes[t] = l
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            var u = e.groups;
            for (n = 0, r = u.length; n < r; n++) {
                var d = u[n];
                this.addGroup(d.start, d.count, d.materialIndex)
            }
            var h = e.boundingBox;
            null !== h && (this.boundingBox = h.clone());
            var p = e.boundingSphere;
            return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var ri = new fn,
        ii = new ur,
        ai = new nr,
        oi = new on,
        si = new on,
        li = new on,
        ci = new on,
        ui = new on,
        di = new on,
        hi = new on,
        pi = new on,
        fi = new on,
        mi = new qt,
        vi = new qt,
        gi = new qt,
        _i = new on,
        yi = new on;

    function xi(e, t) {
        Fn.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new ni, this.material = void 0 !== t ? t : new Fr, this.updateMorphTargets(), this.isMaterialGeneratedMesh = !1
    }

    function bi(e, t, n, r, i, a, o, s) {
        if (null === (t.side === Pe ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, t.side !== ie, s))) return null;
        yi.copy(s), yi.applyMatrix4(e.matrixWorld);
        var l = n.ray.origin.distanceTo(yi);
        return l < n.near || l > n.far ? null : {
            distance: l,
            point: yi.clone(),
            object: e
        }
    }

    function wi(e, t, n, r, i, a, o, s, l, c, u, d) {
        oi.fromBufferAttribute(i, c), si.fromBufferAttribute(i, u), li.fromBufferAttribute(i, d);
        var h = e.morphTargetInfluences;
        if (t.morphTargets && a && h) {
            hi.set(0, 0, 0), pi.set(0, 0, 0), fi.set(0, 0, 0);
            for (var p = 0, f = a.length; p < f; p++) {
                var m = h[p],
                    v = a[p];
                0 !== m && (ci.fromBufferAttribute(v, c), ui.fromBufferAttribute(v, u), di.fromBufferAttribute(v, d), o ? (hi.addScaledVector(ci, m), pi.addScaledVector(ui, m), fi.addScaledVector(di, m)) : (hi.addScaledVector(ci.sub(oi), m), pi.addScaledVector(ui.sub(si), m), fi.addScaledVector(di.sub(li), m)))
            }
            oi.add(hi), si.add(pi), li.add(fi)
        }
        var g = bi(e, t, n, r, oi, si, li, _i);
        if (g) {
            s && (mi.fromBufferAttribute(s, c), vi.fromBufferAttribute(s, u), gi.fromBufferAttribute(s, d), g.uv = Sr.getUV(_i, oi, si, li, mi, vi, gi, new qt)), l && (mi.fromBufferAttribute(l, c), vi.fromBufferAttribute(l, u), gi.fromBufferAttribute(l, d), g.uv2 = Sr.getUV(_i, oi, si, li, mi, vi, gi, new qt));
            var _ = new Ir(c, u, d);
            Sr.getNormal(oi, si, li, _.normal), g.face = _
        }
        return g
    }
    xi.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: xi,
        isMesh: !0,
        copy: function (e) {
            return Fn.prototype.copy.call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.isMaterialGeneratedMesh = e.isMaterialGeneratedMesh, this
        },
        updateMorphTargets: function () {
            var e, t, n, r = this.geometry;
            if (r.isBufferGeometry) {
                var i = r.morphAttributes,
                    a = Object.keys(i);
                if (0 < a.length) {
                    var o = i[a[0]];
                    if (void 0 !== o)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = o.length; e < t; e++) n = o[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                }
            } else {
                var s = r.morphTargets;
                void 0 !== s && 0 < s.length && console.error("v3d.Mesh.updateMorphTargets() no longer supports v3d.Geometry. Use v3d.BufferGeometry instead.")
            }
        },
        raycast: function (e, t) {
            var n, r = this.geometry,
                i = this.material,
                a = this.matrixWorld;
            if (void 0 !== i && (null === r.boundingSphere && r.computeBoundingSphere(), ai.copy(r.boundingSphere), ai.applyMatrix4(a), !1 !== e.ray.intersectsSphere(ai) && (ri.getInverse(a), ii.copy(e.ray).applyMatrix4(ri), null === r.boundingBox || !1 !== ii.intersectsBox(r.boundingBox))))
                if (r.isBufferGeometry) {
                    var o, s, l, c, u, d, h, p, f, m = r.index,
                        v = r.attributes.position,
                        g = r.morphAttributes.position,
                        _ = r.morphTargetsRelative,
                        y = r.attributes.uv,
                        x = r.attributes.uv2,
                        b = r.groups,
                        w = r.drawRange;
                    if (null !== m)
                        if (Array.isArray(i))
                            for (c = 0, d = b.length; c < d; c++)
                                for (f = i[(p = b[c]).materialIndex], u = Math.max(p.start, w.start), h = Math.min(p.start + p.count, w.start + w.count); u < h; u += 3) o = m.getX(u), s = m.getX(u + 1), l = m.getX(u + 2), (n = wi(this, f, e, ii, v, g, _, y, x, o, s, l)) && (n.faceIndex = Math.floor(u / 3), n.face.materialIndex = p.materialIndex, t.push(n));
                        else
                            for (c = Math.max(0, w.start), d = Math.min(m.count, w.start + w.count); c < d; c += 3) o = m.getX(c), s = m.getX(c + 1), l = m.getX(c + 2), (n = wi(this, i, e, ii, v, g, _, y, x, o, s, l)) && (n.faceIndex = Math.floor(c / 3), t.push(n));
                    else if (void 0 !== v)
                        if (Array.isArray(i))
                            for (c = 0, d = b.length; c < d; c++)
                                for (f = i[(p = b[c]).materialIndex], u = Math.max(p.start, w.start), h = Math.min(p.start + p.count, w.start + w.count); u < h; u += 3)(n = wi(this, f, e, ii, v, g, _, y, x, o = u, s = u + 1, l = u + 2)) && (n.faceIndex = Math.floor(u / 3), n.face.materialIndex = p.materialIndex, t.push(n));
                        else
                            for (c = Math.max(0, w.start), d = Math.min(v.count, w.start + w.count); c < d; c += 3)(n = wi(this, i, e, ii, v, g, _, y, x, o = c, s = c + 1, l = c + 2)) && (n.faceIndex = Math.floor(c / 3), t.push(n))
                } else if (r.isGeometry) {
                var M, A, S, T, E = Array.isArray(i),
                    C = r.vertices,
                    P = r.faces,
                    L = r.faceVertexUvs[0];
                0 < L.length && (T = L);
                for (var R = 0, D = P.length; R < D; R++) {
                    var I = P[R],
                        N = E ? i[I.materialIndex] : i;
                    if (void 0 !== N && (M = C[I.a], A = C[I.b], S = C[I.c], n = bi(this, N, e, ii, M, A, S, _i))) {
                        if (T && T[R]) {
                            var O = T[R];
                            mi.copy(O[0]), vi.copy(O[1]), gi.copy(O[2]), n.uv = Sr.getUV(_i, M, A, S, mi, vi, gi, new qt)
                        }
                        n.face = I, n.faceIndex = R, t.push(n)
                    }
                }
            }
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        },
        getWorldDirection: function (e) {
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        isVisible: function () {
            return this.isMaterialGeneratedMesh && this.parent ? this.visible && this.parent.visible : this.visible
        }
    });
    var Mi = 0,
        Ai = new fn,
        Si = new Fn,
        Ti = new on;

    function Ei() {
        Object.defineProperty(this, "id", {
            value: Mi += 2
        }), this.uuid = Yt.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function Ci(e, t, n, r, i, a) {
        Ei.call(this), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: a
        }, this.fromBufferGeometry(new Pi(e, t, n, r, i, a)), this.mergeVertices()
    }

    function Pi(e, t, n, r, i, a) {
        ni.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: a
        };
        var P = this;
        e = e || 1, t = t || 1, n = n || 1, r = Math.floor(r) || 1, i = Math.floor(i) || 1, a = Math.floor(a) || 1;
        var L = [],
            R = [],
            D = [],
            I = [],
            N = 0,
            O = 0;

        function o(e, t, n, r, i, a, o, s, l, c, u) {
            var d, h, p = a / l,
                f = o / c,
                m = a / 2,
                v = o / 2,
                g = s / 2,
                _ = l + 1,
                y = c + 1,
                x = 0,
                b = 0,
                w = new on;
            for (h = 0; h < y; h++) {
                var M = h * f - v;
                for (d = 0; d < _; d++) {
                    var A = d * p - m;
                    w[e] = A * r, w[t] = M * i, w[n] = g, R.push(w.x, w.y, w.z), w[e] = 0, w[t] = 0, w[n] = 0 < s ? 1 : -1, D.push(w.x, w.y, w.z), I.push(d / l), I.push(1 - h / c), x += 1
                }
            }
            for (h = 0; h < c; h++)
                for (d = 0; d < l; d++) {
                    var S = N + d + _ * h,
                        T = N + d + _ * (h + 1),
                        E = N + (d + 1) + _ * (h + 1),
                        C = N + (d + 1) + _ * h;
                    L.push(S, T, C), L.push(T, E, C), b += 6
                }
            P.addGroup(O, b, u), O += b, N += x
        }
        o("z", "y", "x", -1, -1, n, t, e, a, i, 0), o("z", "y", "x", 1, -1, n, t, -e, a, i, 1), o("x", "z", "y", 1, 1, e, n, t, r, a, 2), o("x", "z", "y", 1, -1, e, n, -t, r, a, 3), o("x", "y", "z", 1, -1, e, t, n, r, i, 4), o("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(L), this.setAttribute("position", new Hr(R, 3)), this.setAttribute("normal", new Hr(D, 3)), this.setAttribute("uv", new Hr(I, 2))
    }

    function Li(e) {
        var t = {};
        for (var n in e)
            for (var r in t[n] = {}, e[n]) {
                var i = e[n][r];
                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
            }
        return t
    }

    function Ri(e) {
        for (var t = {}, n = 0; n < e.length; n++) {
            var r = Li(e[n]);
            for (var i in r) t[i] = r[i]
        }
        return t
    }
    Ei.prototype = Object.assign(Object.create(o.prototype), {
        constructor: Ei,
        isGeometry: !0,
        applyMatrix4: function (e) {
            for (var t = (new Zt).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) {
                this.vertices[n].applyMatrix4(e)
            }
            for (n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n];
                i.normal.applyMatrix3(t).normalize();
                for (var a = 0, o = i.vertexNormals.length; a < o; a++) i.vertexNormals[a].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function (e) {
            return Ai.makeRotationX(e), this.applyMatrix4(Ai), this
        },
        rotateY: function (e) {
            return Ai.makeRotationY(e), this.applyMatrix4(Ai), this
        },
        rotateZ: function (e) {
            return Ai.makeRotationZ(e), this.applyMatrix4(Ai), this
        },
        translate: function (e, t, n) {
            return Ai.makeTranslation(e, t, n), this.applyMatrix4(Ai), this
        },
        scale: function (e, t, n) {
            return Ai.makeScale(e, t, n), this.applyMatrix4(Ai), this
        },
        lookAt: function (e) {
            return Si.lookAt(e), Si.updateMatrix(), this.applyMatrix4(Si.matrix), this
        },
        fromBufferGeometry: function (e) {
            var o = this,
                t = null !== e.index ? e.index.array : void 0,
                n = e.attributes;
            if (void 0 === n.position) return console.error("v3d.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
            var r = n.position.array,
                s = void 0 !== n.normal ? n.normal.array : void 0,
                l = void 0 !== n.color ? n.color.array : void 0,
                c = void 0 !== n.uv ? n.uv.array : void 0,
                u = void 0 !== n.uv2 ? n.uv2.array : void 0;
            void 0 !== u && (this.faceVertexUvs[1] = []);
            for (var i = 0; i < r.length; i += 3) o.vertices.push((new on).fromArray(r, i)), void 0 !== l && o.colors.push((new Pr).fromArray(l, i));

            function a(e, t, n, r) {
                var i = void 0 === l ? [] : [o.colors[e].clone(), o.colors[t].clone(), o.colors[n].clone()],
                    a = new Ir(e, t, n, void 0 === s ? [] : [(new on).fromArray(s, 3 * e), (new on).fromArray(s, 3 * t), (new on).fromArray(s, 3 * n)], i, r);
                o.faces.push(a), void 0 !== c && o.faceVertexUvs[0].push([(new qt).fromArray(c, 2 * e), (new qt).fromArray(c, 2 * t), (new qt).fromArray(c, 2 * n)]), void 0 !== u && o.faceVertexUvs[1].push([(new qt).fromArray(u, 2 * e), (new qt).fromArray(u, 2 * t), (new qt).fromArray(u, 2 * n)])
            }
            var d = e.groups;
            if (0 < d.length)
                for (i = 0; i < d.length; i++)
                    for (var h = d[i], p = h.start, f = p, m = p + h.count; f < m; f += 3) void 0 !== t ? a(t[f], t[f + 1], t[f + 2], h.materialIndex) : a(f, f + 1, f + 2, h.materialIndex);
            else if (void 0 !== t)
                for (i = 0; i < t.length; i += 3) a(t[i], t[i + 1], t[i + 2]);
            else
                for (i = 0; i < r.length / 3; i += 3) a(i, i + 1, i + 2);
            return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        },
        center: function () {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Ti).negate(), this.translate(Ti.x, Ti.y, Ti.z), this
        },
        normalize: function () {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center,
                t = this.boundingSphere.radius,
                n = 0 === t ? 1 : 1 / t,
                r = new fn;
            return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix4(r), this
        },
        computeFaceNormals: function () {
            for (var e = new on, t = new on, n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n],
                    a = this.vertices[i.a],
                    o = this.vertices[i.b],
                    s = this.vertices[i.c];
                e.subVectors(s, o), t.subVectors(a, o), e.cross(t), e.normalize(), i.normal.copy(e)
            }
        },
        computeVertexNormals: function (e) {
            var t, n, r, i, a, o;
            for (void 0 === e && (e = !0), o = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) o[t] = new on;
            if (e) {
                var s, l, c, u = new on,
                    d = new on;
                for (r = 0, i = this.faces.length; r < i; r++) a = this.faces[r], s = this.vertices[a.a], l = this.vertices[a.b], c = this.vertices[a.c], u.subVectors(c, l), d.subVectors(s, l), u.cross(d), o[a.a].add(u), o[a.b].add(u), o[a.c].add(u)
            } else
                for (this.computeFaceNormals(), r = 0, i = this.faces.length; r < i; r++) o[(a = this.faces[r]).a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal);
            for (t = 0, n = this.vertices.length; t < n; t++) o[t].normalize();
            for (r = 0, i = this.faces.length; r < i; r++) {
                var h = (a = this.faces[r]).vertexNormals;
                3 === h.length ? (h[0].copy(o[a.a]), h[1].copy(o[a.b]), h[2].copy(o[a.c])) : (h[0] = o[a.a].clone(), h[1] = o[a.b].clone(), h[2] = o[a.c].clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function () {
            var e, t, n;
            for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                var r = (n = this.faces[e]).vertexNormals;
                3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function () {
            var e, t, n, r, i;
            for (n = 0, r = this.faces.length; n < r; n++)
                for ((i = this.faces[n]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
            var a = new Ei;
            for (a.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                    var o = this.morphNormals[e].faceNormals,
                        s = this.morphNormals[e].vertexNormals;
                    for (n = 0, r = this.faces.length; n < r; n++) l = new on, c = {
                        a: new on,
                        b: new on,
                        c: new on
                    }, o.push(l), s.push(c)
                }
                var l, c, u = this.morphNormals[e];
                for (a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals(), n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], l = u.faceNormals[n], c = u.vertexNormals[n], l.copy(i.normal), c.a.copy(i.vertexNormals[0]), c.b.copy(i.vertexNormals[1]), c.c.copy(i.vertexNormals[2])
            }
            for (n = 0, r = this.faces.length; n < r; n++)(i = this.faces[n]).normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new Kn), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new nr), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function (e, t, n) {
            if (e && e.isGeometry) {
                var r, i = this.vertices.length,
                    a = this.vertices,
                    o = e.vertices,
                    s = this.faces,
                    l = e.faces,
                    c = this.colors,
                    u = e.colors;
                void 0 === n && (n = 0), void 0 !== t && (r = (new Zt).getNormalMatrix(t));
                for (var d = 0, h = o.length; d < h; d++) {
                    var p = o[d].clone();
                    void 0 !== t && p.applyMatrix4(t), a.push(p)
                }
                for (d = 0, h = u.length; d < h; d++) c.push(u[d].clone());
                for (d = 0, h = l.length; d < h; d++) {
                    var f, m, v, g = l[d],
                        _ = g.vertexNormals,
                        y = g.vertexColors;
                    (f = new Ir(g.a + i, g.b + i, g.c + i)).normal.copy(g.normal), void 0 !== r && f.normal.applyMatrix3(r).normalize();
                    for (var x = 0, b = _.length; x < b; x++) m = _[x].clone(), void 0 !== r && m.applyMatrix3(r).normalize(), f.vertexNormals.push(m);
                    f.color.copy(g.color);
                    for (x = 0, b = y.length; x < b; x++) v = y[x], f.vertexColors.push(v.clone());
                    f.materialIndex = g.materialIndex + n, s.push(f)
                }
                for (d = 0, h = e.faceVertexUvs.length; d < h; d++) {
                    var w = e.faceVertexUvs[d];
                    void 0 === this.faceVertexUvs[d] && (this.faceVertexUvs[d] = []);
                    for (x = 0, b = w.length; x < b; x++) {
                        for (var M = w[x], A = [], S = 0, T = M.length; S < T; S++) A.push(M[S].clone());
                        this.faceVertexUvs[d].push(A)
                    }
                }
            } else console.error("v3d.Geometry.merge(): geometry not an instance of v3d.Geometry.", e)
        },
        mergeMesh: function (e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("v3d.Geometry.mergeMesh(): mesh not an instance of v3d.Mesh.", e)
        },
        mergeVertices: function () {
            var e, t, n, r, i, a, o, s, l = {},
                c = [],
                u = [],
                d = Math.pow(10, 4);
            for (n = 0, r = this.vertices.length; n < r; n++) e = this.vertices[n], void 0 === l[t = Math.round(e.x * d) + "_" + Math.round(e.y * d) + "_" + Math.round(e.z * d)] ? (l[t] = n, c.push(this.vertices[n]), u[n] = c.length - 1) : u[n] = u[l[t]];
            var h = [];
            for (n = 0, r = this.faces.length; n < r; n++) {
                (i = this.faces[n]).a = u[i.a], i.b = u[i.b], i.c = u[i.c], a = [i.a, i.b, i.c];
                for (var p = 0; p < 3; p++)
                    if (a[p] === a[(p + 1) % 3]) {
                        h.push(n);
                        break
                    }
            }
            for (n = h.length - 1; 0 <= n; n--) {
                var f = h[n];
                for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++) this.faceVertexUvs[o].splice(f, 1)
            }
            var m = this.vertices.length - c.length;
            return this.vertices = c, m
        },
        setFromPoints: function (e) {
            this.vertices = [];
            for (var t = 0, n = e.length; t < n; t++) {
                var r = e[t];
                this.vertices.push(new on(r.x, r.y, r.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function () {
            for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
            e.sort(function (e, t) {
                return e.materialIndex - t.materialIndex
            });
            var r, i, a = this.faceVertexUvs[0],
                o = this.faceVertexUvs[1];
            a && a.length === t && (r = []), o && o.length === t && (i = []);
            for (n = 0; n < t; n++) {
                var s = e[n]._id;
                r && r.push(a[s]), i && i.push(o[s])
            }
            r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i)
        },
        toJSON: function () {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                var t = this.parameters;
                for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            for (var r = [], i = 0; i < this.vertices.length; i++) {
                var a = this.vertices[i];
                r.push(a.x, a.y, a.z)
            }
            var o = [],
                s = [],
                l = {},
                c = [],
                u = {},
                d = [],
                h = {};
            for (i = 0; i < this.faces.length; i++) {
                var p = this.faces[i],
                    f = void 0 !== this.faceVertexUvs[0][i],
                    m = 0 < p.normal.length(),
                    v = 0 < p.vertexNormals.length,
                    g = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                    _ = 0 < p.vertexColors.length,
                    y = 0;
                if (y = M(y, 0, 0), y = M(y, 1, !0), y = M(y, 2, !1), y = M(y, 3, f), y = M(y, 4, m), y = M(y, 5, v), y = M(y, 6, g), y = M(y, 7, _), o.push(y), o.push(p.a, p.b, p.c), o.push(p.materialIndex), f) {
                    var x = this.faceVertexUvs[0][i];
                    o.push(T(x[0]), T(x[1]), T(x[2]))
                }
                if (m && o.push(A(p.normal)), v) {
                    var b = p.vertexNormals;
                    o.push(A(b[0]), A(b[1]), A(b[2]))
                }
                if (g && o.push(S(p.color)), _) {
                    var w = p.vertexColors;
                    o.push(S(w[0]), S(w[1]), S(w[2]))
                }
            }

            function M(e, t, n) {
                return n ? e | 1 << t : e & ~(1 << t)
            }

            function A(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== l[t] || (l[t] = s.length / 3, s.push(e.x, e.y, e.z)), l[t]
            }

            function S(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== u[t] || (u[t] = c.length, c.push(e.getHex())), u[t]
            }

            function T(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== h[t] || (h[t] = d.length / 2, d.push(e.x, e.y)), h[t]
            }
            return e.data = {}, e.data.vertices = r, e.data.normals = s, 0 < c.length && (e.data.colors = c), 0 < d.length && (e.data.uvs = [d]), e.data.faces = o, e
        },
        clone: function () {
            return (new Ei).copy(this)
        },
        copy: function (e) {
            var t, n, r, i, a, o;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
            var s = e.vertices;
            for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
            var l = e.colors;
            for (t = 0, n = l.length; t < n; t++) this.colors.push(l[t].clone());
            var c = e.faces;
            for (t = 0, n = c.length; t < n; t++) this.faces.push(c[t].clone());
            for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                var u = e.faceVertexUvs[t];
                for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), r = 0, i = u.length; r < i; r++) {
                    var d = u[r],
                        h = [];
                    for (a = 0, o = d.length; a < o; a++) {
                        var p = d[a];
                        h.push(p.clone())
                    }
                    this.faceVertexUvs[t].push(h)
                }
            }
            var f = e.morphTargets;
            for (t = 0, n = f.length; t < n; t++) {
                var m = {};
                if (m.name = f[t].name, void 0 !== f[t].vertices)
                    for (m.vertices = [], r = 0, i = f[t].vertices.length; r < i; r++) m.vertices.push(f[t].vertices[r].clone());
                if (void 0 !== f[t].normals)
                    for (m.normals = [], r = 0, i = f[t].normals.length; r < i; r++) m.normals.push(f[t].normals[r].clone());
                this.morphTargets.push(m)
            }
            var v = e.morphNormals;
            for (t = 0, n = v.length; t < n; t++) {
                var g = {};
                if (void 0 !== v[t].vertexNormals)
                    for (g.vertexNormals = [], r = 0, i = v[t].vertexNormals.length; r < i; r++) {
                        var _ = v[t].vertexNormals[r],
                            y = {};
                        y.a = _.a.clone(), y.b = _.b.clone(), y.c = _.c.clone(), g.vertexNormals.push(y)
                    }
                if (void 0 !== v[t].faceNormals)
                    for (g.faceNormals = [], r = 0, i = v[t].faceNormals.length; r < i; r++) g.faceNormals.push(v[t].faceNormals[r].clone());
                this.morphNormals.push(g)
            }
            var x = e.skinWeights;
            for (t = 0, n = x.length; t < n; t++) this.skinWeights.push(x[t].clone());
            var b = e.skinIndices;
            for (t = 0, n = b.length; t < n; t++) this.skinIndices.push(b[t].clone());
            var w = e.lineDistances;
            for (t = 0, n = w.length; t < n; t++) this.lineDistances.push(w[t]);
            var M = e.boundingBox;
            null !== M && (this.boundingBox = M.clone());
            var A = e.boundingSphere;
            return null !== A && (this.boundingSphere = A.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), (Ci.prototype = Object.create(Ei.prototype)).constructor = Ci, (Pi.prototype = Object.create(ni.prototype)).constructor = Pi;
    var Di = {
            clone: Li,
            merge: Ri
        },
        Ii = "void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
        Ni = "void main() {\ngl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}";

    function Oi(e) {
        Or.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.customPrepTokens = {}, this.vertexShader = Ii, this.fragmentShader = Ni, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("v3d.ShaderMaterial: attributes should now be defined in v3d.BufferGeometry instead."), this.setValues(e))
    }

    function Fi() {
        Fn.call(this), this.type = "Camera", this.matrixWorldInverse = new fn, this.projectionMatrix = new fn, this.projectionMatrixInverse = new fn, this.controls = null, this.viewportFit = {
            type: jt,
            initialAspect: 1
        }
    }

    function Bi(e, t, n, r) {
        Fi.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }((Oi.prototype = Object.create(Or.prototype)).constructor = Oi).prototype.isShaderMaterial = !0, Oi.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Li(e.uniforms), this.defines = Object.assign({}, e.defines), this.customPrepTokens = Object.assign({}, e.customPrepTokens), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
    }, Oi.prototype.toJSON = function (e) {
        var t = Or.prototype.toJSON.call(this, e);
        for (var n in t.uniforms = {}, this.uniforms) {
            var r = this.uniforms[n].value;
            r && r.isTexture ? t.uniforms[n] = {
                type: "t",
                value: r.toJSON(e).uuid
            } : r && r.isColor ? t.uniforms[n] = {
                type: "c",
                value: r.getHex()
            } : r && r.isVector2 ? t.uniforms[n] = {
                type: "v2",
                value: r.toArray()
            } : r && r.isVector3 ? t.uniforms[n] = {
                type: "v3",
                value: r.toArray()
            } : r && r.isVector4 ? t.uniforms[n] = {
                type: "v4",
                value: r.toArray()
            } : r && r.isMatrix3 ? t.uniforms[n] = {
                type: "m3",
                value: r.toArray()
            } : r && r.isMatrix4 ? t.uniforms[n] = {
                type: "m4",
                value: r.toArray()
            } : t.uniforms[n] = {
                value: r
            }
        }
        0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
        var i = {};
        for (var a in this.extensions) !0 === this.extensions[a] && (i[a] = !0);
        return 0 < Object.keys(i).length && (t.extensions = i), t
    }, Fi.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: Fi,
        isCamera: !0,
        copy: function (e, t) {
            return Fn.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), e.controls && (this.controls = {
                type: e.controls.type,
                enablePan: e.controls.enablePan,
                rotateSpeed: e.controls.rotateSpeed,
                moveSpeed: e.controls.moveSpeed,
                orbitMinDistance: e.controls.orbitMinDistance,
                orbitMaxDistance: e.controls.orbitMaxDistance,
                orbitMinPolarAngle: e.controls.orbitMinPolarAngle,
                orbitMaxPolarAngle: e.controls.orbitMaxPolarAngle,
                orbitMinAzimuthAngle: e.controls.orbitMinAzimuthAngle,
                orbitMaxAzimuthAngle: e.controls.orbitMaxAzimuthAngle
            }, e.controls.orbitTarget && (this.controls.orbitTarget = e.controls.orbitTarget)), this.viewportFit.type = e.viewportFit.type, this.viewportFit.initialAspect = e.viewportFit.initialAspect, this
        },
        getWorldDirection: function (e) {
            void 0 === e && (console.warn("v3d.Camera: .getWorldDirection() target is now required"), e = new on), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function (e) {
            Fn.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        updateWorldMatrix: function (e, t) {
            Fn.prototype.updateWorldMatrix.call(this, e, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function (e) {
            return (new this.constructor).copy(this, e)
        }
    }), Bi.prototype = Object.assign(Object.create(Fi.prototype), {
        constructor: Bi,
        isPerspectiveCamera: !0,
        copy: function (e, t) {
            return Fi.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        },
        setFocalLength: function (e) {
            var t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * Yt.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
        },
        getFocalLength: function () {
            var e = Math.tan(.5 * Yt.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function () {
            return 2 * Yt.RAD2DEG * Math.atan(Math.tan(.5 * Yt.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function (e, t, n, r, i, a) {
            this.aspect = e / t, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
        },
        clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function () {
            var e = this.near,
                t = e * Math.tan(.5 * Yt.DEG2RAD * this.fov) / this.zoom,
                n = 2 * t,
                r = this.aspect * n,
                i = -.5 * r,
                a = this.view;
            if (null !== this.view && this.view.enabled) {
                var o = a.fullWidth,
                    s = a.fullHeight;
                i += a.offsetX * r / o, t -= a.offsetY * n / s, r *= a.width / o, n *= a.height / s
            }
            var l = this.filmOffset;
            0 !== l && (i += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function (e) {
            var t = Fn.prototype.toJSON.call(this, e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
        }
    });

    function zi(e, t, n, r) {
        Fn.call(this), this.type = "CubeCamera";
        var a = new Bi(90, 1, e, t);
        a.up.set(0, -1, 0), a.lookAt(new on(1, 0, 0)), this.add(a);
        var o = new Bi(90, 1, e, t);
        o.up.set(0, -1, 0), o.lookAt(new on(-1, 0, 0)), this.add(o);
        var s = new Bi(90, 1, e, t);
        s.up.set(0, 0, 1), s.lookAt(new on(0, 1, 0)), this.add(s);
        var l = new Bi(90, 1, e, t);
        l.up.set(0, 0, -1), l.lookAt(new on(0, -1, 0)), this.add(l);
        var c = new Bi(90, 1, e, t);
        c.up.set(0, -1, 0), c.lookAt(new on(0, 0, 1)), this.add(c);
        var u = new Bi(90, 1, e, t);
        u.up.set(0, -1, 0), u.lookAt(new on(0, 0, -1)), this.add(u), r = r || {
            format: st,
            magFilter: Je,
            minFilter: Je
        }, this.renderTarget = new Ui(n, r), this.renderTarget.texture.name = "CubeCamera", this.update = function (e, t) {
            null === this.parent && this.updateMatrixWorld();
            var n = e.getRenderTarget(),
                r = this.renderTarget,
                i = r.texture.generateMipmaps;
            r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, a), e.setRenderTarget(r, 1), e.render(t, o), e.setRenderTarget(r, 2), e.render(t, s), e.setRenderTarget(r, 3), e.render(t, l), e.setRenderTarget(r, 4), e.render(t, c), r.texture.generateMipmaps = i, e.setRenderTarget(r, 5), e.render(t, u), e.setRenderTarget(n)
        }, this.clear = function (e, t, n, r) {
            for (var i = e.getRenderTarget(), a = this.renderTarget, o = 0; o < 6; o++) e.setRenderTarget(a, o), e.clear(t, n, r);
            e.setRenderTarget(i)
        }
    }

    function Ui(e, t, n) {
        Number.isInteger(t) && (console.warn("v3d.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget(size, options)"), t = n), en.call(this, e, e, t)
    }

    function Vi(e, t, n, r, i, a, o, s, l, c, u, d) {
        Jt.call(this, null, a, o, s, l, c, r, i, u, d), this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1
        }, this.magFilter = void 0 !== l ? l : Ze, this.minFilter = void 0 !== c ? c : Ze, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }(zi.prototype = Object.create(Fn.prototype)).constructor = zi, ((Ui.prototype = Object.create(en.prototype)).constructor = Ui).prototype.isWebGLCubeRenderTarget = !0, Ui.prototype.fromEquirectangularTexture = function (e, t) {
        this.texture.type = t.type, this.texture.format = t.format, this.texture.encoding = t.encoding;
        var n = new Bn,
            r = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection(in vec3 dir, in mat4 matrix) {", "    return normalize((matrix * vec4(dir, 0.0)).xyz);", "}", "void main() {", "    vWorldDirection = transformDirection(position, modelMatrix);", "    #include <begin_vertex>", "    #include <project_vertex>", "}"].join("\n"),
                fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "    vec3 direction = normalize(vWorldDirection);", "    vec2 sampleUV;", "    sampleUV.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;", "    sampleUV.x = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;", "    gl_FragColor = texture2D(tEquirect, sampleUV);", "}"].join("\n")
            },
            i = new Oi({
                type: "CubemapFromEquirect",
                uniforms: Li(r.uniforms),
                vertexShader: r.vertexShader,
                fragmentShader: r.fragmentShader,
                side: Pe,
                blending: ae
            });
        i.uniforms.tEquirect.value = t;
        var a = new xi(new Pi(5, 5, 5), i);
        n.add(a);
        var o = new zi(1, 10, 1);
        return o.renderTarget = this, o.renderTarget.texture.name = "CubeCameraTexture", o.update(e, n), a.geometry.dispose(), a.material.dispose(), this
    }, ((Vi.prototype = Object.create(Jt.prototype)).constructor = Vi).prototype.isDataTexture = !0;
    var Gi = new nr,
        ki = new on;

    function ji(e, t, n, r, i, a) {
        this.planes = [void 0 !== e ? e : new fr, void 0 !== t ? t : new fr, void 0 !== n ? n : new fr, void 0 !== r ? r : new fr, void 0 !== i ? i : new fr, void 0 !== a ? a : new fr]
    }
    Object.assign(ji.prototype, {
        set: function (e, t, n, r, i, a) {
            var o = this.planes;
            return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
            return this
        },
        setFromProjectionMatrix: function (e) {
            var t = this.planes,
                n = e.elements,
                r = n[0],
                i = n[1],
                a = n[2],
                o = n[3],
                s = n[4],
                l = n[5],
                c = n[6],
                u = n[7],
                d = n[8],
                h = n[9],
                p = n[10],
                f = n[11],
                m = n[12],
                v = n[13],
                g = n[14],
                _ = n[15];
            return t[0].setComponents(o - r, u - s, f - d, _ - m).normalize(), t[1].setComponents(o + r, u + s, f + d, _ + m).normalize(), t[2].setComponents(o + i, u + l, f + h, _ + v).normalize(), t[3].setComponents(o - i, u - l, f - h, _ - v).normalize(), t[4].setComponents(o - a, u - c, f - p, _ - g).normalize(), t[5].setComponents(o + a, u + c, f + p, _ + g).normalize(), this
        },
        intersectsObject: function (e) {
            var t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(), Gi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Gi)
        },
        intersectsSprite: function (e) {
            return Gi.center.set(0, 0, 0), Gi.radius = .7071067811865476, Gi.applyMatrix4(e.matrixWorld), this.intersectsSphere(Gi)
        },
        intersectsSphere: function (e) {
            for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++) {
                if (t[i].distanceToPoint(n) < r) return !1
            }
            return !0
        },
        intersectsBox: function (e) {
            for (var t = this.planes, n = 0; n < 6; n++) {
                var r = t[n];
                if (ki.x = 0 < r.normal.x ? e.max.x : e.min.x, ki.y = 0 < r.normal.y ? e.max.y : e.min.y, ki.z = 0 < r.normal.z ? e.max.z : e.min.z, r.distanceToPoint(ki) < 0) return !1
            }
            return !0
        },
        containsPoint: function (e) {
            for (var t = this.planes, n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0) return !1;
            return !0
        }
    });
    var Wi = {
        common: {
            diffuse: {
                value: new Pr(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Zt
            },
            uv2Transform: {
                value: new Zt
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new qt(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Pr(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    maxDistance: {},
                    expBias: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {},
                    expBias: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {},
                    expBias: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Pr(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new Zt
            }
        },
        sprite: {
            diffuse: {
                value: new Pr(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new qt(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new Zt
            }
        },
        mask: {
            depthTexture: {
                value: null
            },
            cameraNearFar: {
                value: new qt(.5, .5)
            },
            textureMatrix: {
                value: new fn
            }
        },
        node: {
            nodeRGB: {
                value: []
            },
            nodeValue: {
                value: []
            },
            nodeTexCoordObjectMatrices: {
                value: []
            },
            flipCubeMap: {
                value: -1
            }
        },
        ssr: {
            invProjectionMatrix: {
                value: new fn
            },
            ssrSourceBuffer: {
                value: null
            },
            ssrDepthBuffer: {
                value: null
            },
            ssrBackfaceDepthBuffer: {
                value: null
            },
            ssrStride: {
                value: 20
            },
            ssrResolution: {
                value: new qt
            },
            ssrThickness: {
                value: .01
            },
            ssrJitter: {
                value: 1
            },
            ssrMaxDistance: {
                value: 100
            }
        }
    };

    function Xi() {
        var u = {};
        return {
            get: function (e, t, n, r) {
                if (void 0 !== u[r.id]) var i = u[r.id];
                else {
                    i = [r];
                    for (var a = 1; a < 4; a++) {
                        var o = 0 != (1 & a),
                            s = 0 != (2 & a),
                            l = r.clone();
                        l.morphTargets = o, l.skinning = s, i[a] = l
                    }
                    u[r.id] = i
                }
                o = !1;
                n.morphTargets && (t && t.isBufferGeometry ? o = t.morphAttributes && t.morphAttributes.position && 0 < t.morphAttributes.position.length : t && t.isGeometry && (o = t.morphTargets && 0 < t.morphTargets.length)), e.isSkinnedMesh && !1 === n.skinning && console.warn("v3d.OverrideMatVariants: v3d.SkinnedMesh with material.skinning set to false:", e);
                var c = 0;
                return o && (c |= 1), (s = e.isSkinnedMesh && n.skinning) && (c |= 2), i[c]
            },
            update: function (e) {
                delete u[e.id]
            },
            dispose: function () {
                u = {}
            }
        }
    }

    function Hi() {
        var n = null,
            r = !1,
            i = null;

        function a(e, t) {
            !1 !== r && (i(e, t), n.requestAnimationFrame(a))
        }
        return {
            start: function () {
                !0 !== r && null !== i && (n.requestAnimationFrame(a), r = !0)
            },
            stop: function () {
                r = !1
            },
            setAnimationLoop: function (e) {
                i = e
            },
            setContext: function (e) {
                n = e
            }
        }
    }

    function Yi(l, e) {
        var c = e.isWebGL2,
            u = new WeakMap;
        return {
            get: function (e) {
                return e.isInterleavedBufferAttribute && (e = e.data), u.get(e)
            },
            remove: function (e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var t = u.get(e);
                t && (l.deleteBuffer(t.buffer), u.delete(e))
            },
            update: function (e, t) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var n, r, i, a, o, s = u.get(e);
                void 0 === s ? u.set(e, function (e, t) {
                    var n = e.array,
                        r = e.usage,
                        i = l.createBuffer();
                    l.bindBuffer(t, i), l.bufferData(t, n, r), e.onUploadCallback();
                    var a = 5126;
                    return n instanceof Float32Array ? a = 5126 : n instanceof Float64Array ? console.warn("v3d.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? a = 5123 : n instanceof Int16Array ? a = 5122 : n instanceof Uint32Array ? a = 5125 : n instanceof Int32Array ? a = 5124 : n instanceof Int8Array ? a = 5120 : n instanceof Uint8Array && (a = 5121), {
                        buffer: i,
                        type: a,
                        bytesPerElement: n.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }(e, t)) : s.version < e.version && (n = s.buffer, i = t, a = (r = e).array, o = r.updateRange, l.bindBuffer(i, n), -1 === o.count ? l.bufferSubData(i, 0, a) : (c ? l.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : l.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1), s.version = e.version)
            },
            dispose: function () {
                u = new WeakMap
            }
        }
    }

    function qi(e, t, n, r, i, a) {
        Fi.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
    }

    function Zi(e, t, n, r) {
        Ei.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r
        }, this.fromBufferGeometry(new Qi(e, t, n, r)), this.mergeVertices()
    }

    function Qi(e, t, n, r) {
        ni.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r
        };
        var i, a, o = (e = e || 1) / 2,
            s = (t = t || 1) / 2,
            l = Math.floor(n) || 1,
            c = Math.floor(r) || 1,
            u = l + 1,
            d = c + 1,
            h = e / l,
            p = t / c,
            f = [],
            m = [],
            v = [],
            g = [];
        for (a = 0; a < d; a++) {
            var _ = a * p - s;
            for (i = 0; i < u; i++) {
                var y = i * h - o;
                m.push(y, -_, 0), v.push(0, 0, 1), g.push(i / l), g.push(1 - a / c)
            }
        }
        for (a = 0; a < c; a++)
            for (i = 0; i < l; i++) {
                var x = i + u * a,
                    b = i + u * (a + 1),
                    w = i + 1 + u * (a + 1),
                    M = i + 1 + u * a;
                f.push(x, b, M), f.push(b, w, M)
            }
        this.setIndex(f), this.setAttribute("position", new Hr(m, 3)), this.setAttribute("normal", new Hr(v, 3)), this.setAttribute("uv", new Hr(g, 2))
    }
    qi.prototype = Object.assign(Object.create(Fi.prototype), {
        constructor: qi,
        isOrthographicCamera: !0,
        copy: function (e, t) {
            return Fi.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        },
        setViewOffset: function (e, t, n, r, i, a) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
        },
        clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function () {
            var e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                r = (this.top + this.bottom) / 2,
                i = n - e,
                a = n + e,
                o = r + t,
                s = r - t;
            if (null !== this.view && this.view.enabled) {
                var l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                    c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                a = (i += l * this.view.offsetX) + l * this.view.width, s = (o -= c * this.view.offsetY) - c * this.view.height
            }
            this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function (e) {
            var t = Fn.prototype.toJSON.call(this, e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
        }
    }), (Zi.prototype = Object.create(Ei.prototype)).constructor = Zi, (Qi.prototype = Object.create(ni.prototype)).constructor = Qi;
    var Ki = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\ndiffuseColor.a *= texture2D(alphaMap, vUv).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\nif (diffuseColor.a < ALPHATEST)\ndiscard;\nelse\ndiffuseColor.a = 1.0;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\nfloat ambientOcclusion = (texture2D(aoMap, vUv2).r - 1.0) * aoMapIntensity + 1.0;\nreflectedLight.indirectDiffuse *= ambientOcclusion;\n#if defined(USE_ENVMAP) && defined(STANDARD)\nfloat dotNV = saturate(dot(geometry.normal, geometry.viewDir));\nreflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.specularRoughness);\n#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\nuniform sampler2D aoMap;\nuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3(position);",
            beginnormal_vertex: "vec3 objectNormal = vec3(normal);\n#ifdef USE_TANGENT\nvec3 objectTangent = vec3(tangent.xyz);\n#endif",
            bsdfs: "\nvec2 integrateSpecularBRDF(const in float dotNV, const in float roughness) {\nconst vec4 c0 = vec4(- 1, - 0.0275, - 0.572, 0.022);\nconst vec4 c1 = vec4(1, 0.0425, 1.04, - 0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(- 9.28 * dotNV)) * r.x + r.y;\nreturn vec2(-1.04, 1.04) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor(float lightDistance, const in float cutoffDistance, const in float decayExponent) {\n#if defined (PHYSICALLY_CORRECT_LIGHTS)\nlightDistance = UNITS_SCALE_FACTOR * lightDistance;\n#ifdef MT_MAYA\nfloat distanceFalloff = 1.0 / pow(lightDistance + 1.0, decayExponent);\n#else\nfloat distanceFalloff = 1.0 / max(pow(lightDistance, decayExponent), 0.01);\n#endif\nif(cutoffDistance > 0.0) {\ndistanceFalloff *= pow2(saturate(1.0 - pow4(lightDistance / cutoffDistance)));\n}\nreturn distanceFalloff;\n#elif defined(MT_BLENDER)\nreturn cutoffDistance / (cutoffDistance + pow2(lightDistance));\n#else\nif(cutoffDistance > 0.0 && decayExponent > 0.0) {\nreturn pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);\n}\nreturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert(const in vec3 diffuseColor) {\nreturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {\nfloat fresnel = exp2((-5.55473 * dotLH - 6.98316) * dotLH);\nreturn (1.0 - specularColor) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent(const in vec3 F0, const in float dotNV, const in float roughness) {\nfloat fresnel = exp2((-5.55473 * dotNV - 6.98316) * dotNV);\nvec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\nreturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {\nfloat a2 = pow2(alpha);\nfloat gl = dotNL + sqrt(a2 + (1.0 - a2) * pow2(dotNL));\nfloat gv = dotNV + sqrt(a2 + (1.0 - a2) * pow2(dotNV));\nreturn 1.0 / (gl * gv);\n}\nfloat G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {\nfloat a2 = pow2(alpha);\nfloat gv = dotNL * sqrt(a2 + (1.0 - a2) * pow2(dotNV));\nfloat gl = dotNV * sqrt(a2 + (1.0 - a2) * pow2(dotNL));\nreturn 0.5 / max(gv + gl, EPSILON);\n}\nfloat D_GGX(const in float alpha, const in float dotNH) {\nfloat a2 = pow2(alpha);\nfloat denom = pow2(dotNH) * (a2 - 1.0) + 1.0;\nreturn RECIPROCAL_PI * a2 / pow2(denom);\n}\nvec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in vec3 viewDir,\nconst in vec3 normal, const in vec3 specularColor, const in float roughness) {\nfloat alpha = pow2(clamp(roughness, 0.04, 1.0));\nvec3 halfDir = normalize(incidentLight.direction + viewDir);\nfloat dotNL = saturate(dot(normal, incidentLight.direction));\nfloat dotNV = saturate(dot(normal, viewDir));\nfloat dotNH = saturate(dot(normal, halfDir));\nfloat dotLH = saturate(dot(incidentLight.direction, halfDir));\nvec3 F = F_Schlick(specularColor, dotLH);\nfloat G = G_GGX_SmithCorrelated(alpha, dotNL, dotNV);\nfloat D = D_GGX(alpha, dotNH);\nreturn F * (G * D);\n}\nvec2 LTC_Uv(const in vec3 N, const in vec3 V, const in float roughness) {\nconst float LUT_SIZE  = 64.0;\nconst float LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;\nconst float LUT_BIAS  = 0.5 / LUT_SIZE;\nfloat dotNV = saturate(dot(N, V));\nvec2 uv = vec2(roughness, sqrt(1.0 - dotNV));\nuv = uv * LUT_SCALE + LUT_BIAS;\nreturn uv;\n}\nfloat LTC_ClippedSphereFormFactor(const in vec3 f) {\nfloat l = length(f);\nreturn max((l * l + f.z) / (l + 1.0), 0.0);\n}\nvec3 LTC_EdgeVectorFormFactor(const in vec3 v1, const in vec3 v2) {\nfloat x = dot(v1, v2);\nfloat y = abs(x);\nfloat a = 0.8543985 + (0.4965155 + 0.0145206 * y) * y;\nfloat b = 3.4175940 + (4.1616724 + y) * y;\nfloat v = a / b;\nfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt(max(1.0 - x * x, 1e-7)) - v;\nreturn cross(v1, v2) * theta_sintheta;\n}\nvec3 LTC_Evaluate(const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[4]) {\nvec3 v1 = rectCoords[1] - rectCoords[0];\nvec3 v2 = rectCoords[3] - rectCoords[0];\nvec3 lightNormal = cross(v1, v2);\nif(dot(lightNormal, P - rectCoords[0]) < 0.0) return vec3(0.0);\nvec3 T1, T2;\nT1 = normalize(V - N * dot(V, N));\nT2 = - cross(N, T1);\nmat3 mat = mInv * transposeMat3(mat3(T1, T2, N));\nvec3 coords[4];\ncoords[0] = mat * (rectCoords[0] - P);\ncoords[1] = mat * (rectCoords[1] - P);\ncoords[2] = mat * (rectCoords[2] - P);\ncoords[3] = mat * (rectCoords[3] - P);\ncoords[0] = normalize(coords[0]);\ncoords[1] = normalize(coords[1]);\ncoords[2] = normalize(coords[2]);\ncoords[3] = normalize(coords[3]);\nvec3 vectorFormFactor = vec3(0.0);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[0], coords[1]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[1], coords[2]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[2], coords[3]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[3], coords[0]);\nfloat result = LTC_ClippedSphereFormFactor(vectorFormFactor);\nreturn vec3(result);\n}\nvec2 get_BRDF_SpecCoeffsBlender(float x, float y) {\nvec3 xyFactors0 = vec3(x * x, y * y, x * y);\nvec3 xyFactors1 = vec3(x, y, 1);\nvec3 a0a1a2 = vec3(0.33749372, 0.15167605, 1.09684597);\nvec3 a3a4a5 = vec3(-1.26123466, -0.927699, 0.9199188);\nvec3 b0b1b2 = vec3(0.41699717, 0.44675109, 0.79947684);\nvec3 b3b4b5 = vec3(-1.19307849, -0.89813958, 0.89305222);\nvec3 c0c1c2 = vec3(0.29920727, 0.09505591, -0.9136233);\nvec3 c3c4c5 = vec3(0.77055201, 0.13006674, -0.23085581);\nvec3 d0d1d2 = vec3(15.05004149, 7.98517355, 13.30473726);\nvec3 d3d4d5 = vec3(-32.00353547, -12.97743434, 17.83646751);\nfloat coeff0 = (dot(xyFactors0, a0a1a2) + dot(xyFactors1, a3a4a5))\n/ (dot(xyFactors0, b0b1b2) + dot(xyFactors1, b3b4b5));\nfloat coeff1 = (dot(xyFactors0, c0c1c2) + dot(xyFactors1, c3c4c5))\n/ (dot(xyFactors0, d0d1d2) + dot(xyFactors1, d3d4d5));\ncoeff1 = clamp(coeff1, 0.0, 1.0);\nreturn vec2(coeff0, coeff1);\n}\nvec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness) {\nfloat dotNV = saturate(dot(normal, viewDir));\nconst vec4 c0 = vec4(- 1, - 0.0275, - 0.572, 0.022);\nconst vec4 c1 = vec4(1, 0.0425, 1.04, - 0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(- 9.28 * dotNV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nreturn specularColor * AB.x + AB.y;\n}\nvec3 BRDF_Specular_GGX_Environment_Blender_Approx(const in GeometricContext geometry,\nconst in vec3 fresnelRefl0, const in vec3 fresnelRefl90,\nconst in float roughness, const int useCoat) {\nvec3 normal = geometry.normal;\n#ifdef CLEARCOAT\nif (useCoat == 1) {\nnormal = geometry.clearcoatNormal;\n}\n#endif\nfloat dotNV = saturate(dot(normal, geometry.viewDir));\nfloat angle = acos(abs(dotNV)) / PI_HALF;\nvec2 specCoeffs = get_BRDF_SpecCoeffsBlender(angle, roughness);\nvec3 specular = specCoeffs.x * fresnelRefl0\n+ specCoeffs.y * fresnelRefl90\n* vec3(saturate(50.0 * linearToRelativeLuminance(fresnelRefl0)));\n#if defined (COMPAT_SATURATE_SPEC_ENV_BLENDER_APPROX)\nspecular = saturate(specular);\n#endif\nreturn specular;\n}\nvoid BRDF_Specular_Multiscattering_Environment(const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter) {\nfloat dotNV = saturate(dot(geometry.normal, geometry.viewDir));\nvec3 F = F_Schlick_RoughnessDependent(specularColor, dotNV, roughness);\nvec2 brdf = integrateSpecularBRDF(dotNV, roughness);\nvec3 FssEss = F * brdf.x + brdf.y;\nfloat Ess = brdf.x + brdf.y;\nfloat Ems = 1.0 - Ess;\nvec3 Favg = specularColor + (1.0 - specularColor) * 0.047619;\nvec3 Fms = FssEss * Favg / (1.0 - Ems * Favg);\nsingleScatter += FssEss;\nmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit() {\nreturn 0.25;\n}\nfloat D_BlinnPhong(const in float shininess, const in float dotNH) {\nreturn RECIPROCAL_PI * (shininess * 0.5 + 1.0) * pow(dotNH, shininess);\n}\nvec3 BRDF_Specular_BlinnPhong(const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess) {\nvec3 halfDir = normalize(incidentLight.direction + geometry.viewDir);\nfloat dotNH = saturate(dot(geometry.normal, halfDir));\nfloat dotLH = saturate(dot(incidentLight.direction, halfDir));\nvec3 F = F_Schlick(specularColor, dotLH);\nfloat G = G_BlinnPhong_Implicit();\nfloat D = D_BlinnPhong(shininess, dotNH);\nreturn F * (G * D);\n}\nfloat GGXRoughnessToBlinnExponent(const in float ggxRoughness) {\nreturn (2.0 / pow2(ggxRoughness + 0.0001) - 2.0);\n}\nfloat BlinnExponentToGGXRoughness(const in float blinnExponent) {\nreturn sqrt(2.0 / (blinnExponent + 2.0));\n}\n#if defined(USE_SHEEN)\nfloat D_Charlie(float roughness, float NoH) {\nfloat invAlpha  = 1.0 / roughness;\nfloat cos2h = NoH * NoH;\nfloat sin2h = max(1.0 - cos2h, 0.0078125);\nreturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\nreturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen(const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor) {\nvec3 N = geometry.normal;\nvec3 V = geometry.viewDir;\nvec3 H = normalize(V + L);\nfloat dotNH = saturate(dot(N, H));\nreturn specularColor * D_Charlie(roughness, dotNH) * V_Neubelt(dot(N, V), dot(N, L));\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx(vUv);\nvec2 dSTdy = dFdy(vUv);\nfloat Hll = bumpScale * texture2D(bumpMap, vUv).x;\nfloat dBx = bumpScale * texture2D(bumpMap, vUv + dSTdx).x - Hll;\nfloat dBy = bumpScale * texture2D(bumpMap, vUv + dSTdy).x - Hll;\nreturn vec2(dBx, dBy);\n}\nvec3 perturbNormalArb(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\nvec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\nvec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\nvec3 vN = surf_norm;\nvec3 R1 = cross(vSigmaY, vN);\nvec3 R2 = cross(vN, vSigmaX);\nfloat fDet = dot(vSigmaX, R1);\nfDet *= (float(gl_FrontFacing) * 2.0 - 1.0);\nvec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\nreturn normalize(abs(fDet) * surf_norm - vGrad);\n}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\nvec4 plane;\n#pragma unroll_loop\nfor (int i = 0; i < UNION_CLIPPING_PLANES; i++) {\nplane = clippingPlanes[i];\nif (dot(vViewPosition, plane.xyz) > plane.w) discard;\n}\n#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\nbool clipped = true;\n#pragma unroll_loop\nfor (int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i++) {\nplane = clippingPlanes[i];\nclipped = (dot(vViewPosition, plane.xyz) > plane.w) && clipped;\n}\nif (clipped) discard;\n#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n#if !defined(STANDARD) && !defined(PHONG) && !defined(MATCAP)&& !defined(NODE) && !defined(LAMBERT) && !defined(DEPTH)\nvarying vec3 vViewPosition;\n#endif\nuniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && !defined(STANDARD) && !defined(PHONG) && !defined(MATCAP) && !defined(NODE) && !defined(LAMBERT) && !defined(DEPTH)\nvarying vec3 vViewPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && !defined(STANDARD) && !defined(PHONG) && !defined(MATCAP) && !defined(NODE) && !defined(LAMBERT) && !defined(DEPTH)\nvViewPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\ndiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\nvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp(a, 0.0, 1.0)\n#endif\n#define whiteComplement(a) (1.0 - saturate(a))\n#define RECIPROCAL_3 0.333333333333\nfloat pow2(const in float x) { return x*x; }\nfloat pow3(const in float x) { return x*x*x; }\nfloat pow4(const in float x) { float x2 = x*x; return x2*x2; }\nfloat average(const in vec3 color) { return dot(color, vec3(0.3333)); }\nhighp float rand(const in vec2 uv) {\nconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\nhighp float dt = dot(uv.xy, vec2(a,b)), sn = mod(dt, PI);\nreturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\nfloat precisionSafeLength(vec3 v) { return length(v); }\n#else\nfloat max3(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat precisionSafeLength(vec3 v) {\nfloat maxComponent = max3(abs(v));\nreturn length(v / maxComponent) * maxComponent;\n}\n#endif\nstruct IncidentLight {\nvec3 color;\nvec3 direction;\nbool visible;\n};\nstruct ReflectedLight {\nvec3 directDiffuse;\nvec3 directSpecular;\nvec3 indirectDiffuse;\nvec3 indirectSpecular;\n};\nstruct GeometricContext {\nvec3 position;\nvec3 normal;\nvec3 viewDir;\n#ifdef CLEARCOAT\nvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection(in vec3 dir, in mat4 matrix) {\nreturn normalize((matrix * vec4(dir, 0.0)).xyz);\n}\nvec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {\nreturn normalize((vec4(dir, 0.0) * matrix).xyz);\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\nfloat distance = dot(planeNormal, point - pointOnPlane);\nreturn - distance * planeNormal + point;\n}\nfloat sideOfPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\nreturn sign(dot(point - pointOnPlane, planeNormal));\n}\nvec3 linePlaneIntersect(in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal) {\nreturn lineDirection * (dot(planeNormal, pointOnPlane - pointOnLine) / dot(planeNormal, lineDirection)) + pointOnLine;\n}\nmat3 transposeMat3(const in mat3 m) {\nmat3 tmp;\ntmp[0] = vec3(m[0].x, m[1].x, m[2].x);\ntmp[1] = vec3(m[0].y, m[1].y, m[2].y);\ntmp[2] = vec3(m[0].z, m[1].z, m[2].z);\nreturn tmp;\n}\nfloat linearToRelativeLuminance(const in vec3 color) {\nvec3 weights = vec3(0.2126, 0.7152, 0.0722);\nreturn dot(weights, color.rgb);\n}\nbool isPerspectiveMatrix(mat4 m) {\nreturn m[2][3] == - 1.0;\n}\nhighp vec3 rand3(const in vec3 v) {\nconst highp float c = 43758.5453;\nconst highp mat3 coeffs = mat3(\n165.15, 253.34, 323.22,\n241.49, 329.07, 147.79,\n376.31, 143.45, 281.63\n);\nhighp vec3 sn = mod(coeffs * v, PI);\nreturn fract(sin(sn) * c);\n}\nfloat powCompat(const in float val, const in float power) {\nif (power == 0.0)\nreturn 1.0;\nelse if (val < 0.0) {\nif (mod(-power, 2.0) == 0.0)\nreturn pow(abs(val), power);\nelse\nreturn -pow(abs(val), power);\n} else if (val == 0.0)\nreturn 0.0;\nreturn pow(abs(val), power);\n}\nfloat maxFromRGB(vec3 rgb) {\nreturn max(max(rgb.r, rgb.g), rgb.b);\n}\nbool isOrtho(const in mat4 m) {\nif (m[3][3] != 0.0)\nreturn true;\nelse\nreturn false;\n}\nvec3 swizzleUpZ(const vec3 vec) {\nreturn vec3(vec[0], -vec[2], vec[1]);\n}\nvec3 swizzleUpY(const vec3 vec) {\nreturn vec3(vec[0], vec[2], -vec[1]);\n}\nvec3 xyz_to_sRGB(vec3 xyz) {\nmat3 convMat = mat3(\n3.2406, -0.9689, 0.0557,\n-1.5372, 1.8758, -0.2040,\n-0.4986, 0.0415, 1.0570\n);\nreturn convMat * xyz;\n}\nvec3 xyY_to_XYZ(float x, float y, float Y) {\nfloat X = 0.0;\nfloat Z = 0.0;\nif (y != 0.0) {\nX = (Y / y) * x;\nZ = (Y / y) * (1.0 - x - y);\n}\nreturn vec3(X, Y, Z);\n}\nvec3 octUVToCubeVec(vec2 octUV, vec2 texelSize) {\noctUV = (1.0 + 2.0 * texelSize) * octUV - texelSize;\noctUV = octUV * 2.0 - 1.0;\nfloat x = octUV.x;\nfloat z = -octUV.y;\nfloat absX = abs(x);\nfloat absZ = abs(z);\nvec3 cubeVec = vec3(x, 1.0 - absX - absZ, z);\nif (absX + absZ > 1.0) {\ncubeVec.xz = -(vec2(absZ, absX) - 1.0) * sign(vec2(x, z));\n}\nreturn cubeVec;\n}\nvec2 cubeVecToOctUV(vec3 cubeVec, vec2 texelSize) {\ncubeVec /= dot(vec3(1.0), abs(cubeVec));\nvec2 octUV = vec2(cubeVec.x, -cubeVec.z);\nif (cubeVec.y < 0.0) {\noctUV = sign(octUV) * (1.0 - abs(octUV.ts));\n}\noctUV = (octUV + 1.0) / 2.0;\noctUV = (1.0 - 2.0 * texelSize) * octUV + texelSize;\nreturn octUV;\n}\n#if __VERSION__ == 100\nfloat cosh(float x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nvec2 cosh(vec2 x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nvec3 cosh(vec3 x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nvec4 cosh(vec4 x) {\nreturn (exp(x) + exp(-x)) / 2.0;\n}\nfloat sinh(float x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nvec2 sinh(vec2 x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nvec3 sinh(vec3 x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nvec4 sinh(vec4 x) {\nreturn (exp(x) - exp(-x)) / 2.0;\n}\nfloat tanh(float x) {\nfloat exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nvec2 tanh(vec2 x) {\nvec2 exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nvec3 tanh(vec3 x) {\nvec3 exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nvec4 tanh(vec4 x) {\nvec4 exp2x = exp(2.0 * x);\nreturn (exp2x - 1.0) / (exp2x + 1.0);\n}\nfloat trunc(float x) {\nreturn floor(abs(x)) * sign(x);\n}\nvec2 trunc(vec2 x) {\nreturn floor(abs(x)) * sign(x);\n}\nvec3 trunc(vec3 x) {\nreturn floor(abs(x)) * sign(x);\n}\nvec4 trunc(vec4 x) {\nreturn floor(abs(x)) * sign(x);\n}\n#endif\nfloat getSmoothFactor(float a, float b, float smoothness) {\nreturn max(smoothness - abs(a - b), 0.0) / smoothness;\n}\nfloat smoothMin(float a, float b, float smoothness) {\nfloat smoothFac = getSmoothFactor(a, b, smoothness);\nreturn min(a, b) - smoothFac * smoothFac * smoothFac * smoothness * (1.0 / 6.0);\n}\nfloat smoothMax(float a, float b, float smoothness) {\nfloat smoothFac = getSmoothFactor(a, b, smoothness);\nreturn max(a, b) + smoothFac * smoothFac * smoothFac * smoothness * (1.0 / 6.0);\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\nvec3 absDirection = abs(direction);\nfloat face = -1.0;\nif (absDirection.x > absDirection.z) {\nif (absDirection.x > absDirection.y) {\nface = direction.x > 0.0 ? 0.0 : 3.0;\n} else {\nface = direction.y > 0.0 ? 1.0 : 4.0;\n}\n} else {\nif (absDirection.z > absDirection.y) {\nface = direction.z > 0.0 ? 2.0 : 5.0;\n} else {\nface = direction.y > 0.0 ? 1.0 : 4.0;\n}\n}\nreturn face;\n}\nvec2 getUV(vec3 direction, float face) {\nvec2 uv;\nif (face == 0.0) {\nuv = vec2(-direction.z, direction.y) / abs(direction.x);\n} else if (face == 1.0) {\nuv = vec2(direction.x, -direction.z) / abs(direction.y);\n} else if (face == 2.0) {\nuv = direction.xy / abs(direction.z);\n} else if (face == 3.0) {\nuv = vec2(direction.z, direction.y) / abs(direction.x);\n} else if (face == 4.0) {\nuv = direction.xz / abs(direction.y);\n} else {\nuv = vec2(-direction.x, direction.y) / abs(direction.z);\n}\nreturn 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\nfloat face = getFace(direction);\nfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\nmipInt = max(mipInt, cubeUV_minMipLevel);\nfloat faceSize = exp2(mipInt);\nfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\nvec2 uv = getUV(direction, face) * (faceSize - 1.0);\nvec2 f = fract(uv);\nuv += 0.5 - f;\nif (face > 2.0) {\nuv.y += faceSize;\nface -= 3.0;\n}\nuv.x += face * faceSize;\nif (mipInt < cubeUV_maxMipLevel) {\nuv.y += 2.0 * cubeUV_maxTileSize;\n}\nuv.y += filterInt * 2.0 * cubeUV_minTileSize;\nuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\nuv *= texelSize;\nvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\nuv.x += texelSize;\nvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\nuv.y += texelSize;\nvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\nuv.x -= texelSize;\nvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\nvec3 tm = mix(tl, tr, f.x);\nvec3 bm = mix(bl, br, f.x);\nreturn mix(tm, bm, f.y);\n}\n#define cubeUV_r0 1.0\n#define cubeUV_v0 0.339\n#define cubeUV_m0 -2.0\n#define cubeUV_r1 0.8\n#define cubeUV_v1 0.276\n#define cubeUV_m1 -1.0\n#define cubeUV_r4 0.4\n#define cubeUV_v4 0.046\n#define cubeUV_m4 2.0\n#define cubeUV_r5 0.305\n#define cubeUV_v5 0.016\n#define cubeUV_m5 3.0\n#define cubeUV_r6 0.21\n#define cubeUV_v6 0.0038\n#define cubeUV_m6 4.0\nfloat roughnessToMip(float roughness) {\nfloat r = roughness;\nfloat r2 = r * r;\nfloat r3 = r2 * r;\nroughness = -1.20278049 * r3 + 1.86860137 * r2 + 0.32478081 * r + 0.0098139;\nreturn cubeUV_maxMipLevel - (cubeUV_maxMipLevel - cubeUV_m0) * roughness;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\nfloat mip = clamp(roughnessToMip(roughness), cubeUV_m0, cubeUV_maxMipLevel);\nfloat mipF = fract(mip);\nfloat mipInt = floor(mip);\nvec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\nif (mipF == 0.0) {\nreturn vec4(color0, 1.0);\n} else {\nvec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\nreturn vec4(mix(color0, color1, mipF), 1.0);\n}\n}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\ntransformedNormal = mat3(instanceMatrix) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\ntransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\nvec3 transformedTangent = (modelViewMatrix * vec4(objectTangent, 0.0)).xyz;\n#ifdef FLIP_SIDED\ntransformedTangent = - transformedTangent;\n#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;\nuniform float displacementScale;\nuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\ntransformed += normalize(objectNormal) * (texture2D(displacementMap, vUv).x * displacementScale + displacementBias);\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\nvec4 emissiveColor = texture2D(emissiveMap, vUv);\nemissiveColor.rgb = emissiveMapTexelToLinear(emissiveColor).rgb;\ntotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\nuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel(gl_FragColor);",
            encodings_pars_fragment: "\nvec4 LinearToLinear(in vec4 value) {\nreturn value;\n}\nvec4 GammaToLinear(in vec4 value, in float gammaFactor) {\nvalue = max(value, vec4(0.0));\nreturn vec4(pow(value.rgb, vec3(gammaFactor)), value.a);\n}\nvec4 LinearToGamma(in vec4 value, in float gammaFactor) {\nvalue = max(value, vec4(0.0));\nreturn vec4(pow(value.rgb, vec3(1.0 / gammaFactor)), value.a);\n}\nvec4 sRGBToLinear(in vec4 value) {\nvalue = max(value, vec4(0.0));\nreturn vec4(mix(pow(value.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), value.rgb * 0.0773993808, vec3(lessThanEqual(value.rgb, vec3(0.04045)))), value.a);\n}\nvec4 LinearTosRGB(in vec4 value) {\nvalue = max(value, vec4(0.0));\nreturn vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.a);\n}\nvec4 RGBEToLinear(in vec4 value) {\nreturn vec4(value.rgb * exp2(value.a * 255.0 - 128.0), 1.0);\n}\nvec4 LinearToRGBE(in vec4 value) {\nfloat maxComponent = max(max(value.r, value.g), value.b);\nfloat fExp = clamp(ceil(log2(maxComponent)), -128.0, 127.0);\nreturn vec4(value.rgb / exp2(fExp), (fExp + 128.0) / 255.0);\n}\nvec4 RGBMToLinear(in vec4 value, in float maxRange) {\nreturn vec4(value.rgb * value.a * maxRange, 1.0);\n}\nvec4 LinearToRGBM(in vec4 value, in float maxRange) {\nfloat maxRGB = max(value.r, max(value.g, value.b));\nfloat M = clamp(maxRGB / maxRange, 0.0, 1.0);\nM = ceil(M * 255.0) / 255.0;\nreturn vec4(value.rgb / (M * maxRange), M);\n}\nvec4 RGBDToLinear(in vec4 value, in float maxRange) {\nreturn vec4(value.rgb * ((maxRange / 255.0) / value.a), 1.0);\n}\nvec4 LinearToRGBD(in vec4 value, in float maxRange) {\nfloat maxRGB = max(value.r, max(value.g, value.b));\nfloat D = max(maxRange / maxRGB, 1.0);\nD = clamp(floor(D) / 255.0, 0.0, 1.0);\nreturn vec4(value.rgb * (D * (255.0 / maxRange)), D);\n}\nconst mat3 cLogLuvM = mat3(0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969);\nvec4 LinearToLogLuv(in vec4 value)  {\nvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\nXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\nvec4 vResult;\nvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\nfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\nvResult.w = fract(Le);\nvResult.z = (Le - (floor(vResult.w * 255.0)) / 255.0) / 255.0;\nreturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3(6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268);\nvec4 LogLuvToLinear(in vec4 value) {\nfloat Le = value.z * 255.0 + value.w;\nvec3 Xp_Y_XYZp;\nXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\nXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\nXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\nvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\nreturn vec4(max(vRGB, 0.0), 1.0);\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvec3 cameraToFrag;\nif (isOrthographic) {\ncameraToFrag = normalize(vec3(- viewMatrix[0][2], - viewMatrix[1][2], - viewMatrix[2][2]));\n}  else {\ncameraToFrag = normalize(vWorldPosition - cameraPosition);\n}\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvec3 reflectVec = reflect(cameraToFrag, worldNormal);\n#else\nvec3 reflectVec = refract(cameraToFrag, worldNormal, refractionRatio);\n#endif\n#else\nvec3 reflectVec = vReflect;\n#endif\n#ifdef ENVMAP_TYPE_CUBE\nvec4 envColor = textureCube(envMap, vec3(flipEnvMap * reflectVec.x, reflectVec.yz));\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nvec4 envColor = textureCubeUV(envMap, reflectVec, 0.0);\n#elif defined(ENVMAP_TYPE_EQUIREC)\nvec2 sampleUV;\nreflectVec = normalize(reflectVec);\nsampleUV.y = asin(clamp(reflectVec.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan(reflectVec.z, reflectVec.x) * RECIPROCAL_PI2 + 0.5;\nvec4 envColor = texture2D(envMap, sampleUV);\n#elif defined(ENVMAP_TYPE_SPHERE)\nreflectVec = normalize(reflectVec);\nvec3 reflectView = normalize((viewMatrix * vec4(reflectVec, 0.0)).xyz + vec3(0.0, 0.0, 1.0));\nvec4 envColor = texture2D(envMap, reflectView.xy * 0.5 + 0.5);\n#else\nvec4 envColor = vec4(0.0);\n#endif\n#ifndef ENVMAP_TYPE_CUBE_UV\nenvColor = envMapTexelToLinear(envColor);\n#endif\n#ifdef ENVMAP_BLENDING_MULTIPLY\noutgoingLight = mix(outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity);\n#elif defined(ENVMAP_BLENDING_MIX)\noutgoingLight = mix(outgoingLight, envColor.xyz, specularStrength * reflectivity);\n#elif defined(ENVMAP_BLENDING_ADD)\noutgoingLight += envColor.xyz * specularStrength * reflectivity;\n#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\nuniform float envMapIntensity;\nuniform float flipEnvMap;\nuniform int maxMipLevel;\n#ifdef ENVMAP_TYPE_CUBE\nuniform samplerCube envMap;\n#else\nuniform sampler2D envMap;\n#endif\n#ifdef ENVMAP_TYPE_CUBE_UV\nfloat calcGeometryRoughness(vec3 geometryNormal) {\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nreturn max(max(dxy.x, dxy.y), dxy.z);\n}\nfloat calcCubeUVAdjustedRoughness(float origRoughness, float geomRoughness) {\nreturn min(max(origRoughness, 0.0525) + geomRoughness, 1.0);\n}\n#endif\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\nuniform float reflectivity;\n#if defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(PHONG)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\nvarying vec3 vWorldPosition;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n#if defined(USE_BUMPMAP) || defined(USE_NORMALMAP) ||defined(PHONG)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\n\nvarying vec3 vWorldPosition;\n#else\nvarying vec3 vReflect;\nuniform float refractionRatio;\n#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined(USE_ENVMAP)\n#ifdef ENVMAP_MODE_REFRACTION\nuniform float refractionRatio;\n#endif\nvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel) {\nvec3 worldNormal = inverseTransformDirection(geometry.normal, viewMatrix);\n#ifdef ENVMAP_TYPE_CUBE\nvec3 queryVec = vec3(flipEnvMap * worldNormal.x, worldNormal.yz);\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = textureCubeLodEXT(envMap, queryVec, float(maxMIPLevel));\n#else\nvec4 envMapColor = textureCube(envMap, queryVec, float(maxMIPLevel));\n#endif\nenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nvec3 queryVec = vec3(flipEnvMap * worldNormal.x, worldNormal.yz);\nvec4 envMapColor = textureCubeUV(envMap, queryVec, 1.0);\n#else\nvec4 envMapColor = vec4(0.0);\n#endif\nreturn PI * envMapColor.rgb * envMapIntensity;\n}\nfloat getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {\nfloat maxMIPLevelScalar = float(maxMIPLevel);\nfloat clapmedBlinnShininessExponent = min(blinnShininessExponent, 30000.0);\nfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248\n- 0.5 * log2(pow2(clapmedBlinnShininessExponent) + 1.0);\nreturn clamp(desiredMIPLevel, 0.0, maxMIPLevelScalar);\n}\nvec3 _getLightProbeIndirect(const float blinnShininessExponent,\nconst int maxMIPLevel, vec3 directionVec) {\nfloat specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);\n#ifdef ENVMAP_TYPE_CUBE\nvec3 queryVec = vec3(flipEnvMap * directionVec.x, directionVec.yz);\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = textureCubeLodEXT(envMap, queryVec, specularMIPLevel);\n#else\nvec4 envMapColor = textureCube(envMap, queryVec, specularMIPLevel);\n#endif\nenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nvec3 queryVec = vec3(flipEnvMap * directionVec.x, directionVec.yz);\nvec4 envMapColor = textureCubeUV(envMap, queryVec,\nBlinnExponentToGGXRoughness(blinnShininessExponent));\n#elif defined(ENVMAP_TYPE_EQUIREC)\nvec2 sampleUV;\nsampleUV.y = asin(clamp(directionVec.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan(directionVec.z, directionVec.x) * RECIPROCAL_PI2 + 0.5;\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = texture2DLodEXT(envMap, sampleUV, specularMIPLevel);\n#else\nvec4 envMapColor = texture2D(envMap, sampleUV, specularMIPLevel);\n#endif\nenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\n#elif defined(ENVMAP_TYPE_SPHERE)\nvec3 reflectView = normalize((viewMatrix * vec4(directionVec, 0.0)).xyz + vec3(0.0,0.0,1.0));\n#ifdef TEXTURE_LOD_EXT\nvec4 envMapColor = texture2DLodEXT(envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel);\n#else\nvec4 envMapColor = texture2D(envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel);\n#endif\nenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\n#endif\nreturn envMapColor.rgb * envMapIntensity;\n}\nvec3 getLightProbeIndirectRadiance(\nconst GeometricContext geometry, const float blinnShininessExponent,\nconst int maxMIPLevel, const int useCoat) {\nvec3 normal = geometry.normal;\n#ifdef CLEARCOAT\nif (useCoat == 1) {\nnormal = geometry.clearcoatNormal;\n}\n#endif\n#ifdef ENVMAP_MODE_REFLECTION\nvec3 directionVec = reflect(-geometry.viewDir, normal);\n#else\nvec3 directionVec = refract(-geometry.viewDir, normal, refractionRatio);\n#endif\ndirectionVec = inverseTransformDirection(directionVec, viewMatrix);\nreturn _getLightProbeIndirect(blinnShininessExponent, maxMIPLevel,\ndirectionVec);\n}\nvec3 getLightProbeIndirectRefraction(\nconst GeometricContext geometry, const float blinnShininessExponent,\nconst int maxMIPLevel, const float refrRatio) {\nvec3 directionVec = refract(-geometry.viewDir, geometry.normal, refrRatio);\ndirectionVec = inverseTransformDirection(directionVec, viewMatrix);\nreturn _getLightProbeIndirect(blinnShininessExponent, maxMIPLevel,\ndirectionVec);\n}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvWorldPosition = worldPosition.xyz;\n#else\nvec3 cameraToVertex;\nif (isOrthographic) { \ncameraToVertex = normalize(vec3(- viewMatrix[0][2], - viewMatrix[1][2], - viewMatrix[2][2]));\n} else {\ncameraToVertex = normalize(worldPosition.xyz - cameraPosition);\n}\nvec3 worldNormal = inverseTransformDirection(transformedNormal, viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvReflect = reflect(cameraToVertex, worldNormal);\n#else\nvReflect = refract(cameraToVertex, worldNormal, refractionRatio);\n#endif\n#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\nvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n#ifdef FOG_EXP2\nfloat fogFactor = 1.0 - exp(- fogDensity * fogDensity * fogDepth * fogDepth);\n#else\nfloat fogFactor = smoothstep(fogNear, fogFar, fogDepth);\n#endif\ngl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, fogFactor);\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\nuniform vec3 fogColor;\nvarying float fogDepth;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\nuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance(vec3 normal, vec3 lightDirection) {\nfloat dotNL = dot(normal, lightDirection);\nvec2 coord = vec2(dotNL * 0.5 + 0.5, 0.0);\n#ifdef USE_GRADIENTMAP\nreturn texture2D(gradientMap, coord).rgb;\n#else\nreturn (coord.x < 0.7) ? vec3(0.7) : vec3(1.0);\n#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\nvec4 lightMapTexel= texture2D(lightMap, vUv2);\nreflectedLight.indirectDiffuse += PI * lightMapTexelToLinear(lightMapTexel).rgb * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\nuniform sampler2D lightMap;\nuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3(1.0);\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize(transformedNormal);\ngeometry.viewDir = (isOrthographic) ? vec3(0, 0, 1) : normalize(-mvPosition.xyz);\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3(0.0);\nvIndirectFront = vec3(0.0);\n#ifdef DOUBLE_SIDED\nvLightBack = vec3(0.0);\nvIndirectBack = vec3(0.0);\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\ngetPointDirectLightIrradiance(pointLights[i], geometry, directLight);\ndotNL = dot(geometry.normal, directLight.direction);\ndirectLightColor_Diffuse = PI * directLight.color;\nvLightFront += saturate(dotNL) * directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack += saturate(-dotNL) * directLightColor_Diffuse;\n#endif\n}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\ngetSpotDirectLightIrradiance(spotLights[i], geometry, directLight);\ndotNL = dot(geometry.normal, directLight.direction);\ndirectLightColor_Diffuse = PI * directLight.color;\nvLightFront += saturate(dotNL) * directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack += saturate(-dotNL) * directLightColor_Diffuse;\n#endif\n}\n#endif\n#if NUM_DIR_LIGHTS > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\ngetDirectionalDirectLightIrradiance(directionalLights[i], geometry, directLight);\ndotNL = dot(geometry.normal, directLight.direction);\ndirectLightColor_Diffuse = PI * directLight.color;\nvLightFront += saturate(dotNL) * directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack += saturate(-dotNL) * directLightColor_Diffuse;\n#endif\n}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_HEMI_LIGHTS; i++) {\nvIndirectFront += getHemisphereLightIrradiance(hemisphereLights[i], geometry);\n#ifdef DOUBLE_SIDED\nvIndirectBack += getHemisphereLightIrradiance(hemisphereLights[i], backGeometry);\n#endif\n}\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[9];\nvec3 shGetIrradianceAt(in vec3 normal, in vec3 shCoefficients[9]) {\nfloat x = normal.x, y = normal.y, z = normal.z;\nvec3 result = shCoefficients[0] * 0.886227;\nresult += shCoefficients[1] * 2.0 * 0.511664 * y;\nresult += shCoefficients[2] * 2.0 * 0.511664 * z;\nresult += shCoefficients[3] * 2.0 * 0.511664 * x;\nresult += shCoefficients[4] * 2.0 * 0.429043 * x * y;\nresult += shCoefficients[5] * 2.0 * 0.429043 * y * z;\nresult += shCoefficients[6] * (0.743125 * z * z - 0.247708);\nresult += shCoefficients[7] * 2.0 * 0.429043 * x * z;\nresult += shCoefficients[8] * 0.429043 * (x * x - y * y);\nreturn result;\n}\nvec3 getLightProbeIrradiance(const in vec3 lightProbe[9], const in GeometricContext geometry) {\nvec3 worldNormal = inverseTransformDirection(geometry.normal, viewMatrix);\nvec3 irradiance = shGetIrradianceAt(worldNormal, lightProbe);\nreturn irradiance;\n}\nvec3 getAmbientLightIrradiance(const in vec3 ambientLightColor) {\nvec3 irradiance = ambientLightColor;\n#if defined(MT_BLENDER) || !defined(PHYSICALLY_CORRECT_LIGHTS)\nirradiance *= PI;\n#endif\nreturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\nstruct DirectionalLight {\nvec3 direction;\nvec3 color;\nint shadow;\nfloat shadowBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nvec3 position;\nfloat maxDistance;\nfloat expBias;\n};\nuniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];\nvoid getDirectionalDirectLightIrradiance(const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight) {\ndirectLight.color = directionalLight.color;\ndirectLight.direction = directionalLight.direction;\ndirectLight.visible = true;\n}\n#endif\n#if NUM_POINT_LIGHTS > 0\nstruct PointLight {\nvec3 position;\nvec3 color;\nfloat distance;\nfloat decay;\nint shadow;\nfloat shadowBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform PointLight pointLights[NUM_POINT_LIGHTS];\nvoid getPointDirectLightIrradiance(const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight) {\nvec3 lVector = pointLight.position - geometry.position;\ndirectLight.direction = normalize(lVector);\nfloat lightDistance = length(lVector);\ndirectLight.color = pointLight.color;\ndirectLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.distance, pointLight.decay);\ndirectLight.visible = (directLight.color != vec3(0.0));\n}\n#endif\n#if NUM_SPOT_LIGHTS > 0\nstruct SpotLight {\nvec3 position;\nvec3 direction;\nvec3 color;\nfloat distance;\nfloat decay;\nfloat coneCos;\nfloat penumbraCos;\nint shadow;\nfloat shadowBias;\nfloat shadowRadius;\nvec2 shadowMapSize;\nfloat shadowCameraNear;\nfloat shadowCameraFar;\nfloat expBias;\n};\nuniform SpotLight spotLights[NUM_SPOT_LIGHTS];\nvoid getSpotDirectLightIrradiance(const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight) {\nvec3 lVector = spotLight.position - geometry.position;\ndirectLight.direction = normalize(lVector);\nfloat lightDistance = length(lVector);\nfloat angleCos = dot(directLight.direction, spotLight.direction);\n#if defined(MT_MAX) && defined(PHYSICALLY_CORRECT_LIGHTS)\nfloat coneCosDecayed = 2.0 * spotLight.coneCos - spotLight.penumbraCos;\nif (angleCos > coneCosDecayed) {\nfloat spotEffect = pow(max(angleCos, 0.0), log(0.5) / log(spotLight.penumbraCos) - 1.0);\nif (angleCos < spotLight.coneCos) {\nfloat decayFac = 1.0 + (spotLight.coneCos - angleCos)\n/ (spotLight.coneCos - spotLight.penumbraCos);\nspotEffect *= pow2(decayFac) * (3.0 - 2.0 * decayFac);\n}\ndirectLight.color = spotLight.color * spotEffect\n* punctualLightIntensityToIrradianceFactor(lightDistance,\nspotLight.distance, spotLight.decay);\ndirectLight.visible = true;\n} else {\ndirectLight.color = vec3(0.0);\ndirectLight.visible = false;\n}\n#else\nif (angleCos > spotLight.coneCos) {\nfloat spotEffect = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);\ndirectLight.color = spotLight.color * spotEffect\n* punctualLightIntensityToIrradianceFactor(lightDistance,\nspotLight.distance, spotLight.decay);\ndirectLight.visible = true;\n} else {\ndirectLight.color = vec3(0.0);\ndirectLight.visible = false;\n}\n#endif\n}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\nstruct RectAreaLight {\nvec3 color;\nvec3 position;\nvec3 halfWidth;\nvec3 halfHeight;\n};\nuniform sampler2D ltc_1;\nuniform sampler2D ltc_2;\nuniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];\n#endif\n#if NUM_HEMI_LIGHTS > 0\nstruct HemisphereLight {\nvec3 direction;\nvec3 skyColor;\nvec3 groundColor;\n};\nuniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];\nvec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight, const in GeometricContext geometry) {\nfloat dotNL = dot(geometry.normal, hemiLight.direction);\nfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\nvec3 irradiance = mix(hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight);\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\nreturn irradiance;\n}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\nvec3    diffuseColor;\nvec3    specularColor;\nfloat    specularShininess;\nfloat    specularStrength;\n};\nvoid RE_Direct_Toon(const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight) {\nvec3 irradiance = getGradientIrradiance(geometry.normal, directLight.direction) * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\nreflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\nreflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(directLight, geometry, material.specularColor, material.specularShininess) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon(const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\n#define RE_Direct                RE_Direct_Toon\n#define RE_IndirectDiffuse        RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD(material)    (0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\nvec3    diffuseColor;\nvec3    specularColor;\nfloat    specularShininess;\nfloat    specularStrength;\n};\nvoid RE_Direct_BlinnPhong(const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\nreflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\nreflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(directLight, geometry, material.specularColor, material.specularShininess) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong(const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\n#define RE_Direct                RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse        RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD(material)    (0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * (1.0 - metalnessFactor);\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterial.specularRoughness = max(roughnessFactor, 0.0525);\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min(material.specularRoughness, 1.0);\n#ifdef REFLECTIVITY\nmaterial.specularColor = mix(vec3(MAXIMUM_SPECULAR_COEFFICIENT * pow2(reflectivity)), diffuseColor.rgb, metalnessFactor);\n#else\nmaterial.specularColor = mix(vec3(DEFAULT_SPECULAR_COEFFICIENT), diffuseColor.rgb, metalnessFactor);\n#endif\n#ifdef CLEARCOAT\nmaterial.clearcoat = saturate(clearcoat);\nmaterial.clearcoatRoughness = max(clearcoatRoughness, 0.0525);\nmaterial.clearcoatRoughness += geometryRoughness;\nmaterial.clearcoatRoughness = min(material.clearcoatRoughness, 1.0);\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\nvec3    diffuseColor;\nfloat    specularRoughness;\nvec3    specularColor;\n#ifdef CLEARCOAT\nfloat clearcoat;\nfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox(const in float roughness, const in float dotNL) {\nreturn DEFAULT_SPECULAR_COEFFICIENT + (1.0 - DEFAULT_SPECULAR_COEFFICIENT) * (pow(1.0 - dotNL, 5.0) * pow(1.0 - roughness, 2.0));\n}\n#if NUM_RECT_AREA_LIGHTS > 0\nvoid RE_Direct_RectArea_Physical(const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\nvec3 normal = geometry.normal;\nvec3 viewDir = geometry.viewDir;\nvec3 position = geometry.position;\nvec3 lightPos = rectAreaLight.position;\nvec3 halfWidth = rectAreaLight.halfWidth;\nvec3 halfHeight = rectAreaLight.halfHeight;\nvec3 lightColor = rectAreaLight.color;\nfloat roughness = material.specularRoughness;\nvec3 rectCoords[4];\nrectCoords[0] = lightPos + halfWidth - halfHeight;\nrectCoords[1] = lightPos - halfWidth - halfHeight;\nrectCoords[2] = lightPos - halfWidth + halfHeight;\nrectCoords[3] = lightPos + halfWidth + halfHeight;\nvec2 uv = LTC_Uv(normal, viewDir, roughness);\nvec4 t1 = texture2D(ltc_1, uv);\nvec4 t2 = texture2D(ltc_2, uv);\nmat3 mInv = mat3(\nvec3(t1.x, 0, t1.y),\nvec3(   0, 1,    0),\nvec3(t1.z, 0, t1.w)\n);\nvec3 fresnel = (material.specularColor * t2.x + (vec3(1.0) - material.specularColor) * t2.y);\nreflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate(normal, viewDir, position, mInv, rectCoords);\nreflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate(normal, viewDir, position, mat3(1.0), rectCoords);\n}\n#endif\nvoid RE_Direct_Physical(const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\n#ifdef CLEARCOAT\nfloat ccDotNL = saturate(dot(geometry.clearcoatNormal, directLight.direction));\nvec3 ccIrradiance = ccDotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nccIrradiance *= PI;\n#endif\nfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox(material.clearcoatRoughness, ccDotNL);\nreflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX(directLight, geometry.viewDir, geometry.clearcoatNormal, vec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearcoatRoughness);\n#else\nfloat clearcoatDHR = 0.0;\n#endif\n#ifdef USE_SHEEN\nreflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance * BRDF_Specular_Sheen(\nmaterial.specularRoughness,\ndirectLight.direction,\ngeometry,\nmaterial.sheenColor\n);\n#else\nreflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance * BRDF_Specular_GGX(directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n#endif\nreflectedLight.directDiffuse += (1.0 - clearcoatDHR) * irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectDiffuse_Physical(const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\nvoid RE_IndirectSpecular_Physical(const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n#ifdef CLEARCOAT\nfloat ccDotNV = saturate(dot(geometry.clearcoatNormal, geometry.viewDir));\nreflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.clearcoatNormal, vec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearcoatRoughness);\nfloat ccDotNL = ccDotNV;\nfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox(material.clearcoatRoughness, ccDotNL);\n#else\nfloat clearcoatDHR = 0.0;\n#endif\nfloat clearcoatInv = 1.0 - clearcoatDHR;\nvec3 singleScattering = vec3(0.0);\nvec3 multiScattering = vec3(0.0);\nvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\nBRDF_Specular_Multiscattering_Environment(geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering);\nvec3 diffuse = material.diffuseColor * (1.0 - (singleScattering + multiScattering));\nreflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\nreflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\nreflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct                RE_Direct_Physical\n#define RE_Direct_RectArea        RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse        RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular        RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.specularRoughness)\n#define Material_ClearCoat_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.clearcoatRoughness)\nfloat computeSpecularOcclusion(const in float dotNV, const in float ambientOcclusion, const in float roughness) {\nreturn saturate(pow(abs(dotNV + ambientOcclusion), exp2(- 16.0 * roughness - 1.0)) - 1.0 + ambientOcclusion);\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = (isOrthographic) ? vec3(0, 0, 1) : normalize(vViewPosition);\n#if defined(CLEARCOAT)\n#if defined(COAT_NORMAL)\ngeometry.clearcoatNormal = COAT_NORMAL;\n#else\ngeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#endif\nIncidentLight directLight;\n#if (NUM_POINT_LIGHTS > 0) && defined(RE_Direct)\nPointLight pointLight;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\npointLight = pointLights[i];\ngetPointDirectLightIrradiance(pointLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_POINT_LIGHT_SHADOWS)\ndirectLight.color *= all(bvec2(pointLight.shadow, directLight.visible)) ?\ngetPointShadow(pointLight, pointShadowMap[i], vPointShadowCoord[i]) : 1.0;\n#endif\nRE_Direct(directLight, geometry, material, reflectedLight);\n}\n#endif\n#if (NUM_SPOT_LIGHTS > 0) && defined(RE_Direct)\nSpotLight spotLight;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\nspotLight = spotLights[i];\ngetSpotDirectLightIrradiance(spotLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_SPOT_LIGHT_SHADOWS)\nif (directLight.visible) {\nif (spotLight.shadow == 1) {\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(spotLight.position\n- geometry.position, 0.0)).xyz);\n#endif\ndirectLight.color *= getSpotShadow(spotLight, spotShadowMap[i],\nvSpotShadowCoord[i], distWorld);\n} else if (spotLight.shadow == 2) {\ndirectLight.color *= getSpotOmniShadow(spotLight,\nspotShadowMap[i], vSpotShadowCoord[i]);\n}\n}\n#endif\nRE_Direct(directLight, geometry, material, reflectedLight);\n}\n#endif\n#if (NUM_DIR_LIGHTS > 0) && defined(RE_Direct)\nDirectionalLight directionalLight;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\ndirectionalLight = directionalLights[i];\ngetDirectionalDirectLightIrradiance(directionalLight, geometry, directLight);\n#if defined(USE_SHADOWMAP) && ((i) < NUM_DIR_LIGHT_SHADOWS)\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(directionalLight.position\n- geometry.position, 0.0)).xyz);\n#endif\ndirectLight.color *= all(bvec3(directionalLight.shadow, directLight.visible,\nvViewPosition.z < directionalLight.maxDistance)) ?\ngetShadow(directionalShadowMap[i], directionalLight.shadowMapSize,\ndirectionalLight.shadowBias, directionalLight.expBias,\ndirectionalLight.shadowRadius, vDirectionalShadowCoord[i], distWorld) : 1.0;\n#endif\nRE_Direct(directLight, geometry, material, reflectedLight);\n}\n#endif\n#if (NUM_RECT_AREA_LIGHTS > 0) && defined(RE_Direct_RectArea)\nRectAreaLight rectAreaLight;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_RECT_AREA_LIGHTS; i++) {\nrectAreaLight = rectAreaLights[i];\nRE_Direct_RectArea(rectAreaLight, geometry, material, reflectedLight);\n}\n#endif\n#if defined(RE_IndirectDiffuse)\nvec3 iblIrradiance = vec3(0.0);\nvec3 irradiance = getAmbientLightIrradiance(ambientLightColor);\nirradiance += getLightProbeIrradiance(lightProbe, geometry);\n#if (NUM_HEMI_LIGHTS > 0)\n#pragma unroll_loop\nfor (int i = 0; i < NUM_HEMI_LIGHTS; i++) {\nirradiance += getHemisphereLightIrradiance(hemisphereLights[i], geometry);\n#if defined(MT_BLENDER) && !defined(PHYSICAL)\nRE_HemiSpec_Blender(hemisphereLights[i], geometry, material, reflectedLight);\n#endif\n}\n#endif\n#endif\n#if defined(RE_IndirectSpecular)\nvec3 radiance = vec3(0.0);\nvec3 clearcoatRadiance = vec3(0.0);\n#endif\n#if defined(RE_Refraction) && defined(USE_REFRACTED_LIGHT)\nvec3 refraction = vec3(0.0);\n#endif",
            lights_fragment_maps: "#if defined(RE_IndirectDiffuse)\n#ifdef USE_LIGHTMAP\nvec4 lightMapTexel= texture2D(lightMap, vUv2);\nvec3 lightMapIrradiance = lightMapTexelToLinear(lightMapTexel).rgb * lightMapIntensity;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nlightMapIrradiance *= PI;\n#endif\nirradiance += lightMapIrradiance;\n#endif\n#if defined(USE_ENVMAP) && defined(STANDARD) && defined(ENVMAP_TYPE_CUBE_UV)\niblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel);\n#endif\n#endif\n#if defined(USE_ENVMAP) && defined(RE_IndirectSpecular)\nradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent(material), maxMipLevel, 0);\n#if defined(USE_SSR) && !defined(USE_SSR_REFRACT)\nradiance = computeSSR(radiance, geometry.normal, 0.0);\n#endif\n#ifdef CLEARCOAT\nclearcoatRadiance += getLightProbeIndirectRadiance(geometry, Material_ClearCoat_BlinnShininessExponent(material), maxMipLevel, 1);\n#endif\n#endif\n#if defined(USE_ENVMAP) && defined(RE_Refraction) && defined(USE_REFRACTED_LIGHT)\nrefraction += getLightProbeIndirectRefraction(geometry,\nMaterial_Refraction_BlinnShininessExponent(material), maxMipLevel,\n1.0 / material.refractionIOR);\n#ifdef USE_SSR_REFRACT\nrefraction = computeSSR(refraction, geometry.normal, material.refractionIOR);\n#endif\n#endif",
            lights_fragment_end: "#if defined(RE_IndirectDiffuse)\nRE_IndirectDiffuse(irradiance, geometry, material, reflectedLight);\n#endif\n#if defined(RE_IndirectSpecular)\nRE_IndirectSpecular(radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight);\n#endif\n#if defined(RE_Refraction) && defined(USE_REFRACTED_LIGHT)\nRE_Refraction(refraction, material, refractedLight);\n#endif",
            logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\ngl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\nuniform float logDepthBufFC;\nvarying float vFragDepth;\nvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;\nvarying float vIsPerspective;\n#else\nuniform float logDepthBufFC;\n#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvFragDepth = 1.0 + gl_Position.w;\nvIsPerspective = float(isPerspectiveMatrix(projectionMatrix));\n#else\nif (isPerspectiveMatrix(projectionMatrix)) {\ngl_Position.z = log2(max(EPSILON, gl_Position.w + 1.0)) * logDepthBufFC - 1.0;\ngl_Position.z *= gl_Position.w;\n}\n#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\nvec4 texelColor = texture2D(map, vUv);\ntexelColor = mapTexelToLinear(texelColor);\ndiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined(USE_MAP) || defined(USE_ALPHAMAP)\nvec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy;\n#endif\n#ifdef USE_MAP\nvec4 mapTexel = texture2D(map, uv);\ndiffuseColor *= mapTexelToLinear(mapTexel);\n#endif\n#ifdef USE_ALPHAMAP\ndiffuseColor.a *= texture2D(alphaMap, uv).g;\n#endif",
            map_particle_pars_fragment: "#if defined(USE_MAP) || defined(USE_ALPHAMAP)\nuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\nvec4 texelMetalness = texture2D(metalnessMap, vUv);\nmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\nuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n#if NUM_MORPH_TARGETS > 0\nobjectNormal += (morphNormal0 - normal) * morphTargetInfluences[0];\n#endif\n#if NUM_MORPH_TARGETS > 1\nobjectNormal += (morphNormal1 - normal) * morphTargetInfluences[1];\n#endif\n#if NUM_MORPH_TARGETS > 2\nobjectNormal += (morphNormal2 - normal) * morphTargetInfluences[2];\n#endif\n#if NUM_MORPH_TARGETS > 3\nobjectNormal += (morphNormal3 - normal) * morphTargetInfluences[3];\n#endif\n#if NUM_MORPH_TARGETS > 4\nobjectNormal += (morphNormal4 - normal) * morphTargetInfluences[4];\n#endif\n#if NUM_MORPH_TARGETS > 5\nobjectNormal += (morphNormal5 - normal) * morphTargetInfluences[5];\n#endif\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\nuniform float morphTargetBaseInfluence;\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[12];\n#else\nuniform float morphTargetInfluences[6];\n#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\ntransformed *= morphTargetBaseInfluence;\n#if NUM_MORPH_TARGETS > 0\ntransformed += morphTarget0 * morphTargetInfluences[0];\n#endif\n#if NUM_MORPH_TARGETS > 1\ntransformed += morphTarget1 * morphTargetInfluences[1];\n#endif\n#if NUM_MORPH_TARGETS > 2\ntransformed += morphTarget2 * morphTargetInfluences[2];\n#endif\n#if NUM_MORPH_TARGETS > 3\ntransformed += morphTarget3 * morphTargetInfluences[3];\n#endif\n#if NUM_MORPH_TARGETS > 4\ntransformed += morphTarget4 * morphTargetInfluences[4];\n#endif\n#if NUM_MORPH_TARGETS > 5\ntransformed += morphTarget5 * morphTargetInfluences[5];\n#endif\n#ifndef USE_MORPHNORMALS\n#if NUM_MORPH_TARGETS > 6\ntransformed += morphTarget6 * morphTargetInfluences[6];\n#endif\n#if NUM_MORPH_TARGETS > 7\ntransformed += morphTarget7 * morphTargetInfluences[7];\n#endif\n#if NUM_MORPH_TARGETS > 8\ntransformed += morphTarget8 * morphTargetInfluences[8];\n#endif\n#if NUM_MORPH_TARGETS > 9\ntransformed += morphTarget9 * morphTargetInfluences[9];\n#endif\n#if NUM_MORPH_TARGETS > 10\ntransformed += morphTarget10 * morphTargetInfluences[10];\n#endif\n#if NUM_MORPH_TARGETS > 11\ntransformed += morphTarget1 * morphTargetInfluences[11];\n#endif\n#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\nvec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));\nvec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));\nvec3 normal = normalize(cross(fdx, fdy));\n#else\nvec3 normal = normalize(vNormal);\n#ifdef DOUBLE_SIDED\n#ifdef FRONT_FACING_VALUE\nbool frontFacing = FRONT_FACING_VALUE;\n#else\nbool frontFacing = gl_FrontFacing;\n#endif\nnormal = normal * (float(frontFacing) * 2.0 - 1.0);\n#endif\n#ifdef USE_TANGENT\nvec3 tangent = normalize(vTangent);\nvec3 bitangent = normalize(vBitangent);\n#ifdef DOUBLE_SIDED\ntangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);\nbitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\n#if defined(TANGENTSPACE_NORMALMAP) || defined(USE_CLEARCOAT_NORMALMAP)\nmat3 vTBN = mat3(tangent, bitangent, normal);\n#endif\n#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\nnormal = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;\n#ifdef FLIP_SIDED\nnormal = - normal;\n#endif\n#ifdef DOUBLE_SIDED\nnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\nnormal = normalize(normalMatrix * normal);\n#elif defined(TANGENTSPACE_NORMALMAP)\nvec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;\nmapN.xy *= normalScale;\n#ifdef USE_TANGENT\nnormal = normalize(vTBN * mapN);\n#else\nnormal = perturbNormal2Arb(-vViewPosition, normal, mapN);\n#endif\n#elif defined(USE_BUMPMAP)\nnormal = perturbNormalArb(-vViewPosition, normal, dHdxy_fwd());\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat3 normalMatrix;\n#endif\n#if !defined (USE_TANGENT) && (defined (TANGENTSPACE_NORMALMAP) || defined (USE_CLEARCOAT_NORMALMAP))\nvec3 perturbNormal2Arb(vec3 eye_pos, vec3 surf_norm, vec3 mapN) {\nvec3 q0 = vec3(dFdx(eye_pos.x), dFdx(eye_pos.y), dFdx(eye_pos.z));\nvec3 q1 = vec3(dFdy(eye_pos.x), dFdy(eye_pos.y), dFdy(eye_pos.z));\nvec2 st0 = dFdx(vUv.st);\nvec2 st1 = dFdy(vUv.st);\nfloat scale = sign(st1.t * st0.s - st0.t * st1.s);\nvec3 S = normalize((q0 * st1.t - q1 * st0.t) * scale);\nvec3 T = normalize((- q0 * st1.s + q1 * st0.s) * scale);\nvec3 N = normalize(surf_norm);\nmat3 tsn = mat3(S, T, N);\nmapN.xy *= (float(gl_FrontFacing) * 2.0 - 1.0);\nreturn normalize(tsn * mapN);\n}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\nvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\nvec3 clearcoatMapN = texture2D(clearcoatNormalMap, vUv).xyz * 2.0 - 1.0;\nclearcoatMapN.xy *= clearcoatNormalScale;\n#ifdef USE_TANGENT\nclearcoatNormal = normalize(vTBN * clearcoatMapN);\n#else\nclearcoatNormal = perturbNormal2Arb(- vViewPosition, clearcoatNormal, clearcoatMapN);\n#endif\n#endif",
            clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\nuniform sampler2D clearcoatNormalMap;\nuniform vec2 clearcoatNormalScale;\n#endif",
            packing: "vec3 packNormalToRGB(const in vec3 normal) {\nreturn normalize(normal) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal(const in vec3 rgb) {\nreturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;\nconst float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3(256. * 256. * 256., 256. * 256.,  256.);\nconst vec4 UnpackFactors = UnpackDownscale / vec4(PackFactors, 1.);\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA(const in float v) {\nvec4 r = vec4(fract(v * PackFactors), v);\nr.yzw -= r.xyz * ShiftRight8;\nreturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth(const in vec4 v) {\nreturn dot(v, UnpackFactors);\n}\nvec4 pack2HalfToRGBA(vec2 v) {\nvec4 r = vec4(v.x, fract(v.x * 255.0), v.y, fract(v.y * 255.0));\nreturn vec4(r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half(vec4 v) {\nreturn vec2(v.x + (v.y / 255.0), v.z + (v.w / 255.0));\n}\nfloat viewZToOrthographicDepth(const in float viewZ, const in float near, const in float far) {\nreturn (viewZ + near) / (near - far);\n}\nfloat orthographicDepthToViewZ(const in float linearClipZ, const in float near, const in float far) {\nreturn linearClipZ * (near - far) - near;\n}\nfloat viewZToPerspectiveDepth(const in float viewZ, const in float near, const in float far) {\nreturn ((near + viewZ) * far) / ((far - near) * viewZ);\n}\nfloat perspectiveDepthToViewZ(const in float invClipZ, const in float near, const in float far) {\nreturn (near * far) / ((far - near) * invClipZ - far);\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\ngl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4(transformed, 1.0);\n#ifdef USE_INSTANCING\nmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;\n#if defined(BACKGROUND_DEPTH)\ngl_Position.z = gl_Position.w;\n#endif",
            dithering_fragment: "#ifdef DITHERING\ngl_FragColor.rgb = dithering(gl_FragColor.rgb);\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\nvec3 dithering(vec3 color) {\nfloat grid_position = rand(gl_FragCoord.xy);\nvec3 dither_shift_RGB = vec3(0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0);\ndither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);\nreturn color + dither_shift_RGB;\n}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\nvec4 texelRoughness = texture2D(roughnessMap, vUv);\nroughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\nuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "\n#define BLENDER_BIAS_MULT_POINT 0.05\n#define BLENDER_ESM_SPOT_SINGLE_BLUR_COEFF 0.25\n#define MAX_PCF_POISSON_SPOT_OMNI_BLUR_COEFF 4.0\n#define MAX_PCF_POISSON_POINT_BLUR_COEFF 2.5\n#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS > 0\nuniform sampler2D directionalShadowMap[NUM_DIR_LIGHT_SHADOWS];\nvarying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nuniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];\nvarying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nuniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];\nvarying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];\n#endif\nconst vec3 PERMUTE_DIR_X = vec3(1.0, 0.0, 0.0);\nconst vec3 PERMUTE_DIR_Y = vec3(0.0, 1.0, 0.0);\nconst vec3 PERMUTE_DIR_Z = vec3(0.0, 0.0, 1.0);\nconst mat4 POISSON_DISK_0 = mat4(\n0.954845, 0.242214, -0.623893, -0.235473,\n-0.173288, 0.799228, 0.605969, -0.548050,\n-0.560406, 0.327647, -0.448307, -0.774344,\n0.308258, 0.417332, -0.125623, -0.056098\n);\nconst mat4 POISSON_DISK_1 = mat4(\n0.145585, -0.305634, 0.264060, -0.661648,\n0.617942, 0.652121, -0.041412, -0.893582,\n0.463911, 0.039752, 0.212664, 0.810727,\n-0.955989, -0.014390, -0.652588, 0.671204\n);\nfloat texture2DCompare(sampler2D depths, vec2 uv, float compare) {\nreturn step(compare, unpackRGBAToDepth(texture2D(depths, uv)));\n}\nfloat texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare) {\nconst vec2 offset = vec2(0.0, 1.0);\nvec2 texelSize = vec2(1.0) / size;\nvec2 centroidUV = floor(uv * size + 0.5) / size;\nfloat lb = texture2DCompare(depths, centroidUV + texelSize * offset.xx, compare);\nfloat lt = texture2DCompare(depths, centroidUV + texelSize * offset.xy, compare);\nfloat rb = texture2DCompare(depths, centroidUV + texelSize * offset.yx, compare);\nfloat rt = texture2DCompare(depths, centroidUV + texelSize * offset.yy, compare);\nvec2 f = fract(uv * size + 0.5);\nfloat a = mix(lb, lt, f.y);\nfloat b = mix(rb, rt, f.y);\nfloat c = mix(a, b, f.x);\nreturn c;\n}\nfloat getShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias,\nfloat expBias, float shadowRadius, vec4 shadowCoord, float distWorld) {\nfloat shadow = 1.0;\nshadowCoord.xyz /= shadowCoord.w;\nbvec4 inFrustumVec = bvec4 (shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0);\nbool inFrustum = all(inFrustumVec);\nbvec3 frustumTestVec = bvec3(inFrustum, shadowCoord.z <= 1.0, shadowCoord.z >= 0.0);\nbool frustumTest = all(frustumTestVec);\nif (frustumTest) {\n#if defined(SHADOWMAP_TYPE_PCF)\nshadowCoord.z += shadowBias;\nvec2 texelSize = vec2(1.0) / shadowMapSize;\nfloat dx0 = - texelSize.x * shadowRadius;\nfloat dy0 = - texelSize.y * shadowRadius;\nfloat dx1 = + texelSize.x * shadowRadius;\nfloat dy1 = + texelSize.y * shadowRadius;\nshadow = (\ntexture2DCompare(shadowMap, shadowCoord.xy + vec2(dx0, dy0), shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + vec2(0.0, dy0), shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + vec2(dx1, dy0), shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + vec2(dx0, 0.0), shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + vec2(dx1, 0.0), shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + vec2(dx0, dy1), shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + vec2(0.0, dy1), shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + vec2(dx1, dy1), shadowCoord.z)\n) * (1.0 / 9.0);\n#elif defined(SHADOWMAP_TYPE_PCF_SOFT)\nshadowCoord.z += shadowBias;\nvec2 texelSize = vec2(1.0) / shadowMapSize;\nfloat dx0 = - texelSize.x * shadowRadius;\nfloat dy0 = - texelSize.y * shadowRadius;\nfloat dx1 = + texelSize.x * shadowRadius;\nfloat dy1 = + texelSize.y * shadowRadius;\nshadow = (\ntexture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(dx0, dy0), shadowCoord.z) +\ntexture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(0.0, dy0), shadowCoord.z) +\ntexture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(dx1, dy0), shadowCoord.z) +\ntexture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(dx0, 0.0), shadowCoord.z) +\ntexture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z) +\ntexture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(dx1, 0.0), shadowCoord.z) +\ntexture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(dx0, dy1), shadowCoord.z) +\ntexture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(0.0, dy1), shadowCoord.z) +\ntexture2DShadowLerp(shadowMap, shadowMapSize, shadowCoord.xy + vec2(dx1, dy1), shadowCoord.z)\n) * (1.0 / 9.0);\n#elif defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)\nshadowCoord.z += shadowBias;\nvec2 texelSize = vec2(1.0) / shadowMapSize;\nfloat randAngle = rand(gl_FragCoord.xy) * PI2;\nfloat c = cos(randAngle), s = sin(randAngle);\nmat2 sampleMat = mat2(c, s, -s, c)\n* mat2(shadowRadius * texelSize.x, 0.0, 0.0, shadowRadius * texelSize.y);\nshadow = (\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_0[0].xy, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_0[0].zw, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_0[1].xy, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_0[1].zw, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_0[2].xy, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_0[2].zw, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_0[3].xy, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_0[3].zw, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_1[0].xy, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_1[0].zw, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_1[1].xy, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_1[1].zw, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_1[2].xy, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_1[2].zw, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_1[3].xy, shadowCoord.z) +\ntexture2DCompare(shadowMap, shadowCoord.xy + sampleMat * POISSON_DISK_1[3].zw, shadowCoord.z)\n) / 16.0;\n#elif defined(SHADOWMAP_TYPE_ESM)\nshadow = saturate(exp(expBias * (texture2D(shadowMap, shadowCoord.xy).x\n- length(distWorld) - BLENDER_BIAS_MULT_POINT * shadowBias)));\n#else\nshadowCoord.z += shadowBias;\nshadow = texture2DCompare(shadowMap, shadowCoord.xy, shadowCoord.z);\n#endif\n}\nreturn shadow;\n}\nvec2 cubeToUV(vec3 v, float texelSizeY) {\nvec3 absV = abs(v);\nfloat scaleToCube = 1.0 / max(absV.x, max(absV.y, absV.z));\nabsV *= scaleToCube;\nv *= scaleToCube * (1.0 - 2.0 * texelSizeY);\nvec2 planar = v.xy;\nfloat almostATexel = 1.5 * texelSizeY;\nfloat almostOne = 1.0 - almostATexel;\nif (absV.z >= almostOne) {\nif (v.z > 0.0)\nplanar.x = 4.0 - v.x;\n} else if (absV.x >= almostOne) {\nfloat signX = sign(v.x);\nplanar.x = v.z * signX + 2.0 * signX;\n} else if (absV.y >= almostOne) {\nfloat signY = sign(v.y);\nplanar.x = v.x + 2.0 * signY + 2.0;\nplanar.y = v.z * signY - 2.0;\n}\nreturn vec2(0.125, 0.25) * planar + vec2(0.375, 0.75);\n}\nfloat getOmniShadow(sampler2D shadowMap, vec2 shadowMapSize, float shadowBias,\nfloat expBias, float shadowRadius, vec4 shadowCoord,\nfloat shadowCameraNear, float shadowCameraFar) {\nfloat shadow = 1.0;\nvec3 lightToPosition = shadowCoord.xyz;\nfloat dp = (length(lightToPosition) - shadowCameraNear)\n/ (shadowCameraFar - shadowCameraNear);\nbvec2 frustumTestVec = bvec2(dp <= 1.0, dp >= 0.0);\nbool frustumTest = all(frustumTestVec);\nif (frustumTest) {\ndp += shadowBias;\nvec3 bd3D = normalize(lightToPosition);\nvec2 texelSize = 1.0 / shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\nshadow = saturate(exp(expBias * (texture2D(shadowMap,\ncubeVecToOctUV(bd3D, texelSize)).x\n- length(lightToPosition) - BLENDER_BIAS_MULT_POINT * shadowBias)));\n#elif defined(SHADOWMAP_TYPE_PCF) || defined(SHADOWMAP_TYPE_PCF_SOFT)\nvec2 offset = vec2(-1, 1) * shadowRadius * texelSize.y;\nshadow = (\ntexture2DCompare(shadowMap, cubeToUV(bd3D + offset.xyy, texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + offset.yyy, texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + offset.xyx, texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + offset.yyx, texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D, texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + offset.xxy, texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + offset.yxy, texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + offset.xxx, texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + offset.yxx, texelSize.y), dp)\n) * (1.0 / 9.0);\n#elif defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)\nfloat randAngle = rand(gl_FragCoord.xy) * PI2;\nfloat c = cos(randAngle), s = sin(randAngle);\nmat2 sampleMat = mat2(c, s, -s, c)\n* mat2(shadowRadius * texelSize.y, 0.0, 0.0, shadowRadius * texelSize.y);\nvec3 absBd3D = abs(bd3D);\nabsBd3D /= max(absBd3D.x, max(absBd3D.y, absBd3D.z));\nbvec2 isPointingCubeFace = greaterThan(absBd3D.xy, vec2(0.999));\nmat3 permuteMat = mat3(\nisPointingCubeFace.x ? PERMUTE_DIR_Y : PERMUTE_DIR_X,\nisPointingCubeFace.x || isPointingCubeFace.y ? PERMUTE_DIR_Z : PERMUTE_DIR_Y,\nisPointingCubeFace.x ? PERMUTE_DIR_X : isPointingCubeFace.y ? PERMUTE_DIR_Y : PERMUTE_DIR_Z\n);\nshadow = (\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_0[0].xy, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_0[0].zw, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_0[1].xy, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_0[1].zw, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_0[2].xy, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_0[2].zw, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_0[3].xy, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_0[3].zw, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_1[0].xy, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_1[0].zw, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_1[1].xy, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_1[1].zw, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_1[2].xy, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_1[2].zw, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_1[3].xy, 0.0), texelSize.y), dp) +\ntexture2DCompare(shadowMap, cubeToUV(bd3D + permuteMat * vec3(sampleMat * POISSON_DISK_1[3].zw, 0.0), texelSize.y), dp)\n) / 16.0;\n#else\nshadow = texture2DCompare(shadowMap, cubeToUV(bd3D, texelSize.y), dp);\n#endif\n}\nreturn shadow;\n}\n#if NUM_POINT_LIGHT_SHADOWS > 0\nfloat getPointShadow(PointLight light, sampler2D shadowMap, vec4 shadowCoord) {\nfloat shadowRadius = light.shadowRadius;\nvec2 mapSize = light.shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\nmapSize *= 2.0;\n#else\nmapSize *= vec2(4.0, 2.0);\n#if defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)\nshadowRadius *= MAX_PCF_POISSON_POINT_BLUR_COEFF;\n#endif\n#endif\nreturn getOmniShadow(shadowMap, mapSize, light.shadowBias, light.expBias,\nshadowRadius, shadowCoord, light.shadowCameraNear,\nlight.shadowCameraFar);\n}\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nfloat getSpotOmniShadow(SpotLight light, sampler2D shadowMap, vec4 shadowCoord) {\nfloat shadowRadius = light.shadowRadius;\nvec2 mapSize = light.shadowMapSize;\n#if defined(SHADOWMAP_TYPE_ESM)\n#else\nmapSize *= vec2(4.0, 2.0);\n#if defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)\nshadowRadius *= MAX_PCF_POISSON_SPOT_OMNI_BLUR_COEFF;\n#endif\n#endif\nreturn getOmniShadow(shadowMap, mapSize, light.shadowBias, light.expBias,\nshadowRadius, shadowCoord, light.shadowCameraNear,\nlight.shadowCameraFar);\n}\nfloat biasLinearNormalizedToNonlinear(float bias, float near, float far,\nfloat projZ, float projW) {\nreturn (bias * (far + near) + 2.0 * projZ) / (bias * (far - near) + 2.0 * projW)\n- projZ / projW;\n}\nfloat getSpotShadow(SpotLight light, sampler2D shadowMap, vec4 shadowCoord,\nfloat distWorld) {\nfloat shadowRadius = light.shadowRadius;\nfloat shadowBias = light.shadowBias;\n#if defined(SHADOWMAP_TYPE_ESM)\nshadowRadius *= BLENDER_ESM_SPOT_SINGLE_BLUR_COEFF;\n#elif defined(SHADOWMAP_TYPE_PCF_POISSON_DISK)\nshadowBias = biasLinearNormalizedToNonlinear(shadowBias,\nlight.shadowCameraNear, light.shadowCameraFar, shadowCoord.z,\nshadowCoord.w);\n#endif\nreturn getShadow(shadowMap, light.shadowMapSize, shadowBias,\nlight.expBias, shadowRadius, shadowCoord, distWorld);\n}\n#endif\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS > 0\nuniform mat4 directionalShadowMatrix[NUM_DIR_LIGHT_SHADOWS];\nvarying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nuniform mat4 spotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];\nvarying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nuniform mat4 pointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];\nvarying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];\n#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i++) {\nvDirectionalShadowCoord[i] = directionalShadowMatrix[i] * worldPosition;\n}\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i++) {\nvSpotShadowCoord[i] = spotShadowMatrix[i] * worldPosition;\n}\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\n#pragma unroll_loop\nfor (int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i++) {\nvPointShadowCoord[i] = pointShadowMatrix[i] * worldPosition;\n}\n#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\nfloat shadow = 1.0;\n#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS > 0\nDirectionalLight directionalLight;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i++) {\ndirectionalLight = directionalLights[i];\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(directionalLight.position\n+ vViewPosition, 0.0)).xyz);\n#endif\nshadow *= all(bvec2(directionalLight.shadow, vViewPosition.z\n< directionalLight.maxDistance)) ? getShadow(directionalShadowMap[i],\ndirectionalLight.shadowMapSize, directionalLight.shadowBias,\ndirectionalLight.expBias, directionalLight.shadowRadius,\nvDirectionalShadowCoord[i], distWorld) : 1.0;\n}\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nSpotLight spotLight;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i++) {\nspotLight = spotLights[i];\nif (spotLight.shadow == 1) {\nfloat distWorld = 0.0;\n#if defined(SHADOWMAP_TYPE_ESM)\ndistWorld = length((invViewMatrix * vec4(spotLight.position\n+ vViewPosition, 0.0)).xyz);\n#endif\nshadow *= getSpotShadow(spotLight, spotShadowMap[i], vSpotShadowCoord[i],\ndistWorld);\n} else if (spotLight.shadow == 2) {\nshadow *= getSpotOmniShadow(spotLight, spotShadowMap[i],\nvSpotShadowCoord[i]);\n}\n}\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nPointLight pointLight;\n#pragma unroll_loop\nfor (int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i++) {\npointLight = pointLights[i];\nshadow *= bool(pointLight.shadow) ?\ngetPointShadow(pointLight, pointShadowMap[i], vPointShadowCoord[i]) : 1.0;\n}\n#endif\n#endif\nreturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix(skinIndex.x);\nmat4 boneMatY = getBoneMatrix(skinIndex.y);\nmat4 boneMatZ = getBoneMatrix(skinIndex.z);\nmat4 boneMatW = getBoneMatrix(skinIndex.w);\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\nuniform mat4 bindMatrix;\nuniform mat4 bindMatrixInverse;\n#ifdef BONE_TEXTURE\nuniform highp sampler2D boneTexture;\nuniform int boneTextureSize;\nmat4 getBoneMatrix(const in float i) {\nfloat j = i * 4.0;\nfloat x = mod(j, float(boneTextureSize));\nfloat y = floor(j / float(boneTextureSize));\nfloat dx = 1.0 / float(boneTextureSize);\nfloat dy = 1.0 / float(boneTextureSize);\ny = dy * (y + 0.5);\nvec4 v1 = texture2D(boneTexture, vec2(dx * (x + 0.5), y));\nvec4 v2 = texture2D(boneTexture, vec2(dx * (x + 1.5), y));\nvec4 v3 = texture2D(boneTexture, vec2(dx * (x + 2.5), y));\nvec4 v4 = texture2D(boneTexture, vec2(dx * (x + 3.5), y));\nmat4 bone = mat4(v1, v2, v3, v4);\nreturn bone;\n}\n#else\nuniform mat4 boneMatrices[MAX_BONES];\nmat4 getBoneMatrix(const in float i) {\nmat4 bone = boneMatrices[int(i)];\nreturn bone;\n}\n#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\nvec4 skinVertex = bindMatrix * vec4(transformed, 1.0);\nvec4 skinned = vec4(0.0);\nskinned += boneMatX * skinVertex * skinWeight.x;\nskinned += boneMatY * skinVertex * skinWeight.y;\nskinned += boneMatZ * skinVertex * skinWeight.z;\nskinned += boneMatW * skinVertex * skinWeight.w;\ntransformed = (bindMatrixInverse * skinned).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\nmat4 skinMatrix = mat4(0.0);\nskinMatrix += skinWeight.x * boneMatX;\nskinMatrix += skinWeight.y * boneMatY;\nskinMatrix += skinWeight.z * boneMatZ;\nskinMatrix += skinWeight.w * boneMatW;\nskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\nobjectNormal = vec4(skinMatrix * vec4(objectNormal, 0.0)).xyz;\n#ifdef USE_TANGENT\nobjectTangent = vec4(skinMatrix * vec4(objectTangent, 0.0)).xyz;\n#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D(specularMap, vUv);\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined(TONE_MAPPING)\ngl_FragColor.rgb = toneMapping(gl_FragColor.rgb);\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp(a, 0.0, 1.0)\n#endif\n#ifndef PI\n#define PI 3.14159265359\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingMidTones;\nuniform float toneMappingPhysicalScale;\nuniform float toneMappingWhitePoint;\nuniform float toneMappingBrightness;\nuniform float toneMappingContrast;\nuniform bool toneMappingChromaticAdaptation;\nuniform vec3 toneMappingWhiteColor;\nuniform bool toneMappingColorDifferentiation;\nuniform bool toneMappingExteriorDaylight;\nuniform vec3 toneMappingWhiteBalance;\nuniform float toneMappingHighlights;\nuniform float toneMappingShadows;\nuniform float toneMappingSaturation;\nuniform float toneMappingAperture;\nuniform float toneMappingShutter;\nuniform float toneMappingISO;\nuniform float toneMappingVignetting;\nuniform vec2 toneMappingResolution;\nconst float FILMIC_BLENDER_LOG_MIN = -12.473931188;\nconst float FILMIC_BLENDER_LOG_MAX = 12.526068812;\nconst float FILMIC_BLENDER_EXPOSURE_LATITUDE_RATIO = 0.66;\nvec3 LinearToneMapping(vec3 color) {\nreturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\nreturn saturate(color / (vec3(1.0) + color));\n}\n#define Uncharted2Helper(x) max(((x * (0.15 * x + 0.10 * 0.50) + 0.20 * 0.02) / (x * (0.15 * x + 0.50) + 0.20 * 0.30)) - 0.02 / 0.30, vec3(0.0))\nvec3 Uncharted2ToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\nreturn saturate(Uncharted2Helper(color) / Uncharted2Helper(vec3(toneMappingWhitePoint)));\n}\nvec3 OptimizedCineonToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\ncolor = max(vec3(0.0), color - 0.004);\nreturn pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));\n}\nvec3 ACESFilmicToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\nreturn saturate((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14));\n}\n#define ORDERS_OF_MAG 5.0\nfloat toneCalcBrightness(in vec3 color)\n{\nreturn (abs(color.r) * 0.263 + abs(color.g) * 0.655 + abs(color.b) * 0.082);\n}\nfloat toneApproximateScotopicLuminance(vec3 color)\n{\nreturn (0.062 * color.r + 0.608 * color.g + 0.330 * color.b);\n}\nvec3 LogarithmicMaxToneMapping(vec3 color) {\nfloat inputScaleFactor = toneMappingPhysicalScale / PI;\nfloat brightness = (toneMappingBrightness < 0.0) ? 0.0 : (toneMappingBrightness * 0.7);\nfloat powerBot = toneMappingExteriorDaylight ? 4.0 : 2.0;\nfloat res = 100.0 / ORDERS_OF_MAG;\nfloat mag = floor((50.0 / res));\nfloat power = ((brightness / 20.0 - ORDERS_OF_MAG) - powerBot) + mag;\nfloat stepsize = 9.0 / res;\nfloat step = 50.0 - (mag * res);\nfloat param_c = (0.02 * toneMappingContrast) * 2.0;\nfloat param_b = pow(10.0, power) * (1.0 + (stepsize * step));\nfloat param_a = param_b * (1.0 + param_c);\nparam_c /= pow(2.0, toneMappingMidTones - 1.0);\nparam_b *= PI;\nvec3 whiteConstancyFactor = toneMappingWhiteColor;\nif (toneMappingChromaticAdaptation) {\nfloat luminance = toneCalcBrightness(whiteConstancyFactor);\nwhiteConstancyFactor.r = (whiteConstancyFactor.r > 0.001) ? luminance / whiteConstancyFactor.r : luminance / 0.001;\nwhiteConstancyFactor.g = (whiteConstancyFactor.g > 0.001) ? luminance / whiteConstancyFactor.g : luminance / 0.001;\nwhiteConstancyFactor.b = (whiteConstancyFactor.b > 0.001) ? luminance / whiteConstancyFactor.b : luminance / 0.001;\n}\nvec3 outColor = inputScaleFactor * color;\nif (toneMappingChromaticAdaptation) {\noutColor *= whiteConstancyFactor.rgb;\n}\nfloat luminance = toneCalcBrightness(outColor);\nif (toneMappingColorDifferentiation && (luminance < 5.62)) {\nfloat sLuminance = toneApproximateScotopicLuminance(outColor);\nif (luminance <= 5.62e-3) {\noutColor = vec3(sLuminance);\n} else {\nfloat w = (luminance - 5.62e-3) / 5.61438;\noutColor = outColor * w + sLuminance * (1.0 - w);\n}\n}\noutColor = outColor * (param_a / (param_b * outColor + param_c));\nreturn outColor;\n}\nfloat maxExposurePhotographic(in vec4 color1, in vec4 color2)\n{\nreturn ((color1.r * color2.r) + (color1.g * color2.g)) + (color1.b * color2.b);\n}\nvec3 PhysicalMaxToneMapping(vec3 color) {\nfloat vignettingInfluence = 1.0;\nif (toneMappingVignetting > 0.0) {\nvec3 vignettingCoords = vec3(0.0, 0.0, 0.0);\nfloat aspect = toneMappingResolution.x / toneMappingResolution.y;\nvignettingCoords.x = gl_FragCoord.x / toneMappingResolution.x - 0.5;\nvignettingCoords.y = (gl_FragCoord.y / toneMappingResolution.y - 0.5) / aspect;\nvignettingCoords.z = 1.0;\nvignettingCoords = normalize(vignettingCoords);\nvignettingInfluence = pow(vignettingCoords.z, toneMappingVignetting);\n}\nfloat inputScaleFactor = toneMappingPhysicalScale / PI;\nfloat filmISO = toneMappingISO;\nfloat camShutter = 1.0 / toneMappingShutter;\nfloat fNumber = toneMappingAperture;\nfloat cm2 = 1.0;\nfloat burnHighlights = toneMappingHighlights;\nfloat crushBlacks = toneMappingShadows;\nfloat saturation = toneMappingSaturation;\nvec3 whitePointInfluence = toneMappingWhiteBalance;\nif (whitePointInfluence.r > 0.0) {\nwhitePointInfluence.r = 1.0 / whitePointInfluence.r;\n} else {\nwhitePointInfluence.r = 1.0;\n}\nif (whitePointInfluence.g > 0.0) {\nwhitePointInfluence.g = 1.0 / whitePointInfluence.g;\n} else {\nwhitePointInfluence.g = 1.0;\n}\nif (whitePointInfluence.b > 0.0) {\nwhitePointInfluence.b = 1.0 / whitePointInfluence.b;\n} else {\nwhitePointInfluence.b = 1.0;\n}\nvec4 lumFactor = vec4(0.212671, 0.715160, 0.072169, 0.0);\nfloat whiteLumFactor = maxExposurePhotographic(lumFactor, vec4(whitePointInfluence, 0.0));\nwhitePointInfluence.r /= whiteLumFactor;\nwhitePointInfluence.g /= whiteLumFactor;\nwhitePointInfluence.b /= whiteLumFactor;\nfloat isoInfluence = 0.0;\nfloat camShutterInv = 1.0 / camShutter;\nif (filmISO > 0.0) {\nisoInfluence = ((cm2 * 0.169811) * (filmISO * camShutterInv)) / ((15.4 * fNumber) * fNumber);\n} else {\nisoInfluence = cm2;\n}\nvec3 outColor = inputScaleFactor * color;\noutColor.r = outColor.r * whitePointInfluence.r * isoInfluence * vignettingInfluence;\noutColor.g = outColor.g * whitePointInfluence.g * isoInfluence * vignettingInfluence;\noutColor.b = outColor.b * whitePointInfluence.b * isoInfluence * vignettingInfluence;\noutColor.r = (outColor.r * (1.0 + (outColor.r * burnHighlights))) / (1.0 + outColor.r);\noutColor.g = (outColor.g * (1.0 + (outColor.g * burnHighlights))) / (1.0 + outColor.g);\noutColor.b = (outColor.b * (1.0 + (outColor.b * burnHighlights))) / (1.0 + outColor.b);\nfloat lumFactor2 = maxExposurePhotographic(lumFactor, vec4(outColor, 0.0));\nfloat tmpFloat = 1.0 - saturation;\noutColor.r = outColor.r * saturation + lumFactor2 * tmpFloat;\noutColor.g = outColor.g * saturation + lumFactor2 * tmpFloat;\noutColor.b = outColor.b * saturation + lumFactor2 * tmpFloat;\noutColor = max(vec3(0.0), outColor);\nfloat crushBlacksFac = crushBlacks * 2.0 + 1.0;\nfloat crushBlacksFac2 = pow(maxExposurePhotographic(lumFactor, vec4(outColor, 0.0)), 0.5);\ntmpFloat = (1.0 - crushBlacksFac2);\nif (crushBlacksFac2 < 1.0) {\noutColor.r = outColor.r * crushBlacksFac2 + pow(outColor.r, crushBlacksFac) * tmpFloat;\noutColor.g = outColor.g * crushBlacksFac2 + pow(outColor.g, crushBlacksFac) * tmpFloat;\noutColor.b = outColor.b * crushBlacksFac2 + pow(outColor.b, crushBlacksFac) * tmpFloat;\n}\nreturn outColor;\n}\nfloat filmicBlenderDesaturationMinIntensity(vec3 color) {\nfloat maxChannel = max(color.r, max(color.g, color.b));\nfloat x = max(maxChannel, 0.6251);\nreturn (1.2192868 * x - 0.63221059)\n* ((x - 0.65069831) / (abs(x - 0.65069831) + 0.00952982) + 0.73015231);\n}\nvec3 filmicBlenderDesaturationTransform(vec3 color) {\nconst float CURVE_SMOOTHNESS = 0.03;\nfloat minIntensity = filmicBlenderDesaturationMinIntensity(color);\nvec4 x = vec4(color, 1.0) - minIntensity;\nx = pow(x, vec4(2.0)) / (abs(x) + CURVE_SMOOTHNESS);\nreturn (x.rgb - x.a + color + 1.0) / 2.0;\n}\nvec3 filmicBlenderDynamicRangeTransform(vec3 color) {\nreturn pow(\n(0.28882259 * color - 0.15880336)\n/ (pow(color - 0.6229693, vec3(2.0)) + 0.16965022)\n+ 0.20453365 * color + 0.37847142,\nvec3(3.0)\n);\n}\nvec3 FilmicBlenderToneMapping(vec3 color) {\ncolor *= toneMappingExposure;\ncolor = max(color, 0.000175);\ncolor = clamp((log2(color) - FILMIC_BLENDER_LOG_MIN)\n/ (FILMIC_BLENDER_LOG_MAX - FILMIC_BLENDER_LOG_MIN), 0.0, 1.0);\ncolor = filmicBlenderDesaturationTransform(color);\ncolor = clamp(color / FILMIC_BLENDER_EXPOSURE_LATITUDE_RATIO, 0.0, 1.0);\ncolor = filmicBlenderDynamicRangeTransform(color);\nreturn color;\n}",
            uv_pars_fragment: "#if (defined(USE_UV) && !defined(UVS_VERTEX_ONLY))\nvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n#ifdef UVS_VERTEX_ONLY\nvec2 vUv;\n#else\nvarying vec2 vUv;\n#endif\nuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\nvUv = (uvTransform * vec3(uv, 1)).xy;\n#endif",
            uv2_pars_fragment: "#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)\nvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)\nattribute vec2 uv2;\nvarying vec2 vUv2;\nuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined(USE_LIGHTMAP) || defined(USE_AOMAP)\nvUv2 = (uv2Transform * vec3(uv2, 1)).xy;\n#endif",
            worldpos_vertex: "#if defined(USE_ENVMAP) || defined(DISTANCE) || defined (USE_SHADOWMAP) || defined(MASK) || defined(NODE)\nvec4 worldPosition = vec4(transformed, 1.0);\n#ifdef USE_INSTANCING\nworldPosition = instanceMatrix * worldPosition;\n#endif\nworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\nvec4 texColor = texture2D(t2D, vUv);\ngl_FragColor = mapTexelToLinear(texColor);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\nvUv = (uvTransform * vec3(uv, 1)).xy;\ngl_Position = vec4(position.xy, 1.0, 1.0);\n}",
            cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\nvec3 vReflect = vWorldDirection;\n#include <envmap_fragment>\ngl_FragColor = envColor;\ngl_FragColor.a *= opacity;\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\nvWorldDirection = transformDirection(position, modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\ngl_Position.z = gl_Position.w;\n}",
            depth_frag: "#define DEPTH\nvarying vec3 vViewPosition;\nvarying vec2 vProjectedPosZW;\n#if DEPTH_PACKING == 3200\nuniform float opacity;\n#endif\n#ifdef USE_SLOPE_SCALED_BIAS\nuniform float slopeScaledBias;\nconst float ONE_MINUS_EPS = 0.9999999;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(1.0);\n#if DEPTH_PACKING == 3200\ndiffuseColor.a = opacity;\n#endif\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\n#if DEPTH_PACKING != 3202\nfloat depth = vProjectedPosZW.x / vProjectedPosZW.y;\ndepth = (depth + 1.0) / 2.0;\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy = abs(vec2(dFdx(depth), dFdy(depth)));\nfloat bias = slopeScaledBias * max(dxdy.x, dxdy.y);\ndepth = clamp(depth + max(bias, 1e-7), 0.0, ONE_MINUS_EPS);\n#endif\n#if DEPTH_PACKING == 3200\ngl_FragColor = vec4(vec3(1.0 - depth), opacity);\n#elif DEPTH_PACKING == 3201\ngl_FragColor = packDepthToRGBA(depth);\n#endif\n#else\ngl_FragColor = vec4(vViewPosition.z);\n#endif\n}",
            depth_vert: "#define DEPTH\nvarying vec3 vViewPosition;\nvarying vec2 vProjectedPosZW;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = mvPosition.xyz;\nvProjectedPosZW = mat2(\nprojectionMatrix[2][2], projectionMatrix[2][3],\nprojectionMatrix[3][2], projectionMatrix[3][3]\n) * mvPosition.zw;\n}",
            distanceRGBA_frag: "#define DISTANCE\n#ifdef USE_SLOPE_SCALED_BIAS\nuniform float slopeScaledBias;\nconst float ONE_MINUS_EPS = 0.9999999;\n#endif\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(1.0);\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\nfloat dist = length(vWorldPosition - referencePosition);\n#if DISTANCE_PACKING == 3301\ndist = (dist - nearDistance) / (farDistance - nearDistance);\ndist = saturate(dist);\n#ifdef USE_SLOPE_SCALED_BIAS\nvec2 dxdy = abs(vec2(dFdx(dist), dFdy(dist)));\nfloat bias = slopeScaledBias * max(dxdy.x, dxdy.y);\ndist = clamp(dist + bias, 0.0, ONE_MINUS_EPS);\n#endif\ngl_FragColor = packDepthToRGBA(dist);\n#elif DISTANCE_PACKING == 3302\ngl_FragColor = vec4(dist, 0.0, 0.0, 1.0);\n#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <clipping_planes_vertex>\nvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nuniform bool invertU;\nuniform float offsetU;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\nvec3 direction = normalize(vWorldDirection);\nvec2 sampleUV;\nsampleUV.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;\n\nif (invertU) {\nsampleUV.x = 1.0 - sampleUV.x;\n}\n\nsampleUV.x += offsetU;\nvec4 texColor = texture2D(tEquirect, sampleUV);\ngl_FragColor = mapTexelToLinear(texColor);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\nvWorldDirection = transformDirection(position, modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nif (mod(vLineDistance, totalSize) > dashSize) {\ndiscard;\n}\nvec3 outgoingLight = vec3(0.0);\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <color_fragment>\noutgoingLight = diffuseColor.rgb;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <color_vertex>\nvLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\ngl_Position = projectionMatrix * mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#ifdef USE_LIGHTMAP\n\nvec4 lightMapTexel= texture2D(lightMap, vUv2);\nreflectedLight.indirectDiffuse += lightMapTexelToLinear(lightMapTexel).rgb * lightMapIntensity;\n#else\nreflectedLight.indirectDiffuse += vec3(1.0);\n#endif\n#include <aomap_fragment>\nreflectedLight.indirectDiffuse *= diffuseColor.rgb;\nvec3 outgoingLight = reflectedLight.indirectDiffuse;\n#include <envmap_fragment>\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <skinbase_vertex>\n#ifdef USE_ENVMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <worldpos_vertex>\n#include <clipping_planes_vertex>\n#include <envmap_vertex>\n#include <fog_vertex>\n}",
            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\nvarying vec3 vIndirectBack;\n#endif\nvarying vec3 vViewPosition;\n#ifdef SHADOWMAP_TYPE_ESM\nuniform mat4 invViewMatrix;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 totalEmissiveRadiance = emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\n#include <emissivemap_fragment>\nreflectedLight.indirectDiffuse = getAmbientLightIrradiance(ambientLightColor);\n#ifdef DOUBLE_SIDED\nreflectedLight.indirectDiffuse += (gl_FrontFacing) ? vIndirectFront : vIndirectBack;\n#else\nreflectedLight.indirectDiffuse += vIndirectFront;\n#endif\n#include <lightmap_fragment>\nreflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert(diffuseColor.rgb);\n#ifdef DOUBLE_SIDED\nreflectedLight.directDiffuse = (gl_FrontFacing) ? vLightFront : vLightBack;\n#else\nreflectedLight.directDiffuse = vLightFront;\n#endif\nreflectedLight.directDiffuse *= BRDF_Diffuse_Lambert(diffuseColor.rgb) * getShadowMask();\n#include <aomap_fragment>\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n#include <envmap_fragment>\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\nvarying vec3 vIndirectBack;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = - mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <lights_lambert_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\nvec3 viewDir = normalize(vViewPosition);\nvec3 x = normalize(vec3(viewDir.z, 0.0, - viewDir.x));\nvec3 y = cross(viewDir, x);\nvec2 uv = vec2(dot(x, normal), dot(y, normal)) * 0.495 + 0.5;\n#ifdef USE_MATCAP\nvec4 matcapColor = texture2D(matcap, uv);\nmatcapColor = matcapTexelToLinear(matcapColor);\n#else\nvec4 matcapColor = vec4(1.0);\n#endif\nvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\nvViewPosition = - mvPosition.xyz;\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 totalEmissiveRadiance = emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_toon_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = - mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#ifdef SHADOWMAP_TYPE_ESM\nuniform mat4 invViewMatrix;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 totalEmissiveRadiance = emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_phong_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#include <envmap_fragment>\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = - mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n#define REFLECTIVITY\n#define CLEARCOAT\n#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\nuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\nuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheen;\n#endif\n#ifdef SHADOWMAP_TYPE_ESM\nuniform mat4 invViewMatrix;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(diffuse, opacity);\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\nvec3 totalEmissiveRadiance = emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n#ifdef TRANSPARENCY\ndiffuseColor.a *= saturate(1. - transparency + linearToRelativeLuminance(reflectedLight.directSpecular + reflectedLight.indirectSpecular));\n#endif\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#ifdef USE_TANGENT\nvTangent = normalize(transformedTangent);\nvBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n#endif\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = - mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\ngl_FragColor = vec4(packNormalToRGB(normal), opacity);\n}",
            normal_vert: "#define NORMAL\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#ifdef USE_TANGENT\nvTangent = normalize(transformedTangent);\nvBitangent = normalize(cross(vNormal, vTangent) * tangent.w);\n#endif\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(TANGENTSPACE_NORMALMAP)\nvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec3 outgoingLight = vec3(0.0);\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_particle_fragment>\n#include <color_fragment>\n#include <alphatest_fragment>\noutgoingLight = diffuseColor.rgb;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <color_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\ngl_PointSize = size;\n#ifdef USE_SIZEATTENUATION\nbool isPerspective = isPerspectiveMatrix(projectionMatrix);\nif (isPerspective) gl_PointSize *= (scale / - mvPosition.z);\n#endif\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#ifdef USE_SHADOWMAP\nvarying vec3 vViewPosition;\n#ifdef SHADOWMAP_TYPE_ESM\nuniform mat4 invViewMatrix;\n#endif\n#endif\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\ngl_FragColor = vec4(color, opacity * (1.0 - getShadowMask()));\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}",
            shadow_vert: "#ifdef USE_SHADOWMAP\nvarying vec3 vViewPosition;\n#endif\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n#include <begin_vertex>\n#include <project_vertex>\n#ifdef USE_SHADOWMAP\nvViewPosition = - mvPosition.xyz;\n#endif\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n#include <clipping_planes_fragment>\nvec3 outgoingLight = vec3(0.0);\nvec4 diffuseColor = vec4(diffuse, opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\noutgoingLight = diffuseColor.rgb;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n#include <uv_vertex>\nvec4 mvPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\nvec2 scale;\nscale.x = length(vec3(modelMatrix[0].x, modelMatrix[0].y, modelMatrix[0].z));\nscale.y = length(vec3(modelMatrix[1].x, modelMatrix[1].y, modelMatrix[1].z));\n#ifndef USE_SIZEATTENUATION\nbool isPerspective = isPerspectiveMatrix(projectionMatrix);\nif (isPerspective) scale *= - mvPosition.z;\n#endif\nvec2 alignedPosition = (position.xy - (center - vec2(0.5))) * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\nrotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\nmvPosition.xy += rotatedPosition;\ngl_Position = projectionMatrix * mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}",
            equicube_frag: "uniform sampler2D tEquirect;\nuniform int faceIndex;\nuniform bool invertU;\nuniform float offsetU;\nvarying vec2 vUv;\n#include <common>\nvoid main() {\nvec3 direction;\nvec2 uv = vUv * 2.0 - 1.0;\nif (faceIndex==0) {\ndirection = vec3(1.0, -uv.y, -uv.x);\n} else if (faceIndex==1) {\ndirection = vec3(-1.0, -uv.y, uv.x);\n} else if (faceIndex==2) {\ndirection = vec3(uv.x, 1.0, uv.y);\n} else if (faceIndex==3) {\ndirection = vec3(uv.x, -1.0, -uv.y);\n} else if (faceIndex==4) {\ndirection = vec3(uv.x, -uv.y, 1.0);\n} else {\ndirection = vec3(-uv.x, -uv.y, -1.0);\n}\ndirection = normalize(direction);\nvec2 sampleUV;\nsampleUV.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nsampleUV.x = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;\nif (invertU) {\nsampleUV.x = 1.0 - sampleUV.x;\n}\n\nsampleUV.x += offsetU;\ngl_FragColor = texture2D(tEquirect, sampleUV);\n}",
            equicube_vert: "varying vec2 vUv;\n#include <common>\nvoid main() {\nvUv = uv;\n#include <begin_vertex>\n#include <project_vertex>\n}",
            mask_frag: "#define MASK\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nuniform mat4 projectionMatrix;\nuniform float opacity;\nuniform sampler2D depthTexture;\nuniform vec2 cameraNearFar;\nvarying vec3 vViewPosition;\nvarying vec4 projTexCoord;\nvoid main() {\n#include <clipping_planes_fragment>\nvec4 diffuseColor = vec4(1.0);\ndiffuseColor.a = opacity;\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\nfloat depth = unpackRGBAToDepth(texture2DProj(depthTexture, projTexCoord));\nfloat viewZ;\nif (isOrtho(projectionMatrix))\nviewZ = -orthographicDepthToViewZ(depth,\ncameraNearFar.x, cameraNearFar.y);\nelse\nviewZ = -perspectiveDepthToViewZ(depth,\ncameraNearFar.x, cameraNearFar.y);\nfloat depthTest = (vViewPosition.z > viewZ) ? 1.0 : 0.0;\ngl_FragColor = vec4(0.0, depthTest, 1.0, 0.0);\n}",
            mask_vert: "#define MASK\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nuniform mat4 textureMatrix;\nvarying vec3 vViewPosition;\nvarying vec4 projTexCoord;\nvoid main() {\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\nvViewPosition = -mvPosition.xyz;\n#include <worldpos_vertex>\nprojTexCoord = textureMatrix * worldPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n}",
            meshnode_frag: "#define NODE\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_node_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#if defined(NODE_GEOMETRY_BL) || defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_TEX_COORD_BL) || defined(NODE_MATERIAL_BL) || defined(NODE_MATERIAL_EXT_BL) || defined(NODE_NORMAL_MAP_BL) || defined(NODE_LAYER_WEIGHT_BL) || defined(NODE_FRESNEL_BL) || defined(NODE_BUMP_BL) || defined(NODE_BSDF_GLASS_BL) || defined(NODE_BSDF_PRINCIPLED_BL) || defined(SHADOWMAP_TYPE_ESM) && (defined(NODE_BSDF_DIFFUSE_BL) || defined(NODE_BSDF_GLOSSY_BL) || defined(NODE_BSDF_REFRACTION_BL) || defined(NODE_MATERIAL_MX) || defined(NODE_PHYSICAL_MX)) || defined(NODE_BITMAP_MX) || defined(NODE_GRADIENT_RAMP_MX)\nuniform mat4 invViewMatrix;\n#endif\n#if defined(NODE_GEOMETRY_BL) || defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_LAYER_WEIGHT_BL) || defined(NODE_FRESNEL_BL) || defined(NODE_BSDF_GLASS_BL) || defined(NODE_BSDF_PRINCIPLED_BL) || defined(USE_SSR)\nuniform mat4 projectionMatrix;\n#endif\n#if defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_TEX_COORD_BL) || defined(NODE_NEW_GEOMETRY_BL) || defined(NODE_BITMAP_MX) || defined(NODE_GRADIENT_RAMP_MX)\nuniform mat4 modelMatrix;\nuniform mat4 invModelMatrix;\n#endif\n#if defined(NODE_VECT_TRANSFORM_BL) || defined(NODE_NORMAL_MAP_BL) || defined(NODE_NORMAL_BUMP_MX) || defined(NODE_MATERIAL_GF)\nuniform mat4 modelViewMatrix;\n#endif\n#if defined(NODE_TEX_IMAGE_BL)\nuniform mat3 normalMatrix;\n#endif\n#if defined(NODE_TEX_COORD_BL) || defined(NODE_NEW_GEOMETRY_BL)\nuniform vec3 boundingBoxMin;\nuniform vec3 boundingBoxMax;\n#endif\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_AI_SKYDOME_LIGHT_MY)\nvarying vec3 vWorldPosition;\n#endif\n#if defined(NODE_TEX_COORD_BL)\nuniform vec2 viewWidthHeight;\n#endif\n#include <ssr_pars_fragment>\n#include <node_common_frag>\n#include <node_pars_fragment>\nvoid main() {\nbool _frontFacingValue = gl_FrontFacing;\n#define FRONT_FACING_VALUE _frontFacingValue\n#include <clipping_planes_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\nvec4 outgoingLight = vec4(0.0);\n#include <node_fragment>\n#if WORLD_NODES == 1\noutgoingLight.a = 1.0;\n#endif\n#ifdef ALPHATEST\nif (outgoingLight.a < ALPHATEST)\ndiscard;\nelse\noutgoingLight.a = 1.0;\n#endif\ngl_FragColor = vec4(outgoingLight);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
            meshnode_vert: "#define NODE\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_AI_SKYDOME_LIGHT_MY)\nvarying vec3 vWorldPosition;\n#endif\n#include <node_pars_vertex>\nvoid main() {\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\nvNormal = normalize(transformedNormal);\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition = - mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_BUMP_BL) || defined(NODE_PHY_SUN_SKY_ENV_MX) || defined(NODE_AI_SKYDOME_LIGHT_MY)\nvWorldPosition = worldPosition.xyz;\n#endif\n#include <node_vertex>\n}",
            lights_node_pars_fragment: "\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\nstruct NodeMaterial {\nvec3    diffuseColor;\nvec3    specularColor;\nvec3    refractionColor;\nfloat   refractionRoughness;\nfloat   refractionIOR;\n#ifdef CLEARCOAT\nfloat clearcoat;\nfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nvec3 sheenColor;\n#endif\n#ifdef PHYSICAL\nvec3 fresnelRefl90;\nfloat specularRoughness;\n#else\nfloat   diffuseIntensity;\nfloat   specularIntensity;\nfloat   specularHardness;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n#define BLENDER_SPECULAR_COEFFICIENT 0.08\nfloat shadeSpecPhong(vec3 normal, vec3 lightDir, vec3 viewDir, float hard)\n{\nfloat specFac;\nvec3 h = normalize(lightDir + viewDir);\nfloat rslt = max(dot(h, normal), 0.0);\nspecFac = pow(rslt, hard);\nreturn specFac;\n}\nfloat shadeSpecHemi(vec3 normal, vec3 lightDir, vec3 viewDir, float hard)\n{\nfloat specFac;\nvec3 h = normalize(lightDir + viewDir);\nfloat rslt = 0.5 * max(dot(h, normal), 0.0) + 0.5;\nspecFac = pow(rslt, hard);\nreturn specFac;\n}\nfloat clearcoatDHRApprox(const in float roughness, const in float dotNL) {\nreturn DEFAULT_SPECULAR_COEFFICIENT + (1.0 - DEFAULT_SPECULAR_COEFFICIENT) * (pow(1.0 - dotNL, 5.0) * pow(1.0 - roughness, 2.0));\n}\n#if NUM_RECT_AREA_LIGHTS > 0\nvoid RE_Direct_RectArea_Node(const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {\nvec3 normal = geometry.normal;\nvec3 viewDir = geometry.viewDir;\nvec3 position = geometry.position;\nvec3 lightPos = rectAreaLight.position;\nvec3 halfWidth = rectAreaLight.halfWidth;\nvec3 halfHeight = rectAreaLight.halfHeight;\nvec3 lightColor = rectAreaLight.color;\nfloat roughness = material.specularRoughness;\nvec3 rectCoords[4];\nrectCoords[0] = lightPos + halfWidth - halfHeight;\nrectCoords[1] = lightPos - halfWidth - halfHeight;\nrectCoords[2] = lightPos - halfWidth + halfHeight;\nrectCoords[3] = lightPos + halfWidth + halfHeight;\nvec2 uv = LTC_Uv(normal, viewDir, roughness);\nvec4 t1 = texture2D(ltc_1, uv);\nvec4 t2 = texture2D(ltc_2, uv);\nmat3 mInv = mat3(\nvec3(t1.x, 0, t1.y),\nvec3(   0, 1,    0),\nvec3(t1.z, 0, t1.w)\n);\nvec3 fresnel = (material.specularColor * t2.x + (vec3(1.0) - material.specularColor) * t2.y);\nreflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate(normal, viewDir, position, mInv, rectCoords);\nreflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate(normal, viewDir, position, mat3(1.0), rectCoords);\n}\n#endif\nvoid RE_Direct_Node(const in IncidentLight directLight, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {\nfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\nvec3 irradiance = dotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance *= PI;\n#endif\n#ifdef PHYSICAL\n#ifdef CLEARCOAT\nfloat ccDotNL = saturate(dot(geometry.clearcoatNormal, directLight.direction));\nvec3 ccIrradiance = ccDotNL * directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nccIrradiance *= PI;\n#endif\n#endif\n#ifdef CLEARCOAT\nfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox(material.clearcoatRoughness, ccDotNL);\n#else\nfloat clearcoatDHR = 0.0;\n#endif\nreflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance\n* BRDF_Specular_GGX(directLight, geometry.viewDir, geometry.normal,\nmaterial.specularColor, material.specularRoughness);\nreflectedLight.directDiffuse += (1.0 - clearcoatDHR) * irradiance\n* BRDF_Diffuse_Lambert(material.diffuseColor);\n#ifdef CLEARCOAT\nreflectedLight.directSpecular += ccIrradiance * material.clearcoat\n* BRDF_Specular_GGX(directLight, geometry.viewDir, geometry.clearcoatNormal,\nvec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearcoatRoughness);\n#endif\n#else\nreflectedLight.directDiffuse += irradiance * material.diffuseIntensity * BRDF_Diffuse_Lambert(material.diffuseColor);\nreflectedLight.directSpecular += material.specularIntensity *\nshadeSpecPhong(geometry.normal, directLight.direction,\ngeometry.viewDir, material.specularHardness) *\ndirectLight.color * material.specularColor;\n#endif\n}\nvoid RE_IndirectDiffuse_Node(const in vec3 irradiance, const in GeometricContext geometry, const in NodeMaterial material, inout ReflectedLight reflectedLight) {\nreflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\n#ifdef PHYSICAL\nvoid RE_IndirectSpecular_Node(const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance,\nconst in GeometricContext geometry, const in NodeMaterial material,\ninout ReflectedLight reflectedLight) {\n#ifdef CLEARCOAT\nfloat ccDotNL = saturate(dot(geometry.clearcoatNormal, geometry.viewDir));\nfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox(\nmaterial.clearcoatRoughness, ccDotNL);\n#else\nfloat clearcoatDHR = 0.0;\n#endif\n#ifdef MT_BLENDER\nvec3 specEnv = BRDF_Specular_GGX_Environment_Blender_Approx(geometry,\nmaterial.specularColor, material.fresnelRefl90, material.specularRoughness, 0);\n#elif defined(MT_MAX)\nfloat alphaEnv = pow2(pow2(material.specularRoughness));\nvec3 specEnv = material.specularColor / (1.0 - alphaEnv + PI * alphaEnv);\n#elif defined(MT_MAYA)\nvec3 specEnv = BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n#else\nvec3 specEnv = vec3(1.0);\n#endif\nreflectedLight.indirectSpecular += (1.0 - clearcoatDHR) * radiance * specEnv;\n#ifdef CLEARCOAT\n#ifdef MT_BLENDER\nvec3 specEnvCC = BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.clearcoatNormal, vec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearcoatRoughness);\n#elif defined(MT_MAX)\nvec3 specEnvCC = BRDF_Specular_GGX_Environment(geometry.viewDir, geometry.clearcoatNormal, vec3(DEFAULT_SPECULAR_COEFFICIENT), material.clearcoatRoughness);\n#else\nvec3 specEnvCC = vec3(1.0);\n#endif\nreflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * specEnvCC;\n#endif\nreflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\n#else\n#if defined(MT_BLENDER) && NUM_HEMI_LIGHTS > 0\nvoid RE_HemiSpec_Blender(const in HemisphereLight hemiLight,\nconst in GeometricContext geometry, const in NodeMaterial material,\ninout ReflectedLight reflectedLight)\n{\nreflectedLight.indirectSpecular += material.specularIntensity *\nshadeSpecHemi(geometry.normal, hemiLight.direction,\ngeometry.viewDir, material.specularHardness) *\nhemiLight.skyColor * material.specularColor;\n}\n#endif\n#endif\nvoid RE_Refraction_Node(const vec3 refraction, const NodeMaterial material,\ninout vec3 refractedLight) {\nrefractedLight += refraction * material.refractionColor;\n}\n#ifdef MT_BLENDER\n#define Material_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.specularRoughness)\n#define Material_Refraction_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.refractionRoughness)\n#elif defined(MT_MAX)\n#define Material_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.specularRoughness * exp(0.35*(1.0-pow2(material.specularRoughness))))\n#define Material_Refraction_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.refractionRoughness * exp(0.35*(1.0-pow2(material.refractionRoughness))))\n#else\n#define Material_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.specularRoughness)\n#define Material_Refraction_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.refractionRoughness)\n#endif\n#define Material_ClearCoat_BlinnShininessExponent(material)   GGXRoughnessToBlinnExponent(material.clearcoatRoughness)\nfloat computeSpecularOcclusion(const in float dotNV, const in float ambientOcclusion, const in float roughness) {\nreturn saturate(pow(abs(dotNV + ambientOcclusion), exp2(- 16.0 * roughness - 1.0)) - 1.0 + ambientOcclusion);\n}\n#define RE_Direct           RE_Direct_Node\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_Node\n#define RE_Direct_RectArea  RE_Direct_RectArea_Node\n#ifdef PHYSICAL\n#define RE_IndirectSpecular RE_IndirectSpecular_Node\n#endif\n#define RE_Refraction RE_Refraction_Node",
            ssr_pars_fragment: "#ifdef USE_SSR\nuniform sampler2D ssrSourceBuffer;\nuniform sampler2D ssrDepthBuffer;\nuniform sampler2D ssrBackfaceDepthBuffer;\nuniform mat4 invProjectionMatrix;\nuniform vec2 ssrResolution;\nuniform float ssrThickness;\nuniform float ssrStride;\nuniform float ssrJitter;\nuniform float ssrMaxDistance;\n#ifdef USE_SSR_REFRACT\n#define STEPS_FADE_AMOUNT 0.1\n#define SCREEN_FADE_THRESHOLD 0.6\n#else\n#define STEPS_FADE_AMOUNT 1.0\n#define SCREEN_FADE_THRESHOLD 0.4\n#endif\nvec3 deproject(vec3 p) {\nvec4 res = invProjectionMatrix * vec4(p, 1);\nreturn res.xyz / res.w;\n}\nbool doesIntersect(float rayzmax, float rayzmin, vec2 uv) {\nfloat sceneZMin = texture2D(ssrDepthBuffer, uv).r;\n#ifdef USE_SSR_REFRACT\nreturn rayzmin >= (sceneZMin-ssrThickness) && rayzmax <= sceneZMin;\n#else\nfloat sceneZMax = texture2D(ssrBackfaceDepthBuffer, uv).r;\nreturn rayzmin >= sceneZMax && rayzmax <= sceneZMin;\n#endif\n}\nfloat distanceSquared(vec2 a, vec2 b) { a -= b; return dot(a, a); }\nvoid swapIfBigger(inout float a, inout float b) {\nif (a > b) {\nfloat t = a;\na = b;\nb = t;\n}\n}\nbool isOutsideUvBounds(float x) { return x < 0.0 || x > 1.0; }\nbool isOutsideUvBounds(vec2 uv) { return isOutsideUvBounds(uv.x) || isOutsideUvBounds(uv.y); }\nvec3 computeSSR(vec3 color, vec3 normal, float ior) {\nvec2 uv = gl_FragCoord.xy / ssrResolution;\nvec2 screenCoord = uv * 2.0 - vec2(1, 1);\nfloat nearClip = deproject(vec3(0, 0, -1)).z;\nvec3 ray = deproject(vec3(screenCoord, -1));\nray /= ray.z;\nfloat depthSample = -vViewPosition.z;\nvec3 vpos = depthSample * ray;\n#ifdef USE_SSR_REFRACT\nvec3 dir = normalize(refract(normalize(vpos), normalize(normal), 1.0/ior));\n#else\nvec3 dir = normalize(reflect(normalize(vpos), normalize(normal)));\n#endif\nfloat maxDist = ssrMaxDistance;\nfloat rayLength = (vpos.z + dir.z * maxDist) > nearClip ? (nearClip - vpos.z) / dir.z : maxDist;\nvec3 csOrig = vpos;\nvec3 csEndPoint = csOrig + dir * rayLength;\nvec4 H0 = projectionMatrix * vec4(csOrig, 1.0);\nvec4 H1 = projectionMatrix * vec4(csEndPoint, 1.0);\nfloat k0 = 1.0 / H0.w, k1 = 1.0 / H1.w;\nvec3 Q0 = csOrig.xyz * k0, Q1 = csEndPoint.xyz * k1;\nvec2 P0 = H0.xy * k0, P1 = H1.xy * k1;\nP0 = P0 * 0.5 + vec2(0.5), P1 = P1 * 0.5 + vec2(0.5);\n#ifndef SSR_SIMPLE_REFRACT\nP0 *= ssrResolution, P1 *= ssrResolution;\nP1 += vec2((distanceSquared(P0, P1) < 0.0001) ? 0.01 : 0.0);\nvec2 delta = P1 - P0;\nbool permute = false;\nif (abs(delta.x) < abs(delta.y)) {\npermute = true; delta = delta.yx; P0 = P0.yx; P1 = P1.yx;\n}\nfloat stepDir = sign(delta.x);\nfloat invdx = stepDir / delta.x;\nvec3 dQ = (Q1 - Q0) * invdx;\nfloat dk = (k1 - k0) * invdx;\nvec2 dP = vec2(stepDir, delta.y * invdx);\nfloat pixelStride = ssrStride;\nfloat jitterMod = (gl_FragCoord.x + gl_FragCoord.y) * 0.25;\nvec4 PQK = vec4(P0, Q0.z, k0);\nvec4 dPQK = vec4(dP, dQ.z, dk);\ndPQK *= pixelStride;\nPQK += dPQK * mod(jitterMod, 1.0) * ssrJitter;\nfloat end = P1.x * stepDir;\nfloat prevZMaxEstimate = PQK.z / PQK.w;\nfloat rayZMin = prevZMaxEstimate, rayZMax = prevZMaxEstimate;\nfloat stepped = 0.0;\nvec2 hitUV;\nbool intersected = false;\nfor (float stepCount = 1.0; stepCount <= float(MAX_STEPS); stepCount ++) {\nPQK += dPQK;\nrayZMin = prevZMaxEstimate;\nrayZMax = (dPQK.z * 0.5 + PQK.z) / (dPQK.w * 0.5 + PQK.w);\nprevZMaxEstimate = rayZMax;\nswapIfBigger(rayZMax, rayZMin);\n\nstepped = stepCount;\nhitUV = (permute ? PQK.yx: PQK.xy) / ssrResolution;\nif (isOutsideUvBounds(hitUV)) break;\nintersected = doesIntersect(rayZMax, rayZMin, hitUV);\nif (intersected || (P0.x * stepDir) > end) break;\n}\nif (intersected && pixelStride > 1.0) {\nPQK -= dPQK;\ndPQK /= ssrStride;\nfloat ogStride = pixelStride * 0.5;\nfloat currStride = pixelStride;\nprevZMaxEstimate = PQK.z / PQK.w;\nrayZMin = prevZMaxEstimate, rayZMax = prevZMaxEstimate;\nfor(int j = 0; j < int(BINARY_SEARCH_ITERATIONS); j ++) {\nPQK += dPQK * currStride;\nrayZMin = prevZMaxEstimate;\nrayZMax = (dPQK.z * 0.5 + PQK.z) / (dPQK.w * 0.5 + PQK.w);\nprevZMaxEstimate = rayZMax;\nswapIfBigger(rayZMax, rayZMin);\nvec2 newUV = (permute ? PQK.yx: PQK.xy) / ssrResolution;\nogStride *= 0.5;\nif (doesIntersect(rayZMax, rayZMin, newUV)) {\nhitUV = newUV;\ncurrStride = -ogStride;\n} else {\ncurrStride = ogStride;\n}\n}\n}\nvec3 result = color;\n#ifdef USE_SSR_REFRACT\n#endif\nif (intersected) {\nvec4 col = texture2D(ssrSourceBuffer, hitUV);\nvec2 ndc = abs(hitUV * 2.0 - 1.0);\nfloat maxndc = max(ndc.x, ndc.y);\nfloat fadeVal =\n(1.0 - (max(0.0, maxndc - SCREEN_FADE_THRESHOLD) / (1.0 - SCREEN_FADE_THRESHOLD))) *\n(1.0 - STEPS_FADE_AMOUNT * (stepped / float(MAX_STEPS)));\ncol.a = fadeVal;\nresult = mix(result, col.rgb, col.a);\n}\n#else\nvec3 result = texture2D(ssrSourceBuffer, P1).xyz;\n#endif\nreturn result;\n}\n#endif",
            node_common_frag: "#define LUMENS_PER_WATT 683.0\n#define MAX_ENV_COORDS_DIR 0\n#define MAX_ENV_COORDS_REFLECT 1\n#define MAX_ENV_COORDS_REFRACT 2\nvec4 nodeTexelToLinear(in vec4 color, in int sourceType) {\nif (sourceType == 1)\nreturn sRGBToLinear(color);\nelse if (sourceType == 2)\nreturn RGBEToLinear(color);\nelse\nreturn color;\n}\n#if defined(NODE_COMBHSV_BL) || defined(NODE_SEPHSV_BL) || defined(NODE_HUE_SAT_BL) || defined(NODE_COLOR_CORRECTION_MX) || defined(NODE_COMPOSITE_LAYER_MX)\n#define HSV_NODES\n#endif\n#ifdef HSV_NODES\nvoid hsvToRGB(vec4 hsv, out vec4 outCol)\n{\nfloat i, f, p, q, t, h, s, v;\nvec3 rgb;\nh = hsv[0];\ns = hsv[1];\nv = hsv[2];\nif (s == 0.0)\nrgb = vec3(v, v, v);\nelse {\nif (h == 1.0)\nh = 0.0;\nh *= 6.0;\ni = floor(h);\nf = h - i;\nrgb = vec3(f, f, f);\np = v * (1.0 - s);\nq = v * (1.0 - (s * f));\nt = v * (1.0 - (s * (1.0 - f)));\nif (i == 0.0)\nrgb = vec3(v, t, p);\nelse if (i == 1.0)\nrgb = vec3(q, v, p);\nelse if (i == 2.0)\nrgb = vec3(p, v, t);\nelse if (i == 3.0)\nrgb = vec3(p, q, v);\nelse if (i == 4.0)\nrgb = vec3(t, p, v);\nelse\nrgb = vec3(v, p, q);\n}\noutCol = vec4(rgb, hsv.w);\n}\nvoid rgbToHSV(vec4 rgb, out vec4 outCol)\n{\nfloat cmax, cmin, h, s, v, cdelta;\nvec3 c;\ncmax = max(rgb[0], max(rgb[1], rgb[2]));\ncmin = min(rgb[0], min(rgb[1], rgb[2]));\ncdelta = cmax - cmin;\nv = cmax;\nif (cmax != 0.0)\ns = cdelta / cmax;\nelse {\ns = 0.0;\nh = 0.0;\n}\nif (s == 0.0)\nh = 0.0;\nelse {\nc = (vec3(cmax, cmax, cmax) - rgb.xyz) / cdelta;\nif (rgb.x == cmax) h = c[2] - c[1];\nelse if (rgb.y == cmax) h = 2.0 + c[0] -  c[2];\nelse h = 4.0 + c[1] - c[0];\nh /= 6.0;\nif (h < 0.0)\nh += 1.0;\n}\noutCol = vec4(h, s, v, rgb.w);\n}\n#endif\nbool isPerspective(const mat4 projMatrix)\n{\nreturn (projMatrix[3][3] == 0.0);\n}\n#if defined(NODE_REFLECT_REFRACT_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_AI_SKYDOME_LIGHT_MY)\nvec4 sampleEquirectangular(sampler2D map, vec3 reflectVec, mat3 uvTransform, int encoding)\n{\nreflectVec = normalize(reflectVec);\nvec2 sampleUV;\nsampleUV.y = asin(clamp(reflectVec.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n#ifdef MT_MAYA\nsampleUV.x = atan(reflectVec.z, reflectVec.x) * RECIPROCAL_PI2 + 0.25;\n#else\nsampleUV.x = atan(reflectVec.x, reflectVec.z) * RECIPROCAL_PI2 + 0.5;\n#endif\nsampleUV.y *= -1.0;\nconst float seamWidth = 0.15;\nconst float seamBiasFactor = -10.0;\nfloat seam = max(0.0, 1.0 - abs (reflectVec.x) / seamWidth) *\nclamp (1.0 - reflectVec.z / seamWidth, 0.0, 1.0);\nsampleUV = (uvTransform * vec3(sampleUV, 1.0)).xy;\nvec4 color = texture2D(map, sampleUV, seamBiasFactor * seam);\ncolor = nodeTexelToLinear(color, encoding);\nreturn color;\n}\n#endif\n#if defined(NODE_FRESNEL_BL) || defined(NODE_LAYER_WEIGHT_BL) || defined(NODE_FALLOFF_MX) || defined(NODE_BSDF_GLASS_BL) || defined(NODE_BSDF_PRINCIPLED_BL)\nfloat fresnelReflection(const vec3 dir, const vec3 normal, const float ior) {\nfloat cosTheta = clamp(abs(dot(dir, normal)), -1.0, 1.0);\nfloat gSquared = pow2(ior) + pow2(cosTheta) - 1.0;\nif (gSquared < 0.0) return 1.0;\nfloat g = sqrt(gSquared);\nreturn 0.5 * pow2((g - cosTheta) / (g + cosTheta))\n* (1.0 + pow2(\n((g + cosTheta) * cosTheta - 1.0) /\n((g - cosTheta) * cosTheta + 1.0)\n));\n}\n#endif\n#if defined(NODE_BITMAP_MX) || defined(NODE_BITMAP_ENV_MX) || defined(NODE_GRADIENT_RAMP_MX)\n#define MAPPING_EXPLICIT_MAP_CHANNEL 1\n#define MAPPING_VERTEX_COLOR_CHANNEL 2\n#define MAPPING_PLANAR_OBJECT_XYZ    3\n#define MAPPING_PLANAR_WORLD_XYZ     4\n#define AXIS_XY 1\n#define AXIS_YZ 2\n#define AXIS_ZX 3\nmat3 calcUvTransform(float uOffset, float vOffset, float uTiling, float vTiling, float wAngle)\n{\nif (abs(uOffset) < EPSILON && abs(vOffset) < EPSILON &&\n(abs(uTiling - 1.0)) < EPSILON && (abs(vTiling - 1.0)) < EPSILON &&\nabs(wAngle) < EPSILON)\nreturn mat3(1.0);\nfloat sx = uTiling;\nfloat sy = vTiling;\nfloat tx = -uOffset;\nfloat ty = -vOffset;\nfloat cx = uOffset + 0.5;\nfloat cy = vOffset + 0.5;\nfloat c = cos(-wAngle);\nfloat s = sin(-wAngle);\nreturn mat3(sx * c,                           -sy * s,                             0.0,\nsx * s,                            sy * c,                             0.0,\n-sx * (c * cx + s * cy) + cx + tx, -sy * (- s * cx + c * cy) + cy + ty, 1.0);\n}\n#endif\n#if defined(NODE_TEX_NOISE_BL) || defined(NODE_TEX_WAVE_BL)\n#define NOISE_AMP_HACK 0.75\n#define NOISE_BLENDER_MEAN 0.78\n#define NOISE_SCALE_HACK 0.5\n#define noiseModulo(x) (x - floor(x * (1.0 / 289.0)) * 289.0)\nvec4 noisePermute(vec4 x) {\nreturn noiseModulo(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r) {\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat noisePerlin(vec3 v) {\nconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\nconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\nvec3 i = floor(v + dot(v, C.yyy));\nvec3 x0 = v - i + dot(i, C.xxx);\nvec3 g = step(x0.yzx, x0.xyz);\nvec3 l = 1.0 - g;\nvec3 i1 = min(g.xyz, l.zxy);\nvec3 i2 = max(g.xyz, l.zxy);\nvec3 x1 = x0 - i1 + C.xxx;\nvec3 x2 = x0 - i2 + C.yyy;\nvec3 x3 = x0 - D.yyy;\ni = noiseModulo(i);\nvec4 p = noisePermute(noisePermute(noisePermute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n+ i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\nfloat n_ = 0.142857142857;\nvec3 ns = n_ * D.wyz - D.xzx;\nvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\nvec4 x_ = floor(j * ns.z);\nvec4 y_ = floor(j - 7.0 * x_);\nvec4 x = x_ * ns.x + ns.yyyy;\nvec4 y = y_ * ns.x + ns.yyyy;\nvec4 h = 1.0 - abs(x) - abs(y);\nvec4 b0 = vec4(x.xy, y.xy);\nvec4 b1 = vec4(x.zw, y.zw);\nvec4 s0 = floor(b0) * 2.0 + 1.0;\nvec4 s1 = floor(b1) * 2.0 + 1.0;\nvec4 sh = -step(h, vec4(0.0));\nvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\nvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\nvec3 p0 = vec3(a0.xy, h.x);\nvec3 p1 = vec3(a0.zw, h.y);\nvec3 p2 = vec3(a1.xy, h.z);\nvec3 p3 = vec3(a1.zw, h.w);\nvec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\nvec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\nm = m * m;\nreturn 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\ndot(p2, x2), dot(p3, x3)));\n}\nfloat noiseBlender(vec3 p) {\nreturn 0.5 * NOISE_AMP_HACK * (noisePerlin(NOISE_SCALE_HACK * vec3(p.x, p.y, p.z))) + 0.5;\n}\nfloat noiseSmooth(vec3 p, float octaveLenPerPixel, float falloffFactor,\nfloat dispersionFactor) {\nfloat mixFac = mix(1.0, smoothstep(0.0, 1.0, octaveLenPerPixel) * falloffFactor,\ndispersionFactor);\nreturn mix(noiseBlender(p), NOISE_BLENDER_MEAN, mixFac);\n}\n#define MAX_OCTAVES_NUM 16\nfloat noiseTurbulence(vec3 p, float octaves, float octaveLenPerPixel,\nfloat falloffFactor, float dispersionFactor) {\nfloat fscale = 1.0;\nfloat amp = 1.0;\nfloat sum = 0.0;\noctaves = clamp(octaves, 0.0, 16.0);\nint octavesInt = int(octaves);\nfor (int i = 0; i <= MAX_OCTAVES_NUM; i++) {\n#if __VERSION__ == 300\nif (i <= octavesInt) {\nfloat t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nsum += t * amp;\namp *= 0.5;\nfscale *= 2.0;\noctaveLenPerPixel *= 2.0;\n} else {\ni = MAX_OCTAVES_NUM;\n}\n#else\nif (i > octavesInt) break;\nfloat t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nsum += t * amp;\namp *= 0.5;\nfscale *= 2.0;\noctaveLenPerPixel *= 2.0;\n#endif\n}\nfloat octavesFrac = fract(octaves);\nfloat octavesCoeff = pow(2.0, float(octavesInt));\nif (octavesFrac != 0.0) {\nfloat t = noiseSmooth(fscale * p, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nfloat sum2 = sum + t * amp;\nsum *= octavesCoeff / (2.0 * octavesCoeff - 1.0);\nsum2 *= 2.0 * octavesCoeff / (4.0 * octavesCoeff - 1.0);\nreturn mix(sum, sum2, octavesFrac);\n} else {\nreturn sum * octavesCoeff / (2.0 * octavesCoeff - 1.0);\n}\n}\n#endif",
            node_material_gf_frag: "void node_material(\nvec3 normal, vec3 geometryNormal, vec4 tangent,\nvec4 baseColorFactor, vec4 baseColorTexture,\nfloat metallicFactor, float roughnessFactor, vec3 metallicRoughnessTexture,\nfloat normalmapScale, vec3 normalmapTexture, \nfloat occlusionStrength, float directLightOcclusionFactor, vec3 occlusionTexture,\nvec3 emissiveFactor, vec3 emissiveTexture, \nout vec4 outgoingLight) {\nNodeMaterial material;\nfloat metalness = metallicFactor * metallicRoughnessTexture.b;\nvec3 baseColor = baseColorTexture.rgb * baseColorFactor.rgb;\nmaterial.diffuseColor = baseColor * (1.0 - metalness);\nvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nfloat roughness = roughnessFactor * metallicRoughnessTexture.g;\nmaterial.specularRoughness = max(roughness, 0.0525);\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min(material.specularRoughness, 1.0);\nmaterial.specularColor = mix(vec3(DEFAULT_SPECULAR_COEFFICIENT), baseColor, metalness);\nif (normalmapScale > 0.0) {\nvec3 normalTex = normalmapTexture * 2.0 - 1.0;\n#ifdef MT_BLENDER\nnormalTex.y = -normalTex.y;\n#endif\nvec4 viewTangent = vec4(normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz), tangent.w);\nvec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);\n\nnormal = mix(normal, normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent \n+ normalTex.z * normal), normalmapScale);\n}\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nfloat ambientOcclusion = occlusionStrength * occlusionTexture.r;\nif (ambientOcclusion < 1.0) {\nreflectedLight.indirectDiffuse *= ambientOcclusion;\nfloat dotNV = saturate(dot(geometry.normal, geometry.viewDir));\nfloat specularOcclusion = computeSpecularOcclusion(dotNV, ambientOcclusion, material.specularRoughness);\nreflectedLight.indirectSpecular *= specularOcclusion;\nreflectedLight.directDiffuse *= (1.0 + (ambientOcclusion - 1.0) * directLightOcclusionFactor);\nreflectedLight.directSpecular *= (1.0 + (specularOcclusion - 1.0) * directLightOcclusionFactor);\n}\nvec3 totalEmissiveRadiance = emissiveFactor * emissiveTexture;\nvec3 outColor3 = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\n+ reflectedLight.directSpecular + reflectedLight.indirectSpecular\n+ totalEmissiveRadiance;\nfloat alpha = baseColorFactor.a * baseColorTexture.a;\noutgoingLight = vec4(outColor3, alpha);\n}",
            node_rgb_gf_frag: "uniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb(vec4 color, out vec4 outColor)\n{\noutColor = color;\n}",
            node_texture_gf_frag: "void node_texture(sampler2D map, vec2 uv, const mat3 uvTransform,\nconst int encoding, out vec3 color)\n{\nuv = (uvTransform * vec3(uv, 1.0)).xy;\ncolor = texture2D(map, uv).rgb;\ncolor = nodeTexelToLinear(vec4(color, 0.0), encoding).rgb;\n}\nvoid node_texture(sampler2D map, vec2 uv, const mat3 uvTransform,\nconst int encoding, out vec4 color)\n{\nuv = (uvTransform * vec3(uv, 1.0)).xy;\ncolor = texture2D(map, uv);\ncolor = nodeTexelToLinear(color, encoding);\n}",
            node_value_gf_frag: "uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float val, out float outVal)\n{\noutVal = val;\n}",
            node_add_shader_bl_frag: "void node_add_shader(vec4 color1, vec4 color2, out vec4 outColor) {\noutColor.rgb = color1.rgb + color2.rgb;\noutColor.a = clamp(color1.a + color2.a, 0.0, 1.0);\n}",
            node_ambient_occlusion_bl_frag: "void node_ambient_occlusion(vec4 color, float distance, vec3 normal,\nout vec4 outColor, out float outAO) {\noutColor = color;\noutAO = 1.0;\n}\nvoid node_ambient_occlusion(vec4 color, out vec4 outColor)\n{\noutColor = color;\n}",
            node_attribute_bl_frag: "void node_attribute(\nvec3 paramAttr,\nout vec4 outColor, out vec3 outVector, out float outFac)\n{\noutColor = vec4(paramAttr, 1.0);\noutVector = paramAttr;\noutFac = average(paramAttr);\n}",
            node_background_bl_frag: "void node_background(vec4 color, float strength, out vec4 outColor)\n{\noutColor = strength * color;\n}",
            node_bevel_bl_frag: "void node_bevel(float radius, vec3 normal, out vec3 outNormal) {\noutNormal = normal;\n}",
            node_blackbody_bl_frag: "void node_blackbody(float temp, out vec4 outColor)\n{\noutColor = vec4(0.0);\n}",
            node_brightcontrast_bl_frag: "\nvoid node_brightcontrast(vec4 color, float bright, float contrast, out vec4 outColor)\n{\nfloat bminc = bright - contrast * 0.5;\noutColor.r = max((1.0 + contrast) * color.r + bminc, 0.0);\noutColor.g = max((1.0 + contrast) * color.g + bminc, 0.0);\noutColor.b = max((1.0 + contrast) * color.b + bminc, 0.0);\noutColor.a = color.a;\n}",
            node_bsdf_anisotropic_bl_frag: "void node_bsdf_anisotropic(\nvec4 color, float roughness, float anisotropy, float rotation, vec3 normal, vec3 tangent,\nout vec4 outColor)\n{\noutColor = color;\n}",
            node_bsdf_diffuse_bl_frag: "\nvoid node_bsdf_diffuse(\nvec3 geometryNormal,\nvec4 color, float roughness, vec3 normal,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.diffuseColor = color.rgb;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\noutColor = vec4(reflectedLight.directDiffuse + reflectedLight.indirectDiffuse, 1.0);\n}",
            node_bsdf_glass_bl_frag: "void node_bsdf_glass(\nvec3 geometryNormal,\nvec4 color, float roughness, float ior, vec3 normal,\nout vec4 outColor) {\nnormal = swizzleUpY(normal);\nvec3 normalWorld = normal;\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.specularColor = vec3(1.0);\nmaterial.fresnelRefl90 = vec3(1.0);\nmaterial.specularRoughness = clamp(roughness, 0.0, 1.0);\nmaterial.refractionColor = vec3(1.0);\nmaterial.refractionIOR = ior;\nmaterial.refractionRoughness = pow2(roughness);\n#ifdef ENVMAP_TYPE_CUBE_UV\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.specularRoughness = calcCubeUVAdjustedRoughness(\nmaterial.specularRoughness, geomRoughness);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0),\nvec3(0.0), vec3(0.0));\n#define USE_REFRACTED_LIGHT\nvec3 refractedLight = vec3(0.0);\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef USE_REFRACTED_LIGHT\nvec3 viewWorld;\nif (isPerspective(projectionMatrix))\nviewWorld = (invViewMatrix * vec4(-vViewPosition, 0.0)).xyz;\nelse\nviewWorld = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\nviewWorld = normalize(viewWorld);\nfloat fresnel = fresnelReflection(viewWorld, normalWorld, ior);\noutColor = vec4(color.rgb * mix(refractedLight, reflectedLight.directSpecular\n+ reflectedLight.indirectSpecular, fresnel), 1.0);\n}",
            node_bsdf_glossy_bl_frag: "\nvoid node_bsdf_glossy(\nvec3 geometryNormal,\nvec4 color, float roughness, vec3 normal,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = normalize((viewMatrix * vec4(normal.xyz, 0.0)).xyz);\nNodeMaterial material;\nmaterial.specularColor = vec3(1.0);\nmaterial.fresnelRefl90 = vec3(1.0);\nmaterial.specularRoughness = clamp(roughness, 0.0, 1.0);\n#ifdef ENVMAP_TYPE_CUBE_UV\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.specularRoughness = calcCubeUVAdjustedRoughness(\nmaterial.specularRoughness, geomRoughness);\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\noutColor = vec4(color.rgb * (reflectedLight.directSpecular\n+ reflectedLight.indirectSpecular), 1.0);\n}",
            node_bsdf_hair_bl_frag: "void node_bsdf_hair(vec4 color, float offset, float roughnessU, float roughnessV, vec3 tangent, out vec4 outColor)\n{\noutColor = color;\n}",
            node_bsdf_principled_bl_frag: "\nvec3 tintFromColor(vec3 color) {\n\tfloat lum = dot(color, vec3(0.3, 0.6, 0.1));\n\treturn lum > 0.0 ? color / lum : vec3(1.0);\n}\nvec3 fresnelBlend(float ior, float fresnel, vec3 fresnelColor) {\nfloat fresnelFac = fresnelReflection(vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), ior);\n\tfloat mixFac = saturate((fresnel - fresnelFac) / max(1e-8, 1.0 - fresnelFac));\n\treturn mix(fresnelColor, vec3(1.0), mixFac);\n}\nvoid node_bsdf_principled(\nvec3 geometryNormal,\nvec4 baseColor, float subsurface, vec3 subsurfaceRadius, vec4 subsurfaceColor,\nfloat metallic, float specular, float specularTint, float roughness,\nfloat anisotropic, float anisotropicRotation, float sheen, float sheenTint,\nfloat clearcoat, float clearcoatRoughness, float ior,\nfloat transmission, float transmissionRoughness, vec4 emission, float alpha,\nvec3 normal, vec3 clearcoatNormal, vec3 tangent,\nout vec4 outColor) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nvec3 normalWorld = normal;\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmetallic = clamp(metallic, 0.0, 1.0);\nfloat dielectric = 1.0 - metallic;\ntransmission *= dielectric;\nmaterial.diffuseColor = baseColor.rgb * dielectric;\n#ifndef CLEARCOAT\nfloat dielReflCoeff = BLENDER_SPECULAR_COEFFICIENT;\n#else\nfloat dielReflCoeff = MAXIMUM_SPECULAR_COEFFICIENT;\nmaterial.clearcoat = saturate(clearcoat);\nmaterial.clearcoatRoughness = clamp(clearcoatRoughness, 0.0, 1.0);\n#endif\nvec3 dielRefl = dielReflCoeff * specular\n* mix(vec3(1.0), tintFromColor(baseColor.rgb), specularTint);\nmaterial.specularColor = mix(dielRefl, baseColor.rgb, metallic);\nmaterial.specularRoughness = clamp(roughness, 0.0, 1.0);\nvec3 viewWorld;\nif (isPerspective(projectionMatrix))\nviewWorld = (invViewMatrix * vec4(-vViewPosition, 0.0)).xyz;\nelse\nviewWorld = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\nviewWorld = normalize(viewWorld);\nfloat fresnel = fresnelReflection(viewWorld, normalWorld, ior);\nvec3 fresnelColor = mix(vec3(1.0), baseColor.rgb, specularTint);\nmaterial.specularColor = mix(material.specularColor,\nfresnelBlend(ior, fresnel, fresnelColor) * fresnel, transmission);\nfloat isStrictDielectric = step(0.0, -length(vec4(subsurface, clearcoat,\ntransmission, float(metallic == 1.0))));\nmaterial.fresnelRefl90 = mix(vec3(1.0), material.specularColor,\n(1.0 - specular) * metallic * (1.0 - isStrictDielectric));\nmaterial.refractionColor = baseColor.rgb;\nmaterial.refractionIOR = ior;\nmaterial.refractionRoughness = pow2(roughness);\n#ifdef ENVMAP_TYPE_CUBE_UV\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.specularRoughness = calcCubeUVAdjustedRoughness(\nmaterial.specularRoughness, geomRoughness);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#ifdef CLEARCOAT\nmaterial.clearcoatRoughness = calcCubeUVAdjustedRoughness(\nmaterial.clearcoatRoughness, geomRoughness);\nclearcoatNormal = normalize(vec3(clearcoatNormal[0], clearcoatNormal[2], -clearcoatNormal[1]));\nclearcoatNormal = (viewMatrix * vec4(clearcoatNormal.xyz, 0.0)).xyz;\n#endif\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define USE_REFRACTED_LIGHT\nvec3 refractedLight = vec3(0.0);\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef USE_REFRACTED_LIGHT\nvec3 outColor3 = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * (1.0 - transmission)\n+ reflectedLight.directSpecular + reflectedLight.indirectSpecular\n+ refractedLight * transmission * (1.0 - fresnel)\n+ emission.rgb;\noutColor = vec4(outColor3, alpha);\n}\nvoid node_bsdf_principled(\nvec3 geometryNormal,\nvec4 baseColor, float subsurface, vec3 subsurfaceRadius, vec4 subsurfaceColor,\nfloat metallic, float specular, float specularTint, float roughness,\nfloat anisotropic, float anisotropicRotation, float sheen, float sheenTint,\nfloat clearcoat, float clearcoatRoughness, float ior,\nfloat transmission, float transmissionRoughness,\nvec3 normal, vec3 clearcoatNormal, vec3 tangent,\nout vec4 outColor) {\nnode_bsdf_principled(geometryNormal, baseColor, subsurface, subsurfaceRadius,\nsubsurfaceColor, metallic, specular, specularTint, roughness,\nanisotropic, anisotropicRotation, sheen, sheenTint, clearcoat,\nclearcoatRoughness, ior, transmission, transmissionRoughness,\nvec4(0.0, 0.0, 0.0, 1.0), 1.0, normal, clearcoatNormal, tangent,\noutColor);\n}",
            node_bsdf_refraction_bl_frag: "#define BSDF_REFRACTION_GGX 0\n#define BSDF_REFRACTION_BECKMANN 1\n#define BSDF_REFRACTION_SHARP 2\nvoid node_bsdf_refraction(\nvec3 geometryNormal, const int distribution,\nvec4 color, float roughness, float ior, vec3 normal,\nout vec4 outColor) {\nnormal = swizzleUpY(normal);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\nNodeMaterial material;\nmaterial.refractionColor = color.rgb;\nmaterial.refractionIOR = ior;\nif (distribution == BSDF_REFRACTION_SHARP) {\nmaterial.refractionRoughness = 0.0;\n} else {\nmaterial.refractionRoughness = pow2(roughness);\n}\n#ifdef ENVMAP_TYPE_CUBE_UV\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define USE_REFRACTED_LIGHT\nvec3 refractedLight = vec3(0.0);\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef USE_REFRACTED_LIGHT\noutColor = vec4(refractedLight, 1.0);\n}",
            node_bsdf_toon_bl_frag: "void node_bsdf_toon(\nvec4 color, float size, float smooth, vec3 normal, \nout vec4 outColor)\n{\noutColor = color;\n}",
            node_bsdf_translucent_bl_frag: "void node_bsdf_translucent(vec4 color, vec3 normal, out vec4 outColor)\n{\noutColor = color;\n}",
            node_bsdf_transparent_bl_frag: "\nvoid node_bsdf_transparent(vec4 color, out vec4 outColor)\n{\nfloat alpha = saturate(1.0 - dot(color.rgb, vec3(0.333333)));\noutColor = vec4(0.0, 0.0, 0.0, alpha);\n}",
            node_bsdf_velvet_bl_frag: "void node_bsdf_velvet(vec4 color, float sigma, vec3 normal, out vec4 outColor)\n{\noutColor = color;\n}",
            node_bump_bl_frag: "\nvoid node_bump(\nconst int invert,\nfloat strength, float bumpDist, float height, float height_dx,\nfloat height_dy, vec3 normal,\nout vec3 outNormal) {\nvec3 position = swizzleUpZ(vWorldPosition);\nif (invert == 1)\nbumpDist *= -1.0;\nvec3 dPdx = dFdx(position);\nvec3 dPdy = dFdy(position);\nfloat dHdx = dFdx(height);\nfloat dHdy = dFdy(height);\nvec3 tanX = cross(dPdy, normal);\nvec3 tanY = cross(normal, dPdx);\nvec3 surfaceGrad = dHdx * tanX + dHdy * tanY;\nfloat dotPosTanX = dot(dPdx, tanX);\noutNormal = normalize(normal * abs(dotPosTanX) - surfaceGrad * bumpDist * sign(dotPosTanX));\noutNormal = normalize(mix(normal, outNormal, max(0.0, strength)));\n}\nvoid node_bump(\nconst int invert,\nfloat strength, float bumpDist, float height, vec3 normal,\nout vec3 outNormal) {\nnode_bump(invert, strength, bumpDist, height, 0.0, 0.0, normal, outNormal);\n}",
            node_camera_bl_frag: "\nvoid node_camera(\nvec3 viewPos, const int invCamZ,\nout vec3 outViewVector, out float outViewZDepth, out float outViewDistance)\n{\nviewPos = -viewPos;\nif (invCamZ == 1)\nviewPos.z = -viewPos.z;\noutViewVector = normalize(viewPos);\noutViewZDepth = abs(viewPos.z);\noutViewDistance = length(viewPos);\n}",
            node_clamp_bl_frag: "void node_clamp(float value, float minVal, float maxVal, out float result) {\nresult = clamp(value, minVal, maxVal);\n}",
            node_combhsv_bl_frag: "\nvoid node_combhsv(float h, float s, float v, out vec4 col)\n{\nhsvToRGB(vec4(h, s, v, 1.0), col);\n}",
            node_combrgb_bl_frag: "\nvoid node_combrgb(float r, float g, float b, out vec4 col)\n{\ncol = vec4(r, g, b, 1.0);\n}",
            node_combxyz_bl_frag: "void node_combxyz(float x, float y, float z, out vec3 outVector)\n{\noutVector = vec3(x, y, z);\n}",
            node_curve_rgb_bl_frag: "\nvoid node_curve_rgb(sampler2D curveData, float fac, vec4 col, out vec4 outCol)\n{\noutCol.r = texture2D(curveData, vec2(texture2D(curveData, vec2(col.r, 0.0)).a, 0.0)).r;\noutCol.g = texture2D(curveData, vec2(texture2D(curveData, vec2(col.g, 0.0)).a, 0.0)).g;\noutCol.b = texture2D(curveData, vec2(texture2D(curveData, vec2(col.b, 0.0)).a, 0.0)).b;\noutCol = mix(col, outCol, fac);\noutCol.a = col.a;\n}",
            node_curve_vec_bl_frag: "\nvoid node_curve_vec(sampler2D curveData, float fac, vec3 vec, out vec3 outVec)\n{\noutVec.x = texture2D(curveData, vec2((vec.x + 1.0) * 0.5, 0.0)).x;\noutVec.y = texture2D(curveData, vec2((vec.y + 1.0) * 0.5, 0.0)).y;\noutVec.z = texture2D(curveData, vec2((vec.z + 1.0) * 0.5, 0.0)).z;\noutVec = mix(vec, outVec * 2.0 - vec3(1.0), fac);\n}",
            node_displacement_bl_frag: "void node_displacement(float height, float midlevel, float scale, vec3 normal, out vec3 outDisplacement) {\noutDisplacement = vec3(0.0);\n}",
            node_eevee_specular_bl_frag: "void node_eevee_specular(\nvec4 baseColor, vec4 specular, float roughness, vec4 emissiveColor,\nfloat transparency, vec3 normal, float clearcoat, float clearcoatRoughness, \nvec3 clearcoatNormal, float ambientOcclusion,\nout vec4 outColor) {\noutColor = baseColor;\n}",
            node_emission_bl_frag: "\nvoid node_emission(vec4 color, float strength, out vec4 outColor)\n{\noutColor = vec4(strength * color.rgb, 1.0);\n}",
            node_fresnel_bl_frag: "void node_fresnel(vec3 viewPos, float IOR, vec3 normal, out float fac)\n{\nvec3 worldDir;\nif (isPerspective(projectionMatrix))\nworldDir = (invViewMatrix * vec4(-viewPos, 0.0)).xyz;\nelse\nworldDir = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\n\nworldDir = normalize(swizzleUpZ(worldDir));\nfloat eta = max(IOR, 0.00001);\nfac = fresnelReflection(worldDir, normal, (gl_FrontFacing) ? eta : 1.0 / eta);\n}",
            node_gamma_bl_frag: "\nvoid node_gamma(vec4 col, float gamma, out vec4 outCol)\n{\noutCol = col;\nif (col.r > 0.0)\noutCol.r = powCompat(col.r, gamma);\nif (col.g > 0.0)\noutCol.g = powCompat(col.g, gamma);\nif (col.b > 0.0)\noutCol.b = powCompat(col.b, gamma);\n}",
            node_geometry_bl_frag: "\nvoid node_geometry(\nvec3 viewPos, vec3 viewNorm, vec3 orcoIn, vec2 uvIn, vec4 vcolIn,\nout vec3 global, out vec3 local, out vec3 view, out vec3 orco, out vec3 uv,\nout vec3 normal, out vec4 vcol, out float vcolAlpha, out float frontBack)\n{\nlocal = -viewPos;\nview = (projectionMatrix[3][3] == 0.0) ? normalize(local) : vec3(0.0, 0.0, -1.0);\nglobal = (invViewMatrix * vec4(local, 1.0)).xyz;\nglobal = swizzleUpZ(global);\norco = global;\nuvIn.y = 1.0 - uvIn.y;\nuv = vec3(uvIn * 2.0 - vec2(1.0, 1.0), 0.0);\nnormal = normalize(invViewMatrix * vec4(viewNorm, 0.0)).rgb;\nnormal = swizzleUpZ(normal);\nvcol = sRGBToLinear(vec4(vcolIn.rgb, 1.0));\nvcolAlpha = vcolIn.a;\nfrontBack = (gl_FrontFacing) ? 1.0 : 0.0;\n}",
            node_hair_info_bl_frag: "void node_hair_info(out float isStrand, out float intercept, out float thickness,\nout vec3 tangentNormal, out float random) {\nisStrand = 0.0;\nintercept = 0.0;\nthickness = 0.0;\ntangentNormal = vec3(0.0);\nrandom = 0.0;\n}\nvoid node_hair_info(\nout float isStrand, out float intercept, out float thickness, out vec3 tangentNormal)\n{\nisStrand = 0.0;\nintercept = 0.0;\nthickness = 0.0;\ntangentNormal = vec3(0.0);\n}",
            node_holdout_bl_frag: "void node_holdout(out vec4 outColor)\n{\noutColor = vec4(0.0);\n}",
            node_hue_sat_bl_frag: "\nvoid node_hue_sat(float hue, float sat, float value, float fac, vec4 col, out vec4 outCol)\n{\nvec4 hsv;\nrgbToHSV(col, hsv);\nhsv[0] += (hue - 0.5);\nif (hsv[0] > 1.0) hsv[0] -= 1.0; else if (hsv[0] < 0.0) hsv[0] += 1.0;\nhsv[1] *= sat;\nif (hsv[1] > 1.0) hsv[1] = 1.0; else if (hsv[1] < 0.0) hsv[1] = 0.0;\nhsv[2] *= value;\nif (hsv[2] > 1.0) hsv[2] = 1.0; else if (hsv[2] < 0.0) hsv[2] = 0.0;\nhsvToRGB(hsv, outCol);\noutCol = mix(col, outCol, fac);\n}",
            node_invert_bl_frag: "\nvoid node_invert(float fac, vec4 col, out vec4 outCol)\n{\noutCol.xyz = mix(col.xyz, vec3(1.0, 1.0, 1.0) - col.xyz, fac);\noutCol.w = col.w;\n}",
            node_lamp_bl_frag: "\nvoid node_lamp(out vec4 outCol, out vec3 outLv, out float outDist, out vec4 outShadow, out float outVisibility)\n{\noutCol = vec4(0.0);\noutLv = vec3(0.0);\noutDist = 0.0;\noutShadow = vec4(0.0);\noutVisibility = 1.0;\n}",
            node_layer_weight_bl_frag: "\nvoid node_layer_weight(vec3 viewPos, float blend, vec3 normal, out float fresnel, out float facing)\n{\nvec3 worldDir;\nif (isPerspective(projectionMatrix))\nworldDir = (invViewMatrix * vec4(-viewPos, 0.0)).xyz;\nelse\nworldDir = (invViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\n\nworldDir = normalize(swizzleUpZ(worldDir));\nfloat eta = max(1.0 - blend, EPSILON);\nfresnel = fresnelReflection(worldDir, normal, (gl_FrontFacing) ? 1.0 / eta : eta);\nfacing = abs(dot(worldDir, normal));\nif (blend != 0.5) {\nblend = clamp(blend, 0.0, 1.0 - EPSILON);\nblend = (blend < 0.5) ? blend * 2.0 : 0.5 / (1.0 - blend);\nfacing = pow(facing, blend);\n}\nfacing = 1.0 - facing;\n}",
            node_light_falloff_bl_frag: "void node_light_falloff(\nfloat strength, float inSmooth,\nout float quadratic, out float linear, out float constant)\n{\nquadratic = 1.0;\nlinear = 1.0;\nconstant = 1.0;\n}",
            node_light_path_bl_frag: "void node_light_path(\nout float isCameraRay, out float isShadowRay, out float isDiffuseRay, \nout float isGlossyRay, out float isSingularRay, out float isReflectionRay,\nout float isTransmissionRay, out float rayLength, out float rayDepth, \nout float diffuseDepth, out float glossyDepth, out float transparentDepth, \nout float transmissionDepth)\n{\n#if LIGHT_PATH_IS_CAM_RAY\nisCameraRay = 1.0;\n#else\nisCameraRay = 0.0;\n#endif\nisShadowRay = 0.0;\nisDiffuseRay = 0.0;\nisGlossyRay = 0.0;\nisSingularRay = 0.0;\nisReflectionRay = 0.0;\nisTransmissionRay = 0.0;\nrayLength = 1.0;\nrayDepth = 1.0;\ndiffuseDepth = 1.0;\nglossyDepth = 1.0;\ntransparentDepth = 1.0; \ntransmissionDepth = 1.0;\n}",
            node_mapping_bl_frag: "\nvoid node_mapping(mat4 mat, vec3 minVec, vec3 maxVec, int useMin, int useMax, vec3 vec, out vec3 outVec)\n{\noutVec = (mat * vec4(vec, 1.0)).xyz;\nif (useMin == 1)\noutVec = max(outVec, minVec);\nif (useMax == 1)\noutVec = min(outVec, maxVec);\n}\nmat3 rotationMatrix(float angleX, float angleY, float angleZ) {\nfloat cx = cos(angleX);\nfloat sx = sin(angleX);\nfloat cy = cos(angleY);\nfloat sy = sin(angleY);\nfloat cz = cos(angleZ);\nfloat sz = sin(angleZ);\n\nmat3 mat;\nmat[0][0] = cy * cz;\nmat[0][1] = cy * sz;\nmat[0][2] = -sy;\n\nmat[1][0] = sy * sx * cz - cx * sz;\nmat[1][1] = sy * sx * sz + cx * cz;\nmat[1][2] = cy * sx;\n\nmat[2][0] = sy * cx * cz + sx * sz;\nmat[2][1] = sy * cx * sz - sx * cz;\nmat[2][2] = cy * cx;\n\nreturn mat;\n}\n#define NODE_MAPPING_POINT 1\n#define NODE_MAPPING_TEXTURE 2\n#define NODE_MAPPING_VECTOR 3\n#define NODE_MAPPING_NORMAL 4\nvoid node_mapping(int type, vec3 vec, vec3 loc, vec3 rot, vec3 scale, out vec3 outVec)\n{\nif (type == NODE_MAPPING_POINT)\noutVec = rotationMatrix(rot.x, rot.y, rot.z) * (vec * scale) + loc;\nelse if (type == NODE_MAPPING_TEXTURE)\noutVec = transposeMat3(rotationMatrix(rot.x, rot.y, rot.z)) * (vec - loc) / scale;\nelse if (type == NODE_MAPPING_VECTOR)\noutVec = rotationMatrix(rot.x, rot.y, rot.z) * (vec * scale);\nelse\noutVec = normalize(rotationMatrix(rot.x, rot.y, rot.z) * vec / scale);\n}",
            node_map_range_bl_frag: "#define NODE_MAP_RANGE_INTERP_LINEAR           0\n#define NODE_MAP_RANGE_INTERP_STEPPED_LINEAR   1\n#define NODE_MAP_RANGE_INTERP_SMOOTHSTEP       2\n#define NODE_MAP_RANGE_INTERP_SMOOTHERSTEP     3\nvoid node_map_range(const int interpolation, int inClamp, float value, float fromMin, float fromMax,\nfloat toMin, float toMax, float steps, out float result) {\nif (fromMax == fromMin) {\nresult = 0.0;\n} else {\nresult = (value - fromMin) / (fromMax - fromMin) * (toMax - toMin) + toMin;\n}\nif (inClamp == 1) {\nresult = clamp(result, toMin, toMax);\n}\n}\nvoid node_map_range(const int interpolation, int inClamp, float value,\nfloat fromMin, float fromMax, float toMin, float toMax, out float result) {\nnode_map_range(NODE_MAP_RANGE_INTERP_LINEAR, inClamp, value, fromMin,\nfromMax, toMin, toMax, 0.0, result);\n}",
            node_material_ext_bl_frag: "\nvoid node_material_ext(\nconst int useDiffuse, const int useSpec, const int invertNormal,\nconst float specularIntensity, const float specularHardness,\nconst int useShadeless, const int normalBlendWorld,\nconst vec4 diffuseColor, const vec4 specularColor, const float diffuseIntensity,\nvec3 normal, const vec4 mirror, const float ambient,\nconst float emit, const float specularAlpha, const float reflectivity,\nconst float alpha, const float translucency,\nout vec4 outColor, out float outAlpha, out vec3 outNormal, out vec4 outDiffuse,\nout vec4 outSpec,  out vec4 outAO)\n{\nif (normalBlendWorld == 1) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\n}\nvec3 diffuse, specular;\nif (useShadeless == 0) {\nNodeMaterial material;\nif (useDiffuse == 1)\nmaterial.diffuseColor = diffuseColor.rgb;\nelse\nmaterial.diffuseColor = vec3(0.0);\nif (useSpec == 1)\nmaterial.specularColor = specularColor.rgb;\nelse\nmaterial.specularColor = vec3(0.0);\nmaterial.diffuseIntensity = diffuseIntensity;\nmaterial.specularHardness = specularHardness;\nmaterial.specularIntensity = specularIntensity;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nvec3 totalEmissiveRadiance = emit * material.diffuseColor;\ndiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\ntotalEmissiveRadiance;\nspecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n} else {\ndiffuse = diffuseColor.rgb;\nspecular = vec3(0.0);\n}\noutColor = vec4(diffuse + specular, 1.0);\noutAlpha = alpha - saturate(maxFromRGB(specular) * specularAlpha) * (alpha - 1.0);\noutNormal = normal;\noutDiffuse = vec4(diffuse, 1.0);\noutSpec = vec4(specular, 1.0);\noutAO = vec4(1.0, 1.0, 1.0, 1.0);\n}",
            node_material_bl_frag: "\nvoid node_material(\nconst int useDiffuse, const int useSpec, const int invertNormal,\nconst float specularIntensity, const float specularHardness,\nconst float ambient, const float emit, const float alpha,\nconst int useShadeless, const int normalBlendWorld,\nconst vec4 diffuseColor, const vec4 specularColor, const float diffuseIntensity,\nvec3 normal,\nout vec4 outColor, out float outAlpha, out vec3 outNormal)\n{\nif (normalBlendWorld == 1) {\nnormal = vec3(normal[0], normal[2], -normal[1]);\nnormal = (viewMatrix * vec4(normal.xyz, 0.0)).xyz;\n}\nvec3 diffuse, specular;\nif (useShadeless == 0) {\nNodeMaterial material;\nif (useDiffuse == 1)\nmaterial.diffuseColor = diffuseColor.rgb;\nelse\nmaterial.diffuseColor = vec3(0.0);\nif (useSpec == 1)\nmaterial.specularColor = specularColor.rgb;\nelse\nmaterial.specularColor = vec3(0.0);\nmaterial.diffuseIntensity = diffuseIntensity;\nmaterial.specularHardness = specularHardness;\nmaterial.specularIntensity = specularIntensity;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nvec3 totalEmissiveRadiance = emit * material.diffuseColor;\ndiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\ntotalEmissiveRadiance;\nspecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n} else {\ndiffuse = diffuseColor.rgb;\nspecular = vec3(0.0);\n}\noutColor = vec4(diffuse + specular, 1.0);\noutAlpha = alpha;\noutNormal = normalize(invViewMatrix * vec4(normal, 0.0)).rgb;\noutNormal = swizzleUpZ(outNormal);\n}",
            node_math_bl_frag: "\nvoid node_math_add(float val1, float val2, float val3, out float outVal)\n{\noutVal = val1 + val2;\n}\nvoid node_math_subtract(float val1, float val2, float val3, out float outVal)\n{\noutVal = val1 - val2;\n}\nvoid node_math_multiply(float val1, float val2, float val3, out float outVal)\n{\noutVal = val1 * val2;\n}\nvoid node_math_divide(float val1, float val2, float val3, out float outVal)\n{\nif (val2 == 0.0)\noutVal = 0.0;\nelse\noutVal = val1 / val2;\n}\nvoid node_math_sine(float val, float val2, float val3, out float outVal)\n{\noutVal = sin(val);\n}\nvoid node_math_cosine(float val, float val2, float val3, out float outVal)\n{\noutVal = cos(val);\n}\nvoid node_math_tangent(float val, float val2, float val3, out float outVal)\n{\noutVal = tan(val);\n}\nvoid node_math_arcsine(float val, float val2, float val3, out float outVal)\n{\nif (val <= 1.0 && val >= -1.0)\noutVal = asin(val);\nelse\noutVal = 0.0;\n}\nvoid node_math_arccosine(float val, float val2, float val3, out float outVal)\n{\nif (val <= 1.0 && val >= -1.0)\noutVal = acos(val);\nelse\noutVal = 0.0;\n}\nvoid node_math_arctangent(float val, float val2, float val3, out float outVal)\n{\noutVal = atan(val);\n}\nvoid node_math_arctan2(float val, float val2, float val3, out float outVal)\n{\noutVal = atan(val, val2);\n}\nvoid node_math_power(float val1, float val2, float val3, out float outVal)\n{\nif (val1 >= 0.0)\noutVal = powCompat(val1, val2);\nelse {\nfloat val2_mod_1 = mod(abs(val2), 1.0);\nif (val2_mod_1 > 0.999 || val2_mod_1 < 0.001)\noutVal = powCompat(val1, floor(val2 + 0.5));\nelse\noutVal = 0.0;\n}\n}\nvoid node_math_logarithm(float val1, float val2, float val3, out float outVal)\n{\nif (val1 > 0.0  && val2 > 0.0)\noutVal = log2(val1) / log2(val2);\nelse\noutVal = 0.0;\n}\nvoid node_math_sqrt(float val1, float val2, float val3, out float outVal)\n{\noutVal = sqrt(val1);\n}\nvoid node_math_maximum(float val1, float val2, float val3, out float outVal)\n{\noutVal = max(val1, val2);\n}\nvoid node_math_minimum(float val1, float val2, float val3, out float outVal)\n{\noutVal = min(val1, val2);\n}\nvoid node_math_round(float val1, float val2, float val3, out float outVal)\n{\noutVal = floor(val1 + 0.5);\n}\nvoid node_math_floor(float val1, float val2, float val3, out float outVal)\n{\noutVal = floor(val1);\n}\nvoid node_math_ceil(float val1, float val2, float val3, out float outVal)\n{\noutVal = ceil(val1);\n}\nvoid node_math_fract(float val1, float val2, float val3, out float outVal)\n{\noutVal = fract(val1);\n}\nvoid node_math_less_than(float val1, float val2, float val3, out float outVal)\n{\nif (val1 < val2)\noutVal = 1.0;\nelse\noutVal = 0.0;\n}\nvoid node_math_greater_than(float val1, float val2, float val3, out float outVal)\n{\nif (val1 > val2)\noutVal = 1.0;\nelse\noutVal = 0.0;\n}\nvoid node_math_modulo(float val1, float val2, float val3, out float outVal)\n{\nif (val2 == 0.0)\noutVal = 0.0;\nelse\noutVal = mod(val1, val2);\noutVal = (val1 > 0.0) ? outVal : outVal - val2;\n}\nvoid node_math_absolute(float val1, float val2, float val3, out float outVal)\n{\noutVal = abs(val1);\n}\nvoid node_math_compare(float val1, float val2, float val3, out float outVal) {\noutVal = step(abs(val1 - val2), val3);\n}\nvoid node_math_cosh(float val1, float val2, float val3, out float outVal) {\noutVal = cosh(val1);\n}\nvoid node_math_degrees(float val1, float val2, float val3, out float outVal) {\noutVal = val1 / PI * 180.0;\n}\nvoid node_math_exponent(float val1, float val2, float val3, out float outVal) {\noutVal = exp(val1);\n}\nvoid node_math_inverse_sqrt(float val1, float val2, float val3, out float outVal) {\nif (val1 >= 0.0) {\noutVal = 1.0 / sqrt(val1);\n} else {\noutVal = 0.0;\n}\n}\nvoid node_math_multiply_add(float val1, float val2, float val3, out float outVal) {\noutVal = val1 * val2 + val3;\n}\nvoid node_math_pingpong(float val1, float val2, float val3, out float outVal) {\nif (val2 == 0.0) {\noutVal = 0.0;\n} else {\nfloat absVal2 = abs(val2);\nfloat rem = mod(val1, absVal2);\noutVal = mix(rem, absVal2 - rem, mod(floor(val1 / absVal2), 2.0));\n}\n}\nvoid node_math_radians(float val1, float val2, float val3, out float outVal) {\noutVal = val1 / 180.0 * PI;\n}\nvoid node_math_sign(float val1, float val2, float val3, out float outVal) {\noutVal = sign(val1);\n}\nvoid node_math_sinh(float val1, float val2, float val3, out float outVal) {\noutVal = sinh(val1);\n}\nvoid node_math_smooth_max(float val1, float val2, float val3, out float outVal) {\noutVal = smoothMax(val1, val2, val3);\n}\nvoid node_math_smooth_min(float val1, float val2, float val3, out float outVal) {\noutVal = smoothMin(val1, val2, val3);\n}\nvoid node_math_snap(float val1, float val2, float val3, out float outVal) {\nval1 += 1e-5 * sign(val2);\nfloat quot = val1 / val2;\noutVal = floor(quot) * val2;\n}\nvoid node_math_tanh(float val1, float val2, float val3, out float outVal) {\noutVal = tanh(val1);\n}\nvoid node_math_trunc(float val1, float val2, float val3, out float outVal) {\nval1 += 1e-5;\noutVal = trunc(val1);\n}\nvoid node_math_wrap(float val1, float val2, float val3, out float outVal) {\nval1 += 1e-5;\noutVal = mod(val1 - val3, val2 - val3) + val3;\n}\nvoid node_math_add(float val1, float val2, out float outVal) {\nnode_math_add(val1, val2, 0.0, outVal);\n}\nvoid node_math_subtract(float val1, float val2, out float outVal) {\nnode_math_subtract(val1, val2, 0.0, outVal);\n}\nvoid node_math_multiply(float val1, float val2, out float outVal) {\nnode_math_multiply(val1, val2, 0.0, outVal);\n}\nvoid node_math_divide(float val1, float val2, out float outVal) {\nnode_math_divide(val1, val2, 0.0, outVal);\n}\nvoid node_math_sine(float val1, float val2, out float outVal) {\nnode_math_sine(val1, val2, 0.0, outVal);\n}\nvoid node_math_cosine(float val1, float val2, out float outVal) {\nnode_math_cosine(val1, val2, 0.0, outVal);\n}\nvoid node_math_tangent(float val1, float val2, out float outVal) {\nnode_math_tangent(val1, val2, 0.0, outVal);\n}\nvoid node_math_arcsine(float val1, float val2, out float outVal) {\nnode_math_arcsine(val1, val2, 0.0, outVal);\n}\nvoid node_math_arccosine(float val1, float val2, out float outVal) {\nnode_math_arccosine(val1, val2, 0.0, outVal);\n}\nvoid node_math_arctangent(float val1, float val2, out float outVal) {\nnode_math_arctangent(val1, val2, 0.0, outVal);\n}\nvoid node_math_arctan2(float val1, float val2, out float outVal) {\nnode_math_arctan2(val1, val2, 0.0, outVal);\n}\nvoid node_math_power(float val1, float val2, out float outVal) {\nnode_math_power(val1, val2, 0.0, outVal);\n}\nvoid node_math_logarithm(float val1, float val2, out float outVal) {\nnode_math_logarithm(val1, val2, 0.0, outVal);\n}\nvoid node_math_sqrt(float val1, float val2, out float outVal) {\nnode_math_sqrt(val1, val2, 0.0, outVal);\n}\nvoid node_math_maximum(float val1, float val2, out float outVal) {\nnode_math_maximum(val1, val2, 0.0, outVal);\n}\nvoid node_math_minimum(float val1, float val2, out float outVal) {\nnode_math_minimum(val1, val2, 0.0, outVal);\n}\nvoid node_math_round(float val1, float val2, out float outVal) {\nnode_math_round(val1, val2, 0.0, outVal);\n}\nvoid node_math_floor(float val1, float val2, out float outVal) {\nnode_math_floor(val1, val2, 0.0, outVal);\n}\nvoid node_math_ceil(float val1, float val2, out float outVal) {\nnode_math_ceil(val1, val2, 0.0, outVal);\n}\nvoid node_math_fract(float val1, float val2, out float outVal) {\nnode_math_fract(val1, val2, 0.0, outVal);\n}\nvoid node_math_less_than(float val1, float val2, out float outVal) {\nnode_math_less_than(val1, val2, 0.0, outVal);\n}\nvoid node_math_greater_than(float val1, float val2, out float outVal) {\nnode_math_greater_than(val1, val2, 0.0, outVal);\n}\nvoid node_math_modulo(float val1, float val2, out float outVal) {\nnode_math_modulo(val1, val2, 0.0, outVal);\n}\nvoid node_math_absolute(float val1, float val2, out float outVal) {\nnode_math_absolute(val1, val2, 0.0, outVal);\n}",
            node_mix_rgb_bl_frag: "\nvoid node_mix_rgb_mix(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_add(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 + col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_multiply(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 * col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_screen(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = vec4(1.0) - (vec4(facm) + fac * (vec4(1.0) - col2)) * (vec4(1.0) - col1);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_overlay(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nif (outCol.r < 0.5)\noutCol.r *= facm + 2.0 * fac * col2.r;\nelse\noutCol.r = 1.0 - (facm + 2.0 * fac * (1.0 - col2.r)) * (1.0 - outCol.r);\nif (outCol.g < 0.5)\noutCol.g *= facm + 2.0 * fac * col2.g;\nelse\noutCol.g = 1.0 - (facm + 2.0 * fac * (1.0 - col2.g)) * (1.0 - outCol.g);\nif (outCol.b < 0.5)\noutCol.b *= facm + 2.0 * fac * col2.b;\nelse\noutCol.b = 1.0 - (facm + 2.0 * fac * (1.0 - col2.b)) * (1.0 - outCol.b);\n}\nvoid node_mix_rgb_subtract(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, col1 - col2, fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_divide(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nif (col2.r != 0.0) outCol.r = facm * outCol.r + fac * outCol.r / col2.r;\nif (col2.g != 0.0) outCol.g = facm * outCol.g + fac * outCol.g / col2.g;\nif (col2.b != 0.0) outCol.b = facm * outCol.b + fac * outCol.b / col2.b;\n}\nvoid node_mix_rgb_difference(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = mix(col1, abs(col1 - col2), fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_darken(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol.rgb = min(col1.rgb, col2.rgb * fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_lighten(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol.rgb = max(col1.rgb, col2.rgb * fac);\noutCol.a = col1.a;\n}\nvoid node_mix_rgb_dodge(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = col1;\nif (outCol.r != 0.0) {\nfloat tmp = 1.0 - fac * col2.r;\nif (tmp <= 0.0)\noutCol.r = 1.0;\nelse if ((tmp = outCol.r / tmp) > 1.0)\noutCol.r = 1.0;\nelse\noutCol.r = tmp;\n}\nif (outCol.g != 0.0) {\nfloat tmp = 1.0 - fac * col2.g;\nif (tmp <= 0.0)\noutCol.g = 1.0;\nelse if ((tmp = outCol.g / tmp) > 1.0)\noutCol.g = 1.0;\nelse\noutCol.g = tmp;\n}\nif (outCol.b != 0.0) {\nfloat tmp = 1.0 - fac * col2.b;\nif (tmp <= 0.0)\noutCol.b = 1.0;\nelse if ((tmp = outCol.b / tmp) > 1.0)\noutCol.b = 1.0;\nelse\noutCol.b = tmp;\n}\n}\nvoid node_mix_rgb_burn(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat tmp, facm = 1.0 - fac;\noutCol = col1;\ntmp = facm + fac * col2.r;\nif (tmp <= 0.0)\noutCol.r = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.r) / tmp)) < 0.0)\noutCol.r = 0.0;\nelse if (tmp > 1.0)\noutCol.r = 1.0;\nelse\noutCol.r = tmp;\ntmp = facm + fac * col2.g;\nif (tmp <= 0.0)\noutCol.g = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.g) / tmp)) < 0.0)\noutCol.g = 0.0;\nelse if (tmp > 1.0)\noutCol.g = 1.0;\nelse\noutCol.g = tmp;\ntmp = facm + fac * col2.b;\nif (tmp <= 0.0)\noutCol.b = 0.0;\nelse if ((tmp = (1.0 - (1.0 - outCol.b) / tmp)) < 0.0)\noutCol.b = 0.0;\nelse if (tmp > 1.0)\noutCol.b = 1.0;\nelse\noutCol.b = tmp;\n}\n#ifdef HSV_NODES\nvoid node_mix_rgb_hue(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2, tmp;\nrgbToHSV(col2, hsv2);\nif (hsv2.y != 0.0) {\nrgbToHSV(outCol, hsv);\nhsv.x = hsv2.x;\nhsvToRGB(hsv, tmp);\noutCol = mix(outCol, tmp, fac);\noutCol.a = col1.a;\n}\n}\nvoid node_mix_rgb_saturation(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2;\nrgbToHSV(outCol, hsv);\nif (hsv.y != 0.0) {\nrgbToHSV(col2, hsv2);\nhsv.y = facm * hsv.y + fac * hsv2.y;\nhsvToRGB(hsv, outCol);\n}\n}\nvoid node_mix_rgb_value(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\nvec4 hsv, hsv2;\nrgbToHSV(col1, hsv);\nrgbToHSV(col2, hsv2);\nhsv.z = facm * hsv.z + fac * hsv2.z;\nhsvToRGB(hsv, outCol);\n}\nvoid node_mix_rgb_color(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\noutCol = col1;\nvec4 hsv, hsv2, tmp;\nrgbToHSV(col2, hsv2);\nif (hsv2.y != 0.0) {\nrgbToHSV(outCol, hsv);\nhsv.x = hsv2.x;\nhsv.y = hsv2.y;\nhsvToRGB(hsv, tmp);\noutCol = mix(outCol, tmp, fac);\noutCol.a = col1.a;\n}\n}\n#endif\nvoid node_mix_rgb_soft_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\nfloat facm = 1.0 - fac;\nvec4 one = vec4(1.0);\nvec4 scr = one - (one - col2) * (one - col1);\noutCol = facm * col1 + fac * ((one - col1) * col2 * col1 + col1 * scr);\n}\nvoid node_mix_rgb_linear_light(float fac, vec4 col1, vec4 col2, out vec4 outCol)\n{\nfac = clamp(fac, 0.0, 1.0);\noutCol = col1 + fac * (2.0 * (col2 - vec4(0.5)));\n}",
            node_mix_shader_bl_frag: "\nvoid node_mix_shader(int transpShaderNum,\nfloat fac, vec4 color1, vec4 color2, out vec4 outColor)\n{\nif (transpShaderNum == 0)\ncolor1.rgb = color2.rgb;\nelse if (transpShaderNum == 1)\ncolor2.rgb = color1.rgb;\noutColor = mix(color1, color2, fac);\n}",
            node_new_geometry_bl_frag: "void node_new_geometry(\nbool frontFacing, vec3 viewPos, vec3 viewNorm,\nout vec3 position, out vec3 normal, out vec3 tangent,\nout vec3 trueNormal, out vec3 incoming, out vec3 parametric,\nout float backfacing, out float pointiness, out float randomPerIsland)\n{\nvec4 posWorld = invViewMatrix * vec4(-viewPos, 1.0);\nposition = swizzleUpZ(posWorld.xyz);\nvec4 viewDir = isOrtho(projectionMatrix) ? vec4(0.0, 0.0, -1.0, 0.0) : vec4(normalize(-viewPos), 0.0);\nviewDir = invViewMatrix * viewDir;\nvec3 incomingVec = -swizzleUpZ(viewDir.xyz);\n#if WORLD_NODES == 1\nnormal = incomingVec;\ntangent = vec3(0.0);\n#else\nvec3 norWorld = normalize(invViewMatrix * vec4(viewNorm, 0.0)).xyz;\nnormal = swizzleUpZ(norWorld);\nvec4 posLocal = invModelMatrix * posWorld;\nvec3 posLocalDelta = posLocal.xyz - boundingBoxMin;\nvec3 bbDelta = boundingBoxMax - boundingBoxMin;\nvec3 posOrco = vec3(\nbbDelta.x < 1e-5 ? -sign(posLocal.y) : posLocalDelta.x / bbDelta.x,\n0.0,\nbbDelta.z < 1e-5 ? sign(posLocal.y) : posLocalDelta.z / bbDelta.z\n);\nposOrco -= 0.5;\nvec3 tangWorld = (modelMatrix * vec4(posOrco.z, 0.0, -posOrco.x, 0.0)).xyz;\ntangWorld = cross(norWorld, normalize(cross(tangWorld, norWorld)));\ntangent = swizzleUpZ(tangWorld);\n#endif\ntrueNormal = normal;\nincoming = incomingVec;\nparametric = vec3(0.0);\nbackfacing = (frontFacing) ? 0.0 : 1.0;\n#if WORLD_NODES == 1\npointiness = 0.0;\n#else\npointiness = 0.5;\n#endif\nrandomPerIsland = 0.0;\n}\nvoid node_new_geometry(\nbool frontFacing, vec3 viewPos, vec3 viewNorm,\nout vec3 position, out vec3 normal, out vec3 tangent,\nout vec3 trueNormal, out vec3 incoming, out vec3 parametric,\nout float backfacing, out float pointiness) {\nfloat randomPerIsland;\nnode_new_geometry(frontFacing, viewPos, viewNorm, position, normal, tangent,\ntrueNormal, incoming, parametric, backfacing, pointiness, randomPerIsland);\n}",
            node_normal_bl_frag: "\nvoid node_normal(vec3 norParam, vec3 norIn, out vec3 norOut, out float dotOut)\n{\nnorOut = norParam;\ndotOut = dot(normalize(norIn), norParam);\n}",
            node_normal_map_bl_frag: "\nvoid node_normal_map(vec4 tangent, vec3 normal, float strength, vec4 normalColor, out vec3 normalOut)\n{\n#ifdef DOUBLE_SIDED\nnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n#endif\nvec3 normalTex = (normalColor.xyz * 2.0 - 1.0);\nvec4 viewTangent = vec4(normalize((modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz), tangent.w);\nvec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);\nnormalOut = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent \n+ normalTex.z * normal);\nnormalOut = mix(normal, normalOut, strength);\nnormalOut = normalize((invViewMatrix * vec4(normalOut, 0.0)).xyz);\nnormalOut = swizzleUpZ(normalOut);\n}",
            node_object_info_bl_frag: "\nvoid node_object_info(out vec3 location, out vec4 color, out float objIndex,\nout float matIndex, out float random) {\n#if WORLD_NODES == 1\nlocation = vec3(0.0);\ncolor = vec4(1.0);\nobjIndex = 0.0;\nmatIndex = 0.0;\nrandom = 0.0;\n#else\nlocation = vec3(0.0);\ncolor = vec4(1.0);\nobjIndex = 0.0;\nmatIndex = 0.0;\nrandom = 0.5;\n#endif\n}\nvoid node_object_info(out vec3 location, out float objIndex, out float matIndex, out float random) {\n#if WORLD_NODES == 1\nlocation = vec3(0.0);\nobjIndex = 0.0;\nmatIndex = 0.0;\nrandom = 0.0;\n#else\nlocation = vec3(0.0);\nobjIndex = 0.0;\nmatIndex = 0.0;\nrandom = 0.5;\n#endif\n}",
            node_output_bl_frag: "\nvoid node_output(vec4 rgb, float alpha, out vec4 outgoingLight)\n{\noutgoingLight = vec4(rgb.rgb, alpha);\n}",
            node_output_lamp_bl_frag: "void node_output_lamp(out vec4 outColor)\n{\noutColor = vec4(0.0);\n}",
            node_output_material_bl_frag: "\nvoid node_output_material(vec4 surface, vec4 volume, float displacement, out vec4 outgoingLight) {\noutgoingLight = surface + volume;\n}\nvoid node_output_material(vec4 surface, vec4 volume, vec3 displacement, out vec4 outgoingLight) {\noutgoingLight = surface + volume;\n}",
            node_output_world_bl_frag: "void node_output_world(vec4 surface, vec4 volume, out vec4 outgoingLight)\n{\noutgoingLight = surface;\n}",
            node_particle_info_bl_frag: "\nvoid node_particle_info(out float index, out float random, out float age,\nout float lifeTime, out vec3 location, out float size, out vec3 velocity,\nout vec3 angularVelocity) {\n#if WORLD_NODES == 1\nindex = 0.0;\nrandom = 0.0;\nage = 0.0;\nlifeTime = 0.0;\nlocation = vec3(0.0);\nsize = 0.0;\nvelocity = vec3(0.0);\nangularVelocity = vec3(0.0);\n#else\nindex = 0.0;\nrandom = 0.0;\nage = 0.0;\nlifeTime = 0.0;\nlocation = vec3(0.0);\nsize = 0.0;\nvelocity = vec3(0.0);\nangularVelocity = vec3(0.0);\n#endif\n}\nvoid node_particle_info(out float index, out float age, out float lifeTime, out vec3 location,\nout float size, out vec3 velocity, out vec3 angularVelocity) {\n#if WORLD_NODES == 1\nindex = 0.0;\nage = 0.0;\nlifeTime = 0.0;\nlocation = vec3(0.0);\nsize = 0.0;\nvelocity = vec3(0.0);\nangularVelocity = vec3(0.0);\n#else\nindex = 0.0;\nage = 0.0;\nlifeTime = 0.0;\nlocation = vec3(0.0);\nsize = 0.0;\nvelocity = vec3(0.0);\nangularVelocity = vec3(0.0);\n#endif\n}",
            node_principled_volume_bl_frag: "void node_principled_volume(vec4 color, float colorAttribute, float density,\nfloat densityAttribute, float anisotropy, vec4 absorptionColor,\nfloat emissionStrength, vec4 emissionColor, float blackbodyIntensity,\nvec4 blackbodyTint, float temperature, float temperatureAttribute,\nout vec4 volume) {\nvolume = vec4(0.0);\n}",
            node_rgb_bl_frag: "\nuniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb(vec4 color, out vec4 outColor)\n{\noutColor = color;\n}",
            node_rgbtobw_bl_frag: "\nvoid node_rgbtobw(vec4 color, out float outVal) {\noutVal = color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n}",
            node_script_bl_frag: "void node_script(out vec4 outColor)\n{\noutColor = vec4(0.0);\n}",
            node_sephsv_bl_frag: "\nvoid node_sephsv(vec4 col, out float h, out float s, out float v)\n{\nvec4 hsv;\nrgbToHSV(col, hsv);\nh = hsv[0];\ns = hsv[1];\nv = hsv[2];\n}",
            node_seprgb_bl_frag: "\nvoid node_seprgb(vec4 col, out float r, out float g, out float b)\n{\nr = col.r;\ng = col.g;\nb = col.b;\n}",
            node_sepxyz_bl_frag: "void node_sepxyz(vec3 vector, out float x, out float y, out float z)\n{\nx = vector.x;\ny = vector.y;\nz = vector.z;\n}",
            node_shadertorgb_bl_frag: "void node_shadertorgb(vec4 shader, out vec4 color, out float alpha) {\ncolor = vec4(shader.rgb, 1.0);\nalpha = shader.a;\n}",
            node_squeeze_bl_frag: "\nvoid node_squeeze(float val, float width, float center, out float outVal)\n{\noutVal = 1.0 / (1.0 + pow(2.71828183, -((val - center) * width)));\n}",
            node_subsurface_scattering_bl_frag: "void node_subsurface_scattering(\nvec4 color, float scale, vec3 radius, float sharpen, float textureBlur, vec3 normal,\nout vec4 outColor)\n{\noutColor = color;\n}",
            node_tangent_bl_frag: "void node_tangent(out vec3 outTangent)\n{\noutTangent = vec3(0.0);\n}",
            node_tex_brick_bl_frag: "void node_tex_brick(\nvec3 vector, vec4 color1, vec4 color2, vec4 mortar, float scale,\nfloat mortarSize, float mortarSmooth, float bias, float brickWidth,\nfloat rowHeight,\nout vec4 outColor, out float fac)\n{\noutColor = color1;\n}",
            node_tex_checker_bl_frag: "void node_tex_checker(vec3 vector, vec4 color1, vec4 color2, float scale, \nout vec4 outColor, out float outFac)\n{\nvec3 p = vector * scale;\np = (p + 0.00001) * 0.99999;\nfloat cx = floor(p.x);\nfloat cy = floor(p.y);\nfloat cz = floor(p.z);\nfloat result = sign(mod(cx + cy + cz, 2.0));\noutFac = max(result, 0.0);\noutColor = mix(color2, color1, outFac);\n}",
            node_tex_coord_bl_frag: "uniform mat4 nodeTexCoordObjectMatrices[NODE_TEX_COORD_NUM];\nvoid node_tex_coord(\nmat4 objectMat, vec3 viewPos, vec3 viewNorm, vec2 uv,\nout vec3 outGenerated, out vec3 outNormal, out vec3 outUV, out vec3 outObject,\nout vec3 outCamera, out vec3 outWindow, out vec3 outReflection)\n{\nvec4 view = vec4(-viewPos, 1.0);\nvec4 posWorld = invViewMatrix * view;\nvec3 loc = swizzleUpZ((invModelMatrix * posWorld).xyz);\n#if WORLD_NODES == 1\nloc = normalize(loc);\n#endif\n#if WORLD_NODES == 1\noutGenerated = loc;\n#else\nvec3 boxMin = vec3(boundingBoxMin.x, -boundingBoxMax.z, boundingBoxMin.y);\nvec3 boxMax = vec3(boundingBoxMax.x, -boundingBoxMin.z, boundingBoxMax.y);\nvec3 boxSize = boxMax - boxMin;\nif (abs(boxSize.x) < 0.001) {\noutGenerated.x = 0.5;\n} else {\noutGenerated.x = (loc.x - boxMin.x) / boxSize.x;\n}\nif (abs(boxSize.y) < 0.001) {\noutGenerated.y = 0.5;\n} else {\noutGenerated.y = (loc.y - boxMin.y) / boxSize.y;\n}\nif (abs(boxSize.z) < 0.001) {\noutGenerated.z = 0.5;\n} else {\noutGenerated.z = (loc.z - boxMin.z) / boxSize.z;\n}\n#endif\n#if WORLD_NODES == 1\noutNormal = -loc;\n#else\noutNormal = normalize(invModelMatrix * invViewMatrix * vec4(viewNorm, 0.0)).rgb;\noutNormal = swizzleUpZ(outNormal);\n#endif\n#if WORLD_NODES == 1\noutUV = vec3(0.0);\n#else\nuv.y = 1.0 - uv.y;\noutUV = vec3(uv, 0.0);\n#endif\n#if WORLD_NODES == 1\noutObject = loc;\n#else\noutObject = swizzleUpZ((objectMat * posWorld).xyz);\n#endif\noutCamera = vec3(view.xy, -view.z);\n#if WORLD_NODES == 1\noutWindow = vec3(0.0);\n#else\noutWindow = vec3(gl_FragCoord.xy / viewWidthHeight, 0.0);\n#endif\n#if WORLD_NODES == 1\noutReflection = -loc;\n#else\nvec4 reflection = (invViewMatrix * vec4(reflect(view.xyz, normalize(viewNorm)), 0.0));\noutReflection = normalize(swizzleUpZ(reflection.xyz));\n#endif\n}",
            node_tex_environment_bl_frag: "#define TEX_PROJ_EQUIRECTANGULAR 0\n#define TEX_PROJ_MIRROR_BALL     1\nvoid node_tex_environment(sampler2D tex, const int encoding, const int projection, vec3 vector, out vec4 outColor) {\nvec2 uv;\nfloat bias;\nif (projection == TEX_PROJ_EQUIRECTANGULAR) {\nvec3 direction = swizzleUpY(vector);\nif (length(direction) == 0.0) {\ndirection = vec3(0.0, 1.0, 0.0);\n} else {\ndirection = normalize(direction);\n}\nuv.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nuv.x = atan(direction.z, direction.x) * RECIPROCAL_PI2 + 0.5;\n#if WORLD_NODES == 1\nbias = -16.0;\n#else\nconst float seamWidth = 0.15;\nconst float seamBiasFactor = -10.0;\nfloat seam = max(0.0, 1.0 - abs (direction.z) / seamWidth) *\nclamp (1.0 - direction.x / seamWidth, 0.0, 1.0);\nbias = seamBiasFactor * seam;\n#endif\n} else {\nvec3 normal = normalize(vector);\nnormal.y -= 1.0;\nnormal /= (2.0 * sqrt(max(-0.5 * normal.y, 0.0)));\nuv = clamp(0.5 * normal.xz + 0.5, 0.0, 1.0);\nbias = 0.0;\n}\nuv.y = 1.0 - uv.y;\noutColor = texture2D(tex, uv, bias);\noutColor = nodeTexelToLinear(outColor, encoding);\n}",
            node_tex_environment_none_bl_frag: "void node_tex_environment_none(vec3 vector, out vec4 outColor) {\noutColor = vec4(1.0, 0.0, 1.0, 1.0);\n}",
            node_tex_gradient_bl_frag: "#define TEX_GRAD_LINEAR           0\n#define TEX_GRAD_QUADRATIC        1\n#define TEX_GRAD_EASING           2\n#define TEX_GRAD_DIAGONAL         3\n#define TEX_GRAD_SPHERICAL        4\n#define TEX_GRAD_QUADRATIC_SPHERE 5\n#define TEX_GRAD_RADIAL           6\nvoid node_tex_gradient(const int type, vec3 vector, out vec4 outColor, out float outFac)\n{\nfloat x, y, z, r;\nx = vector.x;\ny = vector.y;\nz = vector.z;\nif (type == TEX_GRAD_LINEAR) {\noutFac = x;\n} else if (type == TEX_GRAD_QUADRATIC) {\nr = max(x, 0.0);\noutFac = pow2(r);\n} else if (type == TEX_GRAD_EASING) {\nr = min(max(x, 0.0), 1.0);\noutFac = (3.0 * pow2(r) - 2.0 * pow3(r));\n} else if (type == TEX_GRAD_DIAGONAL) {\noutFac = (x + y) * 0.5;\n} else if (type == TEX_GRAD_RADIAL) {\noutFac = atan(y, x) / PI2 + 0.5;\n} else {\nr = max(0.99999 - sqrt(x * x + y * y + z * z), 0.0);\nif (type == TEX_GRAD_QUADRATIC_SPHERE) {\noutFac = pow2(r);\n} else if (type == TEX_GRAD_SPHERICAL) {\noutFac = r;\n}\n}\noutFac = clamp(outFac, 0.0, 1.0);\noutColor = vec4(outFac, outFac, outFac, 1.0);\n}",
            node_tex_ies_bl_frag: "void node_tex_ies(vec3 vector, float strength, out float fac) {\nfac = 0.0;\n}",
            node_tex_image_bl_frag: "#define TEX_PROJ_FLAT   0\n#define TEX_PROJ_BOX    1\n#define TEX_PROJ_SPHERE 2\n#define TEX_PROJ_TUBE   3\nvoid node_tex_image(sampler2D ima, const int encoding, vec3 viewNorm,\nconst int projection, const float projectionBlend, const bool clampToEdgeNoExtend,\nvec3 vector,\nout vec4 outColor, out float outAlpha) {\nif (projection == TEX_PROJ_FLAT) {\nvec2 uv = vector.xy;\nuv.y = 1.0 - uv.y;\nif (clampToEdgeNoExtend && (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)) {\noutColor = vec4(0.0);\noutAlpha = 0.0;\n} else {\noutColor = texture2D(ima, uv);\noutAlpha = outColor.a;\n}\noutColor = nodeTexelToLinear(outColor, encoding);\n} else if (projection == TEX_PROJ_BOX) {\nvec3 norm = normalize(viewNorm * normalMatrix);\nvector = swizzleUpY(vector);\nvec2 uvX = vec2(-sign(norm.x) * vector.z, -vector.y);\nvec2 uvY = vec2(sign(norm.y) * vector.z, -vector.x);\nvec2 uvZ = vec2(sign(norm.z) * vector.x, -vector.y);\nvec4 colX = nodeTexelToLinear(texture2D(ima, uvX), encoding);\nvec4 colY = nodeTexelToLinear(texture2D(ima, uvY), encoding);\nvec4 colZ = nodeTexelToLinear(texture2D(ima, uvZ), encoding);\nvec3 barycentric = abs(norm);\nbarycentric /= barycentric.x + barycentric.y + barycentric.z;\nvec3 edgeShape = min(min(barycentric.yzx, barycentric.zxy),\n(projectionBlend - 1.0) / (projectionBlend - 3.0));\nvec3 edgeValue = (1.0 - projectionBlend) * (1.0 - edgeShape) / 2.0;\nvec3 weight = max((barycentric - edgeValue) / (1.0 - edgeValue), 0.0);\nweight /= (weight.x + weight.y + weight.z);\noutColor = weight.x * colX + weight.y * colY + weight.z * colZ;\noutAlpha = outColor.a;\n} else if (projection == TEX_PROJ_SPHERE) {\nvector = normalize(vector * 2.0 - 1.0);\nvector = swizzleUpY(vector);\nvec2 uv = vec2(atan(vector.x, vector.z) / PI2, acos(vector.y) / PI);\nuv.x = mod(uv.x, 1.0);\noutColor = texture2D(ima, uv);\noutAlpha = outColor.a;\noutColor = nodeTexelToLinear(outColor, encoding);\n} else if (projection == TEX_PROJ_TUBE) {\nvector = vector * 2.0 - 1.0;\nvector = swizzleUpY(vector);\nvec2 uv = vec2(atan(vector.x, vector.z) / PI2, (1.0 - vector.y) / 2.0);\nuv.x = mod(uv.x, 1.0);\noutColor = texture2D(ima, uv);\noutAlpha = outColor.a;\noutColor = nodeTexelToLinear(outColor, encoding);\n}\n}",
            node_tex_image_none_bl_frag: "void node_tex_image_none(vec3 vector, out vec4 color, out float alpha)\n{\ncolor = vec4(1.0, 0.0, 1.0, 1.0);\nalpha = 1.0;\n}",
            node_tex_magic_bl_frag: "void node_tex_magic(vec3 vector, float scale, float distortion,\nout vec4 outColor, out float outFac)\n{\noutColor = vec4(0.0);\noutFac = 0.0;\n}",
            node_tex_musgrave_bl_frag: "void node_tex_musgrave(vec3 vector, float w, float scale, float detail,\nfloat dimension, float lacunarity, float offset, float gain,\nout float outFac) {\noutFac = 0.0;\n}\nvoid node_tex_musgrave(\nvec3 vector, float scale, float detail, float dimension, float lacunarity,\nfloat offset, float gain,\nout vec4 outColor, out float outFac)\n{\noutColor = vec4(0.0);\noutFac = 0.0;\n}",
            node_tex_noise_bl_frag: "\nvoid node_tex_noise(\nfloat falloffFactor, float dispersionFactor,\nvec3 vector, float w, float scale, float detail, float distortion,\nout float outFac, out vec4 outColor) {\nvec3 p = vector * scale;\nvec3 dx = dFdx(p);\nvec3 dy = dFdy(p);\nfloat octaveLenPerPixel = (length(dx) + length(dy)) / 4.0;\nif (distortion != 0.0) {\nvec3 r, offset = vec3(13.5, 13.5, 13.5);\nr.x = noiseSmooth(p + offset, octaveLenPerPixel, falloffFactor,\ndispersionFactor) * distortion;\nr.y = noiseSmooth(p, octaveLenPerPixel, falloffFactor,\ndispersionFactor) * distortion;\nr.z = noiseSmooth(p - offset, octaveLenPerPixel, falloffFactor,\ndispersionFactor) * distortion;\np += r;\n}\noutFac = noiseTurbulence(p, detail, octaveLenPerPixel, falloffFactor,\ndispersionFactor);\nvec3 color = vec3(outFac,\nnoiseTurbulence(vec3(p.y, p.x, p.z), detail, octaveLenPerPixel,\nfalloffFactor, dispersionFactor),\nnoiseTurbulence(vec3(p.y, p.z, p.x), detail, octaveLenPerPixel,\nfalloffFactor, dispersionFactor)\n);\noutColor = vec4(color, 1.0);\n}\nvoid node_tex_noise(\nfloat falloffFactor, float dispersionFactor,\nvec3 vector, float scale, float detail, float distortion,\nout vec4 outColor, out float outFac) {\nnode_tex_noise(falloffFactor, dispersionFactor, vector, 0.0, scale, detail, distortion, outFac, outColor);\n}",
            node_tex_pointdensity_bl_frag: "void node_tex_pointdensity(\nvec3 vector,\nout vec4 outColor, out float outDensity)\n{\noutColor = vec4(0.0);\noutDensity = 0.0;\n}",
            node_tex_sky_bl_frag: "\n#define TEX_SKY_PREETHAM 0\n#define TEX_SKY_HOSEK_WILKIE 1\n#define Km 683.0\nvoid node_tex_sky(const int skyType, vec3 param0, vec3 param1, vec3 param2, \nvec3 param3, vec3 param4, vec3 param5, vec3 param6, vec3 param7, \nvec3 param8, vec3 radiance, vec3 sunDirection, vec3 vectorIn, \nout vec4 outColor) {\nif (length(vectorIn) == 0.0) {\nvectorIn = vec3(0.0, 1.0, 0.0);\n} else {\nvectorIn = normalize(vectorIn);\n}\nvectorIn = swizzleUpY(vectorIn);\nsunDirection = swizzleUpY(sunDirection);\nfloat cosGamma = clamp(dot(vectorIn, sunDirection), -1.0, 1.0);\nfloat cosTheta = clamp(vectorIn.y, 0.0, 1.0);\nif (skyType == TEX_SKY_PREETHAM) {\nvec3 radInternal = (1.0 + param0 * exp(param1 / cosTheta)) * (\n1.0 + param2 * exp(param3 * acos(cosGamma)) \n+ param4 * pow(cosGamma, 2.0)\n);\nvec3 XYZ = xyY_to_XYZ(radInternal.y * radiance.y,\nradInternal.z * radiance.z, radInternal.x * radiance.x);\noutColor = vec4(max(xyz_to_sRGB(XYZ), 0.0), 1.0);\n} else if (skyType == TEX_SKY_HOSEK_WILKIE) {\nfloat cosGammaSq = pow(cosGamma, 2.0);\nvec3 chi = (1.0 + cosGammaSq) / pow(1.0 + pow(param8, vec3(2.0))\n- 2.0 * param8 * cosGamma, vec3(1.5));\nvec3 radInternal = (1.0 + param0 * exp(param1 / (cosTheta + 0.01))) * (\nparam2 + param3 * exp(param4 * acos(cosGamma)) \n+ param5 * cosGammaSq + param6 * chi + param7 * sqrt(cosTheta)\n);\noutColor = vec4(max(xyz_to_sRGB(radInternal * radiance), 0.0) * PI2/Km, 1.0);\n} else {\noutColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}",
            node_tex_voronoi_bl_frag: "#define DISTANCE_EUCLIDEAN 0\n#define DISTANCE_MANHATTAN 1\n#define DISTANCE_CHEBYCHEV 2\n#define DISTANCE_MINKOWSKI 3\n#define FEATURE_F1                  0\n#define FEATURE_F2                  1\n#define FEATURE_SMOOTH_F1           2\n#define FEATURE_DISTANCE_TO_EDGE    3\n#define FEATURE_N_SPHERE_RADIUS     4\nstruct VoronoiGridData {\nvec3 point;\nvec3 randVec;\nvec3 toClosest;\nfloat dist;\n};\nfloat worleyLength(vec3 vec, int distance, float exponent) {\nif (distance == DISTANCE_EUCLIDEAN) {\nreturn length(vec);\n} else if (distance == DISTANCE_MANHATTAN) {\nreturn abs(vec.x) + abs(vec.y) + abs(vec.z);\n} else if (distance == DISTANCE_CHEBYCHEV) {\nreturn max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n} else if (distance == DISTANCE_MINKOWSKI) {\nreturn pow(pow(abs(vec.x), exponent)\n+ pow(abs(vec.y), exponent)\n+ pow(abs(vec.z), exponent), 1.0 / exponent);\n}\nreturn 0.0;\n}\nvoid worleyNoise(vec3 pos, int distance, float exponent, int feature,\nfloat smoothness, float randomness, out float outDist, out vec4 outColor,\nout vec3 outPosition, out float outW, out float outRadius) {\nconst highp float RAND_FIX_ZERO = 0.125;\nvec3 posI = floor(pos);\nvec3 posF = fract(pos);\nVoronoiGridData vgd[27];\n#pragma unroll_loop\nfor (int i = 0; i <= 2; i++) {\n#pragma unroll_loop\nfor (int j = 0; j <= 2; j++) {\n#pragma unroll_loop\nfor (int k = 0; k <= 2; k++) {\nvec3 point = vec3((i), (j), (k)) - 1.0;\nvec3 randVec = rand3(posI + point + RAND_FIX_ZERO);\nvec3 toClosest = point + randomness * randVec - posF;\nconst int counter = (i) + (j) * 3 + (k) * 9;\nvgd[counter].point = point;\nvgd[counter].randVec = randVec;\nvgd[counter].toClosest = toClosest;\nvgd[counter].dist = worleyLength(toClosest, distance, exponent);\n}\n}\n}\nfloat f1 = 1e10;\nfloat f2 = 1e10;\nvec3 edgeToClosest = vec3(0.0);\nfloat distToEdge = 1e10;\nvec3 randColF1 = vec3(0.0);\nvec3 randColF2 = vec3(0.0);\nvec3 toClosestF1 = vec3(0.0);\nvec3 toClosestF2 = vec3(0.0);\nvec3 radPoint = vec3(0.0);\nvec3 radToClosest = vec3(0.0);\n#pragma unroll_loop\nfor (int i = 0; i < 27; i++) {\nif (feature == FEATURE_F1) {\nif (vgd[i].dist < f1) {\nf1 = vgd[i].dist;\nrandColF1 = vgd[i].randVec;\ntoClosestF1 = vgd[i].toClosest;\n}\n} else if (feature == FEATURE_F2) {\nif (vgd[i].dist < f1) {\nf2 = f1;\nf1 = vgd[i].dist;\nrandColF2 = randColF1;\nrandColF1 = vgd[i].randVec;\ntoClosestF2 = toClosestF1;\ntoClosestF1 = vgd[i].toClosest;\n} else if (vgd[i].dist < f2) {\nf2 = vgd[i].dist;\nrandColF2 = vgd[i].randVec;\ntoClosestF2 = vgd[i].toClosest;\n}\n} else if (feature == FEATURE_SMOOTH_F1) {\nf1 = smoothMin(f1, vgd[i].dist, smoothness);\n} else if (feature == FEATURE_DISTANCE_TO_EDGE) {\nfloat dist = worleyLength(vgd[i].toClosest, DISTANCE_EUCLIDEAN, exponent);\nif (dist < f1) {\nf1 = dist;\nedgeToClosest = vgd[i].toClosest;\n}\n} else if (feature == FEATURE_N_SPHERE_RADIUS) {\nfloat dist = worleyLength(vgd[i].toClosest, DISTANCE_EUCLIDEAN, exponent);\nif (dist < f1) {\nf1 = dist;\nradPoint = vgd[i].point;\nradToClosest = vgd[i].toClosest;\n}\n}\n}\nif (feature == FEATURE_F1) {\noutDist = f1;\noutColor = vec4(randColF1, 1.0);\noutPosition = pos + toClosestF1;\n} else if (feature == FEATURE_F2) {\noutDist = f2;\noutColor = vec4(randColF2, 1.0);\noutPosition = pos + toClosestF2;\n} else if (feature == FEATURE_SMOOTH_F1) {\noutDist = f1;\nvec3 avgCol = vec3(0.0);\nvec3 avgOff = vec3(0.0);\nfloat sumWeightsCol = 0.0;\nfloat sumWeightsOff = 0.0;\n#pragma unroll_loop\nfor (int i = 0; i < 27; i++) {\nfloat smoothFac = getSmoothFactor(f1, vgd[i].dist, smoothness);\nfloat weightOff = smoothFac * smoothFac * smoothFac;\nfloat weightCol = weightOff * smoothFac;\navgCol += vgd[i].randVec * weightCol;\navgOff += vgd[i].toClosest * weightOff;\nsumWeightsCol += weightCol;\nsumWeightsOff += weightOff;\n}\noutColor = vec4(avgCol / sumWeightsCol, 1.0);\noutPosition = pos + avgOff / sumWeightsOff;\n} else if (feature == FEATURE_DISTANCE_TO_EDGE) {\n#pragma unroll_loop\nfor (int i = 0; i < 27; i++) {\nif (vgd[i].toClosest != edgeToClosest) {\nfloat dist = dot(0.5 * (edgeToClosest + vgd[i].toClosest),\nnormalize(vgd[i].toClosest - edgeToClosest));\ndistToEdge = min(distToEdge, dist);\n}\n}\noutDist = distToEdge;\n} else if (feature == FEATURE_N_SPHERE_RADIUS) {\nfloat diam = 1e10;\n#pragma unroll_loop\nfor (int i = 0; i <= 2; i++) {\n#pragma unroll_loop\nfor (int j = 0; j <= 2; j++) {\n#pragma unroll_loop\nfor (int k = 0; k <= 2; k++) {\nvec3 localPoint = vec3((i), (j), (k)) - 1.0;\nif (length(localPoint) > 0.0) {\nvec3 point = localPoint + radPoint;\nvec3 randVec = rand3(posI + point + RAND_FIX_ZERO);\nvec3 toClosest = point + randomness * randVec - posF;\ndiam = min(diam, length(toClosest - radToClosest));\n}\n}\n}\n}\noutRadius = diam / 2.0;\n}\n}\n#define VORONOI_SMOOTH_COEFF 0.74\nvoid node_tex_voronoi(\nint distance, int feature,\nvec3 vector, float w, float scale, float smoothness, float exponent,\nfloat randomness,\nout float outDistance, out vec4 outColor, out vec3 outPosition,\nout float outW, out float outRadius) {\nvector = scale * (vector - 0.0001);\nsmoothness = clamp(smoothness, 1e-3, 1.0);\nsmoothness *= VORONOI_SMOOTH_COEFF;\nworleyNoise(vector, distance, exponent, feature, smoothness, randomness,\noutDistance, outColor, outPosition, outW, outRadius);\noutPosition /= scale;\n}\n#define DISTANCE_DISTANCE DISTANCE_EUCLIDEAN\n#define FEATURE_F3   5\n#define FEATURE_F4   6\n#define FEATURE_F2F1 7\n#define COLORING_INTENSITY 0\n#define COLORING_CELLS     1\nstruct VoronoiClosest {\nvec4 closestDists;\nvec4 closestInds;\n};\nvoid updateVoronoiClosest(inout VoronoiClosest vf, vec3 newDistances,\nvec3 newIndices) {\n#pragma unroll_loop\nfor (int i = 0; i < 3; i++) {\nfloat currDist = newDistances[i];\nfloat currIdx = newIndices[i];\n#pragma unroll_loop\nfor (int j = 0; j < 4; j++) {\nif (currDist < vf.closestDists[j]) {\nfloat tmp = vf.closestDists[j];\nvf.closestDists[j] = currDist;\ncurrDist = tmp;\ntmp = vf.closestInds[j];\nvf.closestInds[j] = currIdx;\ncurrIdx = tmp;\n}\n}\n}\n}\nvec3 worleyPermute(vec3 x) {\nreturn mod((34.0 * x + 1.0) * x, 289.0);\n}\nvec3 worleyDist(vec3 x, vec3 y, vec3 z, int distance, float exponent) {\nif (distance == DISTANCE_EUCLIDEAN) {\nreturn x * x + y * y + z * z;\n} else if (distance == DISTANCE_MANHATTAN) {\nreturn abs(x) + abs(y) + abs(z);\n} else if (distance == DISTANCE_CHEBYCHEV) {\nreturn max(max(abs(x), abs(y)), abs(z));\n} else if (distance == DISTANCE_MINKOWSKI) {\nvec3 expVec = vec3(exponent);\nreturn pow(pow(abs(x), expVec)\n+ pow(abs(y), expVec)\n+ pow(abs(z), expVec), 1.0 / expVec);\n}\nreturn vec3(0.0);\n}\nVoronoiClosest worleyClosest(vec3 P, float jitter, int distance, float exponent) {\nfloat K = 0.142857142857;\nfloat Ko = 0.428571428571;\nfloat  K2 = 0.020408163265306;\nfloat Kz = 0.166666666667;\nfloat Kzo = 0.416666666667;\nvec3 Pi = mod(floor(P), 289.0);\nvec3 Pf = fract(P) - 0.5;\nvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\nvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\nvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\nvec3 p = worleyPermute(Pi.x + vec3(-1.0, 0.0, 1.0));\nvec3 p1 = worleyPermute(p + Pi.y - 1.0);\nvec3 p2 = worleyPermute(p + Pi.y);\nvec3 p3 = worleyPermute(p + Pi.y + 1.0);\nvec3 p11 = worleyPermute(p1 + Pi.z - 1.0);\nvec3 p12 = worleyPermute(p1 + Pi.z);\nvec3 p13 = worleyPermute(p1 + Pi.z + 1.0);\nvec3 p21 = worleyPermute(p2 + Pi.z - 1.0);\nvec3 p22 = worleyPermute(p2 + Pi.z);\nvec3 p23 = worleyPermute(p2 + Pi.z + 1.0);\nvec3 p31 = worleyPermute(p3 + Pi.z - 1.0);\nvec3 p32 = worleyPermute(p3 + Pi.z);\nvec3 p33 = worleyPermute(p3 + Pi.z + 1.0);\nvec3 ox11 = fract(p11*K) - Ko;\nvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\nvec3 oz11 = floor(p11*K2)*Kz - Kzo;\nvec3 ox12 = fract(p12*K) - Ko;\nvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\nvec3 oz12 = floor(p12*K2)*Kz - Kzo;\nvec3 ox13 = fract(p13*K) - Ko;\nvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\nvec3 oz13 = floor(p13*K2)*Kz - Kzo;\nvec3 ox21 = fract(p21*K) - Ko;\nvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\nvec3 oz21 = floor(p21*K2)*Kz - Kzo;\nvec3 ox22 = fract(p22*K) - Ko;\nvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\nvec3 oz22 = floor(p22*K2)*Kz - Kzo;\nvec3 ox23 = fract(p23*K) - Ko;\nvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\nvec3 oz23 = floor(p23*K2)*Kz - Kzo;\nvec3 ox31 = fract(p31*K) - Ko;\nvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\nvec3 oz31 = floor(p31*K2)*Kz - Kzo;\nvec3 ox32 = fract(p32*K) - Ko;\nvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\nvec3 oz32 = floor(p32*K2)*Kz - Kzo;\nvec3 ox33 = fract(p33*K) - Ko;\nvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\nvec3 oz33 = floor(p33*K2)*Kz - Kzo;\nvec3 dx11 = Pfx + jitter*ox11;\nvec3 dy11 = Pfy.x + jitter*oy11;\nvec3 dz11 = Pfz.x + jitter*oz11;\nvec3 dx12 = Pfx + jitter*ox12;\nvec3 dy12 = Pfy.x + jitter*oy12;\nvec3 dz12 = Pfz.y + jitter*oz12;\nvec3 dx13 = Pfx + jitter*ox13;\nvec3 dy13 = Pfy.x + jitter*oy13;\nvec3 dz13 = Pfz.z + jitter*oz13;\nvec3 dx21 = Pfx + jitter*ox21;\nvec3 dy21 = Pfy.y + jitter*oy21;\nvec3 dz21 = Pfz.x + jitter*oz21;\nvec3 dx22 = Pfx + jitter*ox22;\nvec3 dy22 = Pfy.y + jitter*oy22;\nvec3 dz22 = Pfz.y + jitter*oz22;\nvec3 dx23 = Pfx + jitter*ox23;\nvec3 dy23 = Pfy.y + jitter*oy23;\nvec3 dz23 = Pfz.z + jitter*oz23;\nvec3 dx31 = Pfx + jitter*ox31;\nvec3 dy31 = Pfy.z + jitter*oy31;\nvec3 dz31 = Pfz.x + jitter*oz31;\nvec3 dx32 = Pfx + jitter*ox32;\nvec3 dy32 = Pfy.z + jitter*oy32;\nvec3 dz32 = Pfz.y + jitter*oz32;\nvec3 dx33 = Pfx + jitter*ox33;\nvec3 dy33 = Pfy.z + jitter*oy33;\nvec3 dz33 = Pfz.z + jitter*oz33;\nvec3 d11 = worleyDist(dx11, dy11, dz11, distance, exponent);\nvec3 d12 = worleyDist(dx12, dy12, dz12, distance, exponent);\nvec3 d13 = worleyDist(dx13, dy13, dz13, distance, exponent);\nvec3 d21 = worleyDist(dx21, dy21, dz21, distance, exponent);\nvec3 d22 = worleyDist(dx22, dy22, dz22, distance, exponent);\nvec3 d23 = worleyDist(dx23, dy23, dz23, distance, exponent);\nvec3 d31 = worleyDist(dx31, dy31, dz31, distance, exponent);\nvec3 d32 = worleyDist(dx32, dy32, dz32, distance, exponent);\nvec3 d33 = worleyDist(dx33, dy33, dz33, distance, exponent);\nVoronoiClosest vf = VoronoiClosest(vec4(1e10), vec4(0.0));\nupdateVoronoiClosest(vf, d11, p11);\nupdateVoronoiClosest(vf, d12, p12);\nupdateVoronoiClosest(vf, d13, p13);\nupdateVoronoiClosest(vf, d21, p21);\nupdateVoronoiClosest(vf, d22, p22);\nupdateVoronoiClosest(vf, d23, p23);\nupdateVoronoiClosest(vf, d31, p31);\nupdateVoronoiClosest(vf, d32, p32);\nupdateVoronoiClosest(vf, d33, p33);\nreturn vf;\n}\nvoid node_tex_voronoi(int coloring, int distance, int feature, vec3 vector,\nfloat scale, float exponent, out vec4 outColor, out float outFac) {\nvector = scale * (vector - 0.0001);\nVoronoiClosest vf = worleyClosest(vector, 1.0, distance, exponent);\nvec4 vorColorData;\nif (coloring == COLORING_INTENSITY) {\nvorColorData = vf.closestDists;\n} else if (coloring == COLORING_CELLS) {\nvorColorData = vf.closestInds;\n}\nfloat vorColorFac;\nif (feature == FEATURE_F1) {\nvorColorFac = vorColorData.x;\n} else if (feature == FEATURE_F2) {\nvorColorFac = vorColorData.y;\n} else if (feature == FEATURE_F3) {\nvorColorFac = vorColorData.z;\n} else if (feature == FEATURE_F4) {\nvorColorFac = vorColorData.w;\n} else if (feature == FEATURE_F2F1) {\nvorColorFac = vorColorData.y - vorColorData.x;\n}\nif (coloring == COLORING_INTENSITY) {\noutFac = vorColorFac;\noutColor = vec4(vec3(outFac), 1.0);\n} else if (coloring == COLORING_CELLS) {\nvorColorFac += 1e-3;\nfloat r = rand(vec2(vorColorFac / 289.0));\nfloat g = rand(vec2(vorColorFac / 23535.0));\nfloat b = rand(vec2(vorColorFac / 4353.0));\noutFac = (r + g + b) / 3.0;\noutColor = vec4(r, g, b, 1.0);\n}\n}",
            node_tex_wave_bl_frag: "#define TEX_WAVE_TYPE_BANDS 0\n#define TEX_WAVE_TYPE_RINGS 1\n#define TEX_WAVE_PROFILE_SIN 0\n#define TEX_WAVE_PROFILE_SAW 1\n#define TEX_WAVE_PROFILE_TRI 2\n#define TEX_WAVE_BANDS_DIR_X        0\n#define TEX_WAVE_BANDS_DIR_Y        1\n#define TEX_WAVE_BANDS_DIR_Z        2\n#define TEX_WAVE_BANDS_DIR_DIAGONAL 3\n#define TEX_WAVE_RINGS_DIR_X         0\n#define TEX_WAVE_RINGS_DIR_Y         1\n#define TEX_WAVE_RINGS_DIR_Z         2\n#define TEX_WAVE_RINGS_DIR_SPHERICAL 3\nvoid node_tex_wave(\nint waveType, int waveProfile, int bandsDirection, int ringsDirection,\nvec3 vector, float scale, float distortion, float detail, float detailScale,\nfloat phaseOffset,\nout vec4 outColor, out float outFac) {\nvec3 coScaled = vector * scale;\nfloat waveFac;\nvec3 waveVec = coScaled;\nif (waveType == TEX_WAVE_TYPE_BANDS) {\nconst float BANDS_AXIS_SCALE = 2.0 / 3.0;\nif (bandsDirection == TEX_WAVE_BANDS_DIR_X) {\nwaveVec = waveVec.xxx * BANDS_AXIS_SCALE;\n} else if (bandsDirection == TEX_WAVE_BANDS_DIR_Y) {\nwaveVec = waveVec.yyy * BANDS_AXIS_SCALE;\n} else if (bandsDirection == TEX_WAVE_BANDS_DIR_Z) {\nwaveVec = waveVec.zzz * BANDS_AXIS_SCALE;\n} else if (bandsDirection == TEX_WAVE_BANDS_DIR_DIAGONAL) {\n}\nwaveFac = (waveVec.x + waveVec.y + waveVec.z) * 10.0;\n} else {\nif (ringsDirection == TEX_WAVE_RINGS_DIR_X) {\nwaveVec.x = 0.0;\n} else if (ringsDirection == TEX_WAVE_RINGS_DIR_Y) {\nwaveVec.y = 0.0;\n} else if (ringsDirection == TEX_WAVE_RINGS_DIR_Z) {\nwaveVec.z = 0.0;\n} else if (ringsDirection == TEX_WAVE_RINGS_DIR_SPHERICAL) {\n}\nwaveFac = length(waveVec) * 20.0;\n}\nif (distortion != 0.0) {\nwaveFac += distortion * noiseTurbulence(coScaled * detailScale, detail,\n0.0, 0.0, 1.0);\n}\nif (waveProfile == TEX_WAVE_PROFILE_SIN) {\nwaveFac = 0.5 + 0.5 * sin(waveFac - PI_HALF + phaseOffset);\n} else if (waveProfile == TEX_WAVE_PROFILE_SAW) {\nwaveFac = fract((waveFac + phaseOffset + 1e-4) / PI2);\n} else if (waveProfile == TEX_WAVE_PROFILE_TRI) {\nwaveFac = abs(2.0 * fract((waveFac + PI + phaseOffset) / PI2) - 1.0);\n}\noutColor = vec4(waveFac, waveFac, waveFac, 1.0);\noutFac = waveFac;\n}\nvoid node_tex_wave(int waveType, int waveProfile, int bandsDirection,\nint ringsDirection, vec3 vector, float scale, float distortion,\nfloat detail, float detailScale, out vec4 outColor, out float outFac) {\nfloat legacyOffset = 0.0;\nif (waveProfile == TEX_WAVE_PROFILE_SIN) {\nlegacyOffset = PI_HALF;\n}\nnode_tex_wave(waveType, waveProfile, bandsDirection, ringsDirection, vector,\nscale, distortion, detail, detailScale, legacyOffset, outColor,\noutFac);\n}",
            node_tex_white_noise_bl_frag: "void node_tex_white_noise(vec3 vector, float w, out float outValue,\nout vec4 outColor) {\noutValue = 0.0;\noutColor = vec4(0.0);\n}\nvoid node_tex_white_noise(vec3 vector, float w, out float outValue) {\noutValue = 0.0;\n}",
            node_texture_cube_bl_frag: "\nuniform float flipCubeMap;\nvoid node_texture_cube(samplerCube ima, const int encoding, vec3 vec, out float value, out vec4 color, out vec3 normal)\n{\nvec = vec3(flipCubeMap * vec.x, vec.z, -vec.y);\ncolor = textureCube(ima, vec);\nvalue = color.a;\nnormal.x = 2.0 * (color.r - 0.5);\nnormal.y = 2.0 * (0.5 - color.g);\nnormal.z = 2.0 * (color.b - 0.5);\ncolor = nodeTexelToLinear(color, encoding);\n}",
            node_texture_bl_frag: "\nvoid node_texture(sampler2D ima, const int encoding, vec3 vec, out float value, out vec4 color, out vec3 normal)\n{\nvec2 uv = (vec.xy + vec2(1.0, 1.0)) * 0.5;\nuv.y = 1.0 - uv.y;\ncolor = texture2D(ima, uv);\nvalue = color.a;\nnormal.x = 2.0 * (color.r - 0.5);\nnormal.y = 2.0 * (0.5 - color.g);\nnormal.z = 2.0 * (color.b - 0.5);\ncolor = nodeTexelToLinear(color, encoding);\n}",
            node_texture_none_bl_frag: "\nvoid node_texture_none(vec3 vec, out float value, out vec4 color, out vec3 normal)\n{\nvalue = 0.0;\ncolor = vec4(0.0);\nnormal = vec3(0.0);\n}",
            node_uvmap_bl_frag: "void node_uvmap(vec2 uv, out vec3 outUV) {\n#if WORLD_NODES == 1\noutUV = vec3(0.0);\n#else\nuv.y = 1.0 - uv.y;\noutUV = vec3(uv, 0.0);\n#endif\n}",
            node_valtorgb_bl_frag: "\nvoid node_valtorgb(sampler2D colormap, float fac, out vec4 colOut, out float alphaOut)\n{\ncolOut = texture2D(colormap, vec2(fac, 0.0));\nalphaOut = colOut.a;\n}",
            node_value_bl_frag: "\nuniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float val, out float outVal)\n{\noutVal = val;\n}",
            node_vect_math_bl_frag: "void node_vect_math_add(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = v1 + v2;\n}\nvoid node_vect_math_subtract(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = v1 - v2;\n}\nvoid node_vect_math_multiply(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = v1 * v2;\n}\nvoid node_vect_math_divide(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec.x = v2.x == 0.0 ? 0.0 : v1.x / v2.x;\noutVec.y = v2.y == 0.0 ? 0.0 : v1.y / v2.y;\noutVec.z = v2.z == 0.0 ? 0.0 : v1.z / v2.z;\n}\nvoid node_vect_math_cross_product(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = cross(v1, v2);\n}\nvoid node_vect_math_project(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nfloat d = dot(v2, v2);\noutVec = (d != 0.0) ? (dot(v1, v2) / d) * v2 : vec3(0.0);\n}\nvoid node_vect_math_reflect(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nif (v2 != vec3(0.0)) {\nv2 = normalize(v2);\n}\noutVec = reflect(v1, v2);\n}\nvoid node_vect_math_dot_product(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVal = dot(v1, v2);\n}\nvoid node_vect_math_distance(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVal = distance(v1, v2);\n}\nvoid node_vect_math_length(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVal = length(v1);\n}\nvoid node_vect_math_scale(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = v1 * val;\n}\nvoid node_vect_math_normalize(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\nif (v1 != vec3(0.0)) {\nv1 = normalize(v1);\n}\noutVec = v1;\n}\nvoid node_vect_math_snap(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec.x = v2.x == 0.0 ? 0.0 : floor(v1.x / v2.x) * v2.x;\noutVec.y = v2.y == 0.0 ? 0.0 : floor(v1.y / v2.y) * v2.y;\noutVec.z = v2.z == 0.0 ? 0.0 : floor(v1.z / v2.z) * v2.z;\n}\nvoid node_vect_math_floor(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = floor(v1);\n}\nvoid node_vect_math_ceil(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = ceil(v1);\n}\nvoid node_vect_math_modulo(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nvec3 signProduct = sign(v1) * sign(v2);\nv1 += 1e-5 * signProduct;\noutVec.x = signProduct.x > 0.0 ? mod(v1.x, abs(v2.x)) : 0.0;\noutVec.y = signProduct.y > 0.0 ? mod(v1.y, abs(v2.y)) : 0.0;\noutVec.z = signProduct.z > 0.0 ? mod(v1.z, abs(v2.z)) : 0.0;\n}\nvoid node_vect_math_fraction(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = fract(v1);\n}\nvoid node_vect_math_absolute(vec3 v1, vec3 v2, vec3 v3, float val,\nout vec3 outVec, out float outVal) {\noutVec = abs(v1);\n}\nvoid node_vect_math_minimum(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = min(v1, v2);\n}\nvoid node_vect_math_maximum(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = max(v1, v2);\n}\nvoid node_vect_math_cosine(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = cos(v1);\n}\nvoid node_vect_math_sine(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = sin(v1);\n}\nvoid node_vect_math_tangent(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\noutVec = tan(v1);\n}\nvoid node_vect_math_wrap(vec3 v1, vec3 v2, vec3 v3, float val, out vec3 outVec,\nout float outVal) {\nv1 += 1e-5;\noutVec.x = v2.x == v3.x ? v2.x : mod(v1.x - v3.x, v2.x - v3.x) + v3.x;\noutVec.y = v2.y == v3.y ? v2.y : mod(v1.y - v3.y, v2.y - v3.y) + v3.y;\noutVec.z = v2.z == v3.z ? v2.z : mod(v1.z - v3.z, v2.z - v3.z) + v3.z;\n}\nvoid node_vect_math_absolute(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_absolute(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_add(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_add(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_ceil(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_ceil(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_cross_product(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_cross_product(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_distance(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_distance(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_divide(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_divide(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_dot_product(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_dot_product(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_floor(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_floor(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_fraction(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_fraction(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_maximum(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_maximum(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_length(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_length(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_minimum(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_minimum(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_modulo(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_modulo(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_project(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_project(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_normalize(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_normalize(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_multiply(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_multiply(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_scale(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_scale(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_reflect(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_reflect(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_subtract(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_subtract(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_snap(vec3 v1, vec3 v2, float val, out vec3 outVec,\nout float outVal) {\nnode_vect_math_snap(v1, v2, vec3(0.0), val, outVec, outVal);\n}\nvoid node_vect_math_add(vec3 v1, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVec = v1 + v2;\noutVal = (abs(outVec[0]) + abs(outVec[1]) + abs(outVec[2])) * RECIPROCAL_3;\n}\nvoid node_vect_math_subtract(vec3 v1, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVec = v1 - v2;\noutVal = (abs(outVec[0]) + abs(outVec[1]) + abs(outVec[2])) * RECIPROCAL_3;\n}\nvoid node_vect_math_average(vec3 v1, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVec = v1 + v2;\noutVal = length(outVec);\noutVec = normalize(outVec);\n}\nvoid node_vect_math_dot_product(vec3 v1, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVec = vec3(0, 0, 0);\noutVal = dot(v1, v2);\n}\nvoid node_vect_math_cross_product(vec3 v1, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVec = cross(v1, v2);\noutVal = length(outVec);\noutVec /= outVal;\n}\nvoid node_vect_math_normalize(vec3 v, vec3 v2, out vec3 outVec, out float outVal)\n{\noutVal = length(v);\noutVec = normalize(v);\n}",
            node_vect_transform_bl_frag: "\n#define VEC_TRANS_NONE     0\n#define VEC_TRANS_W_O      1\n#define VEC_TRANS_W_C      2\n#define VEC_TRANS_O_W      3\n#define VEC_TRANS_O_C      4\n#define VEC_TRANS_C_W      5\n#define VEC_TRANS_C_O      6\n#define VEC_TRANS_W_O_DIR  7\n#define VEC_TRANS_W_C_DIR  8\n#define VEC_TRANS_O_W_DIR  9\n#define VEC_TRANS_O_C_DIR 10\n#define VEC_TRANS_C_W_DIR 11\n#define VEC_TRANS_C_O_DIR 12\nvoid node_vect_transform(const int vecTransType, const int invCamZ, vec3 vIn, out vec3 vOut)\n{\nif (vecTransType == VEC_TRANS_NONE)\nvOut = vIn;\nelse {\nvec4 vec;\nif (vecTransType < VEC_TRANS_W_O_DIR)\nvec = vec4(vIn.xyz, 1.0);\nelse\nvec = vec4(vIn.xyz, 0.0);\nif (vecTransType == VEC_TRANS_W_O || vecTransType == VEC_TRANS_W_O_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = invModelMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n} else if (vecTransType == VEC_TRANS_W_C || vecTransType == VEC_TRANS_W_C_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = viewMatrix * vec;\nif (invCamZ == 1)\nvec[2] = -vec[2];\n} else if (vecTransType == VEC_TRANS_O_W || vecTransType == VEC_TRANS_O_W_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = modelMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n} else if (vecTransType == VEC_TRANS_O_C || vecTransType == VEC_TRANS_O_C_DIR) {\nvec = vec4(vec.x, vec.z, -vec.y, vec.w);\nvec = modelViewMatrix * vec;\nif (invCamZ == 1)\nvec[2] = -vec[2];\n} else if (vecTransType == VEC_TRANS_C_W || vecTransType == VEC_TRANS_C_W_DIR) {\nif (invCamZ == 1)\nvec[2] = -vec[2];\nvec = invViewMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n} else if (vecTransType == VEC_TRANS_C_O || vecTransType == VEC_TRANS_C_O_DIR) {\nif (invCamZ == 1)\nvec[2] = -vec[2];\nvec = invModelMatrix * invViewMatrix * vec;\nvec = vec4(vec.x, -vec.z, vec.y, vec.w);\n}\nvOut = vec.xyz;\n}\n}",
            node_vector_displacement_bl_frag: "void node_vector_displacement(vec4 vector, float midLevel, float scale,\nout vec3 displacement) {\ndisplacement = vec3(0.0);\n}",
            node_vector_rotate_bl_frag: "void node_vector_rotate(vec3 vector, vec3 center, vec3 axis, float angle,\nvec3 rotation, out vec3 outVector) {\noutVector = vec3(0.0);\n}",
            node_vertex_color_bl_frag: "void node_vertex_color(out vec4 color, out float alpha) {\ncolor = vec4(vec3(0.0), 1.0);\nalpha = 1.0;\n}",
            node_volume_absorption_bl_frag: "void node_volume_absorption(vec4 color, float density, out vec4 outColor)\n{\noutColor = color;\n}",
            node_volume_info_bl_frag: "void node_volume_info(out vec4 color, out float density, out float flame,\nout float temperature) {\ncolor = vec4(vec3(0.0), 1.0);\ndensity = 0.0;\nflame = 0.0;\ntemperature = 0.0;\n}",
            node_volume_scatter_bl_frag: "void node_volume_scatter(vec4 color, float density, float anisotropy, out vec4 outColor)\n{\noutColor = vec4(color);\n}",
            node_wavelength_bl_frag: "void node_wavelength(float wavelength, out vec4 outColor)\n{\noutColor = vec4(0.0);\n}",
            node_wireframe_bl_frag: "void node_wireframe(float size, out float outFac)\n{\noutFac = 0.0;\n}",
            node_bitmap_none_mx_frag: "void node_bitmap_none(out vec4 color)\n{\ncolor = vec4(1.0);\n}",
            node_bitmap_env_mx_frag: "void node_bitmap_env(sampler2D envMap, int reflectMode, float IOR,\nconst int encoding, const int alphaAsMono, const int alphaAsRGB,\nfloat uOffset, float vOffset, float uTiling, float vTiling, float wAngle, vec3 normal,\nout vec4 color, out float value)\n{\nvec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nvec3 reflectVec;\n#if WORLD_NODES\nreflectVec = normalize(cameraToVertex);\n#else\nif (reflectMode == MAX_ENV_COORDS_REFLECT)\nreflectVec = reflect(cameraToVertex, worldNormal);\nelse {\nfloat refrRatio = 1.0 / IOR;\nreflectVec = refract(cameraToVertex, worldNormal, refrRatio);\n}\n#endif\nmat3 uvTransform = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle);\ncolor = sampleEquirectangular(envMap, reflectVec, uvTransform, encoding);\nif (alphaAsMono == 1)\nvalue = color.a;\nelse\nvalue = average(color.rgb);\nif (alphaAsRGB == 1)\ncolor = vec4(color.a);\n}",
            node_bitmap_mx_frag: "void node_bitmap(sampler2D map, const vec2 uvIn, const int mapping, const int axis,\nconst ivec2 clampToEdgeNoExtend,\nconst int encoding, const int alphaAsMono, const int alphaAsRGB,\nfloat uOffset, float vOffset, float uTiling, float vTiling, float wAngle,\nout vec4 color, out float value)\n{\nvec3 coordsIn;\nif (mapping == MAPPING_EXPLICIT_MAP_CHANNEL) {\ncoordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 0.0);\n} else if (mapping == MAPPING_VERTEX_COLOR_CHANNEL) {\ncoordsIn = vec3(0.0);\n} else if (mapping == MAPPING_PLANAR_OBJECT_XYZ) {\ncoordsIn = swizzleUpZ((invModelMatrix * invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);\n} else {\ncoordsIn = swizzleUpZ((invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);\n}\nif (axis == AXIS_XY)\ncoordsIn = vec3(coordsIn.x, coordsIn.y, 1.0);\nelse if (axis == AXIS_YZ)\ncoordsIn = vec3(coordsIn.y, coordsIn.z, 1.0);\nelse if (axis == AXIS_ZX)\ncoordsIn = vec3(coordsIn.z, coordsIn.x, 1.0);\nvec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;\nvec2 uv = vec2(coordsOut.x, 1.0 - coordsOut.y);\nif ((clampToEdgeNoExtend[0] == 1 && (uvIn.x < 0.0 || uvIn.x > 1.0)) ||\n(clampToEdgeNoExtend[1] == 1 && (uvIn.y < 0.0 || uvIn.y > 1.0))) {\ncolor = vec4(0.0, 0.0, 0.0, 1.0);\n} else {\ncolor = texture2D(map, uv);\ncolor = nodeTexelToLinear(color, encoding);\n}\nif (alphaAsMono == 1)\nvalue = color.a;\nelse\nvalue = average(color.rgb);\nif (alphaAsRGB == 1)\ncolor = vec4(color.a);\n}",
            node_bump_mx_frag: "void node_bump(sampler2D bumpMap, const vec3 eyePos, const vec3 normal, const vec2 uv,\nout vec3 normalOut)\n{\nvec2 dSTdx = dFdx(uv);\nvec2 dSTdy = dFdy(uv);\nif (any(equal(dSTdx, vec2(0.0))) || any(equal(dSTdy, vec2(0.0)))) {\nnormalOut = normal;\n} else {\nconst float bumpScale = 1.0;\nvec3 vSigmaX = vec3(dFdx(eyePos.x), dFdx(eyePos.y), dFdx(eyePos.z));\nvec3 vSigmaY = vec3(dFdy(eyePos.x), dFdy(eyePos.y), dFdy(eyePos.z));\nvec3 vN = normal;\nvec3 R1 = cross(vSigmaY, vN);\nvec3 R2 = cross(vN, vSigmaX);\nfloat fDet = dot(vSigmaX, R1);\nfloat Hll = bumpScale * texture2D(bumpMap, uv).x;\nfloat dBx = bumpScale * texture2D(bumpMap, uv + dSTdx).x - Hll;\nfloat dBy = bumpScale * texture2D(bumpMap, uv + dSTdy).x - Hll;\nvec2 dHdxy = vec2(dBx, dBy);\nvec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\nnormalOut = normalize(abs(fDet) * normal - vGrad);\n}\n}",
            node_blend_mx_frag: "void node_blend(\nconst int useCurve, const float curveLower, const float curveUpper,\nconst vec4 color1, const vec4 color2, float mask,\nout vec4 color)\n{\nif (useCurve == 1)\nmask = smoothstep(curveLower, curveUpper, mask);\nelse\nmask = clamp(mask, 0.0, 1.0);\ncolor = mix(color1, color2, mask);\n}",
            node_color_correction_mx_frag: "#define REWIRE_RED        0\n#define REWIRE_GREEN      1\n#define REWIRE_BLUE       2\n#define REWIRE_ALPHA      3\n#define REWIRE_RED_INV    4\n#define REWIRE_GREEN_INV  5\n#define REWIRE_BLUE_INV   6\n#define REWIRE_ALPHA_INV  7\n#define REWIRE_MONOCHROME 8\n#define REWIRE_ONE        9\n#define REWIRE_ZERO       10\nfloat rewireChannel(int type, vec4 color)\n{\nif (type == REWIRE_RED)\nreturn color.r;\nelse if (type == REWIRE_GREEN)\nreturn color.g;\nelse if (type == REWIRE_BLUE)\nreturn color.b;\nelse if (type == REWIRE_ALPHA)\nreturn color.a;\nelse if (type == REWIRE_RED_INV)\nreturn 1.0-color.r;\nelse if (type == REWIRE_GREEN_INV)\nreturn 1.0-color.g;\nelse if (type == REWIRE_BLUE_INV)\nreturn 1.0-color.b;\nelse if (type == REWIRE_ALPHA_INV)\nreturn 1.0-color.a;\nelse if (type == REWIRE_MONOCHROME)\nreturn average(color.rgb);\nelse if (type == REWIRE_ONE)\nreturn 1.0;\nelse\nreturn 0.0;\n}\nvoid node_color_correction(const ivec4 rewire,\nconst vec4 color, const float hueShift, const float saturation,\nconst vec4 tint, const float tintStrength,\nconst float brightness, const float contrast,\nout vec4 outColor)\n{\nif (all(equal(rewire, ivec4(REWIRE_RED, REWIRE_GREEN, REWIRE_BLUE, REWIRE_ALPHA)))) {\noutColor = color;\n} else {\noutColor.r = rewireChannel(rewire.x, color);\noutColor.g = rewireChannel(rewire.y, color);\noutColor.b = rewireChannel(rewire.z, color);\noutColor.a = rewireChannel(rewire.w, color);\n}\nvec4 hsv;\nrgbToHSV(outColor, hsv);\nhsv[0] += hueShift / 360.0;\nif (hsv[0] > 1.0)\nhsv[0] -= 1.0;\nelse if (hsv[0] < 0.0)\nhsv[0] += 1.0;\nhsv[1] *= (saturation / 100.0 + 1.0);\nhsv[1] = saturate(hsv[1]);\nif (tintStrength > 0.0) {\nvec4 hsvTint;\nrgbToHSV(tint, hsvTint);\nhsv[0] = hsv[0] + (hsvTint[0] - hsv[0]) * tintStrength / 100.0;\n}\nhsvToRGB(hsv, outColor);\noutColor = (outColor - 0.5) * (contrast / 100.0 + 1.0) + 0.5 + brightness / 100.0;\noutColor = max(outColor, 0.0);\n}",
            node_color_map_mx_frag: "void node_color_map(const int reverseGamma,\nconst vec4 color, const float gamma, const float gain,\nout vec4 outColor)\n{\nfloat p = (reverseGamma == 1) ? gamma : 1.0 / gamma;\nfloat g = (reverseGamma == 1) ? (gain > EPSILON ? 1.0 / gain : 1.0) : gain;\noutColor = vec4(g * pow(abs(color.rgb), vec3(p)), color.a);\n}",
            node_composite_layer_mx_frag: "#define COMP_BLEND_NORMAL      0\n#define COMP_BLEND_AVERAGE     1\n#define COMP_BLEND_ADD         2\n#define COMP_BLEND_SUBTRACT    3\n#define COMP_BLEND_DARKEN      4\n#define COMP_BLEND_MULTIPLY    5\n#define COMP_BLEND_COLORBURN   6\n#define COMP_BLEND_LINEARBURN  7\n#define COMP_BLEND_LIGHTEN     8\n#define COMP_BLEND_SCREEN      9\n#define COMP_BLEND_COLORDODGE  10\n#define COMP_BLEND_LINEARDODGE 11\n#define COMP_BLEND_SPOT        12\n#define COMP_BLEND_SPOTBLEND   13\n#define COMP_BLEND_OVERLAY     14\n#define COMP_BLEND_SOFTLIGHT   15\n#define COMP_BLEND_HARDLIGHT   16\n#define COMP_BLEND_PINLIGHT    17\n#define COMP_BLEND_HARDMIX     18\n#define COMP_BLEND_DIFFERENCE  19\n#define COMP_BLEND_EXCLUSION   20\n#define COMP_BLEND_HUE         21\n#define COMP_BLEND_SATURATION  22\n#define COMP_BLEND_COLOR       23\n#define COMP_BLEND_VALUE       24\nvec4 calcBlending(const vec4 colorBG, const vec4 colorFG, const int blendMode) {\nif (blendMode == COMP_BLEND_NORMAL)\nreturn colorFG;\nelse if (blendMode == COMP_BLEND_AVERAGE)\nreturn (colorFG + colorBG) / 2.0;\nelse if (blendMode == COMP_BLEND_ADD)\nreturn colorBG + colorFG;\nelse if (blendMode == COMP_BLEND_SUBTRACT)\nreturn colorBG - colorFG;\nelse if (blendMode == COMP_BLEND_DARKEN)\nreturn min(colorFG, colorBG);\nelse if (blendMode == COMP_BLEND_MULTIPLY)\nreturn colorBG * colorFG;\nelse if (blendMode == COMP_BLEND_COLORBURN) {\nif (colorFG.r == 0.0 && colorFG.g == 0.0 && colorFG.b == 0.0)\nreturn vec4(0.0, 0.0, 0.0, 1.0);\nelse\nreturn max(1.0 - (1.0 - colorBG) / colorFG, 0.0);\n} else if (blendMode == COMP_BLEND_LINEARBURN)\nreturn max(colorFG + colorBG - 1.0, 0.0);\nelse if (blendMode == COMP_BLEND_LIGHTEN)\nreturn max(colorFG, colorBG);\nelse if (blendMode == COMP_BLEND_SCREEN)\nreturn colorFG + colorBG - colorFG * colorBG;\nelse if (blendMode == COMP_BLEND_COLORDODGE) {\nif (colorFG.r == 1.0 && colorFG.g == 1.0 && colorFG.b == 1.0)\nreturn vec4(1.0);\nelse\nreturn min(colorBG / (1.0 - colorFG), 1.0);\n} else if (blendMode == COMP_BLEND_LINEARDODGE)\nreturn min(colorFG + colorBG, 1.0);\nelse if (blendMode == COMP_BLEND_SPOT)\nreturn min(2.0 * colorFG * colorBG, 1.0);\nelse if (blendMode == COMP_BLEND_SPOTBLEND)\nreturn min(colorFG * colorBG + colorBG, 1.0);\nelse if (blendMode == COMP_BLEND_OVERLAY) {\nif (colorBG.r <= 0.5 && colorBG.g <= 0.5 && colorBG.b <= 0.5)\nreturn saturate(2.0 * colorFG * colorBG);\nelse\nreturn saturate(1.0 - 2.0 * (1.0-colorFG) * (1.0-colorBG));\n} else if (blendMode == COMP_BLEND_SOFTLIGHT) {\nif (colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5)\nreturn saturate(colorBG * (colorBG + 2.0 * colorFG * (1.0 - colorBG)));\nelse\nreturn saturate(colorBG + (2.0 * colorFG - 1.0) * (sqrt(colorBG) - colorBG));\n} else if (blendMode == COMP_BLEND_HARDLIGHT) {\nif (colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5)\nreturn saturate(2.0 * colorFG * colorBG);\nelse\nreturn saturate(1.0 - 2.0*(1.0 - colorFG)*(1.0 - colorBG));\n} else if (blendMode == COMP_BLEND_PINLIGHT) {\nif (((colorFG.r > 0.5 && colorFG.g > 0.5 && colorFG.b > 0.5) && all(greaterThan(colorFG, colorBG))) ||\n((colorFG.r <= 0.5 && colorFG.g <= 0.5 && colorFG.b <= 0.5) && all(lessThan(colorFG, colorBG))))\nreturn colorFG;\nelse\nreturn colorBG;\n} else if (blendMode == COMP_BLEND_HARDMIX) {\nif (colorFG.r + colorBG.r <= 1.0 && colorFG.g + colorBG.g <= 1.0 && colorFG.b + colorBG.b <= 1.0)\nreturn vec4(0.0, 0.0, 0.0, 1.0);\nelse\nreturn vec4(1.0);\n} else if (blendMode == COMP_BLEND_DIFFERENCE)\nreturn abs(colorFG - colorBG);\nelse if (blendMode == COMP_BLEND_EXCLUSION)\nreturn colorFG + colorBG - 2.0 * colorFG * colorBG;\n}\nvec4 calcBlendingHSV(const vec4 colorBG, const vec4 colorFG, const int blendMode)\n{\nvec4 hsvBG, hsvFG;\nvec4 outColor;\nif (blendMode == COMP_BLEND_HUE) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvFG[0], hsvBG[1], hsvBG[2], 1.0), outColor);\n} else if (blendMode == COMP_BLEND_SATURATION) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvBG[0], hsvFG[1], hsvBG[2], 1.0), outColor);\n} else if (blendMode == COMP_BLEND_COLOR) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvFG[0], hsvFG[1], hsvBG[2], 1.0), outColor);\n} else if (blendMode == COMP_BLEND_VALUE) {\nrgbToHSV(colorBG, hsvBG);\nrgbToHSV(colorFG, hsvFG);\nhsvToRGB(vec4(hsvBG[0], hsvBG[1], hsvFG[2], 1.0), outColor);\n}\nreturn outColor;\n}\nvoid node_composite_layer(const int blendMode, const float opacity, \nconst vec4 colorBG, const vec4 colorFG, const vec4 mask,\nout vec4 outColor)\n{\nfloat fac = saturate(opacity * average(mask.rgb));\nif (blendMode < COMP_BLEND_HUE)\noutColor = calcBlending(colorBG, colorFG, blendMode);\nelse\noutColor = calcBlendingHSV(colorBG, colorFG, blendMode);\noutColor = mix(colorBG, outColor, fac);\n}",
            node_falloff_mx_frag: "void node_falloff(vec3 viewPos, float IOR,\nconst vec4 color1, const vec4 color2, vec3 normal, out vec4 color)\n{\nfloat fac;\n\nvec3 dir = normalize(viewPos);\nfloat eta = max(IOR, 0.00001);\nfac = fresnelReflection(dir, normal, (gl_FrontFacing) ? eta : 1.0 / eta);\ncolor = mix(color1, color2, fac);\n}",
            node_gradient_ramp_mx_frag: "#define GRAD_TYPE_4_CORNER  0\n#define GRAD_TYPE_BOX       1\n#define GRAD_TYPE_DIAGONAL  2\n#define GRAD_TYPE_LIGHTING  3\n#define GRAD_TYPE_LINEAR    4\n#define GRAD_TYPE_MAPPED    5\n#define GRAD_TYPE_NORMAL    6\n#define GRAD_TYPE_PONG      7\n#define GRAD_TYPE_RADIAL    8\n#define GRAD_TYPE_SPIRAL    9\n#define GRAD_TYPE_SWEEP    10\n#define GRAD_TYPE_TARTAN   11\nvoid node_gradient_ramp(\nsampler2D gradientData, int gradientType, vec2 uvIn, vec3 geometryNormal,\nvec3 viewPos, int mapping, int axis, ivec2 clampToEdgeNoExtend,\nvec4 sourceMap, float uOffset, float vOffset, float uTiling, float vTiling, float wAngle,\nout vec4 outCol)\n{\nvec3 coordsIn;\nif (mapping == MAPPING_EXPLICIT_MAP_CHANNEL) {\ncoordsIn = vec3(uvIn.x, 1.0 - uvIn.y, 0.0);\n} else if (mapping == MAPPING_VERTEX_COLOR_CHANNEL) {\ncoordsIn = vec3(0.0);\n} else if (mapping == MAPPING_PLANAR_OBJECT_XYZ) {\ncoordsIn = swizzleUpZ((invModelMatrix * invViewMatrix * vec4(-viewPos, 1.0)).xyz);\n} else {\ncoordsIn = swizzleUpZ((invViewMatrix * vec4(-vViewPosition, 1.0)).xyz);\n}\nif (axis == AXIS_XY)\ncoordsIn = vec3(coordsIn.x, coordsIn.y, 1.0);\nelse if (axis == AXIS_YZ)\ncoordsIn = vec3(coordsIn.y, coordsIn.z, 1.0);\nelse if (axis == AXIS_ZX)\ncoordsIn = vec3(coordsIn.z, coordsIn.x, 1.0);\nvec3 coordsOut = calcUvTransform(uOffset, vOffset, uTiling, vTiling, wAngle) * coordsIn;\nfloat coord = uvIn.x;\nuvIn = coordsOut.xy;\nif ((clampToEdgeNoExtend[0] == 1 && (uvIn.x < 0.0 || uvIn.x > 1.0)) ||\n(clampToEdgeNoExtend[1] == 1 && (uvIn.y < 0.0 || uvIn.y > 1.0))) {\noutCol = vec4(0.0, 0.0, 0.0, 1.0);\nreturn;\n}\nuvIn = fract(uvIn);\nif (gradientType == GRAD_TYPE_4_CORNER) {\ncoord = pow(uvIn.x, 2.0);\n} else if (gradientType == GRAD_TYPE_BOX) {\nvec2 boxUv = abs(uvIn - vec2(0.5)) * 2.0;\ncoord = max(boxUv.x, boxUv.y);\n} else if (gradientType == GRAD_TYPE_DIAGONAL) {\ncoord = abs(uvIn.x - uvIn.y) * sqrt(2.0);\n} else if (gradientType == GRAD_TYPE_LIGHTING) {\nIncidentLight directLight;\nGeometricContext geometry;\ngeometry.position = -viewPos;\nvec3 irr = vec3(0.0);\n#if (NUM_POINT_LIGHTS > 0)\n#pragma unroll_loop\nfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\ngetPointDirectLightIrradiance(pointLights[i], geometry, directLight);\nfloat dotNL = saturate(dot(geometryNormal, directLight.direction));\nirr += dotNL * directLight.color;\n}\n#endif\n#if (NUM_SPOT_LIGHTS > 0)\n#pragma unroll_loop\nfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\ngetSpotDirectLightIrradiance(spotLights[i], geometry, directLight);\nfloat dotNL = saturate(dot(geometryNormal, directLight.direction));\nirr += dotNL * directLight.color;\n}\n#endif\n#if (NUM_DIR_LIGHTS > 0)\n#pragma unroll_loop\nfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\ngetDirectionalDirectLightIrradiance(directionalLights[i], geometry, directLight);\nfloat dotNL = saturate(dot(geometryNormal, directLight.direction));\nirr += dotNL * directLight.color;\n}\n#endif\n#if defined(PHYSICALLY_CORRECT_LIGHTS)\nirr /= PI;\n#endif\nvec3 ambIrr = getAmbientLightIrradiance(ambientLightColor);\n#if !defined(PHYSICALLY_CORRECT_LIGHTS)\nambIrr /= PI;\n#endif\nirr += ambIrr;\ncoord = (irr.x + irr.y + irr.z) / 3.0;\n} else if (gradientType == GRAD_TYPE_LINEAR) {\ncoord = uvIn.x;\n} else if (gradientType == GRAD_TYPE_MAPPED) {\ncoord = (sourceMap.x + sourceMap.y + sourceMap.z) / 3.0;\n} else if (gradientType == GRAD_TYPE_NORMAL) {\nfloat angle = acos(clamp(dot(geometryNormal, normalize(viewPos)), -1.0, 1.0));\nfloat k = 100.0;\ncoord = 1.0 - sin(pow2(k) - k * sqrt(pow2(k) - pow2(angle)));\n} else if (gradientType == GRAD_TYPE_PONG) {\nfloat y = min(uvIn.y, uvIn.x);\nfloat x = max(uvIn.y, uvIn.x);\ncoord = y / x;\n} else if (gradientType == GRAD_TYPE_RADIAL) {\ncoord = length(uvIn - vec2(0.5)) * 2.0;\n} else if (gradientType == GRAD_TYPE_SPIRAL) {\nvec2 uvSpiral = mat2(0.0, 1.0, -1.0, 0.0) * (uvIn - vec2(0.5));\ncoord = atan(uvSpiral.y, uvSpiral.x) / PI2 + 0.5;\n} else if (gradientType == GRAD_TYPE_SWEEP) {\ncoord = atan(uvIn.x, uvIn.y) / PI_HALF;\n} else if (gradientType == GRAD_TYPE_TARTAN) {\nvec2 uvTartan = abs(uvIn - vec2(0.5));\ncoord = 1.0 - min(uvTartan.x, uvTartan.y) * 2.0;\n}\noutCol = texture2D(gradientData, vec2(coord, 0.0));\n}",
            node_map_mx_frag: "\nvoid node_map(const vec4 colorIn, out vec4 color)\n{\ncolor = colorIn;\n}",
            node_mask_mx_frag: "void node_mask(const int maskInverted, \nconst vec4 color, vec4 mask,\nout vec4 outColor)\n{\nmask = (maskInverted == 1) ? vec4(vec3(1.0) - mask.rgb, mask.a) : mask;\noutColor = color * mask;\n}",
            node_material_mx_frag: "\nvoid node_material(\nfloat reflectionRatio, const float refractionRatio,\nconst int selfIllumColorOn,\nconst vec4 ambientColor, const vec4 diffuseColor, const vec4 specularColor,\nconst float glossiness, const float specularLevel, const vec4 selfIllum,\nconst float opacity, const vec4 filterColor, const vec3 normal,\nconst vec4 reflection, const vec4 refraction, const float displacement,\nout vec4 outColor)\n{\nvec3 diffuse, specular;\nNodeMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specularColor.rgb;\nmaterial.diffuseIntensity = 1.0;\nmaterial.specularHardness = 4.0 * exp2(glossiness * 10.0);\nmaterial.specularIntensity = specularLevel;\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nvec3 totalEmissiveRadiance;\nif (selfIllumColorOn == 1)\ntotalEmissiveRadiance = selfIllum.rgb;\nelse\ntotalEmissiveRadiance = vec3(selfIllum[0] * material.diffuseColor);\ndiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\ntotalEmissiveRadiance;\nspecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\nfloat specularStrength = maxFromRGB(specular);\noutColor = vec4(saturate(diffuse + specular), 1.0);\nfloat alpha = opacity - saturate(maxFromRGB(specular)) * (opacity - 1.0);\noutColor += reflection * specularColor * reflectionRatio;\noutColor += refraction * refractionRatio;\nalpha += saturate(maxFromRGB(reflection.rgb) * maxFromRGB(specularColor.rgb)) * reflectionRatio;\nalpha += saturate(maxFromRGB(refraction.rgb)) * refractionRatio;\noutColor.a = alpha;\n}",
            node_mix_mx_frag: "void node_mix(const vec4 color1, const vec4 color2, const float amount, out vec4 color)\n{\ncolor = mix(color1, color2, clamp(amount, 0.0, 1.0));\n}",
            node_normal_bump_mx_frag: "void node_normal_bump(const vec4 tangent, const vec3 normal, ivec2 flip,\nvec4 normalColor, vec3 additionalBump, float normalMult, float addBumpMult,\nout vec3 normalOut)\n{\nif (flip[0] == 1)\nnormalColor.x = 1.0 - normalColor.x;\nif (flip[1] == 0)\nnormalColor.y = 1.0 - normalColor.y;\nvec3 normalTex = (normalColor.xyz * 2.0 - 1.0);\nvec4 viewTangent = vec4(normalize(modelViewMatrix * vec4(tangent.xyz, 0.0)).xyz, tangent.w);\nvec3 bitangent = viewTangent.w * cross(normal, viewTangent.xyz);\nnormalOut = normalize(normalTex.x * viewTangent.xyz + normalTex.y * bitangent \n+ normalTex.z * normal);\nnormalOut = mix(normal, normalOut, normalMult);\nadditionalBump = mix(normal, additionalBump, addBumpMult);\nnormalOut = normalize(normalOut + additionalBump);\n}",
            node_output_map_mx_frag: "vec4 processOutputColor(vec4 color, const bool invert, const bool clampColor, const bool alphaFromRGB,\nconst float rgbLevel, const float rgbOffset, const float outputAmount)\n{\nvec3 color3 = color.rgb;\ncolor3 = clampColor ? saturate(color3) : color3;\ncolor3 = color3 * rgbLevel + vec3(rgbOffset);\ncolor3 = invert ? (vec3(1.0) - color3) : color3;\ncolor = outputAmount * vec4(color3, color.a);\ncolor.a = alphaFromRGB ? average(color.rgb) : color.a;\nreturn color;\n}\nvoid node_output_map(\nconst bool invert, const bool clampColor, const bool alphaFromRGB,\nconst vec4 color, const float rgbLevel, const float rgbOffset,\nconst float outputAmount, const float bumpAmount,\nout vec4 outColor)\n{\noutColor = processOutputColor(color, invert, clampColor, alphaFromRGB, rgbLevel, rgbOffset, outputAmount);\n}\nvoid node_output_map(\nconst bool invert, const bool clampColor, const bool alphaFromRGB, sampler2D colormap,\nvec4 color, const float rgbLevel, const float rgbOffset,\nconst float outputAmount, const float bumpAmount,\nout vec4 outColor)\n{\nfloat r = texture2D(colormap, vec2(color.r, 0.0)).r;\nfloat g = texture2D(colormap, vec2(color.g, 0.0)).g;\nfloat b = texture2D(colormap, vec2(color.b, 0.0)).b;\noutColor = processOutputColor(vec4(r, g, b, color.a),\ninvert, clampColor, alphaFromRGB, rgbLevel, rgbOffset, outputAmount);\n}",
            node_output_mx_frag: "void node_output(vec4 color, out vec4 outgoingLight)\n{\noutgoingLight = color;\n}",
            node_physical_mx_frag: "#define DEFAULT_REFLECTION_EDGE 1.0\n#define DEFAULT_REFLECTION_SLOPE 5.0\nvoid node_physical(\nvec3 geometryNormal, const float emitLuminance, const int useCustomReflCurve,\nconst float reflFacing, const float reflEdge, const float reflSlope,\nconst bool roughnessInv, const bool transRoughnessLock, const bool transRoughnessInv,\nconst bool thinWalled,\nconst float baseWeight, const vec4 baseColor, const float reflectivity,\nconst vec4 reflColor, const float roughness, const float metalness,\nconst float diffRoughness, const float anisotropy, const float anisoangle,\nconst float transparency, const vec4 transColor, const float transRoughness,\nconst float ior, const float scattering, const vec4 sssColor,\nconst float sssScale, const float emission, const vec4 emitColor,\nconst float coating, const vec4 coatColor, const float coatRoughness,\nconst vec3 normal, const vec3 clearcoatNormal, const float displacement,\nconst float cutout,\nout vec4 outColor)\n{\nNodeMaterial material;\nvec3 baseColorWeighted = baseWeight * baseColor.rgb;\nmaterial.diffuseColor = baseColorWeighted * (1.0 - transparency);\n#ifdef CLEARCOAT\nmaterial.clearcoat = saturate(coating);\nmaterial.clearcoatRoughness = clamp(coatRoughness, 0.0, 1.0);\n#endif\nfloat facing, edge, slope;\nif (useCustomReflCurve == 1) {\nfacing = reflFacing;\nedge = reflEdge;\nslope = reflSlope;\n} else {\nfacing = pow2((1.0 - ior) / (1.0 + ior));\nedge = DEFAULT_REFLECTION_EDGE;\nslope = DEFAULT_REFLECTION_SLOPE;\n}\nfloat cosTheta = saturate(dot(normal, normalize(vViewPosition)));\nfloat fresnelRefl = (facing + (edge - facing) * pow(1.0 - cosTheta, slope))\n* saturate(reflectivity + metalness);\nfloat kd = 1.0 - (metalness * (1.0 - fresnelRefl) + fresnelRefl);\nmaterial.specularColor = mix(metalness * baseColorWeighted, reflColor.rgb, fresnelRefl);\nmaterial.diffuseColor *= kd;\nmaterial.specularRoughness = clamp(roughnessInv ? (1.0 - roughness) : roughness, 0.0, 1.0);\nmaterial.refractionColor = pow(transparency * (1.0 - metalness) * transColor.rgb, vec3(2.0));\nmaterial.refractionIOR = ior;\nfloat tRough;\nif (transRoughnessLock) {\ntRough = roughnessInv ? 1.0 - roughness : roughness;\n} else {\ntRough = transRoughnessInv ? 1.0 - transRoughness : transRoughness;\n}\nmaterial.refractionRoughness = pow2(tRough);\n#ifdef ENVMAP_TYPE_CUBE_UV\nfloat geomRoughness = calcGeometryRoughness(geometryNormal);\nmaterial.specularRoughness = calcCubeUVAdjustedRoughness(\nmaterial.specularRoughness, geomRoughness);\nmaterial.refractionRoughness = calcCubeUVAdjustedRoughness(\nmaterial.refractionRoughness, geomRoughness);\n#ifdef CLEARCOAT\nmaterial.clearcoatRoughness = calcCubeUVAdjustedRoughness(\nmaterial.clearcoatRoughness, geomRoughness);\n#endif\n#endif\nReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n#define COAT_NORMAL clearcoatNormal\n#define USE_REFRACTED_LIGHT\nvec3 refractedLight = vec3(0.0);\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#undef USE_REFRACTED_LIGHT\n#undef COAT_NORMAL\nvec3 totalEmissiveRadiance = emitLuminance / LUMENS_PER_WATT * emission * emitColor.rgb;\nvec3 specular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\nvec3 outColor3 = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse +\nspecular + totalEmissiveRadiance;\nfloat alpha = 1.0;\nif (thinWalled) {\nalpha = 1.0 - saturate(transparency) + maxFromRGB(specular) * saturate(transparency);\n} else {\noutColor3 += refractedLight;\n}\noutColor = vec4(outColor3, saturate(alpha));\n}",
            node_phy_sun_sky_env_mx_frag: "vec3 perezSky(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE,\nvec3 radiance, vec3 sunDirection, vec3 direction)\n{\nfloat cosGamma = clamp(dot(direction, sunDirection), -1.0, 1.0);\nfloat cosTheta = clamp(direction.y, 0.0, 1.0);\nvec3 radInternal = (1.0 + paramA * exp(paramB / cosTheta)) * (\n1.0 + paramC * exp(paramD * acos(cosGamma))\n+ paramE * pow(cosGamma, 2.0)\n);\nfloat ciex = radInternal.y * radiance.y;\nfloat ciey = radInternal.z * radiance.z;\nfloat cieY = clamp(radInternal.x * radiance.x, 0.0, 1000000.0);\nvec3 XYZ = xyY_to_XYZ(ciex, ciey, cieY);\nreturn max(xyz_to_sRGB(XYZ), 0.0);\n}\n#define GROUND_SKY_SAMPLES 16\nvec3 groundSky(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE, vec3 radiance, vec3 sunDirection, vec3 sunIlluminance)\n{\nconst int horizSamples = GROUND_SKY_SAMPLES;\nconst int vertSamples = GROUND_SKY_SAMPLES / 2;\nvec3 result = vec3(0.0);\nfor (int horizSampleIdx = 0; horizSampleIdx < horizSamples; horizSampleIdx++) {\nfloat horizSample = float(horizSampleIdx) / float(horizSamples);\nfloat horizAngle = PI2 * horizSample;\nfor (int vertSampleIdx = 0; vertSampleIdx < vertSamples; vertSampleIdx++) {\nfloat vertSample = float(vertSampleIdx) / float(vertSamples);\nfloat y = 1.0 - vertSample;\nfloat x = sqrt(1.0 - y*y) * cos(horizAngle);\nfloat z = -sqrt(1.0 - y*y) * sin(horizAngle);\nvec3 direction = vec3(x, y, z);\nvec3 sampleColor = perezSky(paramA, paramB, paramC, paramD, paramE,\nradiance, sunDirection, direction);\n\nresult += direction.y * sampleColor;\n}\n}\nresult /= float(horizSamples * vertSamples);\nresult += (sunIlluminance * sunDirection.y) / PI;\nreturn result;\n}\nvoid node_phy_sun_sky_env(vec3 paramA, vec3 paramB, vec3 paramC, vec3 paramD, vec3 paramE,\nvec3 radiance, vec3 sunDirection, vec3 sunIlluminance, vec3 sunLuminance, \nfloat globalIntensity, vec4 groundColor,\nout vec4 outColor) \n{\nvec3 dir = vWorldPosition;\nif (length(dir) == 0.0) {\ndir = vec3(0.0, 0.0, -1.0);\n} else {\ndir = normalize(dir);\n}\nif (dir.y < 0.0) {\noutColor = groundColor * vec4(groundSky(paramA, paramB, paramC, paramD, paramE, radiance, sunDirection, sunIlluminance), 1.0);\n} else {\noutColor = vec4(perezSky(paramA, paramB, paramC, paramD, paramE,\nradiance, sunDirection, dir), 1.0);\n}\noutColor = globalIntensity * outColor;\n}",
            node_reflect_refract_mx_frag: "void node_reflect_refract(sampler2D envMap,\nint reflectMode, const float IOR, const int encoding,\nvec3 normal, out vec4 color)\n{\nvec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nvec3 reflectVec;\nif (reflectMode == MAX_ENV_COORDS_REFLECT)\nreflectVec = reflect(cameraToVertex, worldNormal);\nelse {\nfloat refrRatio = 1.0 / IOR;\nreflectVec = refract(cameraToVertex, worldNormal, refrRatio);\n}\nreflectVec = normalize(reflectVec);\ncolor = sampleEquirectangular(envMap, reflectVec, mat3(1.0), encoding);\n}",
            node_reflect_refract_color_mx_frag: "void node_reflect_refract_color(const vec4 colorIn, out vec4 color)\n{\ncolor = vec4(colorIn);\n}",
            node_rgb_multiply_mx_frag: "void node_rgb_multiply(const vec4 color1, const vec4 color2, out vec4 color)\n{\ncolor = color1 * color2;\n}",
            node_rgb_tint_mx_frag: "void node_rgb_tint(const vec4 color, const vec4 red, const vec4 green, const vec4 blue,\nout vec4 outColor)\n{\nmat3 tintMatrix = mat3(red.rgb, green.rgb, blue.rgb);\noutColor = vec4(tintMatrix * color.rgb, color.a);\n}",
            node_rgb_mx_frag: "uniform vec4 nodeRGB[NODE_RGB_NUM];\nvoid node_rgb(vec4 color, out vec4 outColor)\n{\noutColor = color;\n}",
            node_shellac_mx_frag: "void node_shellac(const vec4 color1, const vec4 color2, const float amount,\nout vec4 color)\n{\ncolor = mix(color1, color2, clamp(amount, 0.0, 1.0));\n}",
            node_tex_environment_mx_frag: "\nvoid node_tex_environment(sampler2D tex, const int encoding, vec3 vector, out vec4 outColor) {\n\nvec3 direction = swizzleUpY(vector);\nif (length(direction) == 0.0) {\ndirection = vec3(0.0, 1.0, 0.0);\n} else {\ndirection = normalize(direction);\n}\nvec2 uv;\nuv.y = asin(clamp(direction.y, - 1.0, 1.0)) * RECIPROCAL_PI + 0.5;\nuv.x = atan(direction.x, direction.z) * RECIPROCAL_PI2 + 0.5;\nuv.y *= -1.0;\nconst float seamWidth = 0.15;\nconst float seamBiasFactor = -10.0;\nfloat seam = max(0.0, 1.0 - abs (direction.x) / seamWidth) *\nclamp (1.0 - direction.z / seamWidth, 0.0, 1.0);\noutColor = texture2D(tex, uv, seamBiasFactor * seam);\noutColor = nodeTexelToLinear(outColor, encoding);\n}",
            node_value_mx_frag: "uniform float nodeValue[NODE_VALUE_NUM];\nvoid node_value(float val, out float outVal)\n{\noutVal = val;\n}",
            node_vertex_color_mx_frag: "void node_vertex_color(vec3 color, out vec4 outColor)\n{\noutColor = vec4(color, 1.0);\n}",
            node_ai_skydome_light_my_frag: "void node_ai_skydome_light(sampler2D envMap, int encoding, vec3 normal,\nfloat intensity,\nout vec4 outgoingLight)\n{\nvec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);\nvec3 worldNormal = inverseTransformDirection(normal, viewMatrix);\nvec3 reflectVec = normalize(cameraToVertex);\nmat3 uvTransform = mat3(1.0);\nvec4 color = sampleEquirectangular(envMap, reflectVec, uvTransform, encoding);\n#if LIGHT_PATH_IS_CAM_RAY\nintensity = 1.0;\n#endif\noutgoingLight = color * intensity;\n}",
            node_blend_colors_my_frag: "\nvoid node_blend_colors(float blender, vec4 color1, vec4 color2, out vec4 outColor)\n{\nblender = clamp(blender, 0.0, 1.0);\noutColor = mix(color1, color2, 1.0 - blender);\n}",
            node_light_path_my_frag: "void node_light_path(out float isCameraRay)\n{\n#if LIGHT_PATH_IS_CAM_RAY\nisCameraRay = 1.0;\n#else\nisCameraRay = 0.0;\n#endif\n}",
            node_output_my_frag: "void node_output(vec4 rgb, out vec4 outgoingLight)\n{\noutgoingLight = rgb;\n}",
            pp_plane_vert: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
            pp_bloom_composite_frag: "varying vec2 vUv;\nuniform sampler2D blurTexture1;\nuniform sampler2D blurTexture2;\nuniform sampler2D blurTexture3;\nuniform sampler2D blurTexture4;\nuniform sampler2D blurTexture5;\nuniform sampler2D dirtTexture;\nuniform float bloomStrength;\nuniform float bloomRadius;\nuniform float bloomFactors[NUM_MIPS];\nuniform vec3 bloomTintColors[NUM_MIPS];\nfloat lerpBloomFactor(const in float factor) {\nfloat mirrorFactor = 1.2 - factor;\nreturn mix(factor, mirrorFactor, bloomRadius);\n}\nvoid main() {\ngl_FragColor = bloomStrength * (\nlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\nlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\nlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\nlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\nlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv)\n);\n}",
            pp_bloom_lum_high_pass_frag: "uniform sampler2D tDiffuse;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat v = dot(texel.xyz, luma);\nvec4 outputColor = vec4(defaultColor.rgb, defaultOpacity);\nfloat alpha = smoothstep(luminosityThreshold, luminosityThreshold + smoothWidth, v);\ngl_FragColor = mix(outputColor, texel, alpha);\ngl_FragColor = clamp(gl_FragColor, 0.0, 10.0);\n}",
            pp_bloom_separable_blur_frag: "#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x/(sigma * sigma)) / sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nfloat fSigma = float(SIGMA);\nfloat weightSum = gaussianPdf(0.0, fSigma);\nvec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;\nfor (int i = 1; i < KERNEL_RADIUS; i++) {\nfloat x = float(i);\nfloat w = gaussianPdf(x, fSigma);\nvec2 uvOffset = direction * invSize * x;\nvec3 sample1 = texture2D(colorTexture, vUv + uvOffset).rgb;\nvec3 sample2 = texture2D(colorTexture, vUv - uvOffset).rgb;\ndiffuseSum += (sample1 + sample2) * w;\nweightSum += 2.0 * w;\n}\ngl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n}",
            pp_blur_frag: "#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nuniform float kernelRadius;\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nfloat weightSum = gaussianPdf(0.0, kernelRadius);\n#if LOG_SPACE == 1\nvec3 origDiffuse = texture2D(colorTexture, vUv).rgb;\nvec3 diffuseSum = vec3(weightSum);\n#else\nvec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;\n#endif\nvec2 delta = direction * invSize * kernelRadius/float(MAX_SAMPLE_RADIUS);\nvec2 uvOffset = delta;\n#if OCTAHEDRAL_MAP == 1\nvec3 cubeDir = normalize(octUVToCubeVec(vUv, invSize));\nvec3 dirX = normalize(abs(cubeDir.y) < 0.99999 ? vec3(cubeDir.z, 0.0, -cubeDir.x)\n: vec3(0.0, -cubeDir.z, cubeDir.y));\nvec3 dirY = cross(cubeDir, dirX);\n#endif\n#pragma unroll_loop\nfor (int i = 1; i <= MAX_SAMPLE_RADIUS; i++) {\nfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n#if OCTAHEDRAL_MAP == 1\nvec3 cubeOffset = uvOffset.x * dirX + uvOffset.y * dirY;\nvec2 uv1 = cubeVecToOctUV(cubeDir + cubeOffset, invSize);\nvec2 uv2 = cubeVecToOctUV(cubeDir - cubeOffset, invSize);\n#else\nvec2 uv1 = vUv + uvOffset;\nvec2 uv2 = vUv - uvOffset;\n#endif\nvec3 sample1 = texture2D(colorTexture, uv1).rgb;\nvec3 sample2 = texture2D(colorTexture, uv2).rgb;\n#if LOG_SPACE == 1\ndiffuseSum += (\nclamp(exp(sample1 - origDiffuse), 0.0, 1e38) +\nclamp(exp(sample2 - origDiffuse), 0.0, 1e38)\n) * w;\n#else\ndiffuseSum += ((sample1 + sample2) * w);\n#endif\nweightSum += 2.0 * w;\nuvOffset += delta;\n}\n#if LOG_SPACE == 1\ngl_FragColor = vec4(origDiffuse + log(diffuseSum/weightSum), 1.0);\n#else\ngl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n#endif\n}",
            pp_brightness_contrast_frag: "\nuniform sampler2D tDiffuse;\nuniform float brightness;\nuniform float contrast;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\ntexel.rgb += brightness;\nif (contrast > 0.0)\ntexel.rgb = (texel.rgb - 0.5) / (1.0 - contrast) + 0.5;\nelse\ntexel.rgb = (texel.rgb - 0.5) * (1.0 + contrast) + 0.5;\ngl_FragColor = texel;\n}",
            pp_bokeh_frag: "#include <common>\nvarying vec2 vUv;\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float maxblur;\nuniform float aperture;\nuniform float nearClip;\nuniform float farClip;\nuniform float focus;\nuniform float aspect;\nuniform float depthLeakThreshold;\n#include <packing>\nfloat getDepth(const in vec2 screenPosition) {\n#if DEPTH_PACKING == 1\nreturn unpackRGBAToDepth(texture2D(tDepth, screenPosition));\n#else\nreturn texture2D(tDepth, screenPosition).x;\n#endif\n}\nfloat getViewZ(const in float depth) {\n#if PERSPECTIVE_CAMERA == 1\nreturn perspectiveDepthToViewZ(depth, nearClip, farClip);\n#else\nreturn orthoDepthToViewZ(depth, nearClip, farClip);\n#endif\n}\nvec4 blurSample(vec2 uvOffset, vec4 centerCol, float viewZCenter) {\nfloat viewZ = -getViewZ(getDepth(vUv + uvOffset));\nfloat blurFactor = (viewZ >= viewZCenter) ? 1.0 : \nmin(depthLeakThreshold * abs((focus - viewZ) / aperture), 1.0);\nreturn mix(centerCol, texture2D(tColor, vUv + uvOffset), blurFactor);\n}\nvoid main() {\nvec2 aspectcorrect = vec2(1.0, aspect);\nfloat viewZ = -getViewZ(getDepth(vUv));\nfloat factor = abs(focus - viewZ);\n\nfloat dofblur = maxblur * min(factor / aperture, 1.0);\nfloat dofblur9 = dofblur * 0.9;\nfloat dofblur7 = dofblur * 0.7;\nfloat dofblur4 = dofblur * 0.4;\nvec4 centerCol = texture2D(tColor, vUv);\nvec4 col = centerCol;\ncol += blurSample((vec2( 0.0,   0.4 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.15,  0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.29,  0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.37,  0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.40,  0.0 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.37, -0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.15, -0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.0,  -0.4 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.15,  0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.29,  0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.37,  0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.4,   0.0 ) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.37, -0.15) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur, centerCol, viewZ);\ncol += blurSample((vec2( 0.15, -0.37) * aspectcorrect) * dofblur, centerCol, viewZ);\n\ncol += blurSample((vec2( 0.15,  0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.37,  0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2( 0.37, -0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.15, -0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.15,  0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2( 0.37,  0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2(-0.37, -0.15) * aspectcorrect) * dofblur9, centerCol, viewZ);\ncol += blurSample((vec2( 0.15, -0.37) * aspectcorrect) * dofblur9, centerCol, viewZ);\n\ncol += blurSample((vec2( 0.29,  0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.40,  0.0 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.0,  -0.4 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2(-0.29,  0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2(-0.4,   0.0 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur7, centerCol, viewZ);\ncol += blurSample((vec2( 0.0,   0.4 ) * aspectcorrect) * dofblur7, centerCol, viewZ);\n\ncol += blurSample((vec2( 0.29,  0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.4,   0.0 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.29, -0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.0,  -0.4 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2(-0.29,  0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2(-0.4,   0.0 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2(-0.29, -0.29) * aspectcorrect) * dofblur4, centerCol, viewZ);\ncol += blurSample((vec2( 0.0,   0.4 ) * aspectcorrect) * dofblur4, centerCol, viewZ);\ngl_FragColor = col / 41.0;\ngl_FragColor.a = centerCol.a;\n}",
            pp_copy_frag: "uniform sampler2D tDiffuse;\nuniform float opacity;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = (texture2D(tDiffuse, vUv));\n#if MAP_TEXELS == 1\ntexel = mapTexelToLinear(texel);\n#endif\ngl_FragColor = opacity * texel;\n#if MAP_TEXELS == 1\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#endif\n}",
            pp_cube_octahedral_proj_frag: "#include <common>\nuniform samplerCube tCube;\nuniform vec2 texelSize;\nvarying vec2 vUv;\nvoid main() {\ngl_FragColor = textureCube(tCube, octUVToCubeVec(gl_FragCoord.xy * texelSize,\ntexelSize));\n}",
            pp_fxaa_frag: "precision highp float;\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#define FXAA_PC 1\n#define FXAA_GLSL_100 1\n#define FXAA_QUALITY_PRESET 12\n#define FXAA_GREEN_AS_LUMA 1\n#ifndef FXAA_PC_CONSOLE\n#define FXAA_PC_CONSOLE 0\n#endif\n#ifndef FXAA_GLSL_120\n#define FXAA_GLSL_120 0\n#endif\n#ifndef FXAA_GLSL_130\n#define FXAA_GLSL_130 0\n#endif\n#ifndef FXAA_HLSL_3\n#define FXAA_HLSL_3 0\n#endif\n#ifndef FXAA_HLSL_4\n#define FXAA_HLSL_4 0\n#endif\n#ifndef FXAA_HLSL_5\n#define FXAA_HLSL_5 0\n#endif\n#ifndef FXAA_GREEN_AS_LUMA\n#define FXAA_GREEN_AS_LUMA 0\n#endif\n#ifndef FXAA_EARLY_EXIT\n#define FXAA_EARLY_EXIT 1\n#endif\n#ifndef FXAA_DISCARD\n#define FXAA_DISCARD 1\n#endif\n#ifndef FXAA_FAST_PIXEL_OFFSET\n#ifdef GL_EXT_gpu_shader4\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifdef GL_NV_gpu_shader5\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifdef GL_ARB_gpu_shader5\n#define FXAA_FAST_PIXEL_OFFSET 1\n#endif\n#ifndef FXAA_FAST_PIXEL_OFFSET\n#define FXAA_FAST_PIXEL_OFFSET 0\n#endif\n#endif\n#ifndef FXAA_GATHER4_ALPHA\n#if (FXAA_HLSL_5 == 1)\n#define FXAA_GATHER4_ALPHA 1\n#endif\n#ifdef GL_ARB_gpu_shader5\n#define FXAA_GATHER4_ALPHA 1\n#endif\n#ifdef GL_NV_gpu_shader5\n#define FXAA_GATHER4_ALPHA 1\n#endif\n#ifndef FXAA_GATHER4_ALPHA\n#define FXAA_GATHER4_ALPHA 0\n#endif\n#endif\n#ifndef FXAA_QUALITY_PRESET\n#define FXAA_QUALITY_PRESET 12\n#endif\n#if (FXAA_QUALITY_PRESET == 10)\n#define FXAA_QUALITY_PS 3\n#define FXAA_QUALITY_P0 1.5\n#define FXAA_QUALITY_P1 3.0\n#define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n#define FXAA_QUALITY_PS 4\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 3.0\n#define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n#define FXAA_QUALITY_PS 5\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 4.0\n#define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n#define FXAA_QUALITY_PS 6\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 4.0\n#define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n#define FXAA_QUALITY_PS 7\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 4.0\n#define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n#define FXAA_QUALITY_PS 8\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 4.0\n#define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n#define FXAA_QUALITY_PS 3\n#define FXAA_QUALITY_P0 1.5\n#define FXAA_QUALITY_P1 2.0\n#define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n#define FXAA_QUALITY_PS 4\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n#define FXAA_QUALITY_PS 5\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n#define FXAA_QUALITY_PS 6\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n#define FXAA_QUALITY_PS 7\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 3.0\n#define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n#define FXAA_QUALITY_PS 8\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 4.0\n#define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n#define FXAA_QUALITY_PS 9\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 4.0\n#define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n#define FXAA_QUALITY_PS 10\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 4.0\n#define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n#define FXAA_QUALITY_PS 11\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 4.0\n#define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n#define FXAA_QUALITY_PS 12\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.5\n#define FXAA_QUALITY_P2 2.0\n#define FXAA_QUALITY_P3 2.0\n#define FXAA_QUALITY_P4 2.0\n#define FXAA_QUALITY_P5 2.0\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 2.0\n#define FXAA_QUALITY_P10 4.0\n#define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n#define FXAA_QUALITY_PS 12\n#define FXAA_QUALITY_P0 1.0\n#define FXAA_QUALITY_P1 1.0\n#define FXAA_QUALITY_P2 1.0\n#define FXAA_QUALITY_P3 1.0\n#define FXAA_QUALITY_P4 1.0\n#define FXAA_QUALITY_P5 1.5\n#define FXAA_QUALITY_P6 2.0\n#define FXAA_QUALITY_P7 2.0\n#define FXAA_QUALITY_P8 2.0\n#define FXAA_QUALITY_P9 2.0\n#define FXAA_QUALITY_P10 4.0\n#define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n#define FxaaBool bool\n#define FxaaDiscard discard\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 ivec2\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTex sampler2D\n#else\n#define FxaaBool bool\n#define FxaaDiscard clip(-1)\n#define FxaaFloat float\n#define FxaaFloat2 float2\n#define FxaaFloat3 float3\n#define FxaaFloat4 float4\n#define FxaaHalf half\n#define FxaaHalf2 half2\n#define FxaaHalf3 half3\n#define FxaaHalf4 half4\n#define FxaaSat(x) saturate(x)\n#endif\n#if (FXAA_GLSL_100 == 1)\n#define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n#if (FXAA_GLSL_120 == 1)\n#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n#if (FXAA_FAST_PIXEL_OFFSET == 1)\n#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n#else\n#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n#endif\n#if (FXAA_GATHER4_ALPHA == 1)\n#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n#endif\n#endif\n#if (FXAA_GLSL_130 == 1)\n#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n#if (FXAA_GATHER4_ALPHA == 1)\n#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n#endif\n#endif\n#if (FXAA_HLSL_3 == 1)\n#define FxaaInt2 float2\n#define FxaaTex sampler2D\n#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n#if (FXAA_HLSL_4 == 1)\n#define FxaaInt2 int2\nstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n#if (FXAA_HLSL_5 == 1)\n#define FxaaInt2 int2\nstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n#if (FXAA_GREEN_AS_LUMA == 0)\nFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\nFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n#if (FXAA_PC == 1)\nFxaaFloat4 FxaaPixelShader(\nFxaaFloat2 pos,\nFxaaFloat4 fxaaConsolePosPos,\nFxaaTex tex,\nFxaaTex fxaaConsole360TexExpBiasNegOne,\nFxaaTex fxaaConsole360TexExpBiasNegTwo,\nFxaaFloat2 fxaaQualityRcpFrame,\nFxaaFloat4 fxaaConsoleRcpFrameOpt,\nFxaaFloat4 fxaaConsoleRcpFrameOpt2,\nFxaaFloat4 fxaaConsole360RcpFrameOpt2,\nFxaaFloat fxaaQualitySubpix,\nFxaaFloat fxaaQualityEdgeThreshold,\nFxaaFloat fxaaQualityEdgeThresholdMin,\nFxaaFloat fxaaConsoleEdgeSharpness,\nFxaaFloat fxaaConsoleEdgeThreshold,\nFxaaFloat fxaaConsoleEdgeThresholdMin,\nFxaaFloat4 fxaaConsole360ConstDir\n) {\nFxaaFloat2 posM;\nposM.x = pos.x;\nposM.y = pos.y;\n#if (FXAA_GATHER4_ALPHA == 1)\n#if (FXAA_DISCARD == 0)\nFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n#if (FXAA_GREEN_AS_LUMA == 0)\n#define lumaM rgbyM.w\n#else\n#define lumaM rgbyM.y\n#endif\n#endif\n#if (FXAA_GREEN_AS_LUMA == 0)\nFxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\nFxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n#else\nFxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\nFxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n#endif\n#if (FXAA_DISCARD == 1)\n#define lumaM luma4A.w\n#endif\n#define lumaE luma4A.z\n#define lumaS luma4A.x\n#define lumaSE luma4A.y\n#define lumaNW luma4B.w\n#define lumaN luma4B.z\n#define lumaW luma4B.x\n#else\nFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n#if (FXAA_GREEN_AS_LUMA == 0)\n#define lumaM rgbyM.w\n#else\n#define lumaM rgbyM.y\n#endif\n#if (FXAA_GLSL_100 == 1)\nFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, 1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 0.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0,-1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n#else\nFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, 1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0,-1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n#endif\n#endif\nFxaaFloat maxSM = max(lumaS, lumaM);\nFxaaFloat minSM = min(lumaS, lumaM);\nFxaaFloat maxESM = max(lumaE, maxSM);\nFxaaFloat minESM = min(lumaE, minSM);\nFxaaFloat maxWN = max(lumaN, lumaW);\nFxaaFloat minWN = min(lumaN, lumaW);\nFxaaFloat rangeMax = max(maxWN, maxESM);\nFxaaFloat rangeMin = min(minWN, minESM);\nFxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\nFxaaFloat range = rangeMax - rangeMin;\nFxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\nFxaaBool earlyExit = range < rangeMaxClamped;\nif(earlyExit)\n#if (FXAA_DISCARD == 1)\nreturn rgbyM;\n#else\nreturn rgbyM;\n#endif\n#if (FXAA_GATHER4_ALPHA == 0)\n#if (FXAA_GLSL_100 == 1)\nFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0,-1.0), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n#else\nFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1,-1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n#endif\n#else\nFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\nFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n#endif\nFxaaFloat lumaNS = lumaN + lumaS;\nFxaaFloat lumaWE = lumaW + lumaE;\nFxaaFloat subpixRcpRange = 1.0/range;\nFxaaFloat subpixNSWE = lumaNS + lumaWE;\nFxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\nFxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\nFxaaFloat lumaNESE = lumaNE + lumaSE;\nFxaaFloat lumaNWNE = lumaNW + lumaNE;\nFxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\nFxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\nFxaaFloat lumaNWSW = lumaNW + lumaSW;\nFxaaFloat lumaSWSE = lumaSW + lumaSE;\nFxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\nFxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\nFxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\nFxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\nFxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\nFxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\nFxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\nFxaaFloat lengthSign = fxaaQualityRcpFrame.x;\nFxaaBool horzSpan = edgeHorz >= edgeVert;\nFxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\nif(!horzSpan) lumaN = lumaW;\nif(!horzSpan) lumaS = lumaE;\nif(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\nFxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\nFxaaFloat gradientN = lumaN - lumaM;\nFxaaFloat gradientS = lumaS - lumaM;\nFxaaFloat lumaNN = lumaN + lumaM;\nFxaaFloat lumaSS = lumaS + lumaM;\nFxaaBool pairN = abs(gradientN) >= abs(gradientS);\nFxaaFloat gradient = max(abs(gradientN), abs(gradientS));\nif(pairN) lengthSign = -lengthSign;\nFxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\nFxaaFloat2 posB;\nposB.x = posM.x;\nposB.y = posM.y;\nFxaaFloat2 offNP;\noffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\noffNP.y = (horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\nif(!horzSpan) posB.x += lengthSign * 0.5;\nif(horzSpan) posB.y += lengthSign * 0.5;\nFxaaFloat2 posN;\nposN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\nposN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\nFxaaFloat2 posP;\nposP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\nposP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\nFxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\nFxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\nFxaaFloat subpixE = subpixC * subpixC;\nFxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\nif(!pairN) lumaNN = lumaSS;\nFxaaFloat gradientScaled = gradient * 1.0/4.0;\nFxaaFloat lumaMM = lumaM - lumaNN * 0.5;\nFxaaFloat subpixF = subpixD * subpixE;\nFxaaBool lumaMLTZero = lumaMM < 0.0;\nlumaEndN -= lumaNN * 0.5;\nlumaEndP -= lumaNN * 0.5;\nFxaaBool doneN = abs(lumaEndN) >= gradientScaled;\nFxaaBool doneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\nFxaaBool doneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n#if (FXAA_QUALITY_PS > 3)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n#if (FXAA_QUALITY_PS > 4)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n#if (FXAA_QUALITY_PS > 5)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n#if (FXAA_QUALITY_PS > 6)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n#if (FXAA_QUALITY_PS > 7)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n#if (FXAA_QUALITY_PS > 8)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n#if (FXAA_QUALITY_PS > 9)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n#if (FXAA_QUALITY_PS > 10)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n#if (FXAA_QUALITY_PS > 11)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n#if (FXAA_QUALITY_PS > 12)\nif(doneNP) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\nif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\nif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\nif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\ndoneN = abs(lumaEndN) >= gradientScaled;\ndoneP = abs(lumaEndP) >= gradientScaled;\nif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\nif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\ndoneNP = (!doneN) || (!doneP);\nif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\nif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\n#endif\n}\nFxaaFloat dstN = posM.x - posN.x;\nFxaaFloat dstP = posP.x - posM.x;\nif(!horzSpan) dstN = posM.y - posN.y;\nif(!horzSpan) dstP = posP.y - posM.y;\nFxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\nFxaaFloat spanLength = (dstP + dstN);\nFxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\nFxaaFloat spanLengthRcp = 1.0/spanLength;\nFxaaBool directionN = dstN < dstP;\nFxaaFloat dst = min(dstN, dstP);\nFxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\nFxaaFloat subpixG = subpixF * subpixF;\nFxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\nFxaaFloat subpixH = subpixG * fxaaQualitySubpix;\nFxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\nFxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\nif(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\nif(horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n#if (FXAA_DISCARD == 1)\nreturn FxaaTexTop(tex, posM);\n#else\nreturn FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n#endif\n}\n#endif\nvoid main() {\ngl_FragColor = FxaaPixelShader(\nvUv,\nvec4(0.0),\ntDiffuse,\ntDiffuse,\ntDiffuse,\nresolution,\nvec4(0.0),\nvec4(0.0),\nvec4(0.0),\n0.75,\n0.166,\n0.0833,\n0.0,\n0.0,\n0.0,\nvec4(0.0)\n);\n\n}",
            pp_grayscale_frag: "uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\nfloat bw = texel.r * 0.35 + texel.g * 0.45 + texel.b * 0.2;\ntexel = vec4(bw, bw, bw, texel.a);\ngl_FragColor = texel;\n}",
            pp_outline_edge_frag: "varying vec2 vUv;\nuniform sampler2D maskTexture;\nuniform vec2 texSize;\nuniform vec4 visibleEdgeColor;\nuniform vec4 hiddenEdgeColor;\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\nvec4 c1 = texture2D(maskTexture, vUv + uvOffset.xy);\nvec4 c2 = texture2D(maskTexture, vUv - uvOffset.xy);\nvec4 c3 = texture2D(maskTexture, vUv + uvOffset.yw);\nvec4 c4 = texture2D(maskTexture, vUv - uvOffset.yw);\nfloat diff1 = (c1.r - c2.r) * 0.5;\nfloat diff2 = (c3.r - c4.r) * 0.5;\nfloat d = length(vec2(diff1, diff2));\nfloat a1 = min(c1.g, c2.g);\nfloat a2 = min(c3.g, c4.g);\nfloat visibilityFactor = min(a1, a2);\nvec4 edgeColor = (1.0 - visibilityFactor > 0.001) ? visibleEdgeColor : hiddenEdgeColor;\ngl_FragColor = edgeColor * vec4(d);\n}",
            pp_outline_blur_frag: "#include <common>\nvarying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;\nuniform vec2 direction;\nuniform float kernelRadius;\nfloat gaussianPdf(in float x, in float sigma) {\nreturn 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;\n}\nvoid main() {\nvec2 invSize = 1.0 / texSize;\nfloat weightSum = gaussianPdf(0.0, kernelRadius);\nvec4 diffuseSum = texture2D(colorTexture, vUv);\n#if defined(LOG_SPACE)\ndiffuseSum = exp(diffuseSum);\n#endif\ndiffuseSum *= weightSum;\nvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\nvec2 uvOffset = delta;\nfor (int i = 1; i <= MAX_RADIUS; i++) {\nfloat w = gaussianPdf(uvOffset.x, kernelRadius);\nvec4 sample1 = texture2D(colorTexture, vUv + uvOffset);\nvec4 sample2 = texture2D(colorTexture, vUv - uvOffset);\n#if defined(LOG_SPACE)\nsample1 = exp(sample1);\nsample2 = exp(sample2);\n#endif\ndiffuseSum += ((sample1 + sample2) * w);\nweightSum += (2.0 * w);\nuvOffset += delta;\n}\nvec4 finalCol = diffuseSum / weightSum;\n#if defined(LOG_SPACE)\nfinalCol = log(finalCol);\n#endif\ngl_FragColor = finalCol;\n}",
            pp_outline_overlay_frag: "varying vec2 vUv;\nuniform sampler2D maskTexture;\nuniform sampler2D edgeTexture1;\nuniform sampler2D edgeTexture2;\nuniform sampler2D patternTexture;\nuniform float edgeStrength;\nuniform float edgeGlow;\nuniform bool usePatternTexture;\nvoid main() {\nvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\nvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\nvec4 maskColor = texture2D(maskTexture, vUv);\nvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\nfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\nvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\nvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\nif (usePatternTexture)\nfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\nfloat maxChannel = max(finalColor.r, max(finalColor.g, finalColor.b));\nif (maxChannel != 0.0) {\nfinalColor.rgb /= maxChannel;\n}\ngl_FragColor = finalColor;\n}",
            pp_ssao_blur_frag: "uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvoid main() {\nvec2 texelSize = (1.0 / resolution);\nfloat result = 0.0;\nfor (int i = - 2; i <= 2; i++) {\nfor (int j = - 2; j <= 2; j ++) {\nvec2 offset = (vec2(float(i), float(j))) * texelSize;\nresult += texture2D(tDiffuse, vUv + offset).r;\n}\n}\ngl_FragColor = vec4(vec3(result / (5.0 * 5.0)), 1.0);\n}",
            pp_ssao_depth_frag: "uniform sampler2D tDepth;\nuniform float cameraNear;\nuniform float cameraFar;\nvarying vec2 vUv;\n#include <packing>\nfloat getLinearDepth(const in vec2 screenPosition) {\n#if PERSPECTIVE_CAMERA == 1\nfloat fragCoordZ = texture2D(tDepth, screenPosition).x;\nfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\nreturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n#else\nreturn texture2D(depthSampler, coord).x;\n#endif\n}\nvoid main() {\nfloat depth = getLinearDepth(vUv);\ngl_FragColor = vec4(vec3(1.0 - depth), 1.0);\n}",
            pp_ssao_frag: "uniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tDepth;\nuniform sampler2D tNoise;\nuniform vec3 kernel[KERNEL_SIZE];\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\nuniform float kernelRadius;\nuniform float minDistance;\nuniform float maxDistance;\nvarying vec2 vUv;\n#include <packing>\nfloat getDepth(const in vec2 screenPosition) {\nreturn texture2D(tDepth, screenPosition).x;\n}\nfloat getLinearDepth(const in vec2 screenPosition) {\n#if PERSPECTIVE_CAMERA == 1\nfloat fragCoordZ = texture2D(tDepth, screenPosition).x;\nfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\nreturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\n#else\nreturn texture2D(depthSampler, coord).x;\n#endif\n}\nfloat getViewZ(const in float depth) {\n#if PERSPECTIVE_CAMERA == 1\nreturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n#endif\n}\nvec3 getViewPosition(const in vec2 screenPosition, const in float depth, const in float viewZ) {\nfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\nvec4 clipPosition = vec4((vec3(screenPosition, depth) - 0.5) * 2.0, 1.0);\nclipPosition *= clipW;\nreturn (cameraInverseProjectionMatrix * clipPosition).xyz;\n}\nvec3 getViewNormal(const in vec2 screenPosition) {\nreturn unpackRGBToNormal(texture2D(tNormal, screenPosition).xyz);\n}\nvoid main() {\nfloat depth = getDepth(vUv);\nfloat viewZ = getViewZ(depth);\nvec3 viewPosition = getViewPosition(vUv, depth, viewZ);\nvec3 viewNormal = getViewNormal(vUv);\nvec2 noiseScale = vec2(resolution.x / 4.0, resolution.y / 4.0);\nvec3 random = texture2D(tNoise, vUv * noiseScale).xyz;\nvec3 tangent = normalize(random - viewNormal * dot(random, viewNormal));\nvec3 bitangent = cross(viewNormal, tangent);\nmat3 kernelMatrix = mat3(tangent, bitangent, viewNormal);\nfloat occlusion = 0.0;\nfor (int i = 0; i < KERNEL_SIZE; i++) {\nvec3 sampleVector = kernelMatrix * kernel[i];\nvec3 samplePoint = viewPosition + (sampleVector * kernelRadius);\nvec4 samplePointNDC = cameraProjectionMatrix * vec4(samplePoint, 1.0);\nsamplePointNDC /= samplePointNDC.w;\nvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\nfloat realDepth = getLinearDepth(samplePointUv);\nfloat sampleDepth = viewZToOrthographicDepth(samplePoint.z, cameraNear, cameraFar);\nfloat delta = sampleDepth - realDepth;\nif (delta > minDistance && delta < maxDistance) {\nocclusion += 1.0;\n}\n}\nocclusion = clamp(occlusion / float(KERNEL_SIZE), 0.0, 1.0);\ngl_FragColor = vec4(vec3(1.0 - occlusion), 1.0);\n}",
            pp_tonemap_frag: "uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D(tDiffuse, vUv);\nfloat alpha = clamp(texel.a, 0.0, 1.0);\ngl_FragColor = texel;\ngl_FragColor.rgb /= alpha;\n#include <tonemapping_fragment>\ngl_FragColor = LinearTosRGB(gl_FragColor);\ngl_FragColor.rgb *= alpha;\n}",
            raw_meshline_frag: "precision mediump float;\nuniform sampler2D map;\nuniform sampler2D alphaMap;\nuniform float useMap;\nuniform float useAlphaMap;\nuniform float visibility;\nuniform float alphaTest;\nuniform vec2 repeat;\nuniform vec3 color;\nuniform float opacity;\nvarying vec2 vUV;\nvarying float vCounters;\n#include <encodings_pars_fragment>\nvoid main() {\nvec4 c = vec4(color, opacity);\nif (useMap == 1.0) {\nc *= texture2D(map, vUV * repeat);\n}\nif (useAlphaMap == 1.0) {\nc.a *= texture2D(alphaMap, vUV * repeat).a;\n}\nif (c.a < alphaTest) {\ndiscard;\n}\ngl_FragColor = c;\ngl_FragColor.a *= step(vCounters, visibility);\ngl_FragColor = LinearTosRGB(gl_FragColor);\n}",
            raw_meshline_vert: "precision highp float;\nattribute vec3 position;\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\nattribute vec2 uv;\nattribute float counters;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\nvarying float vCounters;\nvarying vec2 vUV;\nconst float EQ_EPS = 0.000001;\nvec2 fix(vec4 i, float aspect) {\nvec2 res = i.xy / i.w;\nres.x *= aspect;\nreturn res;\n}\nbool posEqual(vec2 pos0, vec2 pos1) {\nreturn length(pos0 - pos1) < EQ_EPS;\n}\nvoid main() {\nfloat aspect = resolution.x / resolution.y;\nvCounters = counters;\nvUV = uv;\nmat4 m = projectionMatrix * modelViewMatrix;\nvec4 finalPosition = m * vec4(position, 1.0);\nvec4 prevPos = m * vec4(previous, 1.0);\nvec4 nextPos = m * vec4(next, 1.0);\nvec2 currentP = fix(finalPosition, aspect);\nvec2 prevP = fix(prevPos, aspect);\nvec2 nextP = fix(nextPos, aspect);\nfloat w = lineWidth * width;\nif (sizeAttenuation == 0.0) {\nw *= finalPosition.w / resolution.x;\n}\nvec2 dir;\nif (posEqual(nextP, currentP)) {\ndir = normalize(currentP - prevP);\n} else if (posEqual(prevP, currentP)) {\ndir = normalize(nextP - currentP);\n} else {\nvec2 dir1 = normalize(currentP - prevP);\nvec2 dir2 = normalize(nextP - currentP);\ndir = normalize(dir1 + dir2);\n}\nvec2 offset = vec2(-dir.y, dir.x);\noffset.y *= aspect;\noffset *= w;\nfinalPosition.xy += offset * side;\ngl_Position = finalPosition;\n}"
        },
        Ji = {
            basic: {
                uniforms: Ri([Wi.common, Wi.specularmap, Wi.envmap, Wi.aomap, Wi.lightmap, Wi.fog]),
                vertexShader: Ki.meshbasic_vert,
                fragmentShader: Ki.meshbasic_frag
            },
            lambert: {
                uniforms: Ri([Wi.common, Wi.specularmap, Wi.envmap, Wi.aomap, Wi.lightmap, Wi.emissivemap, Wi.fog, Wi.lights, {
                    emissive: {
                        value: new Pr(0)
                    }
                }]),
                vertexShader: Ki.meshlambert_vert,
                fragmentShader: Ki.meshlambert_frag
            },
            phong: {
                uniforms: Ri([Wi.common, Wi.specularmap, Wi.envmap, Wi.aomap, Wi.lightmap, Wi.emissivemap, Wi.bumpmap, Wi.normalmap, Wi.displacementmap, Wi.fog, Wi.lights, {
                    emissive: {
                        value: new Pr(0)
                    },
                    specular: {
                        value: new Pr(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Ki.meshphong_vert,
                fragmentShader: Ki.meshphong_frag
            },
            standard: {
                uniforms: Ri([Wi.common, Wi.envmap, Wi.aomap, Wi.lightmap, Wi.emissivemap, Wi.bumpmap, Wi.normalmap, Wi.displacementmap, Wi.roughnessmap, Wi.metalnessmap, Wi.fog, Wi.lights, {
                    emissive: {
                        value: new Pr(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Ki.meshphysical_vert,
                fragmentShader: Ki.meshphysical_frag
            },
            toon: {
                uniforms: Ri([Wi.common, Wi.specularmap, Wi.aomap, Wi.lightmap, Wi.emissivemap, Wi.bumpmap, Wi.normalmap, Wi.displacementmap, Wi.gradientmap, Wi.fog, Wi.lights, {
                    emissive: {
                        value: new Pr(0)
                    },
                    specular: {
                        value: new Pr(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Ki.meshtoon_vert,
                fragmentShader: Ki.meshtoon_frag
            },
            matcap: {
                uniforms: Ri([Wi.common, Wi.bumpmap, Wi.normalmap, Wi.displacementmap, Wi.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: Ki.meshmatcap_vert,
                fragmentShader: Ki.meshmatcap_frag
            },
            points: {
                uniforms: Ri([Wi.points, Wi.fog]),
                vertexShader: Ki.points_vert,
                fragmentShader: Ki.points_frag
            },
            dashed: {
                uniforms: Ri([Wi.common, Wi.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: Ki.linedashed_vert,
                fragmentShader: Ki.linedashed_frag
            },
            depth: {
                uniforms: Ri([Wi.common, Wi.displacementmap, {
                    slopeScaledBias: {
                        value: 0
                    }
                }]),
                vertexShader: Ki.depth_vert,
                fragmentShader: Ki.depth_frag
            },
            normal: {
                uniforms: Ri([Wi.common, Wi.bumpmap, Wi.normalmap, Wi.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ki.normal_vert,
                fragmentShader: Ki.normal_frag
            },
            sprite: {
                uniforms: Ri([Wi.sprite, Wi.fog]),
                vertexShader: Ki.sprite_vert,
                fragmentShader: Ki.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new Zt
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: Ki.background_vert,
                fragmentShader: Ki.background_frag
            },
            cube: {
                uniforms: Ri([Wi.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ki.cube_vert,
                fragmentShader: Ki.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    },
                    invertU: {
                        value: !1
                    },
                    offsetU: {
                        value: 0
                    }
                },
                vertexShader: Ki.equirect_vert,
                fragmentShader: Ki.equirect_frag
            },
            distanceRGBA: {
                uniforms: Ri([Wi.common, Wi.displacementmap, {
                    referencePosition: {
                        value: new on
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    },
                    slopeScaledBias: {
                        value: 0
                    }
                }]),
                vertexShader: Ki.distanceRGBA_vert,
                fragmentShader: Ki.distanceRGBA_frag
            },
            shadow: {
                uniforms: Ri([Wi.lights, Wi.fog, {
                    color: {
                        value: new Pr(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ki.shadow_vert,
                fragmentShader: Ki.shadow_frag
            },
            mask: {
                uniforms: Ri([Wi.common, Wi.displacementmap, Wi.mask]),
                vertexShader: Ki.mask_vert,
                fragmentShader: Ki.mask_frag
            },
            equicube: {
                uniforms: {
                    tEquirect: {
                        value: null
                    },
                    faceIndex: {
                        value: 0
                    },
                    invertU: {
                        value: !1
                    },
                    offsetU: {
                        value: 0
                    }
                },
                vertexShader: Ki.equicube_vert,
                fragmentShader: Ki.equicube_frag
            },
            node: {
                uniforms: Ri([Wi.common, Wi.displacementmap, Wi.envmap, Wi.fog, Wi.lights, Wi.ssr, Wi.node, {
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Ki.meshnode_vert,
                fragmentShader: Ki.meshnode_frag
            },
            cubeOctahedral: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    texelSize: {
                        value: new qt(.5, .5)
                    }
                },
                vertexShader: Ki.pp_plane_vert,
                fragmentShader: Ki.pp_cube_octahedral_proj_frag
            }
        };

    function $i(h, n, p, r) {
        var f, m, v, g, _ = new Pr(0),
            y = 0,
            x = null,
            b = 0,
            w = null;

        function M(e, t) {
            n.buffers.color.setClear(e.r, e.g, e.b, t, r)
        }
        return {
            getClearColor: function () {
                return _
            },
            setClearColor: function (e, t) {
                _.set(e), M(_, y = void 0 !== t ? t : 1)
            },
            getClearAlpha: function () {
                return y
            },
            setClearAlpha: function (e) {
                M(_, y = e)
            },
            dispose: function () {
                m && (m.geometry.dispose(), m.material.dispose()), m = f = void 0, v && (v.geometry.dispose(), v.material.dispose()), v = void 0, g && (g.geometry.dispose(), g.material.dispose()), g = void 0
            },
            render: function (e, t, n, r) {
                var i = t.background && t.background.isSceneBackground,
                    a = i ? t.background.data : t.background,
                    o = h.xr,
                    s = o.getSession && o.getSession();
                s && "additive" === s.environmentBlendMode && (a = null), null === a ? M(_, y) : a && a.isColor && (M(a, 1), r = !0), (h.autoClear || r) && h.clear(h.autoClearColor, h.autoClearDepth, h.autoClearStencil);
                var l = !!i && t.background.useHDR;
                if (a && (a.isCubeTexture || a.isWebGLCubeRenderTarget || a.mapping === We)) {
                    void 0 === v && ((v = new xi(new Pi(1, 1, 1), new Oi({
                        type: "BackgroundCubeMaterial",
                        uniforms: Di.clone(Ji.cube.uniforms),
                        vertexShader: Ji.cube.vertexShader,
                        fragmentShader: Ji.cube.fragmentShader,
                        side: Pe,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                        polygonOffset: !0,
                        useHDR: l
                    }))).geometry.deleteAttribute("normal"), v.geometry.deleteAttribute("uv"), v.onBeforeRender = function (e, t, n) {
                        var r = n.far;
                        this.matrixWorld.makeScale(r, r, r), this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(v.material, "envMap", {
                        get: function () {
                            return this.uniforms.envMap.value
                        }
                    }), p.update(v));
                    var c = a.isWebGLCubeRenderTarget ? a.texture : a;
                    v.material.uniforms.envMap.value = c, v.material.uniforms.flipEnvMap.value = c.isCubeTexture ? -1 : 1, x === a && b === c.version && w === h.toneMapping || (v.material.needsUpdate = !0, x = a, b = c.version, w = h.toneMapping), e.unshift(v, v.geometry, v.material, 0, 0, null)
                } else if (a && a.isTexture)
                    if (a.mapping === Ge) {
                        var u = !!i && t.background.equirecInvertU,
                            d = i ? t.background.equirecOffsetU : 0;
                        void 0 === g && ((g = new xi(new Pi(1, 1, 1), new Oi({
                            vertexShader: Ji.equirect.vertexShader,
                            fragmentShader: Ji.equirect.fragmentShader,
                            uniforms: Ji.equirect.uniforms,
                            side: Pe,
                            depthTest: !1,
                            depthWrite: !1,
                            polygonOffset: !0,
                            useHDR: l
                        }))).geometry.deleteAttribute("normal"), g.geometry.deleteAttribute("uv"), g.onBeforeRender = function (e, t, n) {
                            var r = n.far;
                            this.matrixWorld.makeScale(r, r, r), this.matrixWorld.copyPosition(n.matrixWorld)
                        }), p.update(g), g.material.uniforms.invertU.value = u, g.material.uniforms.offsetU.value = d, g.material.uniforms.tEquirect.value = a, e.unshift(g, g.geometry, g.material, 0, 0, null)
                    } else void 0 === f && (f = new qi(-1, 1, 1, -1, 0, 1), m = new xi(new Qi(2, 2), new Fr({
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))), p.update(m), m.material.map = a, h.renderBufferDirect(f, null, m.geometry, m.material, m, null)
            }
        }
    }

    function ea(o, s, l, e) {
        var c, u = e.isWebGL2;
        this.setMode = function (e) {
            c = e
        }, this.render = function (e, t) {
            o.drawArrays(c, e, t), l.update(t, c)
        }, this.renderInstances = function (e, t, n, r) {
            if (0 !== r) {
                var i, a;
                if (u) i = o, a = "drawArraysInstanced";
                else if (a = "drawArraysInstancedANGLE", null === (i = s.get("ANGLE_instanced_arrays"))) return void console.error("v3d.WebGLBufferRenderer: using v3d.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                i[a](c, t, n, r), l.update(n, c, r)
            }
        }
    }

    function ta(t, n, e) {
        var r;

        function i(e) {
            if ("highp" === e) {
                if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                e = "mediump"
            }
            return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
        }
        var a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext,
            o = void 0 !== e.precision ? e.precision : "highp",
            s = i(o);
        s !== o && (console.warn("v3d.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);
        var l = !0 === e.logarithmicDepthBuffer,
            c = t.getParameter(34930),
            u = t.getParameter(35660),
            d = t.getParameter(3379),
            h = t.getParameter(34076),
            p = t.getParameter(34921),
            f = t.getParameter(36347),
            m = t.getParameter(36348),
            v = t.getParameter(36349),
            g = 0 < u,
            _ = a || !!n.get("OES_texture_float");
        return {
            isWebGL2: a,
            getMaxAnisotropy: function () {
                if (void 0 !== r) return r;
                var e = n.get("EXT_texture_filter_anisotropic");
                return r = null !== e ? t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: i,
            precision: o,
            logarithmicDepthBuffer: l,
            maxTextures: c,
            maxVertexTextures: u,
            maxTextureSize: d,
            maxCubemapSize: h,
            maxAttributes: p,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: v,
            vertexTextures: g,
            floatFragmentTextures: _,
            floatVertexTextures: g && _,
            maxSamples: a ? t.getParameter(36183) : 0
        }
    }

    function na() {
        var u = this,
            d = null,
            h = 0,
            p = !1,
            f = !1,
            m = new fr,
            v = new Zt,
            g = {
                value: null,
                needsUpdate: !1
            };

        function _() {
            g.value !== d && (g.value = d, g.needsUpdate = 0 < h), u.numPlanes = h, u.numIntersection = 0
        }

        function y(e, t, n, r) {
            var i = null !== e ? e.length : 0,
                a = null;
            if (0 !== i) {
                if (a = g.value, !0 !== r || null === a) {
                    var o = n + 4 * i,
                        s = t.matrixWorldInverse;
                    v.getNormalMatrix(s), (null === a || a.length < o) && (a = new Float32Array(o));
                    for (var l = 0, c = n; l !== i; ++l, c += 4) m.copy(e[l]).applyMatrix4(s, v), m.normal.toArray(a, c), a[c + 3] = m.constant
                }
                g.value = a, g.needsUpdate = !0
            }
            return u.numPlanes = i, a
        }
        this.uniform = g, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, n) {
            var r = 0 !== e.length || t || 0 !== h || p;
            return p = t, d = y(e, n, 0), h = e.length, r
        }, this.beginShadows = function () {
            f = !0, y(null)
        }, this.endShadows = function () {
            f = !1, _()
        }, this.setState = function (e, t, n, r, i, a) {
            if (!p || null === e || 0 === e.length || f && !n) f ? y(null) : _();
            else {
                var o = f ? 0 : h,
                    s = 4 * o,
                    l = i.clippingState || null;
                g.value = l, l = y(e, r, s, a);
                for (var c = 0; c !== s; ++c) l[c] = d[c];
                i.clippingState = l, this.numIntersection = t ? this.numPlanes : 0, this.numPlanes += o
            }
        }
    }

    function ra(n) {
        var r = {};
        return {
            get: function (e) {
                if (void 0 !== r[e]) return r[e];
                var t;
                switch (e) {
                    case "WEBGL_depth_texture":
                        t = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        t = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        t = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        t = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        t = n.getExtension(e)
                }
                return null === t && console.warn("v3d.WebGLRenderer: " + e + " extension not supported."), r[e] = t
            }
        }
    }

    function ia(e, p, a) {
        var o = new WeakMap,
            f = new WeakMap;

        function s(e) {
            var t = e.target,
                n = o.get(t);
            for (var r in null !== n.index && p.remove(n.index), n.attributes) p.remove(n.attributes[r]);
            t.removeEventListener("dispose", s), o.delete(t);
            var i = f.get(n);
            i && (p.remove(i), f.delete(n)), a.memory.geometries--
        }

        function r(e) {
            var t = [],
                n = e.index,
                r = e.attributes.position,
                i = 0;
            if (null !== n) {
                var a = n.array;
                i = n.version;
                for (var o = 0, s = a.length; o < s; o += 3) {
                    var l = a[o + 0],
                        c = a[o + 1],
                        u = a[o + 2];
                    t.push(l, c, c, u, u, l)
                }
            } else {
                a = r.array;
                i = r.version;
                for (o = 0, s = a.length / 3 - 1; o < s; o += 3) {
                    l = o + 0, c = o + 1, u = o + 2;
                    t.push(l, c, c, u, u, l)
                }
            }
            var d = new(65535 < yn(t) ? Xr : jr)(t, 1);
            d.version = i, p.update(d, 34963);
            var h = f.get(e);
            h && p.remove(h), f.set(e, d)
        }
        return {
            get: function (e, t) {
                var n = o.get(t);
                return n || (t.addEventListener("dispose", s), t.isBufferGeometry ? n = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new ni).setFromObject(e)), n = t._bufferGeometry), o.set(t, n), a.memory.geometries++, n)
            },
            update: function (e) {
                var t = e.index,
                    n = e.attributes;
                for (var r in null !== t && p.update(t, 34963), n) p.update(n[r], 34962);
                var i = e.morphAttributes;
                for (var r in i)
                    for (var a = i[r], o = 0, s = a.length; o < s; o++) p.update(a[o], 34962)
            },
            getWireframeAttribute: function (e) {
                var t = f.get(e);
                if (t) {
                    var n = e.index;
                    null !== n && t.version < n.version && r(e)
                } else r(e);
                return f.get(e)
            }
        }
    }

    function aa(o, s, l, e) {
        var c, u, d, h = e.isWebGL2;
        this.setMode = function (e) {
            c = e
        }, this.setIndex = function (e) {
            u = e.type, d = e.bytesPerElement
        }, this.render = function (e, t) {
            o.drawElements(c, t, u, e * d), l.update(t, c)
        }, this.renderInstances = function (e, t, n, r) {
            if (0 !== r) {
                var i, a;
                if (h) i = o, a = "drawElementsInstanced";
                else if (a = "drawElementsInstancedANGLE", null === (i = s.get("ANGLE_instanced_arrays"))) return void console.error("v3d.WebGLIndexedBufferRenderer: using v3d.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                i[a](c, n, u, t * d, r), l.update(n, c, r)
            }
        }
    }

    function oa(e) {
        var r = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: r,
            programs: null,
            autoReset: !0,
            reset: function () {
                r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0
            },
            update: function (e, t, n) {
                switch (n = n || 1, r.calls++, t) {
                    case 4:
                        r.triangles += n * (e / 3);
                        break;
                    case 1:
                        r.lines += n * (e / 2);
                        break;
                    case 3:
                        r.lines += n * (e - 1);
                        break;
                    case 2:
                        r.lines += n * e;
                        break;
                    case 0:
                        r.points += n * e;
                        break;
                    default:
                        console.error("v3d.WebGLInfo: Unknown draw mode:", t)
                }
            }
        }
    }

    function sa(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }

    function la(m) {
        var v = {},
            g = new Float32Array(8);
        return {
            update: function (e, t, n, r) {
                var i = e.morphTargetInfluences,
                    a = void 0 === i ? 0 : i.length,
                    o = v[t.id];
                if (void 0 === o) {
                    o = [];
                    for (var s = 0; s < a; s++) o[s] = [s, 0];
                    v[t.id] = o
                }
                var l = n.morphTargets && t.morphAttributes.position,
                    c = n.morphNormals && t.morphAttributes.normal;
                for (s = 0; s < a; s++) {
                    0 !== (d = o[s])[1] && (l && t.deleteAttribute("morphTarget" + s), c && t.deleteAttribute("morphNormal" + s))
                }
                for (s = 0; s < a; s++) {
                    (d = o[s])[0] = s, d[1] = i[s]
                }
                o.sort(sa);
                var u = 0;
                for (s = 0; s < 8; s++) {
                    var d;
                    if (d = o[s]) {
                        var h = d[0],
                            p = d[1];
                        if (p) {
                            l && t.setAttribute("morphTarget" + s, l[h]), c && t.setAttribute("morphNormal" + s, c[h]), u += g[s] = p;
                            continue
                        }
                    }
                    g[s] = 0
                }
                var f = t.morphTargetsRelative ? 1 : 1 - u;
                r.getUniforms().setValue(m, "morphTargetBaseInfluence", f), r.getUniforms().setValue(m, "morphTargetInfluences", g)
            }
        }
    }

    function ca(e, i, a, o) {
        var s = {};
        return {
            update: function (e) {
                var t = o.render.frame,
                    n = e.geometry,
                    r = i.get(e, n);
                return s[r.id] !== t && (n.isGeometry && r.updateFromObject(e), i.update(r), s[r.id] = t), e.isInstancedMesh && a.update(e.instanceMatrix, 34962), r
            },
            dispose: function () {
                s = {}
            }
        }
    }

    function ua(e, t, n, r, i, a, o, s, l, c) {
        Jt.call(this, e = void 0 !== e ? e : [], t = void 0 !== t ? t : Ue, n, r, i, a, o = void 0 !== o ? o : st, s, l, c), this.flipY = !1
    }

    function da(e, t, n, r) {
        Jt.call(this, null), this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1,
            depth: r || 1
        }, this.magFilter = Ze, this.minFilter = Ze, this.wrapR = Ye, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }

    function ha(e, t, n, r) {
        Jt.call(this, null), this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1,
            depth: r || 1
        }, this.magFilter = Ze, this.minFilter = Ze, this.wrapR = Ye, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }
    Ji.physical = {
        uniforms: Ri([Ji.standard.uniforms, {
            transparency: {
                value: 0
            },
            clearcoat: {
                value: 0
            },
            clearcoatRoughness: {
                value: 0
            },
            sheen: {
                value: new Pr(0)
            },
            clearcoatNormalScale: {
                value: new qt(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            }
        }]),
        vertexShader: Ki.meshphysical_vert,
        fragmentShader: Ki.meshphysical_frag
    }, Ji.copy = {
        defines: {
            MAP_TEXELS: 0
        },
        uniforms: {
            tDiffuse: {
                value: null
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: Ki.pp_plane_vert,
        fragmentShader: Ki.pp_copy_frag
    }, Ji.bokeh = {
        defines: {
            DEPTH_PACKING: 1,
            PERSPECTIVE_CAMERA: 1
        },
        uniforms: {
            tColor: {
                value: null
            },
            tDepth: {
                value: null
            },
            focus: {
                value: 1
            },
            aspect: {
                value: 1
            },
            aperture: {
                value: .025
            },
            maxblur: {
                value: 1
            },
            nearClip: {
                value: 1
            },
            farClip: {
                value: 1e3
            },
            depthLeakThreshold: {
                value: .2
            }
        },
        vertexShader: Ki.pp_plane_vert,
        fragmentShader: Ki.pp_bokeh_frag
    }, Ji.fxaa = {
        uniforms: {
            tDiffuse: {
                value: null
            },
            resolution: {
                value: new qt(1 / 1024, 1 / 512)
            }
        },
        vertexShader: Ki.pp_plane_vert,
        fragmentShader: Ki.pp_fxaa_frag
    }, Ji.grayscale = {
        uniforms: {
            tDiffuse: {
                value: null
            }
        },
        vertexShader: Ki.pp_plane_vert,
        fragmentShader: Ki.pp_grayscale_frag
    }, Ji.brightness_contrast = {
        uniforms: {
            tDiffuse: {
                value: null
            },
            brightness: {
                value: 0
            },
            contrast: {
                value: 0
            }
        },
        vertexShader: Ki.pp_plane_vert,
        fragmentShader: Ki.pp_brightness_contrast_frag
    }, Ji.bloomLumHighPass = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null
            },
            luminosityThreshold: {
                type: "f",
                value: 1
            },
            smoothWidth: {
                type: "f",
                value: 1
            },
            defaultColor: {
                type: "c",
                value: new Pr(0)
            },
            defaultOpacity: {
                type: "f",
                value: 0
            }
        },
        vertexShader: Ki.pp_plane_vert,
        fragmentShader: Ki.pp_bloom_lum_high_pass_frag
    }, Ji.blur = {
        defines: {
            LOG_SPACE: 0,
            OCTAHEDRAL_MAP: 0
        },
        uniforms: {
            colorTexture: {
                value: null
            },
            texSize: {
                value: new qt(.5, .5)
            },
            direction: {
                value: new qt(.5, .5)
            },
            kernelRadius: {
                value: 1
            }
        },
        customPrepTokens: {
            MAX_SAMPLE_RADIUS: 4
        },
        vertexShader: Ki.pp_plane_vert,
        fragmentShader: Ki.pp_blur_frag
    }, Ji.tonemap = {
        uniforms: {
            tDiffuse: {
                value: null
            }
        },
        vertexShader: Ki.pp_plane_vert,
        fragmentShader: Ki.pp_tonemap_frag
    }, ((ua.prototype = Object.create(Jt.prototype)).constructor = ua).prototype.isCubeTexture = !0, Object.defineProperty(ua.prototype, "images", {
        get: function () {
            return this.image
        },
        set: function (e) {
            this.image = e
        }
    }), ((da.prototype = Object.create(Jt.prototype)).constructor = da).prototype.isDataTexture2DArray = !0, ((ha.prototype = Object.create(Jt.prototype)).constructor = ha).prototype.isDataTexture3D = !0;
    var pa = new Jt,
        fa = new da,
        ma = new ha,
        va = new ua,
        ga = [],
        _a = [],
        ya = new Float32Array(16),
        xa = new Float32Array(9),
        ba = new Float32Array(4);

    function wa(e, t, n) {
        var r = e[0];
        if (r <= 0 || 0 < r) return e;
        var i = t * n,
            a = ga[i];
        if (void 0 === a && (a = new Float32Array(i), ga[i] = a), 0 !== t) {
            r.toArray(a, 0);
            for (var o = 1, s = 0; o !== t; ++o) s += n, e[o].toArray(a, s)
        }
        return a
    }

    function Ma(e, t) {
        if (e.length === t.length) {
            for (var n = 0, r = e.length; n < r; n++)
                if (e[n] !== t[n]) return;
            return 1
        }
    }

    function Aa(e, t) {
        for (var n = 0, r = t.length; n < r; n++) e[n] = t[n]
    }

    function Sa(e, t) {
        var n = _a[t];
        void 0 === n && (n = new Int32Array(t), _a[t] = n);
        for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
        return n
    }

    function Ta(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
    }

    function Ea(e, t) {
        var n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
        else {
            if (Ma(n, t)) return;
            e.uniform2fv(this.addr, t), Aa(n, t)
        }
    }

    function Ca(e, t) {
        var n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
        else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
        else {
            if (Ma(n, t)) return;
            e.uniform3fv(this.addr, t), Aa(n, t)
        }
    }

    function Pa(e, t) {
        var n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
        else {
            if (Ma(n, t)) return;
            e.uniform4fv(this.addr, t), Aa(n, t)
        }
    }

    function La(e, t) {
        var n = this.cache,
            r = t.elements;
        if (void 0 === r) {
            if (Ma(n, t)) return;
            e.uniformMatrix2fv(this.addr, !1, t), Aa(n, t)
        } else {
            if (Ma(n, r)) return;
            ba.set(r), e.uniformMatrix2fv(this.addr, !1, ba), Aa(n, r)
        }
    }

    function Ra(e, t) {
        var n = this.cache,
            r = t.elements;
        if (void 0 === r) {
            if (Ma(n, t)) return;
            e.uniformMatrix3fv(this.addr, !1, t), Aa(n, t)
        } else {
            if (Ma(n, r)) return;
            xa.set(r), e.uniformMatrix3fv(this.addr, !1, xa), Aa(n, r)
        }
    }

    function Da(e, t) {
        var n = this.cache,
            r = t.elements;
        if (void 0 === r) {
            if (Ma(n, t)) return;
            e.uniformMatrix4fv(this.addr, !1, t), Aa(n, t)
        } else {
            if (Ma(n, r)) return;
            ya.set(r), e.uniformMatrix4fv(this.addr, !1, ya), Aa(n, r)
        }
    }

    function Ia(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || pa, i)
    }

    function Na(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || fa, i)
    }

    function Oa(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || ma, i)
    }

    function Fa(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || va, i)
    }

    function Ba(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
    }

    function za(e, t) {
        var n = this.cache;
        Ma(n, t) || (e.uniform2iv(this.addr, t), Aa(n, t))
    }

    function Ua(e, t) {
        var n = this.cache;
        Ma(n, t) || (e.uniform3iv(this.addr, t), Aa(n, t))
    }

    function Va(e, t) {
        var n = this.cache;
        Ma(n, t) || (e.uniform4iv(this.addr, t), Aa(n, t))
    }

    function Ga(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
    }

    function ka(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function ja(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function Wa(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function Xa(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function Ha(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function Ya(e, t) {
        var n = wa(t, this.size, 2);
        e.uniform2fv(this.addr, n)
    }

    function qa(e, t) {
        var n = wa(t, this.size, 3);
        e.uniform3fv(this.addr, n)
    }

    function Za(e, t) {
        var n = wa(t, this.size, 4);
        e.uniform4fv(this.addr, n)
    }

    function Qa(e, t) {
        var n = wa(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n)
    }

    function Ka(e, t) {
        var n = wa(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n)
    }

    function Ja(e, t) {
        var n = wa(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n)
    }

    function $a(e, t, n) {
        var r = t.length,
            i = Sa(n, r);
        e.uniform1iv(this.addr, i);
        for (var a = 0; a !== r; ++a) n.safeSetTexture2D(t[a] || pa, i[a])
    }

    function eo(e, t, n) {
        var r = t.length,
            i = Sa(n, r);
        e.uniform1iv(this.addr, i);
        for (var a = 0; a !== r; ++a) n.safeSetTextureCube(t[a] || va, i[a])
    }

    function to(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.setValue = function (e) {
            switch (e) {
                case 5126:
                    return Ta;
                case 35664:
                    return Ea;
                case 35665:
                    return Ca;
                case 35666:
                    return Pa;
                case 35674:
                    return La;
                case 35675:
                    return Ra;
                case 35676:
                    return Da;
                case 5124:
                case 35670:
                    return Ba;
                case 35667:
                case 35671:
                    return za;
                case 35668:
                case 35672:
                    return Ua;
                case 35669:
                case 35673:
                    return Va;
                case 5125:
                    return Ga;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Ia;
                case 35679:
                case 36299:
                case 36307:
                    return Oa;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Fa;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return Na
            }
        }(t.type)
    }

    function no(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function (e) {
            switch (e) {
                case 5126:
                    return ka;
                case 35664:
                    return Ya;
                case 35665:
                    return qa;
                case 35666:
                    return Za;
                case 35674:
                    return Qa;
                case 35675:
                    return Ka;
                case 35676:
                    return Ja;
                case 5124:
                case 35670:
                    return ja;
                case 35667:
                case 35671:
                    return Wa;
                case 35668:
                case 35672:
                    return Xa;
                case 35669:
                case 35673:
                    return Ha;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return $a;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return eo
            }
        }(t.type)
    }

    function ro(e) {
        this.id = e, this.seq = [], this.map = {}
    }
    no.prototype.updateCache = function (e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), Aa(t, e)
    }, ro.prototype.setValue = function (e, t, n) {
        for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
            var o = r[i];
            o.setValue(e, t[o.id], n)
        }
    };
    var io = /([\w\d_]+)(\])?(\[|\.)?/g;

    function ao(e, t) {
        e.seq.push(t), e.map[t.id] = t
    }

    function oo(e, t, n) {
        var r = e.name,
            i = r.length;
        for (io.lastIndex = 0;;) {
            var a = io.exec(r),
                o = io.lastIndex,
                s = a[1],
                l = "]" === a[2],
                c = a[3];
            if (l && (s |= 0), void 0 === c || "[" === c && o + 2 === i) {
                ao(n, new(void 0 === c ? to : no)(s, e, t));
                break
            }
            var u = n.map[s];
            void 0 === u && ao(n, u = new ro(s)), n = u
        }
    }

    function so(e, t) {
        this.seq = [], this.map = {};
        for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) {
            var i = e.getActiveUniform(t, r);
            oo(i, e.getUniformLocation(t, i.name), this)
        }
    }

    function lo(e, t, n) {
        var r = e.createShader(t);
        return e.shaderSource(r, n), e.compileShader(r), r
    }
    so.prototype.setValue = function (e, t, n, r) {
        var i = this.map[t];
        void 0 !== i && i.setValue(e, n, r)
    }, so.prototype.setOptional = function (e, t, n) {
        var r = t[n];
        void 0 !== r && this.setValue(e, n, r)
    }, so.upload = function (e, t, n, r) {
        for (var i = 0, a = t.length; i !== a; ++i) {
            var o = t[i],
                s = n[o.id];
            !1 !== s.needsUpdate && o.setValue(e, s.value, r)
        }
    }, so.seqWithValue = function (e, t) {
        for (var n = [], r = 0, i = e.length; r !== i; ++r) {
            var a = e[r];
            a.id in t && n.push(a)
        }
        return n
    };
    var co = 0;

    function uo(e) {
        switch (e) {
            case At:
                return ["Linear", "(value)"];
            case St:
                return ["sRGB", "(value)"];
            case Et:
                return ["RGBE", "(value)"];
            case Pt:
                return ["RGBM", "(value, 7.0)"];
            case Lt:
                return ["RGBM", "(value, 16.0)"];
            case Rt:
                return ["RGBD", "(value, 256.0)"];
            case Tt:
                return ["Gamma", "(value, float(GAMMA_FACTOR))"];
            case Ct:
                return ["LogLuv", "(value)"];
            default:
                throw new Error("unsupported encoding: " + e)
        }
    }

    function ho(e, t, n) {
        var r = e.getShaderParameter(t, 35713),
            i = e.getShaderInfoLog(t).trim();
        return r && "" === i ? "" : "v3d.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function (e) {
            for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
            return t.join("\n")
        }(e.getShaderSource(t))
    }

    function po(e, t) {
        var n = uo(t);
        return "vec4 " + e + "(vec4 value) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function fo(e) {
        return "" !== e
    }

    function mo(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
    }

    function vo(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }

    function go(e, t) {
        var n = Object.keys(t);
        if (n.length) {
            var r = new RegExp(n.join("|"), "g");
            return e.replace(r, function (e) {
                return t[e]
            })
        }
        return e
    }

    function _o(e, t) {
        for (var n in t) e = e.replace("#include <" + n + ">", t[n]);
        return e
    }
    var yo = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function xo(e) {
        return e.replace(yo, bo)
    }

    function bo(e, t) {
        var n = Ki[t];
        if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
        return xo(n)
    }

    function wo(e) {
        for (var t, n = new RegExp("#pragma unroll_loop[\\s]+?for \\(int (\\w+) \\= (\\d+)\\; (\\w+) <(=?) (\\w+)\\; (\\w+)\\+\\+\\) \\{"), r = new RegExp("\\{|\\}", "g"); t = n.exec(e);) {
            var i, a;
            i = a = r.lastIndex = t.index + t[0].length;
            for (var o, s = 1;
                (o = r.exec(e)) && ("{" == o[0] ? s++ : "}" == o[0] && s--, a = o.index), o && 0 < s;);
            if (0 == s) {
                for (var l = e.substring(t.index, r.lastIndex), c = e.substring(i, a), u = new RegExp("\\[".concat(t[1], "\\]"), "g"), d = new RegExp("\\(".concat(t[1], "\\)"), "g"), h = "", p = parseInt(t[2]), f = parseInt(t[5]) + ("=" === t[4] ? 1 : 0), m = p; m < f; m++) h += "{" + c.replace(u, "[".concat(m, "]")).replace(d, "(".concat(m, ")")) + "}";
                e = e.replace(l, h)
            }
        }
        return e
    }

    function Mo(e) {
        var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
        return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
    }

    function Ao(e, t, n) {
        var r, i, a, o, s, l, c, u, d = e.getContext(),
            h = n.defines,
            p = n.vertexShader,
            f = n.fragmentShader,
            m = (i = "SHADOWMAP_TYPE_BASIC", (r = n).shadowMapType === Z ? i = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === $ ? i = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === ee ? i = "SHADOWMAP_TYPE_VSM" : r.shadowMapType === te ? i = "SHADOWMAP_TYPE_ESM" : r.shadowMapType === ne && (i = "SHADOWMAP_TYPE_PCF_POISSON_DISK"), i),
            v = function (e) {
                var t = "ENVMAP_TYPE_CUBE";
                if (e.envMap) switch (e.envMapMode) {
                    case Ue:
                    case Ve:
                        t = "ENVMAP_TYPE_CUBE";
                        break;
                    case We:
                    case Xe:
                        t = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case Ge:
                    case ke:
                        t = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case je:
                        t = "ENVMAP_TYPE_SPHERE"
                }
                return t
            }(n),
            g = function (e) {
                var t = "ENVMAP_MODE_REFLECTION";
                if (e.envMap) switch (e.envMapMode) {
                    case Ve:
                    case ke:
                        t = "ENVMAP_MODE_REFRACTION"
                }
                return t
            }(n),
            _ = function (e) {
                var t = "ENVMAP_BLENDING_NONE";
                if (e.envMap) switch (e.combine) {
                    case U:
                        t = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case V:
                        t = "ENVMAP_BLENDING_MIX";
                        break;
                    case G:
                        t = "ENVMAP_BLENDING_ADD"
                }
                return t
            }(n),
            y = 0 < e.gammaFactor ? e.gammaFactor : 1,
            x = n.unitsScaleFactor % 1 ? String(n.unitsScaleFactor) : String(n.unitsScaleFactor) + ".0",
            b = n.isWebGL2 ? "" : [(a = n).extensionDerivatives || a.envMapCubeUV || a.bumpMap || a.tangentSpaceNormalMap || a.clearcoatNormalMap || a.flatShading || "physical" === a.shaderID || a.useSlopeScaledBias ? "#extension GL_OES_standard_derivatives : enable" : "", (a.extensionFragDepth || a.logarithmicDepthBuffer) && a.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", a.extensionDrawBuffers && a.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (a.extensionShaderTextureLOD || a.envMap) && a.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(fo).join("\n"),
            w = function (e) {
                var t = [];
                for (var n in e) {
                    var r = e[n];
                    !1 !== r && t.push("#define " + n + " " + r)
                }
                return t.join("\n")
            }(h),
            M = d.createProgram(),
            A = n.numMultiviewViews;
        if (n.isRawShaderMaterial ? (0 < (o = [w].filter(fo).join("\n")).length && (o += "\n"), 0 < (s = [b, w].filter(fo).join("\n")).length && (s += "\n")) : (o = [Mo(n), "#define SHADER_NAME " + n.shaderName, e.compatSettings.saturateSpecEnvBlenderApprox ? "#define COMPAT_SATURATE_SPEC_ENV_BLENDER_APPROX" : "", w, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + g : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", "#define NUM_MORPH_TARGETS " + n.numMorphTargets, n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + m : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "    attribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "    attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "    attribute vec3 morphTarget0;", "    attribute vec3 morphTarget1;", "    attribute vec3 morphTarget2;", "    attribute vec3 morphTarget3;", "    attribute vec3 morphTarget4;", "    attribute vec3 morphTarget5;", "    #ifdef USE_MORPHNORMALS", "        attribute vec3 morphNormal0;", "        attribute vec3 morphNormal1;", "        attribute vec3 morphNormal2;", "        attribute vec3 morphNormal3;", "        attribute vec3 morphNormal4;", "        attribute vec3 morphNormal5;", "    #else", "        attribute vec3 morphTarget6;", "        attribute vec3 morphTarget7;", "        attribute vec3 morphTarget8;", "        attribute vec3 morphTarget9;", "        attribute vec3 morphTarget10;", "        attribute vec3 morphTarget11;", "    #endif", "#endif", "#ifdef USE_SKINNING", "    attribute vec4 skinIndex;", "    attribute vec4 skinWeight;", "#endif", "\n"].filter(fo).join("\n"), s = [b, Mo(n), "#define SHADER_NAME " + n.shaderName, w, function (e) {
                switch (e) {
                    case "blender":
                        return "#define MT_BLENDER";
                    case "max":
                        return "#define MT_MAX";
                    case "maya":
                        return "#define MT_MAYA";
                    default:
                        return ""
                }
            }(n.materialProfile), e.compatSettings.saturateSpecEnvBlenderApprox ? "#define COMPAT_SATURATE_SPEC_ENV_BLENDER_APPROX" : "", n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + y, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + v : "", n.envMap ? "#define " + g : "", n.envMap ? "#define " + _ : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + m : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", n.physicallyCorrectLights ? "#define UNITS_SCALE_FACTOR " + x : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping === k || n.useHDR ? "" : "#define TONE_MAPPING", n.toneMapping === k || n.useHDR ? "" : Ki.tonemapping_pars_fragment, n.toneMapping === k || n.useHDR ? "" : function (e, t) {
                var n;
                switch (t) {
                    case Fe:
                        n = "Linear";
                        break;
                    case j:
                        n = "Reinhard";
                        break;
                    case W:
                        n = "Uncharted2";
                        break;
                    case X:
                        n = "OptimizedCineon";
                        break;
                    case H:
                        n = "ACESFilmic";
                        break;
                    case Be:
                        n = "LogarithmicMax";
                        break;
                    case ze:
                        n = "PhysicalMax";
                        break;
                    case Y:
                        n = "FilmicBlender";
                        break;
                    default:
                        throw new Error("unsupported toneMapping: " + t)
                }
                return "vec3 " + e + "(vec3 color) { return " + n + "ToneMapping(color); }"
            }("toneMapping", n.toneMapping), n.dithering ? "#define DITHERING" : "", n.outputEncoding || n.mapEncoding || n.matcapEncoding || n.envMapEncoding || n.emissiveMapEncoding || n.lightMapEncoding ? Ki.encodings_pars_fragment : "", n.mapEncoding ? po("mapTexelToLinear", n.mapEncoding) : "", n.matcapEncoding ? po("matcapTexelToLinear", n.matcapEncoding) : "", n.envMapEncoding ? po("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? po("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMapEncoding ? po("lightMapTexelToLinear", n.lightMapEncoding) : "", n.outputEncoding ? (l = "linearToOutputTexel", c = n.outputEncoding, u = uo(c), "vec4 " + l + "(vec4 value) { return LinearTo" + u[0] + u[1] + "; }") : "", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", n.distancePacking ? "#define DISTANCE_PACKING " + n.distancePacking : "", n.useSlopeScaledBias ? "#define USE_SLOPE_SCALED_BIAS" : "", "\n"].filter(fo).join("\n")), n.isMeshNodeMaterial && (p = _o(p, n.nodeChunks), f = _o(f, n.nodeChunks)), p = vo(p = mo(p = xo(p), n), n), n.customPrepTokens && (p = go(p, n.customPrepTokens)), f = vo(f = mo(f = xo(f), n), n), n.customPrepTokens && (f = go(f, n.customPrepTokens)), p = wo(p), f = wo(f), n.isWebGL2 && !n.isRawShaderMaterial) {
            var S = !1,
                T = /^\s*#version\s+300\s+es\s*\n/;
            n.isShaderMaterial && null !== p.match(T) && null !== f.match(T) && (S = !0, p = p.replace(T, ""), f = f.replace(T, "")), o = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + o, s = ["#version 300 es\n", "#define varying in", S ? "" : "out highp vec4 pc_fragColor;", S ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + s, 0 < A && (o = (o = o.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "layout(num_views = " + A + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace(["uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;"].join("\n"), ["uniform mat4 modelViewMatrices[" + A + "];", "uniform mat4 projectionMatrices[" + A + "];", "uniform mat4 viewMatrices[" + A + "];", "uniform mat3 normalMatrices[" + A + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]", "#define projectionMatrix projectionMatrices[VIEW_ID]", "#define viewMatrix viewMatrices[VIEW_ID]", "#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")), s = (s = s.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + A + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n")))
        }
        var E, C, P = s + f,
            L = lo(d, 35633, o + p),
            R = lo(d, 35632, P);
        if (d.attachShader(M, L), d.attachShader(M, R), void 0 !== n.index0AttributeName ? d.bindAttribLocation(M, 0, n.index0AttributeName) : !0 === n.morphTargets && d.bindAttribLocation(M, 0, "position"), d.linkProgram(M), e.debug.checkShaderErrors) {
            var D = d.getProgramInfoLog(M).trim(),
                I = d.getShaderInfoLog(L).trim(),
                N = d.getShaderInfoLog(R).trim(),
                O = !0,
                F = !0;
            if (!1 === d.getProgramParameter(M, 35714)) {
                O = !1;
                var B = ho(d, L, "vertex"),
                    z = ho(d, R, "fragment");
                console.error("v3d.WebGLProgram: shader error: ", d.getError(), "35715", d.getProgramParameter(M, 35715), "gl.getProgramInfoLog", D, B, z)
            } else "" !== D ? console.warn("v3d.WebGLProgram: gl.getProgramInfoLog()", D) : "" !== I && "" !== N || (F = !1);
            F && (this.diagnostics = {
                runnable: O,
                programLog: D,
                vertexShader: {
                    log: I,
                    prefix: o
                },
                fragmentShader: {
                    log: N,
                    prefix: s
                }
            })
        }
        return d.deleteShader(L), d.deleteShader(R), this.getUniforms = function () {
            return void 0 === E && (E = new so(d, M)), E
        }, this.getAttributes = function () {
            return void 0 === C && (C = function (e, t) {
                for (var n = {}, r = e.getProgramParameter(t, 35721), i = 0; i < r; i++) {
                    var a = e.getActiveAttrib(t, i).name;
                    n[a] = e.getAttribLocation(t, a)
                }
                return n
            }(d, M)), C
        }, this.getTexUniformCount = function () {
            return this.getUniforms().seq.reduce(function (e, t) {
                if (t.info) switch (t.info.type) {
                    case 35678:
                    case 35679:
                    case 35680:
                    case 35682:
                    case 36289:
                    case 36292:
                    case 36293:
                    case 36298:
                    case 36299:
                    case 36300:
                    case 36303:
                    case 36306:
                    case 36307:
                    case 36308:
                    case 36311:
                        e += t.info.size
                }
                return e
            }, 0)
        }, this.destroy = function () {
            d.deleteProgram(M), this.program = void 0
        }, this.name = n.shaderName, this.id = co++, this.cacheKey = t, this.usedTimes = 1, this.program = M, this.vertexShader = L, this.fragmentShader = R, this.numMultiviewViews = A, this.profile = {
            calcRenderTime: !1,
            renderTime: 0,
            timerQueries: [],
            materials: []
        }, this.beginTimerQuery = function (e, t) {
            if (this.profile.calcRenderTime) {
                var n = e.getExtension(t ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
                if (n) {
                    if (t) {
                        var r = e.createQuery();
                        e.beginQuery(n.TIME_ELAPSED_EXT, r)
                    } else {
                        r = n.createQueryEXT();
                        n.beginQueryEXT(n.TIME_ELAPSED_EXT, r)
                    }
                    this.profile.timerQueries.push(r)
                }
            }
        }, this.endTimerQuery = function (e, t) {
            if (this.profile.calcRenderTime) {
                var n = e.getExtension(t ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
                if (n) {
                    t ? e.endQuery(n.TIME_ELAPSED_EXT) : n.endQueryEXT(n.TIME_ELAPSED_EXT);
                    for (var r = this.profile.timerQueries, i = r.length - 1; 0 <= i; i--) {
                        var a = r[i],
                            o = t ? e.getQueryParameter(a, 34919) : n.getQueryObjectEXT(a, n.QUERY_RESULT_AVAILABLE_EXT),
                            s = e.getParameter(n.GPU_DISJOINT_EXT);
                        if (o && !s) {
                            var l = t ? e.getQueryParameter(a, 34918) : n.getQueryObjectEXT(a, n.QUERY_RESULT_EXT);
                            this.profile.renderTime += l / 1e6, r.splice(i, 1)
                        }
                    }
                }
            }
        }, this
    }

    function So(v, g, _) {
        var s = [],
            y = _.isWebGL2,
            x = _.logarithmicDepthBuffer,
            b = _.floatVertexTextures,
            w = _.precision,
            M = _.maxVertexUniforms,
            A = _.vertexTextures,
            S = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite",
                MeshMaskMaterial: "mask",
                MeshNodeMaterial: "node"
            },
            i = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "numMultiviewViews", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "distancePacking", "useSlopeScaledBias", "numMorphTargets", "unitsScaleFactor", "useHDR"];

        function T(e) {
            var t;
            return e ? e.isTexture ? t = e.encoding : e.isWebGLRenderTarget && (console.warn("v3d.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = At, t
        }
        this.getParameters = function (e, t, n, r, i, a, o) {
            var s = r.fog,
                l = e.isMeshStandardMaterial ? r.environment : null,
                c = e.envMap || l,
                u = S[e.type],
                d = o.isSkinnedMesh ? function (e) {
                    var t = e.skeleton.bones;
                    if (b) return 1024;
                    var n = M,
                        r = Math.floor((n - 20) / 4),
                        i = Math.min(r, t.length);
                    return i < t.length ? (console.warn("v3d.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + i + "."), 0) : i
                }(o) : 0;
            null !== e.precision && (w = _.getMaxPrecision(e.precision)) !== e.precision && console.warn("v3d.WebGLProgram.getParameters:", e.precision, "not supported, using", w, "instead.");
            var h = function (e, t) {
                var n;
                if (t) {
                    var r = Ji[t];
                    n = {
                        name: e.type,
                        uniforms: Di.clone(r.uniforms),
                        vertexShader: r.vertexShader,
                        fragmentShader: r.fragmentShader
                    }
                } else n = {
                    name: e.type,
                    uniforms: e.uniforms,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader
                };
                return n
            }(e, u);
            e.onBeforeCompile(h, v);
            var p = v.getRenderTarget(),
                f = o.geometry,
                m = p && p.isWebGLMultiviewRenderTarget ? p.numViews : 0;
            return {
                isWebGL2: y,
                shaderID: u,
                shaderName: h.name,
                uniforms: h.uniforms,
                vertexShader: h.vertexShader,
                fragmentShader: h.fragmentShader,
                defines: e.defines,
                isRawShaderMaterial: e.isRawShaderMaterial,
                isShaderMaterial: e.isShaderMaterial,
                precision: w,
                instancing: !0 === o.isInstancedMesh,
                supportsVertexTextures: A,
                numMultiviewViews: m,
                outputEncoding: null !== p ? T(p.texture) : v.outputEncoding,
                map: !!e.map,
                mapEncoding: T(e.map),
                matcap: !!e.matcap,
                matcapEncoding: T(e.matcap),
                envMap: !!c,
                envMapMode: c && c.mapping,
                envMapEncoding: T(c),
                envMapCubeUV: !!c && (c.mapping === We || c.mapping === Xe),
                lightMap: !!e.lightMap,
                lightMapEncoding: T(e.lightMap),
                aoMap: !!e.aoMap,
                emissiveMap: !!e.emissiveMap,
                emissiveMapEncoding: T(e.emissiveMap),
                bumpMap: !!e.bumpMap,
                normalMap: !!e.normalMap,
                objectSpaceNormalMap: e.normalMapType === Bt,
                tangentSpaceNormalMap: e.normalMapType === Ft,
                clearcoatNormalMap: !!e.clearcoatNormalMap,
                displacementMap: !!e.displacementMap,
                roughnessMap: !!e.roughnessMap,
                metalnessMap: !!e.metalnessMap,
                specularMap: !!e.specularMap,
                alphaMap: !!e.alphaMap,
                gradientMap: !!e.gradientMap,
                sheen: !!e.sheen,
                combine: e.combine,
                vertexTangents: e.normalMap && (e.vertexTangents || f && f.isBufferGeometry && f.getAttribute("tangent")),
                vertexColors: e.vertexColors,
                vertexUvs: !!(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || e.displacementMap),
                uvsVertexOnly: !(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || !e.displacementMap),
                fog: !!s,
                useFog: e.fog,
                fogExp2: s && s.isFogExp2,
                flatShading: e.flatShading,
                sizeAttenuation: e.sizeAttenuation,
                logarithmicDepthBuffer: x,
                skinning: e.skinning && 0 < d,
                maxBones: d,
                useVertexTexture: b,
                morphTargets: e.morphTargets,
                morphNormals: e.morphNormals,
                maxMorphTargets: v.maxMorphTargets,
                maxMorphNormals: v.maxMorphNormals,
                numDirLights: t.directional.length,
                numPointLights: t.point.length,
                numSpotLights: t.spot.length,
                numRectAreaLights: t.rectArea.length,
                numHemiLights: t.hemi.length,
                numDirLightShadows: t.directionalShadowMap.length,
                numPointLightShadows: t.pointShadowMap.length,
                numSpotLightShadows: t.spotShadowMap.length,
                numClippingPlanes: i,
                numClipIntersection: a,
                dithering: e.dithering,
                shadowMapEnabled: v.shadowMap.enabled && 0 < n.length,
                shadowMapType: v.shadowMap.type,
                toneMapping: e.toneMapped ? v.toneMapping : k,
                physicallyCorrectLights: v.physicallyCorrectLights,
                premultipliedAlpha: e.premultipliedAlpha,
                alphaTest: e.alphaTest,
                doubleSided: e.side === ie,
                flipSided: e.side === Pe,
                depthPacking: void 0 !== e.depthPacking && e.depthPacking,
                numMorphTargets: Math.min((o.morphTargetInfluences || []).length, v.maxMorphTargets),
                distancePacking: void 0 !== e.distancePacking && e.distancePacking,
                useSlopeScaledBias: void 0 !== e.useSlopeScaledBias && e.useSlopeScaledBias,
                materialName: e.name,
                materialProfile: e.profile,
                unitsScaleFactor: v.unitsScaleFactor,
                useHDR: !!e.useHDR,
                customPrepTokens: e.customPrepTokens,
                isMeshNodeMaterial: e.isMeshNodeMaterial,
                nodeChunks: e.nodeChunks,
                nodeChunksHash: e.nodeChunksHash,
                index0AttributeName: e.index0AttributeName,
                extensionDerivatives: e.extensions && e.extensions.derivatives,
                extensionFragDepth: e.extensions && e.extensions.frawbuffers,
                extensionDrawbuffers: e.extensions && e.extensions.drawbuffers,
                extensionShaderTextureLOD: e.extensions && e.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: y || null !== g.get("EXT_frag_depth"),
                rendererExtensionDrawBuffers: y || null !== g.get("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod: y || null !== g.get("EXT_shader_texture_lod"),
                onBeforeCompile: e.onBeforeCompile
            }
        }, this.getProgramCacheKey = function (e) {
            var t = [];
            if (e.shaderID ? t.push(e.shaderID) : (t.push(e.fragmentShader), t.push(e.vertexShader)), void 0 !== e.defines)
                for (var n in e.defines) t.push(n), t.push(e.defines[n]);
            if (void 0 !== e.customPrepTokens)
                for (var n in e.customPrepTokens) t.push(n), t.push(e.customPrepTokens[n]);
            if (void 0 === e.isRawShaderMaterial) {
                for (var r = 0; r < i.length; r++) t.push(e[i[r]]);
                t.push(v.outputEncoding), t.push(v.gammaFactor)
            }
            return t.push(e.onBeforeCompile.toString()), void 0 !== e.nodeChunksHash && t.push(e.nodeChunksHash), t.join()
        }, this.acquireProgram = function (e, t) {
            for (var n, r = 0, i = s.length; r < i; r++) {
                var a = s[r];
                if (a.cacheKey === t) {
                    ++(n = a).usedTimes;
                    break
                }
            }
            void 0 === n && (n = new Ao(v, t, e), s.push(n));
            var o = n.profile.materials;
            return e.materialName && o.indexOf(e.materialName) < 0 && o.push(e.materialName), n
        }, this.releaseProgram = function (e) {
            if (0 == --e.usedTimes) {
                var t = s.indexOf(e);
                s[t] = s[s.length - 1], s.pop(), e.destroy()
            }
        }, this.programs = s
    }

    function To() {
        var r = new WeakMap;
        return {
            get: function (e) {
                var t = r.get(e);
                return void 0 === t && (t = {}, r.set(e, t)), t
            },
            remove: function (e) {
                r.delete(e)
            },
            update: function (e, t, n) {
                r.get(e)[t] = n
            },
            dispose: function () {
                r = new WeakMap
            }
        }
    }

    function Eo(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function Co(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function Po() {
        var s = [],
            l = 0,
            c = [],
            u = [],
            d = {
                id: -1
            };

        function h(e, t, n, r, i, a) {
            var o = s[l];
            return void 0 === o ? (o = {
                id: e.id,
                object: e,
                geometry: t,
                material: n,
                program: n.program || d,
                groupOrder: r,
                renderOrder: e.renderOrder,
                z: i,
                group: a
            }, s[l] = o) : (o.id = e.id, o.object = e, o.geometry = t, o.material = n, o.program = n.program || d, o.groupOrder = r, o.renderOrder = e.renderOrder, o.z = i, o.group = a), l++, o
        }
        return {
            opaque: c,
            transparent: u,
            init: function () {
                l = 0, c.length = 0, u.length = 0
            },
            push: function (e, t, n, r, i, a) {
                var o = h(e, t, n, r, i, a);
                (!0 === n.transparent ? u : c).push(o)
            },
            unshift: function (e, t, n, r, i, a) {
                var o = h(e, t, n, r, i, a);
                (!0 === n.transparent ? u : c).unshift(o)
            },
            sort: function (e, t) {
                1 < c.length && c.sort(e || Eo), 1 < u.length && u.sort(t || Co)
            }
        }
    }

    function Lo() {
        var i = new WeakMap;

        function a(e) {
            var t = e.target;
            t.removeEventListener("dispose", a), i.delete(t)
        }
        return {
            get: function (e, t) {
                var n, r = i.get(e);
                return void 0 === r ? (n = new Po, i.set(e, new WeakMap), i.get(e).set(t, n), e.addEventListener("dispose", a)) : void 0 === (n = r.get(t)) && (n = new Po, r.set(t, n)), n
            },
            dispose: function () {
                i = new WeakMap
            }
        }
    }

    function Ro(e) {
        this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new qt(512, 512), this.map = null, this.mapPass = null, this.matrix = new fn, this._frustum = new ji, this._frameExtents = new qt(1, 1), this._viewportCount = 1, this._viewports = [new $t(0, 0, 1, 1)], this.expBias = 1, this.slopeScaledBias = 0, this._additionalMap2D = null, this._additionalMapCube = null
    }

    function Do() {
        Ro.call(this, new Bi(50, 1, .5, 500)), this.useMinFov90 = !1
    }

    function Io() {
        var n = {};
        return {
            get: function (e) {
                if (void 0 !== n[e.id]) return n[e.id];
                var t;
                switch (e.type) {
                    case "DirectionalLight":
                        t = {
                            direction: new on,
                            color: new Pr,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new qt,
                            position: new on,
                            maxDistance: 0,
                            expBias: 1
                        };
                        break;
                    case "SpotLight":
                        t = {
                            position: new on,
                            direction: new on,
                            color: new Pr,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new qt,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3,
                            expBias: 1
                        };
                        break;
                    case "PointLight":
                        t = {
                            position: new on,
                            color: new Pr,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new qt,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3,
                            expBias: 1
                        };
                        break;
                    case "HemisphereLight":
                        t = {
                            direction: new on,
                            skyColor: new Pr,
                            groundColor: new Pr
                        };
                        break;
                    case "RectAreaLight":
                        t = {
                            color: new Pr,
                            position: new on,
                            halfWidth: new on,
                            halfHeight: new on
                        }
                }
                return n[e.id] = t
            }
        }
    }
    Object.assign(Ro.prototype, {
        isLightShadow: !0,
        _projScreenMatrix: new fn,
        _lightPositionWorld: new on,
        _lookTarget: new on,
        getViewportCount: function () {
            return this._viewportCount
        },
        getFrustum: function () {
            return this._frustum
        },
        updateMatrices: function (e) {
            var t = this.camera,
                n = this.matrix,
                r = this._projScreenMatrix,
                i = this._lookTarget,
                a = this._lightPositionWorld;
            a.setFromMatrixPosition(e.matrixWorld), t.position.copy(a), i.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(i), t.updateMatrixWorld(), r.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
        },
        getViewport: function (e) {
            return this._viewports[e]
        },
        getFrameExtents: function () {
            return this._frameExtents
        },
        copy: function (e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this.expBias = e.expBias, this.slopeScaledBias = e.slopeScaledBias, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        dispose: function () {
            null !== this.map && this.map.dispose(), null !== this._additionalMap2D && this._additionalMap2D.dispose(), null !== this._additionalMapCube && this._additionalMapCube.dispose()
        },
        toJSON: function () {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }), Do.prototype = Object.assign(Object.create(Ro.prototype), {
        constructor: Do,
        isSpotLightShadow: !0,
        updateMatrices: function (e) {
            var t = this.camera,
                n = 2 * Yt.RAD2DEG * e.angle,
                r = this.mapSize.width / this.mapSize.height,
                i = e.distance || t.far;
            n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), Ro.prototype.updateMatrices.call(this, e)
        },
        copy: function (e) {
            return Ro.prototype.copy.call(this, e), this.useMinFov90 = e.useMinFov90, this
        }
    }), Do.OMNI_MAP_ANGLE = Math.PI / 4;
    var No = 0;

    function Oo(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
    }

    function Fo() {
        for (var T = new Io, E = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            }, e = 0; e < 9; e++) E.probe.push(new on);
        var C = new on,
            P = new fn,
            L = new fn;
        return {
            setup: function (e, t, n) {
                for (var r = 0, i = 0, a = 0, o = 0; o < 9; o++) E.probe[o].set(0, 0, 0);
                var s = 0,
                    l = 0,
                    c = 0,
                    u = 0,
                    d = 0,
                    h = 0,
                    p = 0,
                    f = 0,
                    m = n.matrixWorldInverse;
                e.sort(Oo), o = 0;
                for (var v = e.length; o < v; o++) {
                    var g = e[o],
                        _ = g.color,
                        y = g.intensity,
                        x = g.distance,
                        b = g.shadow && g.shadow.map ? g.shadow.map.texture : null;
                    if (g.isAmbientLight) r += _.r * y, i += _.g * y, a += _.b * y;
                    else if (g.isLightProbe)
                        for (var w = 0; w < 9; w++) E.probe[w].addScaledVector(g.sh.coefficients[w], y);
                    else if (g.isDirectionalLight) {
                        if ((A = T.get(g)).position.setFromMatrixPosition(g.matrixWorld), A.position.applyMatrix4(m), A.color.copy(g.color).multiplyScalar(g.intensity), A.direction.setFromMatrixPosition(g.matrixWorld), C.setFromMatrixPosition(g.target.matrixWorld), A.direction.sub(C), A.direction.transformDirection(m), A.shadow = g.castShadow, g.castShadow) {
                            var M = g.shadow;
                            A.shadowBias = M.bias, A.shadowRadius = M.radius, A.shadowMapSize = M.mapSize, E.directionalShadowMap[s] = b, E.directionalShadowMatrix[s] = g.shadow.matrix, h++, A.expBias = M.expBias, A.maxDistance = M.isDirectionalLightShadowCSM ? M.maxDistance : n.far
                        }
                        E.directional[s] = A, s++
                    } else if (g.isSpotLight) {
                        if ((A = T.get(g)).position.setFromMatrixPosition(g.matrixWorld), A.position.applyMatrix4(m), A.color.copy(_).multiplyScalar(y), A.distance = x, A.direction.setFromMatrixPosition(g.matrixWorld), C.setFromMatrixPosition(g.target.matrixWorld), A.direction.sub(C), A.direction.transformDirection(m), A.coneCos = Math.cos(g.angle), A.penumbraCos = Math.cos(g.angle * (1 - g.penumbra)), A.decay = g.decay, A.shadow = g.castShadow ? g.angle > Do.OMNI_MAP_ANGLE ? 2 : 1 : 0, g.castShadow) {
                            M = g.shadow;
                            A.shadowBias = M.bias, A.expBias = M.expBias, A.shadowRadius = M.radius, A.shadowMapSize = M.mapSize, E.spotShadowMap[c] = b, E.spotShadowMatrix[c] = g.shadow.matrix, f++, A.shadowCameraNear = M.camera.near, A.shadowCameraFar = M.camera.far
                        }
                        E.spot[c] = A, c++
                    } else if (g.isRectAreaLight) {
                        (A = T.get(g)).color.copy(_).multiplyScalar(y), A.position.setFromMatrixPosition(g.matrixWorld), A.position.applyMatrix4(m), L.identity(), P.copy(g.matrixWorld), P.premultiply(m), L.extractRotation(P), A.halfWidth.set(.5 * g.width, 0, 0), A.halfHeight.set(0, .5 * g.height, 0), A.halfWidth.applyMatrix4(L), A.halfHeight.applyMatrix4(L), E.rectArea[u] = A, u++
                    } else if (g.isPointLight) {
                        if ((A = T.get(g)).position.setFromMatrixPosition(g.matrixWorld), A.position.applyMatrix4(m), A.color.copy(g.color).multiplyScalar(g.intensity), A.distance = g.distance, A.decay = g.decay, A.shadow = g.castShadow, g.castShadow) {
                            M = g.shadow;
                            A.shadowBias = M.bias, A.expBias = M.expBias, A.shadowRadius = M.radius, A.shadowMapSize = M.mapSize, A.shadowCameraNear = M.camera.near, A.shadowCameraFar = M.camera.far, E.pointShadowMap[l] = b, E.pointShadowMatrix[l] = g.shadow.matrix, p++
                        }
                        E.point[l] = A, l++
                    } else if (g.isHemisphereLight) {
                        var A;
                        (A = T.get(g)).direction.setFromMatrixPosition(g.matrixWorld), A.direction.transformDirection(m), A.direction.normalize(), A.skyColor.copy(g.color).multiplyScalar(y), A.groundColor.copy(g.groundColor).multiplyScalar(y), E.hemi[d] = A, d++
                    }
                }
                E.ambient[0] = r, E.ambient[1] = i, E.ambient[2] = a;
                var S = E.hash;
                S.directionalLength === s && S.pointLength === l && S.spotLength === c && S.rectAreaLength === u && S.hemiLength === d && S.numDirectionalShadows === h && S.numPointShadows === p && S.numSpotShadows === f || (E.directional.length = s, E.spot.length = c, E.rectArea.length = u, E.point.length = l, E.hemi.length = d, E.directionalShadowMap.length = h, E.pointShadowMap.length = p, E.spotShadowMap.length = f, E.directionalShadowMatrix.length = h, E.pointShadowMatrix.length = p, E.spotShadowMatrix.length = f, S.directionalLength = s, S.pointLength = l, S.spotLength = c, S.rectAreaLength = u, S.hemiLength = d, S.numDirectionalShadows = h, S.numPointShadows = p, S.numSpotShadows = f, E.version = No++)
            },
            state: E
        }
    }

    function Bo() {
        var t = new Fo,
            n = [],
            r = [];
        return {
            init: function () {
                n.length = 0, r.length = 0
            },
            state: {
                lightsArray: n,
                shadowsArray: r,
                lights: t
            },
            setupLights: function (e) {
                t.setup(n, r, e)
            },
            pushLight: function (e) {
                n.push(e)
            },
            pushShadow: function (e) {
                r.push(e)
            }
        }
    }

    function zo() {
        var r = new WeakMap;

        function i(e) {
            var t = e.target;
            t.removeEventListener("dispose", i), r.delete(t)
        }
        return {
            get: function (e, t) {
                var n;
                return !1 === r.has(e) ? (n = new Bo, r.set(e, new WeakMap), r.get(e).set(t, n), e.addEventListener("dispose", i)) : !1 === r.get(e).has(t) ? (n = new Bo, r.get(e).set(t, n)) : n = r.get(e).get(t), n
            },
            dispose: function () {
                r = new WeakMap
            }
        }
    }

    function Uo(e) {
        Or.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Dt, this.useSlopeScaledBias = !1, this.slopeScaledBias = 0, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
    }

    function Vo(e) {
        Or.call(this), this.type = "MeshDistanceMaterial", this.distancePacking = Nt, this.useSlopeScaledBias = !1, this.slopeScaledBias = 0, this.referencePosition = new on, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
    }((Uo.prototype = Object.create(Or.prototype)).constructor = Uo).prototype.isMeshDepthMaterial = !0, Uo.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.useSlopeScaledBias = e.useSlopeScaledBias, this.slopeScaledBias = e.slopeScaledBias, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }, ((Vo.prototype = Object.create(Or.prototype)).constructor = Vo).prototype.isMeshDistanceMaterial = !0, Vo.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.distancePacking = e.distancePacking, this.useSlopeScaledBias = e.useSlopeScaledBias, this.slopeScaledBias = e.slopeScaledBias, this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    };
    var Go = .8,
        ko = .2,
        jo = .8,
        Wo = 3;

    function Xo(_, v, g) {
        var y = new ji,
            x = new fn,
            h = new fn,
            b = new qt,
            w = new qt(g.maxTextureSize, g.maxTextureSize),
            M = new on,
            A = new on,
            S = 1,
            T = 2,
            e = 1 + (S | T),
            E = new Array(e),
            C = new Array(e),
            P = {},
            L = {
                0: Pe,
                1: re,
                2: ie
            },
            R = [new on(1, 0, 0), new on(-1, 0, 0), new on(0, 1, 0), new on(0, -1, 0), new on(0, 0, 1), new on(0, 0, -1)],
            D = [new on(0, 1, 0), new on(0, 1, 0), new on(0, 0, 1), new on(0, 0, -1), new on(0, 1, 0), new on(0, 1, 0)],
            c = [new $t, new $t, new $t, new $t, new $t, new $t],
            f = new nr,
            p = [new on, new on, new on, new on, new on, new on, new on, new on],
            I = 0,
            N = 1,
            O = 0,
            m = 1,
            F = new qi(-1, 1, 1, -1, 0, 10),
            B = new xi(new Qi(2, 2)),
            z = new Oi({
                type: "ShadowCubeOctahedral",
                defines: Object.assign({}, Ji.cubeOctahedral.defines),
                uniforms: Di.clone(Ji.cubeOctahedral.uniforms),
                vertexShader: Ji.cubeOctahedral.vertexShader,
                fragmentShader: Ji.cubeOctahedral.fragmentShader
            }),
            u = {};
        var d = {};

        function U(e, t, n, r, i, a, o) {
            var s, l, c = B.material = o === O ? ((l = r) in u || ((u[l] = new Oi({
                type: "ShadowBlur",
                defines: Object.assign({}, Ji.blur.defines, {
                    LOG_SPACE: 1,
                    OCTAHEDRAL_MAP: 1
                }),
                uniforms: Di.clone(Ji.blur.uniforms),
                customPrepTokens: Object.assign({}, Ji.blur.customPrepTokens),
                vertexShader: Ji.blur.vertexShader,
                fragmentShader: Ji.blur.fragmentShader
            })).customPrepTokens.MAX_SAMPLE_RADIUS = l), u[l]) : ((s = r) in d || ((d[s] = new Oi({
                type: "ShadowBlur",
                defines: Object.assign({}, Ji.blur.defines, {
                    LOG_SPACE: 1
                }),
                uniforms: Di.clone(Ji.blur.uniforms),
                customPrepTokens: Object.assign({}, Ji.blur.customPrepTokens),
                vertexShader: Ji.blur.vertexShader,
                fragmentShader: Ji.blur.fragmentShader
            })).customPrepTokens.MAX_SAMPLE_RADIUS = s), d[s]);
            c.uniforms.direction.value.set(+(a === I), +(a === N)), c.uniforms.colorTexture.value = t.texture, c.uniforms.texSize.value.set(t.width, t.height), c.uniforms.kernelRadius.value = i, c.uniformsNeedUpdate = !0, e.setRenderTarget(n), e.clear(), e.updateGeometry(B), e.renderBufferDirect(F, !1, B.geometry, c, B, null)
        }
        for (var t = 0; t !== e; ++t) {
            var n = 0 != (t & S),
                r = 0 != (t & T),
                i = new Uo({
                    depthPacking: It,
                    morphTargets: n,
                    skinning: r
                });
            E[t] = i;
            var a = new Vo({
                distancePacking: Nt,
                morphTargets: n,
                skinning: r
            });
            C[t] = a
        }
        var V = this;

        function G(e, t, n, r, i, a, o) {
            var s = e.geometry,
                l = null,
                c = E,
                u = e.customDepthMaterial;
            if (!r && V.type !== te || (c = C, u = e.customDistanceMaterial), u) l = u;
            else {
                var d = !1;
                t.morphTargets && (s && s.isBufferGeometry ? d = s.morphAttributes && s.morphAttributes.position && 0 < s.morphAttributes.position.length : s && s.isGeometry && (d = s.morphTargets && 0 < s.morphTargets.length)), e.isSkinnedMesh && !1 === t.skinning && console.warn("v3d.WebGLShadowMap: v3d.SkinnedMesh with material.skinning set to false:", e);
                var h = e.isSkinnedMesh && t.skinning,
                    p = 0;
                d && (p |= S), h && (p |= T), l = c[p]
            }
            if (_.localClippingEnabled && !0 === t.clipShadows && 0 !== t.clippingPlanes.length) {
                var f = l.uuid,
                    m = t.uuid,
                    v = P[f];
                void 0 === v && (v = {}, P[f] = v);
                var g = v[m];
                void 0 === g && (g = l.clone(), v[m] = g), l = g
            }
            return l.visible = t.visible, l.wireframe = t.wireframe, l.side = null != t.shadowSide ? t.shadowSide : L[t.side], l.clipShadows = t.clipShadows, l.clippingPlanes = t.clippingPlanes, l.clipIntersection = t.clipIntersection, l.wireframeLinewidth = t.wireframeLinewidth, l.linewidth = t.linewidth, (r || V.type === te) && l.isMeshDistanceMaterial && (l.referencePosition.copy(i), l.nearDistance = a, l.farDistance = o, l.distancePacking = V.type === te ? Ot : Nt), V.type === ne && (l.useSlopeScaledBias = !0, l.slopeScaledBias = n.shadow.slopeScaledBias), l
        }

        function k(e, t, n, r, i) {
            if (!1 !== e.visible) {
                if (e.layers.test(t.layers) && (e.isMesh || e.isLine || e.isPoints) && e.castShadow && (!e.frustumCulled || y.intersectsObject(e))) {
                    e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld);
                    var a = v.update(e),
                        o = e.material;
                    if (Array.isArray(o))
                        for (var s = a.groups, l = 0, c = s.length; l < c; l++) {
                            var u = s[l],
                                d = o[u.materialIndex];
                            if (d && d.visible) {
                                var h = G(e, d, i, r, A, n.near, n.far);
                                _.renderBufferDirect(n, null, a, h, e, u)
                            }
                        } else if (o.visible) {
                            h = G(e, o, i, r, A, n.near, n.far);
                            _.renderBufferDirect(n, null, a, h, e, null)
                        }
                }
                for (var p = e.children, f = 0, m = p.length; f < m; f++) k(p[f], t, n, r, i)
            }
        }

        function j(e, t, n) {
            var r = n.shadow,
                i = r.camera,
                a = r.matrix,
                o = n.isPointLight ? 2 : 1,
                s = b.copy(r.mapSize).multiplyScalar(o).min(w).multiplyScalar(1 / o);
            null === r._additionalMapCube && (r._additionalMapCube = new Ui(s.x, {
                minFilter: Je,
                magFilter: Je,
                format: g.isWebGL2 ? dt : lt,
                type: at
            }), r._additionalMapCube.texture.name = n.name + ".shadowMap.tmpCube"), null === r._additionalMap2D && (r._additionalMap2D = new en(s.x * o, s.y * o, {
                minFilter: Je,
                magFilter: Je,
                format: g.isWebGL2 ? dt : lt,
                type: at
            }), r._additionalMap2D.texture.name = n.name + ".shadowMap.tmp2D"), null === r.map && (r.map = new en(s.x * o, s.y * o, {
                minFilter: Je,
                magFilter: Je,
                format: g.isWebGL2 ? dt : lt,
                type: at
            }), r.map.texture.name = n.name + ".shadowMap"), A.setFromMatrixPosition(n.matrixWorld), i.position.copy(A), n.isSpotLight && (i.fov = 90, i.updateProjectionMatrix()), a.makeTranslation(-A.x, -A.y, -A.z), _.state.buffers.color.setClear(i.far, 1, 1, 1);
            for (var l = 0; l < 6; l++) _.setRenderTarget(r._additionalMapCube, l), _.clear(), M.copy(i.position), M.add(R[l]), i.up.copy(D[l]), 2 !== l && 3 !== l && i.up.multiplyScalar(-1), i.lookAt(M), i.updateMatrixWorld(), x.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), y.setFromProjectionMatrix(x), k(e, t, i, !0, n);
            var c, u, d, h, p, f = Math.max(r.radius * o, .001),
                m = (c = f, Math.ceil(ko * c));
            u = _, d = r._additionalMapCube, h = r.map, (p = B.material = z).uniforms.tCube.value = d.texture, p.uniforms.texelSize.value.set(1 / h.width, 1 / h.height), p.uniformsNeedUpdate = !0, u.setRenderTarget(h), u.clear(), u.updateGeometry(B), u.renderBufferDirect(F, !1, B.geometry, p, B, null), U(_, r.map, r._additionalMap2D, m, f, N, O), U(_, r._additionalMap2D, r.map, m, f, I, O)
        }

        function W(e, t, n) {
            var r = n.shadow,
                i = r.camera,
                a = r.matrix,
                o = b.copy(r.mapSize);
            if (o.x *= 4, o.y *= 2, o.min(w), o.x /= 4, o.y /= 2, c[0].set(2 * o.x, o.y, o.x, o.y), c[1].set(0, o.y, o.x, o.y), c[2].set(3 * o.x, 0, o.x, o.y), c[3].set(o.x, 0, o.x, o.y), c[4].set(3 * o.x, o.y, o.x, o.y), c[5].set(o.x, o.y, o.x, o.y), n.isSpotLight && r.map && r.map.width / r.map.height != 2) {
                var s = r.map;
                r.map = r._additionalMap2D, r._additionalMap2D = s
            }
            null === r.map && (r.map = new en(4 * o.x, 2 * o.y, {
                minFilter: Ze,
                magFilter: Ze,
                format: lt,
                type: tt
            }), r.map.texture.name = n.name + ".shadowMap"), A.setFromMatrixPosition(n.matrixWorld), i.position.copy(A), n.isSpotLight && (i.fov = 90, i.updateProjectionMatrix()), a.makeTranslation(-A.x, -A.y, -A.z), _.state.buffers.color.setClear(1, 1, 1, 1), _.setRenderTarget(r.map), _.clear();
            for (var l = 0; l < 6; l++) _.state.viewport(c[l]), M.copy(i.position), M.add(R[l]), i.up.copy(D[l]), i.lookAt(M), i.updateMatrixWorld(), x.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), y.setFromProjectionMatrix(x), k(e, t, i, !0, n)
        }

        function X(e, t, n) {
            var r, i, a, o = n.shadow,
                s = o.camera,
                l = o.matrix,
                c = b.copy(o.mapSize).min(w);
            if (null === o._additionalMap2D && (o._additionalMap2D = new en(c.x, c.y, {
                    minFilter: Je,
                    magFilter: Je,
                    format: g.isWebGL2 ? dt : lt,
                    type: at
                }), o._additionalMap2D.texture.name = n.name + ".shadowMap.tmp2D"), null === o.map && (o.map = new en(c.x, c.y, {
                    minFilter: Je,
                    magFilter: Je,
                    format: g.isWebGL2 ? dt : lt,
                    type: at
                }), o.map.texture.name = n.name + ".shadowMap"), A.setFromMatrixPosition(n.matrixWorld), s.position.copy(A), M.setFromMatrixPosition(n.target.matrixWorld), s.lookAt(M), s.updateMatrixWorld(), n.isDirectionalLight && n.shadow.isDirectionalLightShadowCSM) {
                var u = Y(t, o, c, f);
                s.left = u.center.x - u.radius, s.right = u.center.x + u.radius, s.top = u.center.y + u.radius, s.bottom = u.center.y - u.radius, s.updateProjectionMatrix()
            } else n.isSpotLight && o.useMinFov90 && (s.fov = 90, s.updateProjectionMatrix());
            if (l.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), l.multiply(s.projectionMatrix), l.multiply(s.matrixWorldInverse), _.state.buffers.color.setClear(Wo * s.far, 1, 1, 1), _.setRenderTarget(o.map), _.clear(), x.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), y.setFromProjectionMatrix(x), k(e, t, s, !1, n), n.isDirectionalLight && n.shadow.isDirectionalLightShadowCSM) var d = (r = o.radius, i = (s.right - s.left) / 2, (a = r / i) < 2 ? .5 * a + 1 : 2.5 * a - 3);
            else if (n.isSpotLight) d = o.radius * jo;
            else d = o.radius;
            d = Math.max(d, .001);
            var h, p = (h = d, Math.ceil(Go * h));
            U(_, o.map, o._additionalMap2D, p, d, I, m), U(_, o._additionalMap2D, o.map, p, d, N, m)
        }

        function H(e, t, n) {
            var r = n.shadow,
                i = r.camera,
                a = r.matrix,
                o = b.copy(r.mapSize).min(w);
            if (n.isSpotLight && r.map && r.map.width !== r.map.height) {
                var s = r.map;
                r.map = r._additionalMap2D, r._additionalMap2D = s
            }
            if (null === r.map && (r.map = new en(o.x, o.y, {
                    minFilter: Ze,
                    magFilter: Ze,
                    format: lt,
                    type: tt
                }), r.map.texture.name = n.name + ".shadowMap"), r.isSpotLightShadow && r.updateMatrices(n), A.setFromMatrixPosition(n.matrixWorld), i.position.copy(A), M.setFromMatrixPosition(n.target.matrixWorld), i.lookAt(M), i.updateMatrixWorld(), n.isDirectionalLight && n.shadow.isDirectionalLightShadowCSM) {
                var l = Y(t, r, o, f);
                i.left = l.center.x - l.radius, i.right = l.center.x + l.radius, i.top = l.center.y + l.radius, i.bottom = l.center.y - l.radius, i.updateProjectionMatrix()
            } else n.isSpotLight && r.useMinFov90 && (i.fov = 90, i.updateProjectionMatrix());
            a.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), a.multiply(i.projectionMatrix), a.multiply(i.matrixWorldInverse), _.state.buffers.color.setClear(1, 1, 1, 1), _.setRenderTarget(r.map), _.clear(), x.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), y.setFromProjectionMatrix(x), k(e, t, i, !1, n)
        }

        function Y(e, t, n, r) {
            for (var i = Yt.clamp(t.maxDistance, e.near, e.far) / e.far, a = 0; a < p.length; a++) {
                var o = p[a],
                    s = 1 & a;
                o.set(a >> 2 & 1, a >> 1 & 1, s).multiplyScalar(2).subScalar(1).applyMatrix4(e.projectionMatrixInverse), 1 == s && o.multiplyScalar(i)
            }
            r.setFromPoints(p), h.multiplyMatrices(t.camera.matrixWorldInverse, e.matrixWorld);
            var l = r.center.applyMatrix4(h),
                c = r.radius *= h.getMaxScaleOnAxis(),
                u = n.x / 2 / c,
                d = n.y / 2 / c;
            return l.x = Math.round(l.x * u) / u, l.y = Math.round(l.y * d) / d, r
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Z, this.render = function (e, t, n) {
            if (V.type == ee && (V.type = Z, console.warn("v3d.WebGLShadowMap: disable unsupported VSM shadow maps")), !1 !== V.enabled && (!1 !== V.autoUpdate || !1 !== V.needsUpdate) && 0 !== e.length) {
                var r = _.getRenderTarget(),
                    i = _.getActiveCubeFace(),
                    a = _.getActiveMipmapLevel(),
                    o = _.state;
                o.setBlending(ae), o.buffers.color.setClear(1, 1, 1, 1), o.buffers.depth.setTest(!0), o.setScissorTest(!1);
                for (var s = 0, l = e.length; s < l; s++) {
                    var c = e[s];
                    if (void 0 !== c.shadow)
                        if (c.shadow.updateMatrices(c), c.isPointLight || c.isSpotLight && c.angle > Do.OMNI_MAP_ANGLE)
                            if (V.type === q || V.type === Z || V.type === $ || V.type === ne) W(t, n, c);
                            else {
                                if (V.type !== te) continue;
                                j(t, n, c)
                            }
                    else {
                        if (!c.isSpotLight && !c.isDirectionalLight) continue;
                        if (V.type === q || V.type === Z || V.type === $ || V.type === ne) H(t, n, c);
                        else {
                            if (V.type !== te) continue;
                            X(t, n, c)
                        }
                    } else console.warn("v3d.WebGLShadowMap:", c, "has no shadow.")
                }
                V.needsUpdate = !1, _.setRenderTarget(r, i, a)
            }
        }
    }

    function Ho(u, n, e) {
        var t, r, i = e.isWebGL2;
        var a = new function () {
                var t = !1,
                    a = new $t,
                    n = null,
                    o = new $t(0, 0, 0, 0);
                return {
                    setMask: function (e) {
                        n === e || t || (u.colorMask(e, e, e, e), n = e)
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (e, t, n, r, i) {
                        !0 === i && (e *= r, t *= r, n *= r), a.set(e, t, n, r), !1 === o.equals(a) && (u.clearColor(e, t, n, r), o.copy(a))
                    },
                    reset: function () {
                        t = !1, n = null, o.set(-1, 0, 0, 0)
                    }
                }
            },
            o = new function () {
                var t = !1,
                    n = null,
                    r = null,
                    i = null;
                return {
                    setTest: function (e) {
                        (e ? V : G)(2929)
                    },
                    setMask: function (e) {
                        n === e || t || (u.depthMask(e), n = e)
                    },
                    setFunc: function (e) {
                        if (r !== e) {
                            if (e) switch (e) {
                                case Ee:
                                    u.depthFunc(512);
                                    break;
                                case Ce:
                                    u.depthFunc(519);
                                    break;
                                case Le:
                                    u.depthFunc(513);
                                    break;
                                case Re:
                                    u.depthFunc(515);
                                    break;
                                case De:
                                    u.depthFunc(514);
                                    break;
                                case Ie:
                                    u.depthFunc(518);
                                    break;
                                case Ne:
                                    u.depthFunc(516);
                                    break;
                                case Oe:
                                    u.depthFunc(517);
                                    break;
                                default:
                                    u.depthFunc(515)
                            } else u.depthFunc(515);
                            r = e
                        }
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (e) {
                        i !== e && (u.clearDepth(e), i = e)
                    },
                    reset: function () {
                        t = !1, i = r = n = null
                    }
                }
            },
            s = new function () {
                var t = !1,
                    n = null,
                    r = null,
                    i = null,
                    a = null,
                    o = null,
                    s = null,
                    l = null,
                    c = null;
                return {
                    setTest: function (e) {
                        t || (e ? V : G)(2960)
                    },
                    setMask: function (e) {
                        n === e || t || (u.stencilMask(e), n = e)
                    },
                    setFunc: function (e, t, n) {
                        r === e && i === t && a === n || (u.stencilFunc(e, t, n), r = e, i = t, a = n)
                    },
                    setOp: function (e, t, n) {
                        o === e && s === t && l === n || (u.stencilOp(e, t, n), o = e, s = t, l = n)
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (e) {
                        c !== e && (u.clearStencil(e), c = e)
                    },
                    reset: function () {
                        t = !1, c = l = s = o = a = i = r = n = null
                    }
                }
            },
            l = u.getParameter(34921),
            c = new Uint8Array(l),
            d = new Uint8Array(l),
            h = new Uint8Array(l),
            p = {},
            f = null,
            m = null,
            v = null,
            g = null,
            _ = null,
            y = null,
            x = null,
            b = null,
            w = null,
            M = !1,
            A = null,
            S = null,
            T = null,
            E = null,
            C = null,
            P = u.getParameter(35661),
            L = !1,
            R = 0,
            D = u.getParameter(7938); - 1 !== D.indexOf("WebGL") ? (R = parseFloat(/^WebGL\ ([0-9])/.exec(D)[1]), L = 1 <= R) : -1 !== D.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(D)[1]), L = 2 <= R);
        var I = null,
            N = {},
            O = new $t,
            F = new $t;

        function B(e, t, n) {
            var r = new Uint8Array(4),
                i = u.createTexture();
            u.bindTexture(e, i), u.texParameteri(e, 10241, 9728), u.texParameteri(e, 10240, 9728);
            for (var a = 0; a < n; a++) u.texImage2D(t + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return i
        }
        var z = {};

        function U(e, t) {
            c[e] = 1, 0 === d[e] && (u.enableVertexAttribArray(e), d[e] = 1), h[e] !== t && ((i ? u : n.get("ANGLE_instanced_arrays"))[i ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e, t), h[e] = t)
        }

        function V(e) {
            !0 !== p[e] && (u.enable(e), p[e] = !0)
        }

        function G(e) {
            !1 !== p[e] && (u.disable(e), p[e] = !1)
        }
        z[3553] = B(3553, 3553, 1), z[34067] = B(34067, 34069, 6), a.setClear(0, 0, 0, 1), o.setClear(1), s.setClear(0), V(2929), o.setFunc(Re), H(!1), Y(K), V(2884), X(ae);
        var k = (_defineProperty(t = {}, de, 32774), _defineProperty(t, he, 32778), _defineProperty(t, pe, 32779), t);
        if (i) k[fe] = 32775, k[me] = 32776;
        else {
            var j = n.get("EXT_blend_minmax");
            null !== j && (k[fe] = j.MIN_EXT, k[me] = j.MAX_EXT)
        }
        var W = (_defineProperty(r = {}, ve, 0), _defineProperty(r, ge, 1), _defineProperty(r, _e, 768), _defineProperty(r, xe, 770), _defineProperty(r, Te, 776), _defineProperty(r, Ae, 774), _defineProperty(r, we, 772), _defineProperty(r, ye, 769), _defineProperty(r, be, 771), _defineProperty(r, Se, 775), _defineProperty(r, Me, 773), r);

        function X(e, t, n, r, i, a, o, s) {
            if (e !== ae) {
                if (m || (V(3042), m = !0), e === ue) i = i || t, a = a || n, o = o || r, t === g && i === x || (u.blendEquationSeparate(k[t], k[i]), g = t, x = i), n === _ && r === y && a === b && o === w || (u.blendFuncSeparate(W[n], W[r], W[a], W[o]), _ = n, y = r, b = a, w = o), v = e, M = null;
                else if (e !== v || s !== M) {
                    if (g === de && x === de || (u.blendEquation(32774), x = g = de), s) switch (e) {
                        case oe:
                            u.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case se:
                            u.blendFunc(1, 1);
                            break;
                        case le:
                            u.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case ce:
                            u.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("v3d.WebGLState: Invalid blending: ", e)
                    } else switch (e) {
                        case oe:
                            u.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case se:
                            u.blendFunc(770, 1);
                            break;
                        case le:
                            u.blendFunc(0, 769);
                            break;
                        case ce:
                            u.blendFunc(0, 768);
                            break;
                        default:
                            console.error("v3d.WebGLState: Invalid blending: ", e)
                    }
                    w = b = y = _ = null, v = e, M = s
                }
            } else m && (G(3042), m = !1)
        }

        function H(e) {
            A !== e && (e ? u.frontFace(2304) : u.frontFace(2305), A = e)
        }

        function Y(e) {
            e !== Q ? (V(2884), e !== S && (e === K ? u.cullFace(1029) : e === J ? u.cullFace(1028) : u.cullFace(1032))) : G(2884), S = e
        }

        function q(e, t, n) {
            e ? (V(32823), E === t && C === n || (u.polygonOffset(t, n), E = t, C = n)) : G(32823)
        }

        function Z(e) {
            void 0 === e && (e = 33984 + P - 1), I !== e && (u.activeTexture(e), I = e)
        }
        return {
            buffers: {
                color: a,
                depth: o,
                stencil: s
            },
            initAttributes: function () {
                for (var e = 0, t = c.length; e < t; e++) c[e] = 0
            },
            enableAttribute: function (e) {
                U(e, 0)
            },
            enableAttributeAndDivisor: U,
            disableUnusedAttributes: function () {
                for (var e = 0, t = d.length; e !== t; ++e) d[e] !== c[e] && (u.disableVertexAttribArray(e), d[e] = 0)
            },
            enable: V,
            disable: G,
            useProgram: function (e) {
                return f !== e && (u.useProgram(e), f = e, !0)
            },
            setBlending: X,
            setMaterial: function (e, t) {
                (e.side === ie ? G : V)(2884);
                var n = e.side === Pe;
                t && (n = !n), H(n), e.blending === oe && !1 === e.transparent ? X(ae) : X(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), o.setFunc(e.depthFunc), o.setTest(e.depthTest), o.setMask(e.depthWrite), a.setMask(e.colorWrite);
                var r = e.stencilWrite;
                s.setTest(r), r && (s.setMask(e.stencilWriteMask), s.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), s.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: H,
            setCullFace: Y,
            setLineWidth: function (e) {
                e !== T && (L && u.lineWidth(e), T = e)
            },
            setPolygonOffset: q,
            setScissorTest: function (e) {
                (e ? V : G)(3089)
            },
            activeTexture: Z,
            bindTexture: function (e, t) {
                null === I && Z();
                var n = N[I];
                void 0 === n && (n = {
                    type: void 0,
                    texture: void 0
                }, N[I] = n), n.type === e && n.texture === t || (u.bindTexture(e, t || z[e]), n.type = e, n.texture = t)
            },
            unbindTexture: function () {
                var e = N[I];
                void 0 !== e && void 0 !== e.type && (u.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
            },
            compressedTexImage2D: function () {
                try {
                    u.compressedTexImage2D.apply(u, arguments)
                } catch (e) {
                    console.error("v3d.WebGLState:", e)
                }
            },
            texImage2D: function () {
                try {
                    u.texImage2D.apply(u, arguments)
                } catch (e) {
                    console.error("v3d.WebGLState:", e)
                }
            },
            texImage3D: function () {
                try {
                    u.texImage3D.apply(u, arguments)
                } catch (e) {
                    console.error("v3d.WebGLState:", e)
                }
            },
            scissor: function (e) {
                !1 === O.equals(e) && (u.scissor(e.x, e.y, e.z, e.w), O.copy(e))
            },
            viewport: function (e) {
                !1 === F.equals(e) && (u.viewport(e.x, e.y, e.z, e.w), F.copy(e))
            },
            reset: function () {
                for (var e = 0; e < d.length; e++) 1 === d[e] && (u.disableVertexAttribArray(e), d[e] = 0);
                p = {}, N = {}, S = A = v = f = I = null, a.reset(), o.reset(), s.reset()
            }
        }
    }

    function Yo(y, x, b, w, i, M, A) {
        var e, t, c, S = i.isWebGL2,
            n = i.maxTextures,
            v = i.maxCubemapSize,
            m = i.maxTextureSize,
            r = i.maxSamples,
            o = new WeakMap,
            a = !1;
        try {
            a = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
        } catch (e) {}

        function u(e, t) {
            return a ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }

        function g(e, t, n, r) {
            var i = 1;
            if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    var a = t ? Yt.floorPowerOfTwo : Math.floor,
                        o = a(i * e.width),
                        s = a(i * e.height);
                    void 0 === c && (c = u(o, s));
                    var l = n ? u(o, s) : c;
                    return l.width = o, l.height = s, l.getContext("2d").drawImage(e, 0, 0, o, s), console.warn("v3d.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + s + ")."), l
                }
                return "data" in e && console.warn("v3d.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
            }
            return e
        }

        function T(e) {
            return Yt.isPowerOfTwo(e.width) && Yt.isPowerOfTwo(e.height)
        }

        function E(e, t) {
            return e.generateMipmaps && t && e.minFilter !== Ze && e.minFilter !== Je
        }

        function C(e, t, n, r) {
            y.generateMipmap(e), w.get(t).__maxMipLevel = Math.log(Math.max(n, r)) * Math.LOG2E
        }

        function P(e, t, n) {
            if (!1 === S) return t;
            if (null !== e) {
                if (void 0 !== y[e]) return y[e];
                console.warn("v3d.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'")
            }
            var r = t;
            return 6403 === t && (5126 === n && (r = 33326), 5131 === n && (r = 33325), 5121 === n && (r = 33321)), 6407 === t && (5126 === n && (r = 34837), 5131 === n && (r = 34843), 5121 === n && (r = 32849)), 6408 === t && (5126 === n && (r = 34836), 5131 === n && (r = 34842), 5121 === n && (r = 32856)), 33325 === r || 33326 === r || 34842 === r || 34836 === r ? x.get("EXT_color_buffer_float") : 34843 !== r && 34837 !== r || console.warn("v3d.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), r
        }

        function s(e) {
            return e === Ze || e === Qe || e === Ke ? 9728 : 9729
        }

        function l(e) {
            var t = e.target;
            t.removeEventListener("dispose", l),
                function (e) {
                    var t = w.get(e);
                    if (void 0 === t.__webglInit) return;
                    y.deleteTexture(t.__webglTexture), w.remove(e)
                }(t), t.isVideoTexture && o.delete(t), A.memory.textures--
        }

        function L(e) {
            var t = e.target;
            t.removeEventListener("dispose", L),
                function (e) {
                    var t = w.get(e),
                        n = w.get(e.texture);
                    if (!e) return;
                    void 0 !== n.__webglTexture && y.deleteTexture(n.__webglTexture);
                    e.depthTexture && e.depthTexture.dispose();
                    if (e.isWebGLCubeRenderTarget)
                        for (var r = 0; r < 6; r++) y.deleteFramebuffer(t.__webglFramebuffer[r]), t.__webglDepthbuffer && y.deleteRenderbuffer(t.__webglDepthbuffer[r]);
                    else y.deleteFramebuffer(t.__webglFramebuffer), t.__webglDepthbuffer && y.deleteRenderbuffer(t.__webglDepthbuffer);
                    if (e.isWebGLMultiviewRenderTarget) {
                        y.deleteTexture(t.__webglColorTexture), y.deleteTexture(t.__webglDepthStencilTexture), A.memory.textures -= 2;
                        r = 0;
                        for (var i = t.__webglViewFramebuffers.length; r < i; r++) y.deleteFramebuffer(t.__webglViewFramebuffers[r])
                    }
                    w.remove(e.texture), w.remove(e)
                }(t), A.memory.textures--
        }
        var d = 0;

        function h(e, t) {
            var n, r, i = w.get(e);
            if (e.isVideoTexture && (n = e, r = A.render.frame, o.get(n) !== r && (o.set(n, r), n.update())), 0 < e.version && i.__version !== e.version) {
                var a = e.image;
                if (void 0 === a) console.warn("v3d.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== a.complete) return void N(i, e, t);
                    console.warn("v3d.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            b.activeTexture(33984 + t), b.bindTexture(3553, i.__webglTexture)
        }

        function p(e, t) {
            if (6 === e.image.length) {
                var n = w.get(e);
                if (0 < e.version && n.__version !== e.version) {
                    I(n, e), b.activeTexture(33984 + t), b.bindTexture(34067, n.__webglTexture), y.pixelStorei(37440, e.flipY);
                    for (var r = e && (e.isCompressedTexture || e.image[0].isCompressedTexture), i = e.image[0] && e.image[0].isDataTexture, a = [], o = 0; o < 6; o++) a[o] = r || i ? i ? e.image[o].image : e.image[o] : g(e.image[o], !1, !0, v);
                    var s, l = a[0],
                        c = T(l) || S,
                        u = M.convert(e.format),
                        d = M.convert(e.type),
                        h = P(e.internalFormat, u, d);
                    if (D(34067, e, c), r) {
                        for (o = 0; o < 6; o++) {
                            s = a[o].mipmaps;
                            for (var p = 0; p < s.length; p++) {
                                var f = s[p];
                                e.format !== lt && e.format !== st ? null !== u ? b.compressedTexImage2D(34069 + o, p, h, f.width, f.height, 0, f.data) : console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : b.texImage2D(34069 + o, p, h, f.width, f.height, 0, u, d, f.data)
                            }
                        }
                        n.__maxMipLevel = s.length - 1
                    } else {
                        s = e.mipmaps;
                        for (o = 0; o < 6; o++)
                            if (i) {
                                b.texImage2D(34069 + o, 0, h, a[o].width, a[o].height, 0, u, d, a[o].data);
                                for (p = 0; p < s.length; p++) {
                                    var m = (f = s[p]).image[o].image;
                                    b.texImage2D(34069 + o, p + 1, h, m.width, m.height, 0, u, d, m.data)
                                }
                            } else {
                                b.texImage2D(34069 + o, 0, h, u, d, a[o]);
                                for (p = 0; p < s.length; p++) {
                                    f = s[p];
                                    b.texImage2D(34069 + o, p + 1, h, u, d, f.image[o])
                                }
                            } n.__maxMipLevel = s.length
                    }
                    E(e, c) && C(34067, e, l.width, l.height), n.__version = e.version, e.onUpdate && e.onUpdate(e)
                } else b.activeTexture(33984 + t), b.bindTexture(34067, n.__webglTexture)
            }
        }

        function f(e, t) {
            b.activeTexture(33984 + t), b.bindTexture(34067, w.get(e).__webglTexture)
        }
        var _ = (_defineProperty(e = {}, He, 10497), _defineProperty(e, Ye, 33071), _defineProperty(e, qe, 33648), e),
            R = (_defineProperty(t = {}, Ze, 9728), _defineProperty(t, Qe, 9984), _defineProperty(t, Ke, 9986), _defineProperty(t, Je, 9729), _defineProperty(t, $e, 9985), _defineProperty(t, et, 9987), t);

        function D(e, t, n) {
            n ? (y.texParameteri(e, 10242, _[t.wrapS]), y.texParameteri(e, 10243, _[t.wrapT]), 32879 !== e && 35866 !== e || y.texParameteri(e, 32882, _[t.wrapR]), y.texParameteri(e, 10240, R[t.magFilter]), y.texParameteri(e, 10241, R[t.minFilter])) : (y.texParameteri(e, 10242, 33071), y.texParameteri(e, 10243, 33071), 32879 !== e && 35866 !== e || y.texParameteri(e, 32882, 33071), t.wrapS === Ye && t.wrapT === Ye || console.warn("v3d.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to v3d.ClampToEdgeWrapping."), y.texParameteri(e, 10240, s(t.magFilter)), y.texParameteri(e, 10241, s(t.minFilter)), t.minFilter !== Ze && t.minFilter !== Je && console.warn("v3d.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to v3d.NearestFilter or v3d.LinearFilter."));
            var r = x.get("EXT_texture_filter_anisotropic");
            if (r) {
                if (t.type === it && null === x.get("OES_texture_float_linear")) return;
                if (t.type === at && null === (S || x.get("OES_texture_half_float_linear"))) return;
                (1 < t.anisotropy || w.get(t).__currentAnisotropy) && (y.texParameterf(e, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, i.getMaxAnisotropy())), w.get(t).__currentAnisotropy = t.anisotropy)
            }
        }

        function I(e, t) {
            void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", l), e.__webglTexture = y.createTexture(), A.memory.textures++)
        }

        function N(e, t, n) {
            var r = 3553;
            t.isDataTexture2DArray && (r = 35866), t.isDataTexture3D && (r = 32879), I(e, t), b.activeTexture(33984 + n), b.bindTexture(r, e.__webglTexture), y.pixelStorei(37440, t.flipY), y.pixelStorei(37441, t.premultiplyAlpha), y.pixelStorei(3317, t.unpackAlignment);
            var i, a = (i = t, !S && (i.wrapS !== Ye || i.wrapT !== Ye || i.minFilter !== Ze && i.minFilter !== Je) && !1 === T(t.image)),
                o = g(t.image, a, !1, m),
                s = T(o) || S,
                l = M.convert(t.format),
                c = M.convert(t.type),
                u = P(t.internalFormat, l, c);
            D(r, t, s);
            var d, h = t.mipmaps;
            if (t.isDepthTexture) {
                if (u = 6402, t.type === it) {
                    if (!1 === S) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    u = 36012
                } else S && (u = 33189);
                t.format === ct && 6402 === u && t.type !== nt && t.type !== rt && (console.warn("v3d.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), t.type = nt, c = M.convert(t.type)), t.format === ut && (u = 34041, t.type !== ot && (console.warn("v3d.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), t.type = ot, c = M.convert(t.type))), b.texImage2D(3553, 0, u, o.width, o.height, 0, l, c, null)
            } else if (t.isDataTexture)
                if (0 < h.length && s) {
                    for (var p = 0, f = h.length; p < f; p++) d = h[p], b.texImage2D(3553, p, u, d.width, d.height, 0, l, c, d.data);
                    t.generateMipmaps = !1, e.__maxMipLevel = h.length - 1
                } else b.texImage2D(3553, 0, u, o.width, o.height, 0, l, c, o.data), e.__maxMipLevel = 0;
            else if (t.isCompressedTexture) {
                for (p = 0, f = h.length; p < f; p++) d = h[p], t.format !== lt && t.format !== st ? null !== l ? b.compressedTexImage2D(3553, p, u, d.width, d.height, 0, d.data) : console.warn("v3d.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : b.texImage2D(3553, p, u, d.width, d.height, 0, l, c, d.data);
                e.__maxMipLevel = h.length - 1
            } else if (t.isDataTexture2DArray) b.texImage3D(35866, 0, u, o.width, o.height, o.depth, 0, l, c, o.data), e.__maxMipLevel = 0;
            else if (t.isDataTexture3D) b.texImage3D(32879, 0, u, o.width, o.height, o.depth, 0, l, c, o.data), e.__maxMipLevel = 0;
            else if (0 < h.length && s) {
                for (p = 0, f = h.length; p < f; p++) d = h[p], b.texImage2D(3553, p, u, l, c, d);
                t.generateMipmaps = !1, e.__maxMipLevel = h.length - 1
            } else b.texImage2D(3553, 0, u, l, c, o), e.__maxMipLevel = 0;
            E(t, s) && C(r, t, o.width, o.height), e.__version = t.version, t.onUpdate && t.onUpdate(t)
        }

        function O(e, t, n, r) {
            var i = M.convert(t.texture.format),
                a = M.convert(t.texture.type),
                o = P(t.texture.internalFormat, i, a);
            b.texImage2D(r, 0, o, t.width, t.height, 0, i, a, null), y.bindFramebuffer(36160, e), y.framebufferTexture2D(36160, n, r, w.get(t.texture).__webglTexture, 0), y.bindFramebuffer(36160, null)
        }

        function F(e, t, n) {
            if (y.bindRenderbuffer(36161, e), t.depthBuffer && !t.stencilBuffer) {
                if (n) {
                    var r = z(t);
                    y.renderbufferStorageMultisample(36161, r, 33189, t.width, t.height)
                } else y.renderbufferStorage(36161, 33189, t.width, t.height);
                y.framebufferRenderbuffer(36160, 36096, 36161, e)
            } else if (t.depthBuffer && t.stencilBuffer) {
                if (n) {
                    r = z(t);
                    y.renderbufferStorageMultisample(36161, r, 35056, t.width, t.height)
                } else y.renderbufferStorage(36161, 34041, t.width, t.height);
                y.framebufferRenderbuffer(36160, 33306, 36161, e)
            } else {
                var i = M.convert(t.texture.format),
                    a = M.convert(t.texture.type),
                    o = P(t.texture.internalFormat, i, a);
                if (n) {
                    r = z(t);
                    y.renderbufferStorageMultisample(36161, r, o, t.width, t.height)
                } else y.renderbufferStorage(36161, o, t.width, t.height)
            }
            y.bindRenderbuffer(36161, null)
        }

        function B(e) {
            var t = w.get(e),
                n = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture) {
                if (n) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function (e, t) {
                    if (t && t.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                    if (y.bindFramebuffer(36160, e), !t.depthTexture || !t.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of v3d.DepthTexture");
                    w.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), h(t.depthTexture, 0);
                    var n = w.get(t.depthTexture).__webglTexture;
                    if (t.depthTexture.format === ct) y.framebufferTexture2D(36160, 36096, 3553, n, 0);
                    else {
                        if (t.depthTexture.format !== ut) throw new Error("Unknown depthTexture format");
                        y.framebufferTexture2D(36160, 33306, 3553, n, 0)
                    }
                }(t.__webglFramebuffer, e)
            } else if (n) {
                t.__webglDepthbuffer = [];
                for (var r = 0; r < 6; r++) y.bindFramebuffer(36160, t.__webglFramebuffer[r]), t.__webglDepthbuffer[r] = y.createRenderbuffer(), F(t.__webglDepthbuffer[r], e)
            } else y.bindFramebuffer(36160, t.__webglFramebuffer), t.__webglDepthbuffer = y.createRenderbuffer(), F(t.__webglDepthbuffer, e);
            y.bindFramebuffer(36160, null)
        }

        function z(e) {
            return S && e.isWebGLMultisampleRenderTarget ? Math.min(r, e.samples) : 0
        }
        var U = !1,
            V = !1;
        this.allocateTextureUnit = function () {
            var e = d;
            return n <= e && console.warn("v3d.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + n), d += 1, e
        }, this.resetTextureUnits = function () {
            d = 0
        }, this.setTexture2D = h, this.setTexture2DArray = function (e, t) {
            var n = w.get(e);
            0 < e.version && n.__version !== e.version ? N(n, e, t) : (b.activeTexture(33984 + t), b.bindTexture(35866, n.__webglTexture))
        }, this.setTexture3D = function (e, t) {
            var n = w.get(e);
            0 < e.version && n.__version !== e.version ? N(n, e, t) : (b.activeTexture(33984 + t), b.bindTexture(32879, n.__webglTexture))
        }, this.setTextureCube = p, this.setTextureCubeDynamic = f, this.setupRenderTarget = function (e) {
            var t = w.get(e),
                n = w.get(e.texture);
            e.addEventListener("dispose", L), n.__webglTexture = y.createTexture(), A.memory.textures++;
            var r = !0 === e.isWebGLCubeRenderTarget,
                i = !0 === e.isWebGLMultisampleRenderTarget,
                a = !0 === e.isWebGLMultiviewRenderTarget,
                o = T(e) || S;
            if (r) {
                t.__webglFramebuffer = [];
                for (var s = 0; s < 6; s++) t.__webglFramebuffer[s] = y.createFramebuffer()
            } else if (t.__webglFramebuffer = y.createFramebuffer(), i)
                if (S) {
                    t.__webglMultisampledFramebuffer = y.createFramebuffer(), t.__webglColorRenderbuffer = y.createRenderbuffer(), y.bindRenderbuffer(36161, t.__webglColorRenderbuffer);
                    var l = M.convert(e.texture.format),
                        c = M.convert(e.texture.type),
                        u = P(e.texture.internalFormat, l, c),
                        d = z(e);
                    y.renderbufferStorageMultisample(36161, d, u, e.width, e.height), y.bindFramebuffer(36160, t.__webglMultisampledFramebuffer), y.framebufferRenderbuffer(36160, 36064, 36161, t.__webglColorRenderbuffer), y.bindRenderbuffer(36161, null), e.depthBuffer && (t.__webglDepthRenderbuffer = y.createRenderbuffer(), F(t.__webglDepthRenderbuffer, e, !0)), y.bindFramebuffer(36160, null)
                } else console.warn("v3d.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            else if (a) {
                var h = e.width,
                    p = e.height,
                    f = e.numViews;
                y.bindFramebuffer(36160, t.__webglFramebuffer);
                var m = x.get("OVR_multiview2");
                A.memory.textures += 2;
                var v = y.createTexture();
                y.bindTexture(35866, v), y.texParameteri(35866, 10240, 9728), y.texParameteri(35866, 10241, 9728), y.texImage3D(35866, 0, 32856, h, p, f, 0, 6408, 5121, null), m.framebufferTextureMultiviewOVR(36160, 36064, v, 0, 0, f);
                var g = y.createTexture();
                y.bindTexture(35866, g), y.texParameteri(35866, 10240, 9728), y.texParameteri(35866, 10241, 9728), y.texImage3D(35866, 0, 35056, h, p, f, 0, 34041, 34042, null), m.framebufferTextureMultiviewOVR(36160, 33306, g, 0, 0, f);
                var _ = new Array(f);
                for (s = 0; s < f; ++s) _[s] = y.createFramebuffer(), y.bindFramebuffer(36160, _[s]), y.framebufferTextureLayer(36160, 36064, v, 0, s);
                t.__webglColorTexture = v, t.__webglDepthStencilTexture = g, t.__webglViewFramebuffers = _, y.bindFramebuffer(36160, null), y.bindTexture(35866, null)
            }
            if (r) {
                b.bindTexture(34067, n.__webglTexture), D(34067, e.texture, o);
                for (s = 0; s < 6; s++) O(t.__webglFramebuffer[s], e, 36064, 34069 + s);
                E(e.texture, o) && C(34067, e.texture, e.width, e.height), b.bindTexture(34067, null)
            } else a || (b.bindTexture(3553, n.__webglTexture), D(3553, e.texture, o), O(t.__webglFramebuffer, e, 36064, 3553), E(e.texture, o) && C(3553, e.texture, e.width, e.height), b.bindTexture(3553, null));
            e.depthBuffer && B(e)
        }, this.updateRenderTargetMipmap = function (e) {
            var t = e.texture;
            if (E(t, T(e) || S)) {
                var n = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                    r = w.get(t).__webglTexture;
                b.bindTexture(n, r), C(n, t, e.width, e.height), b.bindTexture(n, null)
            }
        }, this.updateMultisampleRenderTarget = function (e) {
            if (e.isWebGLMultisampleRenderTarget && !e.disableBlit)
                if (S) {
                    var t = w.get(e);
                    y.bindFramebuffer(36008, t.__webglMultisampledFramebuffer), y.bindFramebuffer(36009, t.__webglFramebuffer);
                    var n = e.width,
                        r = e.height,
                        i = 16384;
                    e.depthBuffer && (i |= 256), e.stencilBuffer && (i |= 1024), y.blitFramebuffer(0, 0, n, r, 0, 0, n, r, i, 9728)
                } else console.warn("v3d.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }, this.safeSetTexture2D = function (e, t) {
            e && e.isWebGLRenderTarget && (!1 === U && (console.warn("v3d.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), U = !0), e = e.texture), h(e, t)
        }, this.safeSetTextureCube = function (e, t) {
            e && e.isWebGLCubeRenderTarget && (!1 === V && (console.warn("v3d.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), V = !0), e = e.texture), (e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? p : f)(e, t)
        }
    }

    function qo(e, n, t) {
        var r = t.isWebGL2;
        return {
            convert: function (e) {
                var t;
                if (e === tt) return 5121;
                if (e === c) return 32819;
                if (e === u) return 32820;
                if (e === d) return 33635;
                if (e === i) return 5120;
                if (e === a) return 5122;
                if (e === nt) return 5123;
                if (e === l) return 5124;
                if (e === rt) return 5125;
                if (e === it) return 5126;
                if (e === at) return r ? 5131 : null !== (t = n.get("OES_texture_half_float")) ? t.HALF_FLOAT_OES : null;
                if (e === h) return 6406;
                if (e === st) return 6407;
                if (e === lt) return 6408;
                if (e === p) return 6409;
                if (e === f) return 6410;
                if (e === ct) return 6402;
                if (e === ut) return 34041;
                if (e === dt) return 6403;
                if (e === m) return 36244;
                if (e === v) return 33319;
                if (e === g) return 33320;
                if (e === y) return 36248;
                if (e === x) return 36249;
                if (e === b || e === w || e === M || e === A) {
                    if (null === (t = n.get("WEBGL_compressed_texture_s3tc"))) return null;
                    if (e === b) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (e === w) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (e === M) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (e === A) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (e === T || e === E || e === C || e === P) {
                    if (null === (t = n.get("WEBGL_compressed_texture_pvrtc"))) return null;
                    if (e === T) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (e === E) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (e === C) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (e === P) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                return e === L ? null !== (t = n.get("WEBGL_compressed_texture_etc1")) ? t.COMPRESSED_RGB_ETC1_WEBGL : null : e === R || e === D || e === I || e === N || e === O || e === F || e === B || e === z || e === ht || e === pt || e === ft || e === mt || e === vt || e === gt ? null !== (t = n.get("WEBGL_compressed_texture_astc")) ? e : null : e === ot ? r ? 34042 : null !== (t = n.get("WEBGL_depth_texture")) ? t.UNSIGNED_INT_24_8_WEBGL : null : void 0
            }
        }
    }

    function Zo(e, t, n, r) {
        en.call(this, e, t, r), this.depthBuffer = !1, this.stencilBuffer = !1, this.numViews = n
    }

    function Qo(n, h) {
        var p, r, a, o, i, f, s, l = 2,
            c = n.extensions,
            m = n.properties,
            u = 0;

        function d(e) {
            return e.isArrayCamera ? e.cameras : (i[0] = e, i)
        }
        this.isAvailable = function () {
            if (void 0 === s) {
                var e = c.get("OVR_multiview2");
                if (s = null !== e && !1 === h.getContextAttributes().antialias) {
                    u = h.getParameter(e.MAX_VIEWS_OVR), p = new Zo(0, 0, l), f = new qt, o = [], a = [], i = [];
                    for (var t = 0; t < u; t++) o[t] = new fn, a[t] = new Zt
                }
            }
            return s
        }, this.attachCamera = function (e) {
            !1 !== function (e) {
                if (void 0 === e.isArrayCamera) return !0;
                var t = e.cameras;
                if (t.length > u) return !1;
                for (var n = 1, r = t.length; n < r; n++)
                    if (t[0].viewport.z !== t[n].viewport.z || t[0].viewport.w !== t[n].viewport.w) return !1;
                return !0
            }(e) && (r = n.getRenderTarget(), function (e) {
                if (r ? f.set(r.width, r.height) : n.getDrawingBufferSize(f), e.isArrayCamera) {
                    var t = e.cameras[0].viewport;
                    p.setSize(t.z, t.w), p.setNumViews(e.cameras.length)
                } else p.setSize(f.x, f.y), p.setNumViews(l)
            }(e), n.setRenderTarget(p))
        }, this.detachCamera = function (e) {
            p === n.getRenderTarget() && (n.setRenderTarget(r), function (e) {
                var t = p,
                    n = t.numViews,
                    r = m.get(t).__webglViewFramebuffers,
                    i = t.width,
                    a = t.height;
                if (e.isArrayCamera)
                    for (var o = 0; o < n; o++) {
                        var s = e.cameras[o].viewport,
                            l = s.x,
                            c = s.y,
                            u = l + s.z,
                            d = c + s.w;
                        h.bindFramebuffer(36008, r[o]), h.blitFramebuffer(0, 0, i, a, l, c, u, d, 16384, 9728)
                    } else h.bindFramebuffer(36008, r[0]), h.blitFramebuffer(0, 0, i, a, 0, 0, f.x, f.y, 16384, 9728)
            }(e))
        }, this.updateCameraProjectionMatricesUniform = function (e, t) {
            for (var n = d(e), r = 0; r < n.length; r++) o[r].copy(n[r].projectionMatrix);
            t.setValue(h, "projectionMatrices", o)
        }, this.updateCameraViewMatricesUniform = function (e, t) {
            for (var n = d(e), r = 0; r < n.length; r++) o[r].copy(n[r].matrixWorldInverse);
            t.setValue(h, "viewMatrices", o)
        }, this.updateObjectMatricesUniforms = function (e, t, n) {
            for (var r = d(t), i = 0; i < r.length; i++) o[i].multiplyMatrices(r[i].matrixWorldInverse, e.matrixWorld), a[i].getNormalMatrix(o[i]);
            n.setValue(h, "modelViewMatrices", o), n.setValue(h, "normalMatrices", a)
        }
    }

    function Ko(e) {
        Bi.call(this), this.cameras = e || []
    }

    function Jo() {
        Fn.call(this), this.type = "Group"
    }
    Zo.prototype = Object.assign(Object.create(en.prototype), {
        constructor: Zo,
        isWebGLMultiviewRenderTarget: !0,
        copy: function (e) {
            return en.prototype.copy.call(this, e), this.numViews = e.numViews, this
        },
        setNumViews: function (e) {
            return this.numViews !== e && (this.numViews = e, this.dispose()), this
        }
    }), Ko.prototype = Object.assign(Object.create(Bi.prototype), {
        constructor: Ko,
        isArrayCamera: !0
    }), Jo.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: Jo,
        isGroup: !0,
        getWorldDirection: function (e) {
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        }
    });
    var $o = {
        checkWebGL: function () {
            try {
                var e = document.createElement("canvas");
                return !(!window.WebGLRenderingContext || !e.getContext("webgl") && !e.getContext("experimental-webgl"))
            } catch (e) {
                return !1
            }
        },
        checkWebGL2: function () {
            try {
                var e = document.createElement("canvas");
                return !(!window.WebGL2RenderingContext || !e.getContext("webgl2"))
            } catch (e) {
                return !1
            }
        },
        checkWorkers: function () {
            return !!window.Worker
        },
        checkFileAPI: function () {
            return window.File && window.FileReader && window.FileList && window.Blob
        },
        genWebGLErrorMessage: function () {
            var e = document.createElement("div");
            return e.setAttribute("class", "v3d-webgl-error"), e.innerHTML = window.WebGLRenderingContext ? ["Ouch! Your graphics card does not support WebGL.<br/>", 'Find out how to fix it <a href="https://www.soft8soft.com/webgl-supported-browsers-and-troubleshooting/" target="_top" class="v3d-webgl-error-link">here</a>.'].join("\n") : ["Ouch! Your browser does not support WebGL.<br/>", 'Find out how to fix it <a href="https://www.soft8soft.com/webgl-supported-browsers-and-troubleshooting/" target="_top" class="v3d-webgl-error-link">here</a>.'].join("\n"), e
        },
        showWebGLErrorMessage: function (e) {
            (e = e || document.body).appendChild($o.genWebGLErrorMessage());
            var t = document.getElementById("v3d_preloader_container");
            t && (t.style.visibility = "hidden")
        },
        checkIOS: function () {
            return !!navigator.userAgent.match(/iPhone|iPad|iPod/i)
        },
        checkAndroid: function () {
            return !!navigator.userAgent.match(/Android/i)
        },
        checkHDR: function (e) {
            var t = e.getContext();
            return !!(e.capabilities.isWebGL2 && t.getExtension("EXT_color_buffer_float") && t.getExtension("OES_texture_float_linear")) || !!(t.getExtension("OES_texture_half_float") && t.getExtension("OES_texture_half_float_linear") && t.getExtension("OES_texture_float") && t.getExtension("OES_texture_float_linear"))
        },
        checkFloatTex: function (e, t) {
            var n = e.getContext();
            return !(!e.capabilities.isWebGL2 || !n.getExtension("EXT_color_buffer_float") || t && !n.getExtension("OES_texture_float_linear")) || !(!n.getExtension("OES_texture_float") || t && !n.getExtension("OES_texture_float_linear"))
        },
        checkHalfFloatTex: function (e, t) {
            var n = e.getContext();
            return !(!e.capabilities.isWebGL2 || !n.getExtension("EXT_color_buffer_float") || t && !n.getExtension("OES_texture_float_linear")) || !(!n.getExtension("OES_texture_half_float") || t && !n.getExtension("OES_texture_half_float_linear"))
        },
        checkDepthTex: function (e) {
            var t = e.getContext();
            return !(!e.capabilities.isWebGL2 && !t.getExtension("WEBGL_depth_texture"))
        },
        getGPUVendor: function (e) {
            var t = e ? e.getContext() : document.createElement("canvas").getContext("webgl") || document.createElement("canvas").getContext("experimental-webgl"),
                n = t.getExtension("WEBGL_debug_renderer_info");
            return null != n ? t.getParameter(n.UNMASKED_VENDOR_WEBGL) : ""
        },
        getGPUModel: function (e) {
            var t = e ? e.getContext() : document.createElement("canvas").getContext("webgl") || document.createElement("canvas").getContext("experimental-webgl"),
                n = t.getExtension("WEBGL_debug_renderer_info");
            return null != n ? t.getParameter(n.UNMASKED_RENDERER_WEBGL) : ""
        },
        checkWebXR: function (e, t, n) {
            "xr" in navigator && navigator.xr.isSessionSupported ? navigator.xr.isSessionSupported(e).then(function (e) {
                (e ? t : n)()
            }).catch(n) : n()
        },
        checkNativeWebXR: function () {
            var e = "polyfill" in window && "WebXRPolyfill" in window && polyfill instanceof WebXRPolyfill;
            return "xr" in navigator && (!e || e && polyfill.nativeWebXR)
        },
        checkCardboard: function () {
            if (!("polyfill" in window && "WebXRPolyfill" in window && polyfill instanceof WebXRPolyfill)) return !1;
            for (var e = Object.getOwnPropertySymbols(navigator.xr), t = 0; t < e.length; t++) {
                var n = e[t];
                if ("Symbol(@@webxr-polyfill/XR)" == n.toString()) {
                    var r = navigator.xr[n].device;
                    if (r && "CardboardXRDevice" == r.constructor.name) return !0
                }
            }
            return !1
        },
        checkSwiftShader: function (e) {
            return "Google SwiftShader" == this.getGPUModel(e)
        }
    };

    function es(e, t, n, r) {
        this.ray = new ur(e, t), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.params = {
            Mesh: {
                omitGeometry: !1
            },
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {},
            checkVisibility: !0
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function () {
                    return console.warn("v3d.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function ts(e, t) {
        return e.distance - t.distance
    }

    function ns(e, t, n, r, i) {
        if (!(i && (!1 === e.visible || e.isMesh && e.isMaterialGeneratedMesh && e.parent && !e.parent.visible) || (e.raycast(t, n), !0 !== r)))
            for (var a = e.children, o = 0, s = a.length; o < s; o++) ns(a[o], t, n, !0)
    }

    function rs(p, i) {
        var t = this,
            f = null,
            a = 1,
            m = null,
            o = "local-floor",
            v = null,
            g = [],
            s = new Map,
            l = new Bi;
        l.layers.enable(1), l.viewport = new $t;
        var c = new Bi;
        c.layers.enable(2), c.viewport = new $t;
        var _ = new Ko([l, c]);
        _.layers.enable(1), _.layers.enable(2);
        var u = null,
            d = null,
            y = null,
            x = null,
            h = null,
            b = null,
            w = null;

        function M(e) {
            var t = s.get(e.inputSource);
            t && (t.targetRay && t.targetRay.dispatchEvent({
                type: e.type
            }), t.grip && t.grip.dispatchEvent({
                type: e.type
            }))
        }

        function A() {
            s.forEach(function (e, t) {
                e.targetRay && (e.targetRay.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), e.targetRay.visible = !1), e.grip && (e.grip.dispatchEvent({
                    type: "disconnected",
                    data: t
                }), e.grip.visible = !1)
            }), s.clear(), p.setFramebuffer(null), p.setRenderTarget(p.getRenderTarget()), n.stop(), t.isPresenting = !1, t.dispatchEvent({
                type: "sessionend"
            })
        }

        function S(e) {
            m = e, n.setContext(f), n.start(), t.isPresenting = !0, t.dispatchEvent({
                type: "sessionstart"
            })
        }

        function T(e) {
            for (var t = x || f.inputSources, n = 0; n < g.length; n++) s.set(t[n], g[n]);
            for (n = 0; n < e.removed.length; n++) {
                var r = e.removed[n];
                (i = s.get(r)) && (i.targetRay && i.targetRay.dispatchEvent({
                    type: "disconnected",
                    data: r
                }), i.grip && i.grip.dispatchEvent({
                    type: "disconnected",
                    data: r
                }), s.delete(r))
            }
            for (n = 0; n < e.added.length; n++) {
                var i;
                r = e.added[n];
                (i = s.get(r)) && (i.targetRay && i.targetRay.dispatchEvent({
                    type: "connected",
                    data: r
                }), i.grip && i.grip.dispatchEvent({
                    type: "connected",
                    data: r
                }))
            }
        }
        this.enabled = !1, this.isPresenting = !1, this.getController = function (e) {
            var t = g[e];
            return void 0 === t && (t = {}, g[e] = t), void 0 === t.targetRay && (t.targetRay = new Jo, t.targetRay.matrixAutoUpdate = !1, t.targetRay.visible = !1, t.targetRay.name = "XR_CONTROLLER_" + String(e)), t.targetRay
        }, this.getControllerGrip = function (e) {
            var t = g[e];
            return void 0 === t && (t = {}, g[e] = t), void 0 === t.grip && (t.grip = new Jo, t.grip.matrixAutoUpdate = !1, t.grip.visible = !1), t.grip
        }, this.setFramebufferScaleFactor = function (e) {
            a = e
        }, this.setReferenceSpaceType = function (e) {
            o = e
        }, this.getReferenceSpace = function () {
            return m
        }, this.getSession = function () {
            return f
        }, this.setSession = function (e) {
            if (null !== (f = e)) {
                f.addEventListener("select", M), f.addEventListener("selectstart", M), f.addEventListener("selectend", M), f.addEventListener("squeeze", M), f.addEventListener("squeezestart", M), f.addEventListener("squeezeend", M), f.addEventListener("end", A);
                var t = i.getContextAttributes(),
                    n = {
                        antialias: t.antialias,
                        alpha: t.alpha,
                        depth: t.depth,
                        stencil: t.stencil,
                        framebufferScaleFactor: a
                    },
                    r = new XRWebGLLayer(f, i, n);
                if (f.updateRenderState({
                        baseLayer: r
                    }), f.requestReferenceSpace(o).then(S), f.addEventListener("inputsourceschange", T), $o.checkCardboard()) {
                    T({
                        added: x = [{
                            gamepad: null,
                            gripSpace: null,
                            handedness: "none",
                            targetRayMode: "gaze",
                            targetRaySpace: {},
                            profiles: []
                        }],
                        removed: []
                    }), document.addEventListener("touchstart", function () {
                        var e = g[0];
                        e && e.targetRay && e.targetRay.dispatchEvent({
                            type: "selectstart"
                        })
                    }), document.addEventListener("touchend", function () {
                        var e = g[0];
                        e && e.targetRay && (e.targetRay.dispatchEvent({
                            type: "selectend"
                        }), e.targetRay.dispatchEvent({
                            type: "select"
                        }))
                    })
                }
            }
        };
        var E = new on,
            C = new on;

        function P(e, t) {
            y = null === t ? (e.matrixWorld.copy(e.matrix), null) : (e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), t.matrixWorld), e.matrixWorldInverse.getInverse(e.matrixWorld)
        }
        this.getCamera = function (e) {
            _.near = c.near = l.near = e.near, _.far = c.far = l.far = e.far, u === _.near && d === _.far || (f.updateRenderState({
                depthNear: _.near,
                depthFar: _.far
            }), u = _.near, d = _.far);
            var t = e.parent,
                n = _.cameras;
            P(_, t);
            for (var r = 0; r < n.length; r++) P(n[r], t);
            e.matrixWorld.copy(_.matrixWorld), e.matrix.getInverse(t.matrixWorld), e.matrix.multiply(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale);
            for (var i = e.children, a = (r = 0, i.length); r < a; r++) i[r].updateMatrixWorld(!0);
            return function (e, t, n) {
                E.setFromMatrixPosition(t.matrixWorld), C.setFromMatrixPosition(n.matrixWorld);
                var r = E.distanceTo(C),
                    i = t.projectionMatrix.elements,
                    a = n.projectionMatrix.elements,
                    o = i[14] / (i[10] - 1),
                    s = i[14] / (i[10] + 1),
                    l = (i[9] + 1) / i[5],
                    c = (i[9] - 1) / i[5],
                    u = (i[8] - 1) / i[0],
                    d = (a[8] + 1) / a[0],
                    h = o * u,
                    p = o * d,
                    f = r / (d - u),
                    m = f * -u;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld);
                var v = o + f,
                    g = s + f,
                    _ = h - m,
                    y = r - m + p,
                    x = l * s / g * v,
                    b = c * s / g * v;
                e.projectionMatrix.makePerspective(_, y, x, b, v, g)
            }(_, l, c), _
        };
        var L = null;
        var n = new Hi;

        function R(e) {
            if (h) {
                var t = e.getHitTestResults(h);
                if (t.length) {
                    var n = t[0].getPose(m),
                        r = (new fn).fromArray(n.transform.matrix),
                        i = new on;
                    i.setFromMatrixPosition(r), b(i)
                } else w()
            }
        }
        n.setAnimationLoop(function (e, t) {
            if (null !== (v = t.getViewerPose(m))) {
                var n = v.views,
                    r = f.renderState.baseLayer;
                p.setFramebuffer(r.framebuffer);
                for (var i = 0; i < n.length; i++) {
                    var a = n[i],
                        o = r.getViewport(a),
                        s = _.cameras[i];
                    s.matrix.fromArray(a.transform.matrix), s.projectionMatrix.fromArray(a.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === i && _.matrix.copy(s.matrix)
                }
            }
            var l = f.inputSources;
            for (i = 0; i < g.length; i++) {
                var c = g[i],
                    u = l[i],
                    d = null,
                    h = null;
                u && (c.targetRay && null !== (d = t.getPose(u.targetRaySpace, m)) && (c.targetRay.matrix.fromArray(d.transform.matrix), y && c.targetRay.matrix.multiplyMatrices(y, c.targetRay.matrix), c.targetRay.matrix.decompose(c.targetRay.position, c.targetRay.rotation, c.targetRay.scale)), c.grip && u.gripSpace && null !== (h = t.getPose(u.gripSpace, m)) && (c.grip.matrix.fromArray(h.transform.matrix), c.grip.matrix.decompose(c.grip.position, c.grip.rotation, c.grip.scale))), x && x[i] && c.targetRay && (c.targetRay.matrix.copy(_.matrix), y && c.targetRay.matrix.multiplyMatrices(y, c.targetRay.matrix), c.targetRay.matrix.decompose(c.targetRay.position, c.targetRay.rotation, c.targetRay.scale), d = {}), R(t), c.targetRay && (c.targetRay.visible = null !== d), c.grip && (c.grip.visible = null !== h)
            }
            L && L(e, t)
        }), this.setAnimationLoop = function (e) {
            L = e
        }, this.dispose = function () {}, this.arHitTest = function (e, t, n, r) {
            if (f && XRSession.prototype.requestHitTestSource) {
                b = n || function () {}, w = r || function () {}, this.raycaster = this.raycaster || new es, this.raycaster.setFromCamera({
                    x: e,
                    y: t
                }, _.cameras[0]);
                var i = this.raycaster.ray;
                new XRRay(i.origin, i.direction);
                f.requestReferenceSpace("viewer").then(function (e) {
                    var t = {
                        space: e
                    };
                    f.requestHitTestSource(t).then(function (e) {
                        h = e
                    })
                })
            }
        }
    }
    Object.assign(es.prototype, {
        linePrecision: 1,
        set: function (e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function (e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("v3d.Raycaster: Unsupported camera type.")
        },
        intersectObject: function (e, t, n) {
            var r = n || [];
            return ns(e, this, r, t, this.params.checkVisibility), r.sort(ts), r
        },
        intersectObjects: function (e, t, n) {
            var r = n || [];
            if (!1 === Array.isArray(e)) return console.warn("v3d.Raycaster.intersectObjects: objects is not an Array."), r;
            for (var i = 0, a = e.length; i < a; i++) ns(e[i], this, r, t, this.params.checkVisibility);
            return r.sort(ts), r
        }
    }), Object.assign(rs.prototype, o.prototype);

    function is(e) {
        var r = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            t = void 0 !== e.context ? e.context : null,
            n = void 0 !== e.alpha && e.alpha,
            i = void 0 === e.depth || e.depth,
            a = void 0 === e.stencil || e.stencil,
            o = void 0 !== e.antialias && e.antialias,
            s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            c = void 0 !== e.powerPreference ? e.powerPreference : "default",
            u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
            d = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext;
        console.log("Verge3D 3.0.1 (" + (d ? "WebGL 2.0" : "WebGL 1.0") + ")");
        var m = null,
            O = null;
        this.domElement = r, this.debug = {
            checkShaderErrors: !0
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = At, this.physicallyCorrectLights = !1, this.unitsScaleFactor = 1, this.toneMapping = Fe, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 12, this.maxMorphNormals = 6, this.compatSettings = {
            saturateSpecEnvBlenderApprox: !1
        };
        var F, M, B, z, h, U, V, A, S, v, _, p, f, g, T, E, C, y, x, G = this,
            b = !1,
            w = null,
            P = 0,
            L = 0,
            R = null,
            D = null,
            k = -1,
            I = {
                geometry: null,
                program: null,
                wireframe: !1
            },
            j = null,
            N = null,
            W = new $t,
            X = new $t,
            H = null,
            Y = r.width,
            q = r.height,
            Z = 1,
            Q = null,
            K = null,
            J = new $t(0, 0, Y, q),
            $ = new $t(0, 0, Y, q),
            ee = !1,
            te = new ji,
            ne = new na,
            re = !1,
            ie = !1,
            ae = new fn,
            oe = new fn,
            se = new fn,
            le = new qt,
            ce = new on;

        function ue() {
            return null === R ? Z : 1
        }
        try {
            var de = {
                alpha: n,
                depth: i,
                stencil: a,
                antialias: o,
                premultipliedAlpha: s,
                preserveDrawingBuffer: l,
                powerPreference: c,
                failIfMajorPerformanceCaveat: u,
                xrCompatible: !0
            };
            if (r.addEventListener("webglcontextlost", ve, !1), r.addEventListener("webglcontextrestored", ge, !1), null === (F = t || r.getContext("webgl", de) || r.getContext("experimental-webgl", de))) throw null !== r.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === F.getShaderPrecisionFormat && (F.getShaderPrecisionFormat = function () {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (e) {
            throw console.error("v3d.WebGLRenderer: " + e.message), e
        }

        function he() {
            M = new ra(F), !1 === (B = new ta(F, M, e)).isWebGL2 && (M.get("WEBGL_depth_texture"), M.get("OES_texture_float"), M.get("OES_texture_half_float"), M.get("OES_texture_half_float_linear"), M.get("OES_standard_derivatives"), M.get("OES_element_index_uint"), M.get("ANGLE_instanced_arrays")), M.get("OES_texture_float_linear"), y = new qo(F, M, B), (z = new Ho(F, M, B)).scissor(X.copy($).multiplyScalar(Z).floor()), z.viewport(W.copy(J).multiplyScalar(Z).floor()), h = new oa(F), U = new To, V = new Yo(F, M, z, U, B, y, h), A = new Yi(F, B), S = new ia(F, A, h), v = new ca(F, S, A, h), T = new la(F), _ = new So(G, M, B), p = new Lo, f = new zo, g = new $i(G, z, v, s), E = new ea(F, M, h, B), C = new aa(F, M, h, B), h.programs = _.programs, G.capabilities = B, G.extensions = M, G.properties = U, G.renderLists = p, G.state = z, G.info = h, x = new Xi
        }
        he();
        var pe = new rs(G, F);
        this.xr = pe;
        var fe = new Qo(G, F),
            me = new Xo(G, v, B);

        function ve(e) {
            e.preventDefault(), console.log("v3d.WebGLRenderer: Context Lost."), b = !0
        }

        function ge() {
            console.log("v3d.WebGLRenderer: Context Restored."), b = !1, he()
        }

        function _e(e) {
            var t, n = e.target;
            n.removeEventListener("dispose", _e), ye(t = n), U.remove(t)
        }

        function ye(e) {
            var t = U.get(e).program;
            (e.program = void 0) !== t && _.releaseProgram(t)
        }
        this.shadowMap = me, this.getContext = function () {
            return F
        }, this.getContextAttributes = function () {
            return F.getContextAttributes()
        }, this.forceContextLoss = function () {
            var e = M.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.forceContextRestore = function () {
            var e = M.get("WEBGL_lose_context");
            e && e.restoreContext()
        }, this.getPixelRatio = function () {
            return Z
        }, this.setPixelRatio = function (e) {
            void 0 !== e && (Z = e, this.setSize(Y, q, !1))
        }, this.getSize = function (e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new qt), e.set(Y, q)
        }, this.setSize = function (e, t, n) {
            pe.isPresenting ? console.warn("v3d.WebGLRenderer: Can't change size while VR device is presenting.") : (Y = e, q = t, r.width = Math.floor(e * Z), r.height = Math.floor(t * Z), !1 !== n && (r.style.width = e + "px", r.style.height = t + "px"), this.setViewport(0, 0, e, t))
        }, this.getDrawingBufferSize = function (e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new qt), e.set(Y * Z, q * Z).floor()
        }, this.setDrawingBufferSize = function (e, t, n) {
            Y = e, q = t, Z = n, r.width = Math.floor(e * n), r.height = Math.floor(t * n), this.setViewport(0, 0, e, t)
        }, this.getCurrentViewport = function (e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new $t), e.copy(W)
        }, this.getViewport = function (e) {
            return e.copy(J)
        }, this.setViewport = function (e, t, n, r) {
            e.isVector4 ? J.set(e.x, e.y, e.z, e.w) : J.set(e, t, n, r), z.viewport(W.copy(J).multiplyScalar(Z).floor())
        }, this.getScissor = function (e) {
            return e.copy($)
        }, this.setScissor = function (e, t, n, r) {
            e.isVector4 ? $.set(e.x, e.y, e.z, e.w) : $.set(e, t, n, r), z.scissor(X.copy($).multiplyScalar(Z).floor())
        }, this.getScissorTest = function () {
            return ee
        }, this.setScissorTest = function (e) {
            z.setScissorTest(ee = e)
        }, this.setOpaqueSort = function (e) {
            Q = e
        }, this.setTransparentSort = function (e) {
            K = e
        }, this.getClearColor = function () {
            return g.getClearColor()
        }, this.setClearColor = function () {
            g.setClearColor.apply(g, arguments)
        }, this.getClearAlpha = function () {
            return g.getClearAlpha()
        }, this.setClearAlpha = function () {
            g.setClearAlpha.apply(g, arguments)
        }, this.clear = function (e, t, n) {
            var r = 0;
            void 0 !== e && !e || (r |= 16384), void 0 !== t && !t || (r |= 256), void 0 !== n && !n || (r |= 1024), F.clear(r)
        }, this.clearColor = function () {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
        }, this.dispose = function () {
            r.removeEventListener("webglcontextlost", ve, !1), r.removeEventListener("webglcontextrestored", ge, !1), this.disposeInternalCaches(), pe.dispose(), we.stop()
        }, this.disposeInternalCaches = function () {
            p.dispose(), f.dispose(), g.dispose(), A.dispose(), v.dispose(), U.dispose(), x.dispose()
        }, this.renderBufferImmediate = function (e, t) {
            z.initAttributes();
            var n = U.get(e);
            e.hasPositions && !n.position && (n.position = F.createBuffer()), e.hasNormals && !n.normal && (n.normal = F.createBuffer()), e.hasUvs && !n.uv && (n.uv = F.createBuffer()), e.hasColors && !n.color && (n.color = F.createBuffer());
            var r = t.getAttributes();
            e.hasPositions && (F.bindBuffer(34962, n.position), F.bufferData(34962, e.positionArray, 35048), z.enableAttribute(r.position), F.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), e.hasNormals && (F.bindBuffer(34962, n.normal), F.bufferData(34962, e.normalArray, 35048), z.enableAttribute(r.normal), F.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (F.bindBuffer(34962, n.uv), F.bufferData(34962, e.uvArray, 35048), z.enableAttribute(r.uv), F.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), e.hasColors && (F.bindBuffer(34962, n.color), F.bufferData(34962, e.colorArray, 35048), z.enableAttribute(r.color), F.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), z.disableUnusedAttributes(), F.drawArrays(4, 0, e.count), e.count = 0
        };
        var xe = new Bn;
        this.renderBufferDirect = function (e, t, n, r, i, a) {
            null === t && (t = xe);
            var o = i.isMesh && i.matrixWorld.determinant() < 0,
                s = Te(e, t, r, i);
            z.setMaterial(r, o);
            var l = !1;
            I.geometry === n.id && I.program === s.id && I.wireframe === (!0 === r.wireframe) || (I.geometry = n.id, I.program = s.id, I.wireframe = !0 === r.wireframe, l = !0), (r.morphTargets || r.morphNormals) && (T.update(i, n, r, s), l = !0);
            var c = n.index,
                u = n.attributes.position;
            if (null === c) {
                if (void 0 === u || 0 === u.count) return
            } else if (0 === c.count) return;
            var d, h = 1;
            !0 === r.wireframe && (c = S.getWireframeAttribute(n), h = 2);
            var p = E;
            null !== c && (d = A.get(c), (p = C).setIndex(d)), l && (function (e, t, n, r) {
                if (!1 === B.isWebGL2 && (e.isInstancedMesh || t.isInstancedBufferGeometry) && null === M.get("ANGLE_instanced_arrays")) return;
                z.initAttributes();
                var i = t.attributes,
                    a = r.getAttributes(),
                    o = n.defaultAttributeValues;
                for (var s in a) {
                    var l = a[s];
                    if (0 <= l) {
                        var c = i[s];
                        if (void 0 !== c) {
                            var u = c.normalized,
                                d = c.itemSize;
                            if (void 0 === (_ = A.get(c))) continue;
                            var h = _.buffer,
                                p = _.type,
                                f = _.bytesPerElement;
                            if (c.isInterleavedBufferAttribute) {
                                var m = c.data,
                                    v = m.stride,
                                    g = c.offset;
                                m && m.isInstancedInterleavedBuffer ? (z.enableAttributeAndDivisor(l, m.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = m.meshPerAttribute * m.count)) : z.enableAttribute(l), F.bindBuffer(34962, h), F.vertexAttribPointer(l, d, p, u, v * f, g * f)
                            } else c.isInstancedBufferAttribute ? (z.enableAttributeAndDivisor(l, c.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = c.meshPerAttribute * c.count)) : z.enableAttribute(l), F.bindBuffer(34962, h), F.vertexAttribPointer(l, d, p, u, 0, 0)
                        } else if ("instanceMatrix" === s) {
                            var _;
                            if (void 0 === (_ = A.get(e.instanceMatrix))) continue;
                            h = _.buffer, p = _.type;
                            z.enableAttributeAndDivisor(l + 0, 1), z.enableAttributeAndDivisor(l + 1, 1), z.enableAttributeAndDivisor(l + 2, 1), z.enableAttributeAndDivisor(l + 3, 1), F.bindBuffer(34962, h), F.vertexAttribPointer(l + 0, 4, p, !1, 64, 0), F.vertexAttribPointer(l + 1, 4, p, !1, 64, 16), F.vertexAttribPointer(l + 2, 4, p, !1, 64, 32), F.vertexAttribPointer(l + 3, 4, p, !1, 64, 48)
                        } else if (void 0 !== o) {
                            var y = o[s];
                            if (void 0 !== y) switch (y.length) {
                                case 2:
                                    F.vertexAttrib2fv(l, y);
                                    break;
                                case 3:
                                    F.vertexAttrib3fv(l, y);
                                    break;
                                case 4:
                                    F.vertexAttrib4fv(l, y);
                                    break;
                                default:
                                    F.vertexAttrib1fv(l, y)
                            }
                        }
                    }
                }
                z.disableUnusedAttributes()
            }(i, n, r, s), null !== c && F.bindBuffer(34963, d.buffer));
            var f = null !== c ? c.count : u.count,
                m = n.drawRange.start * h,
                v = n.drawRange.count * h,
                g = null !== a ? a.start * h : 0,
                _ = null !== a ? a.count * h : 1 / 0,
                y = Math.max(m, g),
                x = Math.min(f, m + v, g + _) - 1,
                b = Math.max(0, x - y + 1);
            if (0 !== b) {
                if (i.isMesh) !0 === r.wireframe ? (z.setLineWidth(r.wireframeLinewidth * ue()), p.setMode(1)) : p.setMode(4);
                else if (i.isLine) {
                    var w = r.linewidth;
                    void 0 === w && (w = 1), z.setLineWidth(w * ue()), i.isLineSegments ? p.setMode(1) : i.isLineLoop ? p.setMode(2) : p.setMode(3)
                } else i.isPoints ? p.setMode(0) : i.isSprite && p.setMode(4);
                s.beginTimerQuery(F, B.isWebGL2), i.isInstancedMesh ? p.renderInstances(n, y, b, i.count) : n.isInstancedBufferGeometry ? p.renderInstances(n, y, b, n.maxInstancedCount) : p.render(y, b), s.endTimerQuery(F, B.isWebGL2)
            }
        }, this.compile = function (n, e) {
            var r = f.get(n, e);
            r.init(), n.traverse(function (e) {
                e.isLight && (r.pushLight(e), e.castShadow && r.pushShadow(e))
            }), r.setupLights(e);
            var i = {};
            n.traverse(function (e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var t = 0; t < e.material.length; t++) e.material[t].uuid in i == !1 && (Se(e.material[t], n, e, r), i[e.material[t].uuid] = !0);
                    else e.material.uuid in i == !1 && (Se(e.material, n, e, r), i[e.material.uuid] = !0)
            })
        }, this.compileAsync = function (n, e, a) {
            var o = f.get(n, e);
            o.init(), n.traverse(function (e) {
                e.isLight && (o.pushLight(e), e.castShadow && o.pushShadow(e))
            }), o.setupLights(e);
            var s = 0,
                r = Promise.resolve({
                    counter: 0,
                    timePrev: performance.now()
                });
            n.traverse(function (t) {
                if (t.material) {
                    var e = Array.isArray(t.material) ? t.material : [t.material];
                    e.forEach(function (e) {
                        r = r.then(function (e, t, n, r) {
                            Se(n, e, t, o), a && a((r.counter + 1) / s), r.counter++;
                            var i = performance.now();
                            return 16 < i - r.timePrev ? (r.timePrev = i, new Promise(function (e) {
                                setTimeout(function () {
                                    e(r)
                                }, 1)
                            })) : r
                        }.bind(null, n, t, e))
                    }), s += e.length
                }
            }), 0 === s && a(1)
        };
        var be = null;
        var we = new Hi;

        function Me(e, t, n, r) {
            for (var i = 0, a = e.length; i < a; i++) {
                var o = e[i],
                    s = o.object,
                    l = o.geometry,
                    c = void 0 === r ? o.material : x.get(s, l, o.material, r),
                    u = o.group;
                if (n.isArrayCamera)
                    if (N = n, pe.enabled && fe.isAvailable()) Ae(s, t, n, l, c, u);
                    else
                        for (var d = n.cameras, h = 0, p = d.length; h < p; h++) {
                            var f = d[h];
                            s.layers.test(f.layers) && (z.viewport(W.copy(f.viewport)), O.setupLights(f), Ae(s, t, f, l, c, u))
                        } else N = null, Ae(s, t, n, l, c, u)
            }
        }

        function Ae(e, t, n, r, i, a) {
            if (e.onBeforeRender(G, t, n, r, i, a), O = f.get(t, N || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                var o = Te(n, t, i, e);
                z.setMaterial(i), I.geometry = null, I.program = null, I.wireframe = !1, s = o, e.render(function (e) {
                    G.renderBufferImmediate(e, s)
                })
            } else G.renderBufferDirect(n, t, r, i, e, a);
            var s;
            e.onAfterRender(G, t, n, r, i, a), O = f.get(t, N || n)
        }

        function Se(e, t, n, r) {
            var i = U.get(e),
                a = r.state.lights,
                o = r.state.shadowsArray,
                s = a.state.version,
                l = _.getParameters(e, a.state, o, t, ne.numPlanes, ne.numIntersection, n),
                c = _.getProgramCacheKey(l),
                u = i.program,
                d = !0;
            if (void 0 === u) e.addEventListener("dispose", _e);
            else if (u.cacheKey !== c) ye(e);
            else if (i.lightsStateVersion !== s) i.lightsStateVersion = s, d = !1;
            else {
                if (void 0 !== l.shaderID) return;
                d = !1
            }
            d && (u = _.acquireProgram(l, c), i.program = u, i.uniforms = l.uniforms, i.environment = e.isMeshStandardMaterial ? t.environment : null, i.outputEncoding = G.outputEncoding, e.program = u);
            var h = u.getAttributes();
            if (e.morphTargets)
                for (var p = e.numSupportedMorphTargets = 0; p < G.maxMorphTargets; p++) 0 <= h["morphTarget" + p] && e.numSupportedMorphTargets++;
            if (e.morphNormals)
                for (p = e.numSupportedMorphNormals = 0; p < G.maxMorphNormals; p++) 0 <= h["morphNormal" + p] && e.numSupportedMorphNormals++;
            var f, m = i.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (i.numClippingPlanes = ne.numPlanes, i.numIntersection = ne.numIntersection, m.clippingPlanes = ne.uniform), i.fog = t.fog, i.needsLights = (f = e).isMeshLambertMaterial || f.isMeshToonMaterial || f.isMeshPhongMaterial || f.isMeshStandardMaterial || f.isShadowMaterial || f.isShaderMaterial && !0 === f.lights || f.isMeshNodeMaterial, i.lightsStateVersion = s, i.needsLights && (m.ambientLightColor.value = a.state.ambient, m.lightProbe.value = a.state.probe, m.directionalLights.value = a.state.directional, m.spotLights.value = a.state.spot, m.rectAreaLights.value = a.state.rectArea, m.pointLights.value = a.state.point, m.hemisphereLights.value = a.state.hemi, m.directionalShadowMap.value = a.state.directionalShadowMap, m.directionalShadowMatrix.value = a.state.directionalShadowMatrix, m.spotShadowMap.value = a.state.spotShadowMap, m.spotShadowMatrix.value = a.state.spotShadowMatrix, m.pointShadowMap.value = a.state.pointShadowMap, m.pointShadowMatrix.value = a.state.pointShadowMatrix), e.nodeValue && (m.nodeValue.value = e.nodeValue), e.nodeRGBArr && (m.nodeRGB.value = e.nodeRGBArr), e.nodeTexCoordObjectArr && (m.nodeTexCoordObjectMatrices.value = e.nodeTexCoordObjectArr);
            var v = i.program.getUniforms(),
                g = so.seqWithValue(v.seq, m);
            i.uniformsList = g
        }

        function Te(e, t, n, r) {
            V.resetTextureUnits();
            var i = t.fog,
                a = n.isMeshStandardMaterial ? t.environment : null,
                o = U.get(n),
                s = O.state.lights;
            if (re && (ie || e !== j)) {
                var l = e === j && n.id === k;
                ne.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, o, l)
            }
            if (n.version === o.__version) void 0 === o.program || n.fog && o.fog !== i || o.environment !== a || o.needsLights && o.lightsStateVersion !== s.state.version ? Se(n, t, r, O) : void 0 === o.numClippingPlanes || o.numClippingPlanes === ne.numPlanes && o.numIntersection === ne.numIntersection ? o.outputEncoding !== G.outputEncoding && Se(n, t, r, O) : Se(n, t, r, O);
            else if (Se(n, t, r, O), o.__version = n.version, n.nodeRGBArr)
                for (var c = 0; c < n.nodeRGB.length; c++) {
                    n.nodeRGB[c].toArray(n.nodeRGBArr, 4 * c)
                }
            var u, d, h, p, f, m, v, g, _, y, x, b, w = !1,
                M = !1,
                A = !1,
                S = o.program,
                T = S.getUniforms(),
                E = o.uniforms;
            if (z.useProgram(S.program) && (A = M = w = !0), n.id !== k && (k = n.id, M = !0), w || j !== e) {
                if (0 < S.numMultiviewViews ? fe.updateCameraProjectionMatricesUniform(e, T) : T.setValue(F, "projectionMatrix", e.projectionMatrix), B.logarithmicDepthBuffer && T.setValue(F, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), j !== e && (j = e, A = M = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.isMeshNodeMaterial || n.envMap) {
                    var C = T.map.cameraPosition;
                    void 0 !== C && C.setValue(F, ce.setFromMatrixPosition(e.matrixWorld))
                }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isMeshNodeMaterial) && T.setValue(F, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isMeshNodeMaterial || n.skinning) && (0 < S.numMultiviewViews ? fe.updateCameraViewMatricesUniform(e, T) : T.setValue(F, "viewMatrix", e.matrixWorldInverse)), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshNodeMaterial || n.isMeshPhysicalMaterial || n.isShadowMaterial) && T.setValue(F, "invViewMatrix", e.matrixWorld)
            }
            if (n.skinning) {
                T.setOptional(F, r, "bindMatrix"), T.setOptional(F, r, "bindMatrixInverse");
                var P = r.skeleton;
                if (P) {
                    var L = P.bones;
                    if (B.floatVertexTextures) {
                        if (void 0 === P.boneTexture) {
                            var R = Math.sqrt(4 * L.length);
                            R = Yt.ceilPowerOfTwo(R), R = Math.max(R, 4);
                            var D = new Float32Array(R * R * 4);
                            D.set(P.boneMatrices);
                            var I = new Vi(D, R, R, lt, it);
                            P.boneMatrices = D, P.boneTexture = I, P.boneTextureSize = R
                        }
                        T.setValue(F, "boneTexture", P.boneTexture, V), T.setValue(F, "boneTextureSize", P.boneTextureSize)
                    } else T.setOptional(F, P, "boneMatrices")
                }
            }
            if (!M && o.receiveShadow === r.receiveShadow || (o.receiveShadow = r.receiveShadow, T.setValue(F, "receiveShadow", r.receiveShadow)), n.needsBoundingBox) {
                var N = r.geometry;
                N && (null === N.boundingBox && N.computeBoundingBox(), T.setValue(F, "boundingBoxMin", N.boundingBox.min), T.setValue(F, "boundingBoxMax", N.boundingBox.max))
            }
            return M && (T.setValue(F, "toneMappingExposure", G.toneMappingExposure), T.setValue(F, "toneMappingWhitePoint", G.toneMappingWhitePoint), G.toneMapping == Be ? (T.setValue(F, "toneMappingBrightness", G.toneMappingBrightness), T.setValue(F, "toneMappingContrast", G.toneMappingContrast), T.setValue(F, "toneMappingMidTones", G.toneMappingMidTones), T.setValue(F, "toneMappingPhysicalScale", G.toneMappingPhysicalScale), T.setValue(F, "toneMappingChromaticAdaptation", G.toneMappingChromaticAdaptation), T.setValue(F, "toneMappingWhiteColor", G.toneMappingWhiteColor), T.setValue(F, "toneMappingColorDifferentiation", G.toneMappingColorDifferentiation), T.setValue(F, "toneMappingExteriorDaylight", G.toneMappingExteriorDaylight)) : G.toneMapping == ze && (T.setValue(F, "toneMappingResolution", le.set(Y, q)), T.setValue(F, "toneMappingWhiteBalance", G.toneMappingWhiteBalance), T.setValue(F, "toneMappingHighlights", G.toneMappingHighlights), T.setValue(F, "toneMappingMidTones", G.toneMappingMidTones), T.setValue(F, "toneMappingShadows", G.toneMappingShadows), T.setValue(F, "toneMappingSaturation", G.toneMappingSaturation), T.setValue(F, "toneMappingPhysicalScale", G.toneMappingPhysicalScale), T.setValue(F, "toneMappingAperture", G.toneMappingAperture), T.setValue(F, "toneMappingShutter", G.toneMappingShutter), T.setValue(F, "toneMappingISO", G.toneMappingISO), T.setValue(F, "toneMappingVignetting", G.toneMappingVignetting)), o.needsLights && (b = A, (x = E).ambientLightColor.needsUpdate = b, x.lightProbe.needsUpdate = b, x.directionalLights.needsUpdate = b, x.pointLights.needsUpdate = b, x.spotLights.needsUpdate = b, x.rectAreaLights.needsUpdate = b, x.hemisphereLights.needsUpdate = b), i && n.fog && (y = i, (_ = E).fogColor.value.copy(y.color), y.isFog ? (_.fogNear.value = y.near, _.fogFar.value = y.far) : y.isFogExp2 && (_.fogDensity.value = y.density)), n.ssrParams && (g = n, (v = E).invProjectionMatrix.value = g.ssrParams.invProjectionMatrix, v.ssrSourceBuffer.value = g.ssrParams.sourceBuffer.texture, v.ssrDepthBuffer.value = g.ssrParams.depthBuffer.texture, v.ssrBackfaceDepthBuffer.value = g.ssrParams.backfaceDepthBuffer.texture, v.ssrResolution.value = new qt(g.ssrParams.sourceBuffer.width, g.ssrParams.sourceBuffer.height), v.ssrStride.value = g.ssrParams.stride, v.ssrThickness.value = g.ssrParams.thickness, v.ssrMaxDistance.value = g.ssrParams.maxDistance, v.ssrJitter.value = g.ssrParams.jitter), n.isMeshBasicMaterial ? Ee(E, n) : n.isMeshLambertMaterial ? (Ee(E, n), f = E, (m = n).emissiveMap && (f.emissiveMap.value = m.emissiveMap)) : n.isMeshToonMaterial ? (Ee(E, n), function (e, t) {
                e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.gradientMap && (e.gradientMap.value = t.gradientMap);
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Pe && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Pe && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }(E, n)) : n.isMeshPhongMaterial ? (Ee(E, n), function (e, t) {
                e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Pe && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Pe && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }(E, n)) : n.isMeshStandardMaterial ? (Ee(E, n, a), (n.isMeshPhysicalMaterial ? function (e, t, n) {
                Ce(e, t, n), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy(t.sheen);
                t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === Pe && e.clearcoatNormalScale.value.negate());
                e.transparency.value = t.transparency
            } : Ce)(E, n, a)) : n.isMeshMatcapMaterial ? (Ee(E, n), function (e, t) {
                t.matcap && (e.matcap.value = t.matcap);
                t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Pe && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Pe && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }(E, n)) : n.isMeshDepthMaterial ? (Ee(E, n), function (e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                e.slopeScaledBias.value = t.slopeScaledBias
            }(E, n)) : n.isMeshDistanceMaterial ? (Ee(E, n), function (e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance, e.slopeScaledBias.value = t.slopeScaledBias
            }(E, n)) : n.isMeshNormalMaterial ? (Ee(E, n), function (e, t) {
                t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Pe && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Pe && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }(E, n)) : n.isLineBasicMaterial ? (p = n, (h = E).diffuse.value.copy(p.color), h.opacity.value = p.opacity, n.isLineDashedMaterial && (d = n, (u = E).dashSize.value = d.dashSize, u.totalSize.value = d.dashSize + d.gapSize, u.scale.value = d.scale)) : n.isPointsMaterial ? function (e, t) {
                e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * Z, e.scale.value = .5 * q, t.map && (e.map.value = t.map);
                t.alphaMap && (e.alphaMap.value = t.alphaMap);
                var n;
                t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
            }(E, n) : n.isSpriteMaterial ? function (e, t) {
                e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map);
                t.alphaMap && (e.alphaMap.value = t.alphaMap);
                var n;
                t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
            }(E, n) : n.isShadowMaterial ? (E.color.value.copy(n.color), E.opacity.value = n.opacity) : n.isMeshMaskMaterial ? (Ee(E, n), function (e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                e.cameraNearFar.value = t.cameraNearFar, e.depthTexture.value = t.depthTexture, e.textureMatrix.value = t.textureMatrix
            }(E, n)) : n.isMeshNodeMaterial ? function (e, t, n, r) {
                var i = n.envMap || r;
                i && (e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio, e.maxMipLevel.value = U.get(i).__maxMipLevel);
                for (var a in n.nodeTextures) t.setValue(F, a, n.nodeTextures[a], V);
                n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias)
            }(E, T, n, a) : n.isMeshLineMaterial && function (e, t) {
                e.lineWidth.value = t.lineWidth, e.sizeAttenuation.value = t.sizeAttenuation, e.color.value = t.color, e.opacity.value = t.opacity, e.useMap.value = t.useMap, t.map && (e.map.value = t.map);
                e.useAlphaMap.value = t.useAlphaMap, t.alphaMap && (e.alphaMap.value = t.alphaMap);
                e.resolution.value.set(Y, q), e.visibility.value = t.visibility, e.alphaTest.value = t.alphaTest, e.repeat.value = t.repeat
            }(E, n), void 0 !== E.ltc_1 && (E.ltc_1.value = Wi.LTC_1), void 0 !== E.ltc_2 && (E.ltc_2.value = Wi.LTC_2), so.upload(F, o.uniformsList, E, V), n.isShaderMaterial && (n.uniformsNeedUpdate = !1)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (so.upload(F, o.uniformsList, E, V), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && T.setValue(F, "center", r.center), n.isMeshNodeMaterial && (oe.getInverse(r.matrixWorld), T.setValue(F, "invModelMatrix", oe), T.setValue(F, "viewWidthHeight", le.set(W.z - W.x, W.w - W.y)), n.nodeTexCoordObject.forEach(function (e, t) {
                (null === e ? oe : se.getInverse(e.matrixWorld)).toArray(n.nodeTexCoordObjectArr, 16 * t)
            })), 0 < S.numMultiviewViews ? fe.updateObjectMatricesUniforms(r, e, T) : (T.setValue(F, "modelViewMatrix", r.modelViewMatrix), T.setValue(F, "normalMatrix", r.normalMatrix)), T.setValue(F, "modelMatrix", r.matrixWorld), S
        }

        function Ee(e, t, n) {
            e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap);
            var r, i, a = t.envMap || n;
            a && (e.envMap.value = a, e.flipEnvMap.value = a.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = U.get(a).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? r = t.map : t.specularMap ? r = t.specularMap : t.displacementMap ? r = t.displacementMap : t.normalMap ? r = t.normalMap : t.bumpMap ? r = t.bumpMap : t.roughnessMap ? r = t.roughnessMap : t.metalnessMap ? r = t.metalnessMap : t.alphaMap ? r = t.alphaMap : t.emissiveMap && (r = t.emissiveMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), t.aoMap ? i = t.aoMap : t.lightMap && (i = t.lightMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uv2Transform.value.copy(i.matrix))
        }

        function Ce(e, t, n) {
            e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Pe && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Pe && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), (t.envMap || n) && (e.envMapIntensity.value = t.envMapIntensity)
        }
        we.setAnimationLoop(function (e) {
            pe.isPresenting || be && be(e)
        }), "undefined" != typeof window && we.setContext(window), this.setAnimationLoop = function (e) {
            be = e, pe.setAnimationLoop(e), we.start()
        }, this.render = function (e, t) {
            var n, r;
            if (void 0 !== arguments[2] && (console.warn("v3d.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("v3d.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), t && t.isCamera) {
                if (!b) {
                    I.geometry = null, I.program = null, I.wireframe = !1, k = -1, !(j = null) === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), pe.enabled && pe.isPresenting && (t = pe.getCamera(t)), (O = f.get(e, t)).init(), e.onBeforeRender(G, e, t, n || R), ae.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), te.setFromProjectionMatrix(ae), ie = this.localClippingEnabled, re = ne.init(this.clippingPlanes, ie, t), (m = p.get(e, t)).init(),
                        function e(t, n, r, i) {
                            t.isAnnotationControl && t.update(n);
                            if (t.visible) {
                                var a = t.layers.test(n.layers);
                                if (a)
                                    if (t.isGroup) r = t.renderOrder;
                                    else if (t.isLOD) !0 === t.autoUpdate && t.update(n);
                                else if (t.isLight) O.pushLight(t), t.castShadow && O.pushShadow(t);
                                else if (t.isSprite) {
                                    if (!t.frustumCulled || te.intersectsSprite(t)) {
                                        i && ce.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ae);
                                        var o = v.update(t),
                                            s = t.material;
                                        m.push(t, o, s, r, ce.z, null)
                                    }
                                } else if (t.isImmediateRenderObject) i && ce.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ae), m.push(t, null, t.material, r, ce.z, null);
                                else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || te.intersectsObject(t))) {
                                    i && ce.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ae);
                                    var o = v.update(t),
                                        s = t.material;
                                    if (Array.isArray(s))
                                        for (var l = o.groups, c = 0, u = l.length; c < u; c++) {
                                            var d = l[c],
                                                h = s[d.materialIndex];
                                            h && h.visible && m.push(t, o, h, r, ce.z, d)
                                        } else s.visible && m.push(t, o, s, r, ce.z, null)
                                }
                            } else var a = !1;
                            if (t.disableChildRendering) return;
                            var p = t.children;
                            for (var c = 0, u = p.length; c < u; c++) {
                                var f = p[c];
                                !a && f.isMesh && f.isMaterialGeneratedMesh || e(f, n, r, i)
                            }
                        }(e, t, 0, G.sortObjects), !0 === G.sortObjects && m.sort(Q, K), re && ne.beginShadows();
                    var i = O.state.shadowsArray;
                    me.render(i, e, t), O.setupLights(t), re && ne.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), pe.enabled && fe.isAvailable() && fe.attachCamera(t), g.render(m, e, t, r);
                    var a = m.opaque,
                        o = m.transparent;
                    if (e.overrideMaterial) {
                        var s = e.overrideMaterial;
                        a.length && Me(a, e, t, s), o.length && Me(o, e, t, s)
                    } else a.length && Me(a, e, t), o.length && Me(o, e, t);
                    e.onAfterRender(G, e, t), null !== R && (V.updateRenderTargetMipmap(R), V.updateMultisampleRenderTarget(R)), z.buffers.depth.setTest(!0), z.buffers.depth.setMask(!0), z.buffers.color.setMask(!0), z.setPolygonOffset(!1), pe.enabled && fe.isAvailable() && fe.detachCamera(t), O = m = null
                }
            } else console.error("v3d.WebGLRenderer.render: camera is not an instance of v3d.Camera.")
        }, this.setFramebuffer = function (e) {
            w !== e && null === R && F.bindFramebuffer(36160, e), w = e
        }, this.getActiveCubeFace = function () {
            return P
        }, this.getActiveMipmapLevel = function () {
            return L
        }, this.getRenderTarget = function () {
            return R
        }, this.setRenderTarget = function (e, t, n) {
            P = t, L = n, (R = e) && void 0 === U.get(e).__webglFramebuffer && V.setupRenderTarget(e);
            var r = w,
                i = !1;
            if (e) {
                var a = U.get(e).__webglFramebuffer;
                e.isWebGLCubeRenderTarget ? (r = a[t || 0], i = !0) : r = e.isWebGLMultisampleRenderTarget ? U.get(e).__webglMultisampledFramebuffer : a, W.copy(e.viewport), X.copy(e.scissor), H = e.scissorTest
            } else W.copy(J).multiplyScalar(Z).floor(), X.copy($).multiplyScalar(Z).floor(), H = ee;
            if (D !== r && (F.bindFramebuffer(36160, r), D = r), z.viewport(W), z.scissor(X), z.setScissorTest(H), i) {
                var o = U.get(e.texture);
                F.framebufferTexture2D(36160, 36064, 34069 + (t || 0), o.__webglTexture, n || 0)
            }
        }, this.readRenderTargetPixels = function (e, t, n, r, i, a, o) {
            if (e && e.isWebGLRenderTarget) {
                var s = U.get(e).__webglFramebuffer;
                if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) {
                    var l = !1;
                    s !== D && (F.bindFramebuffer(36160, s), l = !0);
                    try {
                        var c = e.texture,
                            u = c.format,
                            d = c.type;
                        if (u !== lt && y.convert(u) !== F.getParameter(35739)) return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(d === tt || y.convert(d) === F.getParameter(35738) || d === it && (B.isWebGL2 || M.get("OES_texture_float") || M.get("WEBGL_color_buffer_float")) || d === at && (B.isWebGL2 ? M.get("EXT_color_buffer_float") : M.get("EXT_color_buffer_half_float")))) return void console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === F.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - r && 0 <= n && n <= e.height - i && F.readPixels(t, n, r, i, y.convert(u), y.convert(d), a) : console.error("v3d.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        l && F.bindFramebuffer(36160, D)
                    }
                }
            } else console.error("v3d.WebGLRenderer.readRenderTargetPixels: renderTarget is not v3d.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function (e, t, n) {
            void 0 === n && (n = 0);
            var r = Math.pow(2, -n),
                i = Math.floor(t.image.width * r),
                a = Math.floor(t.image.height * r),
                o = y.convert(t.format);
            V.setTexture2D(t, 0), F.copyTexImage2D(3553, n, o, e.x, e.y, i, a, 0), z.unbindTexture()
        }, this.copyTextureToTexture = function (e, t, n, r) {
            var i = t.image.width,
                a = t.image.height,
                o = y.convert(n.format),
                s = y.convert(n.type);
            V.setTexture2D(n, 0), t.isDataTexture ? F.texSubImage2D(3553, r || 0, e.x, e.y, i, a, o, s, t.image.data) : F.texSubImage2D(3553, r || 0, e.x, e.y, o, s, t.image), z.unbindTexture()
        }, this.initTexture = function (e) {
            V.setTexture2D(e, 0), z.unbindTexture()
        }, "undefined" != typeof __v3d_DEVTOOLS__ && __v3d_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        })), this.updateGeometry = function (e) {
            return v.update(e)
        }, this.renderObject = Ae, this.setCanvas = function (e) {
            r = e, this.domElement = e
        }
    }

    function as(e, t) {
        this.name = "", this.color = new Pr(e), this.density = void 0 !== t ? t : 25e-5
    }

    function os(e, t, n) {
        this.name = "", this.color = new Pr(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
    }

    function ss(e, t) {
        this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = Vt, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }
    Object.assign(as.prototype, {
        isFogExp2: !0,
        clone: function () {
            return new as(this.color, this.density)
        },
        toJSON: function () {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }), Object.assign(os.prototype, {
        isFog: !0,
        clone: function () {
            return new os(this.color, this.near, this.far)
        },
        toJSON: function () {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }), Object.defineProperty(ss.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(ss.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function () {},
        setUsage: function (e) {
            return this.usage = e, this
        },
        copy: function (e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
        },
        copyAt: function (e, t, n) {
            e *= this.stride, n *= t.stride;
            for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
            return this
        },
        set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        onUpload: function (e) {
            return this.onUploadCallback = e, this
        }
    });
    var ls, cs = new on;

    function us(e, t, n, r) {
        this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r
    }

    function ds(e) {
        Or.call(this), this.type = "SpriteMaterial", this.color = new Pr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
    }
    Object.defineProperties(us.prototype, {
        count: {
            get: function () {
                return this.data.count
            }
        },
        array: {
            get: function () {
                return this.data.array
            }
        }
    }), Object.assign(us.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function (e) {
            for (var t = 0, n = this.data.count; t < n; t++) cs.x = this.getX(t), cs.y = this.getY(t), cs.z = this.getZ(t), cs.applyMatrix4(e), this.setXYZ(t, cs.x, cs.y, cs.z);
            return this
        },
        setX: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t, this
        },
        setY: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
        },
        setZ: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
        },
        setW: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
        },
        getX: function (e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function (e, t, n) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
        },
        setXYZ: function (e, t, n, r) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
        },
        setXYZW: function (e, t, n, r, i) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
        }
    }), ((ds.prototype = Object.create(Or.prototype)).constructor = ds).prototype.isSpriteMaterial = !0, ds.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
    };
    var hs = new on,
        ps = new on,
        fs = new on,
        ms = new qt,
        vs = new qt,
        gs = new fn,
        _s = new on,
        ys = new on,
        xs = new on,
        bs = new qt,
        ws = new qt,
        Ms = new qt;

    function As(e) {
        if (Fn.call(this), this.type = "Sprite", void 0 === ls) {
            ls = new ni;
            var t = new ss(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
            ls.setIndex([0, 1, 2, 0, 2, 3]), ls.setAttribute("position", new us(t, 3, 0, !1)), ls.setAttribute("uv", new us(t, 2, 3, !1))
        }
        this.geometry = ls, this.material = void 0 !== e ? e : new ds, this.center = new qt(.5, .5)
    }

    function Ss(e, t, n, r, i, a) {
        ms.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (vs.x = a * ms.x - i * ms.y, vs.y = i * ms.x + a * ms.y) : vs.copy(ms), e.copy(t), e.x += vs.x, e.y += vs.y, e.applyMatrix4(gs)
    }
    As.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: As,
        isSprite: !0,
        raycast: function (e, t) {
            if (null !== e.camera) {
                ps.setFromMatrixScale(this.matrixWorld), gs.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), fs.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && ps.multiplyScalar(-fs.z);
                var n, r, i = this.material.rotation;
                0 !== i && (r = Math.cos(i), n = Math.sin(i));
                var a = this.center;
                Ss(_s.set(-.5, -.5, 0), fs, a, ps, n, r), Ss(ys.set(.5, -.5, 0), fs, a, ps, n, r), Ss(xs.set(.5, .5, 0), fs, a, ps, n, r), bs.set(0, 0), ws.set(1, 0), Ms.set(1, 1);
                var o = e.ray.intersectTriangle(_s, ys, xs, !1, hs);
                if (null !== o || (Ss(ys.set(-.5, .5, 0), fs, a, ps, n, r), ws.set(0, 1), null !== (o = e.ray.intersectTriangle(_s, xs, ys, !1, hs)))) {
                    var s = e.ray.origin.distanceTo(hs);
                    s < e.near || s > e.far || t.push({
                        distance: s,
                        point: hs.clone(),
                        uv: Sr.getUV(hs, _s, ys, xs, bs, ws, Ms, new qt),
                        face: null,
                        object: this
                    })
                }
            } else console.error('v3d.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.')
        },
        clone: function () {
            return new this.constructor(this.material).copy(this)
        },
        copy: function (e) {
            return Fn.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
        }
    });
    var Ts = new on,
        Es = new on;

    function Cs() {
        Fn.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        }), this.autoUpdate = !0
    }

    function Ps(e, t) {
        e && e.isGeometry && console.error("v3d.SkinnedMesh no longer supports v3d.Geometry. Use v3d.BufferGeometry instead."), xi.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new fn, this.bindMatrixInverse = new fn, this.normalizeSkinWeights()
    }
    Cs.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: Cs,
        isLOD: !0,
        copy: function (e) {
            Fn.prototype.copy.call(this, e, !1);
            for (var t = e.levels, n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                this.addLevel(i.object.clone(), i.distance)
            }
            return this.autoUpdate = e.autoUpdate, this
        },
        addLevel: function (e, t) {
            void 0 === t && (t = 0), t = Math.abs(t);
            for (var n = this.levels, r = 0; r < n.length && !(t < n[r].distance); r++);
            return n.splice(r, 0, {
                distance: t,
                object: e
            }), this.add(e), this
        },
        getObjectForDistance: function (e) {
            var t = this.levels;
            if (0 < t.length) {
                for (var n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
                return t[n - 1].object
            }
            return null
        },
        raycast: function (e, t) {
            if (0 < this.levels.length) {
                Ts.setFromMatrixPosition(this.matrixWorld);
                var n = e.ray.origin.distanceTo(Ts);
                this.getObjectForDistance(n).raycast(e, t)
            }
        },
        update: function (e) {
            var t = this.levels;
            if (1 < t.length) {
                Ts.setFromMatrixPosition(e.matrixWorld), Es.setFromMatrixPosition(this.matrixWorld);
                var n = Ts.distanceTo(Es);
                t[0].object.visible = !0;
                for (var r = 1, i = t.length; r < i && n >= t[r].distance; r++) t[r - 1].object.visible = !1, t[r].object.visible = !0;
                for (; r < i; r++) t[r].object.visible = !1
            }
        },
        toJSON: function (e) {
            var t = Fn.prototype.toJSON.call(this, e);
            !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
            for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                var a = n[r];
                t.object.levels.push({
                    object: a.object.uuid,
                    distance: a.distance
                })
            }
            return t
        }
    }), Ps.prototype = Object.assign(Object.create(xi.prototype), {
        constructor: Ps,
        isSkinnedMesh: !0,
        bind: function (e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
        },
        pose: function () {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function () {
            for (var e = new $t, t = this.geometry.attributes.skinWeight, n = 0, r = t.count; n < r; n++) {
                e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                var i = 1 / e.manhattanLength();
                i != 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function (e) {
            xi.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("v3d.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    });
    var Ls = new fn,
        Rs = new fn;

    function Ds(e, t) {
        if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === t) this.calculateInverses();
        else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
        else {
            console.warn("v3d.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new fn)
        }
    }

    function Is() {
        Fn.call(this), this.type = "Bone"
    }
    Object.assign(Ds.prototype, {
        calculateInverses: function () {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var n = new fn;
                this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
            }
        },
        pose: function () {
            var e, t, n;
            for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: function () {
            for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, a = e.length; i < a; i++) {
                var o = e[i] ? e[i].matrixWorld : Rs;
                Ls.multiplyMatrices(o, t[i]), Ls.toArray(n, 16 * i)
            }
            void 0 !== r && (r.needsUpdate = !0)
        },
        clone: function () {
            return new Ds(this.bones, this.boneInverses)
        },
        getBoneByName: function (e) {
            for (var t = 0, n = this.bones.length; t < n; t++) {
                var r = this.bones[t];
                if (r.name === e) return r
            }
        }
    }), Is.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: Is,
        isBone: !0
    });
    var Ns = new fn,
        Os = new fn,
        Fs = [],
        Bs = new xi;

    function zs(e, t, n) {
        xi.call(this, e, t), this.instanceMatrix = new zr(new Float32Array(16 * n), 16), this.count = n, this.frustumCulled = !1
    }

    function Us(e) {
        Or.call(this), this.type = "LineBasicMaterial", this.color = new Pr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
    }
    zs.prototype = Object.assign(Object.create(xi.prototype), {
        constructor: zs,
        isInstancedMesh: !0,
        getMatrixAt: function (e, t) {
            t.fromArray(this.instanceMatrix.array, 16 * e)
        },
        raycast: function (e, t) {
            var n = this.matrixWorld,
                r = this.count;
            if (Bs.geometry = this.geometry, Bs.material = this.material, void 0 !== Bs.material)
                for (var i = 0; i < r; i++) this.getMatrixAt(i, Ns), Os.multiplyMatrices(n, Ns), Bs.matrixWorld = Os, Bs.raycast(e, Fs), 0 < Fs.length && (Fs[0].instanceId = i, Fs[0].object = this, t.push(Fs[0]), Fs.length = 0)
        },
        setMatrixAt: function (e, t) {
            t.toArray(this.instanceMatrix.array, 16 * e)
        },
        updateMorphTargets: function () {}
    }), ((Us.prototype = Object.create(Or.prototype)).constructor = Us).prototype.isLineBasicMaterial = !0, Us.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
    };
    var Vs = new on,
        Gs = new on,
        ks = new fn,
        js = new ur,
        Ws = new nr;

    function Xs(e, t, n) {
        1 === n && console.error("v3d.Line: parameter v3d.LinePieces no longer supported. Use v3d.LineSegments instead."), Fn.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new ni, this.material = void 0 !== t ? t : new Us
    }
    Xs.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: Xs,
        isLine: !0,
        computeLineDistances: function () {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, n = [0], r = 1, i = t.count; r < i; r++) Vs.fromBufferAttribute(t, r - 1), Gs.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += Vs.distanceTo(Gs);
                    e.setAttribute("lineDistance", new Hr(n, 1))
                } else console.warn("v3d.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry) {
                var a = e.vertices;
                (n = e.lineDistances)[0] = 0;
                for (r = 1, i = a.length; r < i; r++) n[r] = n[r - 1], n[r] += a[r - 1].distanceTo(a[r])
            }
            return this
        },
        raycast: function (e, t) {
            var n = e.linePrecision,
                r = this.geometry,
                i = this.matrixWorld;
            if (null === r.boundingSphere && r.computeBoundingSphere(), Ws.copy(r.boundingSphere), Ws.applyMatrix4(i), Ws.radius += n, !1 !== e.ray.intersectsSphere(Ws)) {
                ks.getInverse(i), js.copy(e.ray).applyMatrix4(ks);
                var a = n / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    o = a * a,
                    s = new on,
                    l = new on,
                    c = new on,
                    u = new on,
                    d = this && this.isLineSegments ? 2 : 1;
                if (r.isBufferGeometry) {
                    var h = r.index,
                        p = r.attributes.position.array;
                    if (null !== h)
                        for (var f = h.array, m = 0, v = f.length - 1; m < v; m += d) {
                            var g = f[m],
                                _ = f[m + 1];
                            if (s.fromArray(p, 3 * g), l.fromArray(p, 3 * _), !(o < js.distanceSqToSegment(s, l, u, c))) u.applyMatrix4(this.matrixWorld), (b = e.ray.origin.distanceTo(u)) < e.near || b > e.far || t.push({
                                distance: b,
                                point: c.clone().applyMatrix4(this.matrixWorld),
                                index: m,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        } else
                            for (m = 0, v = p.length / 3 - 1; m < v; m += d) {
                                if (s.fromArray(p, 3 * m), l.fromArray(p, 3 * m + 3), !(o < js.distanceSqToSegment(s, l, u, c))) u.applyMatrix4(this.matrixWorld), (b = e.ray.origin.distanceTo(u)) < e.near || b > e.far || t.push({
                                    distance: b,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                } else if (r.isGeometry) {
                    var y = r.vertices,
                        x = y.length;
                    for (m = 0; m < x - 1; m += d) {
                        var b;
                        if (!(o < js.distanceSqToSegment(y[m], y[m + 1], u, c))) u.applyMatrix4(this.matrixWorld), (b = e.ray.origin.distanceTo(u)) < e.near || b > e.far || t.push({
                            distance: b,
                            point: c.clone().applyMatrix4(this.matrixWorld),
                            index: m,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            }
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    });
    var Hs = new on,
        Ys = new on;

    function qs(e, t) {
        Xs.call(this, e, t), this.type = "LineSegments"
    }

    function Zs(e, t) {
        Xs.call(this, e, t), this.type = "LineLoop"
    }

    function Qs(e) {
        Or.call(this), this.type = "PointsMaterial", this.color = new Pr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e)
    }
    qs.prototype = Object.assign(Object.create(Xs.prototype), {
        constructor: qs,
        isLineSegments: !0,
        computeLineDistances: function () {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, n = [], r = 0, i = t.count; r < i; r += 2) Hs.fromBufferAttribute(t, r), Ys.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + Hs.distanceTo(Ys);
                    e.setAttribute("lineDistance", new Hr(n, 1))
                } else console.warn("v3d.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry) {
                var a = e.vertices;
                for (n = e.lineDistances, r = 0, i = a.length; r < i; r += 2) Hs.copy(a[r]), Ys.copy(a[r + 1]), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + Hs.distanceTo(Ys)
            }
            return this
        }
    }), Zs.prototype = Object.assign(Object.create(Xs.prototype), {
        constructor: Zs,
        isLineLoop: !0
    }), ((Qs.prototype = Object.create(Or.prototype)).constructor = Qs).prototype.isPointsMaterial = !0, Qs.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
    };
    var Ks = new fn,
        Js = new ur,
        $s = new nr,
        el = new on;

    function tl(e, t) {
        Fn.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new ni, this.material = void 0 !== t ? t : new Qs, this.updateMorphTargets()
    }

    function nl(e, t, n, r, i, a, o) {
        var s = Js.distanceSqToPoint(e);
        if (s < n) {
            var l = new on;
            Js.closestPointToPoint(e, l), l.applyMatrix4(r);
            var c = i.ray.origin.distanceTo(l);
            if (c < i.near || c > i.far) return;
            a.push({
                distance: c,
                distanceToRay: Math.sqrt(s),
                point: l,
                index: t,
                face: null,
                object: o
            })
        }
    }

    function rl(e, t, n, r, i, a, o, s, l) {
        Jt.call(this, e, t, n, r, i, a, o, s, l), this.format = void 0 !== o ? o : st, this.minFilter = void 0 !== a ? a : Je, this.magFilter = void 0 !== i ? i : Je, this.generateMipmaps = !1
    }

    function il(e, t, n, r, i, a, o, s, l, c, u, d) {
        Jt.call(this, null, a, o, s, l, c, r, i, u, d), this.image = {
            width: t,
            height: n
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
    }

    function al(e, t, n, r, i, a, o, s, l) {
        Jt.call(this, e, t, n, r, i, a, o, s, l), this.needsUpdate = !0
    }

    function ol(e, t, n, r, i, a, o, s, l, c) {
        if ((c = void 0 !== c ? c : ct) !== ct && c !== ut) throw new Error("DepthTexture format must be either v3d.DepthFormat or v3d.DepthStencilFormat");
        void 0 === n && c === ct && (n = nt), void 0 === n && c === ut && (n = ot), Jt.call(this, null, r, i, a, o, s, c, n, l), this.image = {
            width: e,
            height: t
        }, this.magFilter = void 0 !== o ? o : Ze, this.minFilter = void 0 !== s ? s : Ze, this.flipY = !1, this.generateMipmaps = !1
    }

    function sl(e) {
        ni.call(this), this.type = "WireframeGeometry";
        var t, n, r, i, a, o, s, l, c, u, d = [],
            h = [0, 0],
            p = {},
            f = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var m = e.faces;
            for (t = 0, r = m.length; t < r; t++) {
                var v = m[t];
                for (n = 0; n < 3; n++) s = v[f[n]], l = v[f[(n + 1) % 3]], h[0] = Math.min(s, l), h[1] = Math.max(s, l), void 0 === p[c = h[0] + "," + h[1]] && (p[c] = {
                    index1: h[0],
                    index2: h[1]
                })
            }
            for (c in p) o = p[c], u = e.vertices[o.index1], d.push(u.x, u.y, u.z), u = e.vertices[o.index2], d.push(u.x, u.y, u.z)
        } else if (e && e.isBufferGeometry) {
            var g, _, y, x, b, w;
            if (u = new on, null !== e.index) {
                for (g = e.attributes.position, _ = e.index, 0 === (y = e.groups).length && (y = [{
                        start: 0,
                        count: _.count,
                        materialIndex: 0
                    }]), i = 0, a = y.length; i < a; ++i)
                    for (r = (t = (x = y[i]).start) + x.count; t < r; t += 3)
                        for (n = 0; n < 3; n++) s = _.getX(t + n), l = _.getX(t + (n + 1) % 3), h[0] = Math.min(s, l), h[1] = Math.max(s, l), void 0 === p[c = h[0] + "," + h[1]] && (p[c] = {
                            index1: h[0],
                            index2: h[1]
                        });
                for (c in p) o = p[c], u.fromBufferAttribute(g, o.index1), d.push(u.x, u.y, u.z), u.fromBufferAttribute(g, o.index2), d.push(u.x, u.y, u.z)
            } else
                for (t = 0, r = (g = e.attributes.position).count / 3; t < r; t++)
                    for (n = 0; n < 3; n++) b = 3 * t + n, u.fromBufferAttribute(g, b), d.push(u.x, u.y, u.z), w = 3 * t + (n + 1) % 3, u.fromBufferAttribute(g, w), d.push(u.x, u.y, u.z)
        }
        this.setAttribute("position", new Hr(d, 3))
    }

    function ll(e, t, n) {
        Ei.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: n
        }, this.fromBufferGeometry(new cl(e, t, n)), this.mergeVertices()
    }

    function cl(e, t, n) {
        ni.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: n
        };
        var r, i, a = [],
            o = [],
            s = [],
            l = [],
            c = new on,
            u = new on,
            d = new on,
            h = new on,
            p = new on;
        e.length < 3 && console.error("v3d.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var f = t + 1;
        for (r = 0; r <= n; r++) {
            var m = r / n;
            for (i = 0; i <= t; i++) {
                var v = i / t;
                e(v, m, u), o.push(u.x, u.y, u.z), 0 <= v - 1e-5 ? (e(v - 1e-5, m, d), h.subVectors(u, d)) : (e(1e-5 + v, m, d), h.subVectors(d, u)), 0 <= m - 1e-5 ? (e(v, m - 1e-5, d), p.subVectors(u, d)) : (e(v, 1e-5 + m, d), p.subVectors(d, u)), c.crossVectors(h, p).normalize(), s.push(c.x, c.y, c.z), l.push(v, m)
            }
        }
        for (r = 0; r < n; r++)
            for (i = 0; i < t; i++) {
                var g = r * f + i,
                    _ = r * f + i + 1,
                    y = (r + 1) * f + i + 1,
                    x = (r + 1) * f + i;
                a.push(g, _, x), a.push(_, y, x)
            }
        this.setIndex(a), this.setAttribute("position", new Hr(o, 3)), this.setAttribute("normal", new Hr(s, 3)), this.setAttribute("uv", new Hr(l, 2))
    }

    function ul(e, t, n, r) {
        Ei.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: r
        }, this.fromBufferGeometry(new dl(e, t, n, r)), this.mergeVertices()
    }

    function dl(r, a, e, t) {
        ni.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: r,
            indices: a,
            radius: e,
            detail: t
        }, e = e || 1;
        var u = [],
            d = [];

        function o(e, t, n, r) {
            var i, a, o = Math.pow(2, r),
                s = [];
            for (i = 0; i <= o; i++) {
                s[i] = [];
                var l = e.clone().lerp(n, i / o),
                    c = t.clone().lerp(n, i / o),
                    u = o - i;
                for (a = 0; a <= u; a++) s[i][a] = 0 === a && i === o ? l : l.clone().lerp(c, a / u)
            }
            for (i = 0; i < o; i++)
                for (a = 0; a < 2 * (o - i) - 1; a++) {
                    var d = Math.floor(a / 2);
                    a % 2 == 0 ? (h(s[i][d + 1]), h(s[i + 1][d]), h(s[i][d])) : (h(s[i][d + 1]), h(s[i + 1][d + 1]), h(s[i + 1][d]))
                }
        }

        function h(e) {
            u.push(e.x, e.y, e.z)
        }

        function s(e, t) {
            var n = 3 * e;
            t.x = r[0 + n], t.y = r[1 + n], t.z = r[2 + n]
        }

        function p(e, t, n, r) {
            r < 0 && 1 === e.x && (d[t] = e.x - 1), 0 === n.x && 0 === n.z && (d[t] = r / 2 / Math.PI + .5)
        }

        function f(e) {
            return Math.atan2(e.z, -e.x)
        }! function (e) {
            for (var t = new on, n = new on, r = new on, i = 0; i < a.length; i += 3) s(a[i + 0], t), s(a[i + 1], n), s(a[i + 2], r), o(t, n, r, e)
        }(t = t || 0),
        function (e) {
            for (var t = new on, n = 0; n < u.length; n += 3) t.x = u[n + 0], t.y = u[n + 1], t.z = u[n + 2], t.normalize().multiplyScalar(e), u[n + 0] = t.x, u[n + 1] = t.y, u[n + 2] = t.z
        }(e),
        function () {
            for (var e = new on, t = 0; t < u.length; t += 3) {
                e.x = u[t + 0], e.y = u[t + 1], e.z = u[t + 2];
                var n = f(e) / 2 / Math.PI + .5,
                    r = (i = e, Math.atan2(-i.y, Math.sqrt(i.x * i.x + i.z * i.z)) / Math.PI + .5);
                d.push(n, 1 - r)
            }
            var i;
            (function () {
                for (var e = new on, t = new on, n = new on, r = new on, i = new qt, a = new qt, o = new qt, s = 0, l = 0; s < u.length; s += 9, l += 6) {
                    e.set(u[s + 0], u[s + 1], u[s + 2]), t.set(u[s + 3], u[s + 4], u[s + 5]), n.set(u[s + 6], u[s + 7], u[s + 8]), i.set(d[l + 0], d[l + 1]), a.set(d[l + 2], d[l + 3]), o.set(d[l + 4], d[l + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                    var c = f(r);
                    p(i, l + 0, e, c), p(a, l + 2, t, c), p(o, l + 4, n, c)
                }
            })(),
            function () {
                for (var e = 0; e < d.length; e += 6) {
                    var t = d[e + 0],
                        n = d[e + 2],
                        r = d[e + 4],
                        i = Math.max(t, n, r),
                        a = Math.min(t, n, r);
                    .9 < i && a < .1 && (t < .2 && (d[e + 0] += 1), n < .2 && (d[e + 2] += 1), r < .2 && (d[e + 4] += 1))
                }
            }()
        }(), this.setAttribute("position", new Hr(u, 3)), this.setAttribute("normal", new Hr(u.slice(), 3)), this.setAttribute("uv", new Hr(d, 2)), 0 === t ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function hl(e, t) {
        Ei.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new pl(e, t)), this.mergeVertices()
    }

    function pl(e, t) {
        dl.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function fl(e, t) {
        Ei.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new ml(e, t)), this.mergeVertices()
    }

    function ml(e, t) {
        dl.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function vl(e, t) {
        Ei.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new gl(e, t)), this.mergeVertices()
    }

    function gl(e, t) {
        var n = (1 + Math.sqrt(5)) / 2;
        dl.call(this, [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function _l(e, t) {
        Ei.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new yl(e, t)), this.mergeVertices()
    }

    function yl(e, t) {
        var n = (1 + Math.sqrt(5)) / 2,
            r = 1 / n;
        dl.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function xl(e, t, n, r, i, a) {
        Ei.call(this), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: r,
            closed: i
        }, void 0 !== a && console.warn("v3d.TubeGeometry: taper has been removed.");
        var o = new bl(e, t, n, r, i);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices()
    }

    function bl(o, s, l, c, e) {
        ni.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: o,
            tubularSegments: s,
            radius: l,
            radialSegments: c,
            closed: e
        }, s = s || 64, l = l || 1, c = c || 8, e = e || !1;
        var u = o.computeFrenetFrames(s, e);
        this.tangents = u.tangents, this.normals = u.normals, this.binormals = u.binormals;
        var i, d, h = new on,
            p = new on,
            t = new qt,
            f = new on,
            m = [],
            v = [],
            n = [],
            a = [];

        function r(e) {
            f = o.getPointAt(e / s, f);
            var t = u.normals[e],
                n = u.binormals[e];
            for (d = 0; d <= c; d++) {
                var r = d / c * Math.PI * 2,
                    i = Math.sin(r),
                    a = -Math.cos(r);
                p.x = a * t.x + i * n.x, p.y = a * t.y + i * n.y, p.z = a * t.z + i * n.z, p.normalize(), v.push(p.x, p.y, p.z), h.x = f.x + l * p.x, h.y = f.y + l * p.y, h.z = f.z + l * p.z, m.push(h.x, h.y, h.z)
            }
        }! function () {
            for (i = 0; i < s; i++) r(i);
            r(!1 === e ? s : 0),
                function () {
                    for (i = 0; i <= s; i++)
                        for (d = 0; d <= c; d++) t.x = i / s, t.y = d / c, n.push(t.x, t.y)
                }(),
                function () {
                    for (d = 1; d <= s; d++)
                        for (i = 1; i <= c; i++) {
                            var e = (c + 1) * (d - 1) + (i - 1),
                                t = (c + 1) * d + (i - 1),
                                n = (c + 1) * d + i,
                                r = (c + 1) * (d - 1) + i;
                            a.push(e, t, r), a.push(t, n, r)
                        }
                }()
        }(), this.setIndex(a), this.setAttribute("position", new Hr(m, 3)), this.setAttribute("normal", new Hr(v, 3)), this.setAttribute("uv", new Hr(n, 2))
    }

    function wl(e, t, n, r, i, a, o) {
        Ei.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: a
        }, void 0 !== o && console.warn("v3d.TorusKnotGeometry: heightScale has been deprecated. Use .scale(x, y, z) instead."), this.fromBufferGeometry(new Ml(e, t, n, r, i, a)), this.mergeVertices()
    }

    function Ml(e, t, n, r, i, a) {
        ni.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: a
        }, e = e || 1, t = t || .4, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, a = a || 3;
        var o, s, l = [],
            c = [],
            u = [],
            d = [],
            h = new on,
            p = new on,
            f = new on,
            m = new on,
            v = new on,
            g = new on,
            _ = new on;
        for (o = 0; o <= n; ++o) {
            var y = o / n * i * Math.PI * 2;
            for (E(y, i, a, e, f), E(.01 + y, i, a, e, m), g.subVectors(m, f), _.addVectors(m, f), v.crossVectors(g, _), _.crossVectors(v, g), v.normalize(), _.normalize(), s = 0; s <= r; ++s) {
                var x = s / r * Math.PI * 2,
                    b = -t * Math.cos(x),
                    w = t * Math.sin(x);
                h.x = f.x + (b * _.x + w * v.x), h.y = f.y + (b * _.y + w * v.y), h.z = f.z + (b * _.z + w * v.z), c.push(h.x, h.y, h.z), p.subVectors(h, f).normalize(), u.push(p.x, p.y, p.z), d.push(o / n), d.push(s / r)
            }
        }
        for (s = 1; s <= n; s++)
            for (o = 1; o <= r; o++) {
                var M = (r + 1) * (s - 1) + (o - 1),
                    A = (r + 1) * s + (o - 1),
                    S = (r + 1) * s + o,
                    T = (r + 1) * (s - 1) + o;
                l.push(M, A, T), l.push(A, S, T)
            }

        function E(e, t, n, r, i) {
            var a = Math.cos(e),
                o = Math.sin(e),
                s = n / t * e,
                l = Math.cos(s);
            i.x = r * (2 + l) * .5 * a, i.y = r * (2 + l) * o * .5, i.z = r * Math.sin(s) * .5
        }
        this.setIndex(l), this.setAttribute("position", new Hr(c, 3)), this.setAttribute("normal", new Hr(u, 3)), this.setAttribute("uv", new Hr(d, 2))
    }

    function Al(e, t, n, r, i) {
        Ei.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        }, this.fromBufferGeometry(new Sl(e, t, n, r, i)), this.mergeVertices()
    }

    function Sl(e, t, n, r, i) {
        ni.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        }, e = e || 1, t = t || .4, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
        var a, o, s = [],
            l = [],
            c = [],
            u = [],
            d = new on,
            h = new on,
            p = new on;
        for (a = 0; a <= n; a++)
            for (o = 0; o <= r; o++) {
                var f = o / r * i,
                    m = a / n * Math.PI * 2;
                h.x = (e + t * Math.cos(m)) * Math.cos(f), h.y = (e + t * Math.cos(m)) * Math.sin(f), h.z = t * Math.sin(m), l.push(h.x, h.y, h.z), d.x = e * Math.cos(f), d.y = e * Math.sin(f), p.subVectors(h, d).normalize(), c.push(p.x, p.y, p.z), u.push(o / r), u.push(a / n)
            }
        for (a = 1; a <= n; a++)
            for (o = 1; o <= r; o++) {
                var v = (r + 1) * a + o - 1,
                    g = (r + 1) * (a - 1) + o - 1,
                    _ = (r + 1) * (a - 1) + o,
                    y = (r + 1) * a + o;
                s.push(v, g, y), s.push(g, _, y)
            }
        this.setIndex(s), this.setAttribute("position", new Hr(l, 3)), this.setAttribute("normal", new Hr(c, 3)), this.setAttribute("uv", new Hr(u, 2))
    }
    tl.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: tl,
        isPoints: !0,
        raycast: function (e, t) {
            var n = this.geometry,
                r = this.matrixWorld,
                i = e.params.Points.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(), $s.copy(n.boundingSphere), $s.applyMatrix4(r), $s.radius += i, !1 !== e.ray.intersectsSphere($s)) {
                Ks.getInverse(r), Js.copy(e.ray).applyMatrix4(Ks);
                var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    o = a * a;
                if (n.isBufferGeometry) {
                    var s = n.index,
                        l = n.attributes.position.array;
                    if (null !== s)
                        for (var c = s.array, u = 0, d = c.length; u < d; u++) {
                            var h = c[u];
                            el.fromArray(l, 3 * h), nl(el, h, o, r, e, t, this)
                        } else {
                            u = 0;
                            for (var p = l.length / 3; u < p; u++) el.fromArray(l, 3 * u), nl(el, u, o, r, e, t, this)
                        }
                } else {
                    var f = n.vertices;
                    for (u = 0, p = f.length; u < p; u++) nl(f[u], u, o, r, e, t, this)
                }
            }
        },
        updateMorphTargets: function () {
            var e, t, n, r = this.geometry;
            if (r.isBufferGeometry) {
                var i = r.morphAttributes,
                    a = Object.keys(i);
                if (0 < a.length) {
                    var o = i[a[0]];
                    if (void 0 !== o)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = o.length; e < t; e++) n = o[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                }
            } else {
                var s = r.morphTargets;
                void 0 !== s && 0 < s.length && console.error("v3d.Points.updateMorphTargets() does not support v3d.Geometry. Use v3d.BufferGeometry instead.")
            }
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), rl.prototype = Object.assign(Object.create(Jt.prototype), {
        constructor: rl,
        isVideoTexture: !0,
        update: function () {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), ((il.prototype = Object.create(Jt.prototype)).constructor = il).prototype.isCompressedTexture = !0, ((al.prototype = Object.create(Jt.prototype)).constructor = al).prototype.isCanvasTexture = !0, ((ol.prototype = Object.create(Jt.prototype)).constructor = ol).prototype.isDepthTexture = !0, (sl.prototype = Object.create(ni.prototype)).constructor = sl, (ll.prototype = Object.create(Ei.prototype)).constructor = ll, (cl.prototype = Object.create(ni.prototype)).constructor = cl, (ul.prototype = Object.create(Ei.prototype)).constructor = ul, (dl.prototype = Object.create(ni.prototype)).constructor = dl, (hl.prototype = Object.create(Ei.prototype)).constructor = hl, (pl.prototype = Object.create(dl.prototype)).constructor = pl, (fl.prototype = Object.create(Ei.prototype)).constructor = fl, (ml.prototype = Object.create(dl.prototype)).constructor = ml, (vl.prototype = Object.create(Ei.prototype)).constructor = vl, (gl.prototype = Object.create(dl.prototype)).constructor = gl, (_l.prototype = Object.create(Ei.prototype)).constructor = _l, (yl.prototype = Object.create(dl.prototype)).constructor = yl, (xl.prototype = Object.create(Ei.prototype)).constructor = xl, ((bl.prototype = Object.create(ni.prototype)).constructor = bl).prototype.toJSON = function () {
        var e = ni.prototype.toJSON.call(this);
        return e.path = this.parameters.path.toJSON(), e
    }, (wl.prototype = Object.create(Ei.prototype)).constructor = wl, (Ml.prototype = Object.create(ni.prototype)).constructor = Ml, (Al.prototype = Object.create(Ei.prototype)).constructor = Al, (Sl.prototype = Object.create(ni.prototype)).constructor = Sl;
    var Tl = function (e, t, n) {
        n = n || 2;
        var r, i, a, o, s, l, c, u = t && t.length,
            d = u ? t[0] * n : e.length,
            h = El(e, 0, d, n, !0),
            p = [];
        if (!h || h.next === h.prev) return p;
        if (u && (h = function (e, t, n, r) {
                var i, a, o, s, l, c = [];
                for (i = 0, a = t.length; i < a; i++) o = t[i] * r, s = i < a - 1 ? t[i + 1] * r : e.length, (l = El(e, o, s, r, !1)) === l.next && (l.steiner = !0), c.push(Bl(l));
                for (c.sort(Nl), i = 0; i < c.length; i++) Ol(c[i], n), n = Cl(n, n.next);
                return n
            }(e, t, h, n)), e.length > 80 * n) {
            r = a = e[0], i = o = e[1];
            for (var f = n; f < d; f += n)(s = e[f]) < r && (r = s), (l = e[f + 1]) < i && (i = l), a < s && (a = s), o < l && (o = l);
            c = 0 !== (c = Math.max(a - r, o - i)) ? 1 / c : 0
        }
        return Pl(h, p, n, r, i, c), p
    };

    function El(e, t, n, r, i) {
        var a, o;
        if (i === 0 < function (e, t, n, r) {
                for (var i = 0, a = t, o = n - r; a < n; a += r) i += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a;
                return i
            }(e, t, n, r))
            for (a = t; a < n; a += r) o = Wl(a, e[a], e[a + 1], o);
        else
            for (a = n - r; t <= a; a -= r) o = Wl(a, e[a], e[a + 1], o);
        return o && Vl(o, o.next) && (Xl(o), o = o.next), o
    }

    function Cl(e, t) {
        if (!e) return e;
        t = t || e;
        var n, r = e;
        do {
            if (n = !1, r.steiner || !Vl(r, r.next) && 0 !== Ul(r.prev, r, r.next)) r = r.next;
            else {
                if (Xl(r), (r = t = r.prev) === r.next) break;
                n = !0
            }
        } while (n || r !== t);
        return t
    }

    function Pl(e, t, n, r, i, a, o) {
        if (e) {
            !o && a && function (e, t, n, r) {
                var i = e;
                for (; null === i.z && (i.z = Fl(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next, i !== e;);
                i.prevZ.nextZ = null, i.prevZ = null,
                    function (e) {
                        var t, n, r, i, a, o, s, l, c = 1;
                        do {
                            for (n = e, a = e = null, o = 0; n;) {
                                for (o++, r = n, t = s = 0; t < c && (s++, r = r.nextZ); t++);
                                for (l = c; 0 < s || 0 < l && r;) 0 !== s && (0 === l || !r || n.z <= r.z) ? (n = (i = n).nextZ, s--) : (r = (i = r).nextZ, l--), a ? a.nextZ = i : e = i, i.prevZ = a, a = i;
                                n = r
                            }
                            a.nextZ = null, c *= 2
                        } while (1 < o)
                    }(i)
            }(e, r, i, a);
            for (var s, l, c = e; e.prev !== e.next;)
                if (s = e.prev, l = e.next, a ? Rl(e, r, i, a) : Ll(e)) t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), Xl(e), e = l.next, c = l.next;
                else if ((e = l) === c) {
                o ? 1 === o ? Pl(e = Dl(e, t, n), t, n, r, i, a, 2) : 2 === o && Il(e, t, n, r, i, a) : Pl(Cl(e), t, n, r, i, a, 1);
                break
            }
        }
    }

    function Ll(e) {
        var t = e.prev,
            n = e,
            r = e.next;
        if (!(0 <= Ul(t, n, r))) {
            for (var i = e.next.next; i !== e.prev;) {
                if (zl(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && 0 <= Ul(i.prev, i, i.next)) return;
                i = i.next
            }
            return 1
        }
    }

    function Rl(e, t, n, r) {
        var i = e.prev,
            a = e,
            o = e.next;
        if (!(0 <= Ul(i, a, o))) {
            for (var s = i.x < a.x ? i.x < o.x ? i.x : o.x : a.x < o.x ? a.x : o.x, l = i.y < a.y ? i.y < o.y ? i.y : o.y : a.y < o.y ? a.y : o.y, c = i.x > a.x ? i.x > o.x ? i.x : o.x : a.x > o.x ? a.x : o.x, u = i.y > a.y ? i.y > o.y ? i.y : o.y : a.y > o.y ? a.y : o.y, d = Fl(s, l, t, n, r), h = Fl(c, u, t, n, r), p = e.prevZ, f = e.nextZ; p && p.z >= d && f && f.z <= h;) {
                if (p !== e.prev && p !== e.next && zl(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && 0 <= Ul(p.prev, p, p.next)) return;
                if (p = p.prevZ, f !== e.prev && f !== e.next && zl(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && 0 <= Ul(f.prev, f, f.next)) return;
                f = f.nextZ
            }
            for (; p && p.z >= d;) {
                if (p !== e.prev && p !== e.next && zl(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && 0 <= Ul(p.prev, p, p.next)) return;
                p = p.prevZ
            }
            for (; f && f.z <= h;) {
                if (f !== e.prev && f !== e.next && zl(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && 0 <= Ul(f.prev, f, f.next)) return;
                f = f.nextZ
            }
            return 1
        }
    }

    function Dl(e, t, n) {
        var r = e;
        do {
            var i = r.prev,
                a = r.next.next;
            !Vl(i, a) && Gl(i, r, r.next, a) && kl(i, a) && kl(a, i) && (t.push(i.i / n), t.push(r.i / n), t.push(a.i / n), Xl(r), Xl(r.next), r = e = a), r = r.next
        } while (r !== e);
        return r
    }

    function Il(e, t, n, r, i, a) {
        var o, s, l = e;
        do {
            for (var c = l.next.next; c !== l.prev;) {
                if (l.i !== c.i && (s = c, (o = l).next.i !== s.i && o.prev.i !== s.i && ! function (e, t) {
                        var n = e;
                        do {
                            if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Gl(n, n.next, e, t)) return 1;
                            n = n.next
                        } while (n !== e);
                        return
                    }(o, s) && kl(o, s) && kl(s, o) && function (e, t) {
                        var n = e,
                            r = !1,
                            i = (e.x + t.x) / 2,
                            a = (e.y + t.y) / 2;
                        for (; n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next, n !== e;);
                        return r
                    }(o, s))) {
                    var u = jl(l, c);
                    return l = Cl(l, l.next), u = Cl(u, u.next), Pl(l, t, n, r, i, a), void Pl(u, t, n, r, i, a)
                }
                c = c.next
            }
            l = l.next
        } while (l !== e)
    }

    function Nl(e, t) {
        return e.x - t.x
    }

    function Ol(e, t) {
        if (t = function (e, t) {
                var n, r = t,
                    i = e.x,
                    a = e.y,
                    o = -1 / 0;
                do {
                    if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
                        var s = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (s <= i && o < s) {
                            if ((o = s) === i) {
                                if (a === r.y) return r;
                                if (a === r.next.y) return r.next
                            }
                            n = r.x < r.next.x ? r : r.next
                        }
                    }
                    r = r.next
                } while (r !== t);
                if (!n) return null;
                if (i === o) return n.prev;
                var l, c = n,
                    u = n.x,
                    d = n.y,
                    h = 1 / 0;
                r = n.next;
                for (; r !== c;) i >= r.x && r.x >= u && i !== r.x && zl(a < d ? i : o, a, u, d, a < d ? o : i, a, r.x, r.y) && ((l = Math.abs(a - r.y) / (i - r.x)) < h || l === h && r.x > n.x) && kl(r, e) && (n = r, h = l), r = r.next;
                return n
            }(e, t)) {
            var n = jl(t, e);
            Cl(n, n.next)
        }
    }

    function Fl(e, t, n, r, i) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }

    function Bl(e) {
        for (var t = e, n = e;
            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), (t = t.next) !== e;);
        return n
    }

    function zl(e, t, n, r, i, a, o, s) {
        return 0 <= (i - o) * (t - s) - (e - o) * (a - s) && 0 <= (e - o) * (r - s) - (n - o) * (t - s) && 0 <= (n - o) * (a - s) - (i - o) * (r - s)
    }

    function Ul(e, t, n) {
        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
    }

    function Vl(e, t) {
        return e.x === t.x && e.y === t.y
    }

    function Gl(e, t, n, r) {
        return Vl(e, n) && Vl(t, r) || Vl(e, r) && Vl(n, t) || 0 < Ul(e, t, n) != 0 < Ul(e, t, r) && 0 < Ul(n, r, e) != 0 < Ul(n, r, t)
    }

    function kl(e, t) {
        return Ul(e.prev, e, e.next) < 0 ? 0 <= Ul(e, t, e.next) && 0 <= Ul(e, e.prev, t) : Ul(e, t, e.prev) < 0 || Ul(e, e.next, t) < 0
    }

    function jl(e, t) {
        var n = new Hl(e.i, e.x, e.y),
            r = new Hl(t.i, t.x, t.y),
            i = e.next,
            a = t.prev;
        return (e.next = t).prev = e, (n.next = i).prev = n, (r.next = n).prev = r, (a.next = r).prev = a, r
    }

    function Wl(e, t, n, r) {
        var i = new Hl(e, t, n);
        return r ? (i.next = r.next, (i.prev = r).next.prev = i, r.next = i) : (i.prev = i).next = i, i
    }

    function Xl(e) {
        e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }

    function Hl(e, t, n) {
        this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }
    var Yl = {
        area: function (e) {
            for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
            return .5 * n
        },
        isClockWise: function (e) {
            return Yl.area(e) < 0
        },
        triangulateShape: function (e, t) {
            var n = [],
                r = [],
                i = [];
            ql(e), Zl(n, e);
            var a = e.length;
            t.forEach(ql);
            for (var o = 0; o < t.length; o++) r.push(a), a += t[o].length, Zl(n, t[o]);
            var s = Tl(n, r);
            for (o = 0; o < s.length; o += 3) i.push(s.slice(o, o + 3));
            return i
        }
    };

    function ql(e) {
        var t = e.length;
        2 < t && e[t - 1].equals(e[0]) && e.pop()
    }

    function Zl(e, t) {
        for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
    }

    function Ql(e, t) {
        Ei.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, this.fromBufferGeometry(new Kl(e, t)), this.mergeVertices()
    }

    function Kl(e, K) {
        ni.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: e,
            options: K
        }, e = Array.isArray(e) ? e : [e];
        for (var J = this, $ = [], ee = [], t = 0, n = e.length; t < n; t++) {
            r(e[t])
        }

        function r(e) {
            var r = [],
                t = void 0 !== K.curveSegments ? K.curveSegments : 12,
                l = void 0 !== K.steps ? K.steps : 1,
                n = void 0 !== K.depth ? K.depth : 100,
                i = void 0 === K.bevelEnabled || K.bevelEnabled,
                a = void 0 !== K.bevelThickness ? K.bevelThickness : 6,
                o = void 0 !== K.bevelSize ? K.bevelSize : a - 2,
                s = void 0 !== K.bevelOffset ? K.bevelOffset : 0,
                c = void 0 !== K.bevelSegments ? K.bevelSegments : 3,
                u = K.extrudePath,
                d = void 0 !== K.UVGenerator ? K.UVGenerator : Jl;
            void 0 !== K.amount && (console.warn("v3d.ExtrudeBufferGeometry: amount has been renamed to depth."), n = K.amount);
            var h, p, f, m, v, g, _, y, x = !1;
            u && (h = u.getSpacedPoints(l), i = !(x = !0), p = u.computeFrenetFrames(l, !1), f = new on, m = new on, v = new on), i || (s = o = a = c = 0);
            var b = e.extractPoints(t),
                w = b.shape,
                M = b.holes;
            if (!Yl.isClockWise(w))
                for (w = w.reverse(), _ = 0, y = M.length; _ < y; _++) g = M[_], Yl.isClockWise(g) && (M[_] = g.reverse());
            var A = Yl.triangulateShape(w, M),
                S = w;
            for (_ = 0, y = M.length; _ < y; _++) g = M[_], w = w.concat(g);

            function T(e, t, n) {
                return t || console.error("v3d.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
            }
            var E, C, P, L, R, D, I = w.length,
                N = A.length;

            function O(e, t, n) {
                var r, i, a, o = e.x - t.x,
                    s = e.y - t.y,
                    l = n.x - e.x,
                    c = n.y - e.y,
                    u = o * o + s * s,
                    d = o * c - s * l;
                if (Math.abs(d) > Number.EPSILON) {
                    var h = Math.sqrt(u),
                        p = Math.sqrt(l * l + c * c),
                        f = t.x - s / h,
                        m = t.y + o / h,
                        v = ((n.x - c / p - f) * c - (n.y + l / p - m) * l) / (o * c - s * l),
                        g = (r = f + o * v - e.x) * r + (i = m + s * v - e.y) * i;
                    if (g <= 2) return new qt(r, i);
                    a = Math.sqrt(g / 2)
                } else {
                    var _ = !1;
                    o > Number.EPSILON ? l > Number.EPSILON && (_ = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (_ = !0) : Math.sign(s) === Math.sign(c) && (_ = !0), a = _ ? (r = -s, i = o, Math.sqrt(u)) : (r = o, i = s, Math.sqrt(u / 2))
                }
                return new qt(r / a, i / a)
            }
            for (var F = [], B = 0, z = S.length, U = z - 1, V = B + 1; B < z; B++, U++, V++) U === z && (U = 0), V === z && (V = 0), F[B] = O(S[B], S[U], S[V]);
            var G, k, j = [],
                W = F.concat();
            for (_ = 0, y = M.length; _ < y; _++) {
                for (g = M[_], G = [], B = 0, U = (z = g.length) - 1, V = B + 1; B < z; B++, U++, V++) U === z && (U = 0), V === z && (V = 0), G[B] = O(g[B], g[U], g[V]);
                j.push(G), W = W.concat(G)
            }
            for (E = 0; E < c; E++) {
                for (P = E / c, L = a * Math.cos(P * Math.PI / 2), C = o * Math.sin(P * Math.PI / 2) + s, B = 0, z = S.length; B < z; B++) H((R = T(S[B], F[B], C)).x, R.y, -L);
                for (_ = 0, y = M.length; _ < y; _++)
                    for (g = M[_], G = j[_], B = 0, z = g.length; B < z; B++) H((R = T(g[B], G[B], C)).x, R.y, -L)
            }
            for (C = o + s, B = 0; B < I; B++) R = i ? T(w[B], W[B], C) : w[B], x ? (m.copy(p.normals[0]).multiplyScalar(R.x), f.copy(p.binormals[0]).multiplyScalar(R.y), v.copy(h[0]).add(m).add(f), H(v.x, v.y, v.z)) : H(R.x, R.y, 0);
            for (k = 1; k <= l; k++)
                for (B = 0; B < I; B++) R = i ? T(w[B], W[B], C) : w[B], x ? (m.copy(p.normals[k]).multiplyScalar(R.x), f.copy(p.binormals[k]).multiplyScalar(R.y), v.copy(h[k]).add(m).add(f), H(v.x, v.y, v.z)) : H(R.x, R.y, n / l * k);
            for (E = c - 1; 0 <= E; E--) {
                for (P = E / c, L = a * Math.cos(P * Math.PI / 2), C = o * Math.sin(P * Math.PI / 2) + s, B = 0, z = S.length; B < z; B++) H((R = T(S[B], F[B], C)).x, R.y, n + L);
                for (_ = 0, y = M.length; _ < y; _++)
                    for (g = M[_], G = j[_], B = 0, z = g.length; B < z; B++) R = T(g[B], G[B], C), x ? H(R.x, R.y + h[l - 1].y, h[l - 1].x + L) : H(R.x, R.y, n + L)
            }

            function X(e, t) {
                var n, r;
                for (B = e.length; 0 <= --B;) {
                    (r = (n = B) - 1) < 0 && (r = e.length - 1);
                    var i = 0,
                        a = l + 2 * c;
                    for (i = 0; i < a; i++) {
                        var o = I * i,
                            s = I * (i + 1);
                        q(t + n + o, t + r + o, t + r + s, t + n + s)
                    }
                }
            }

            function H(e, t, n) {
                r.push(e), r.push(t), r.push(n)
            }

            function Y(e, t, n) {
                Z(e), Z(t), Z(n);
                var r = $.length / 3,
                    i = d.generateTopUV(J, $, r - 3, r - 2, r - 1);
                Q(i[0]), Q(i[1]), Q(i[2])
            }

            function q(e, t, n, r) {
                Z(e), Z(t), Z(r), Z(t), Z(n), Z(r);
                var i = $.length / 3,
                    a = d.generateSideWallUV(J, $, i - 6, i - 3, i - 2, i - 1);
                Q(a[0]), Q(a[1]), Q(a[3]), Q(a[1]), Q(a[2]), Q(a[3])
            }

            function Z(e) {
                $.push(r[3 * e + 0]), $.push(r[3 * e + 1]), $.push(r[3 * e + 2])
            }

            function Q(e) {
                ee.push(e.x), ee.push(e.y)
            }! function () {
                var e = $.length / 3;
                if (i) {
                    var t = 0,
                        n = I * t;
                    for (B = 0; B < N; B++) Y((D = A[B])[2] + n, D[1] + n, D[0] + n);
                    for (n = I * (t = l + 2 * c), B = 0; B < N; B++) Y((D = A[B])[0] + n, D[1] + n, D[2] + n)
                } else {
                    for (B = 0; B < N; B++) Y((D = A[B])[2], D[1], D[0]);
                    for (B = 0; B < N; B++) Y((D = A[B])[0] + I * l, D[1] + I * l, D[2] + I * l)
                }
                J.addGroup(e, $.length / 3 - e, 0)
            }(),
            function () {
                var e = $.length / 3,
                    t = 0;
                for (X(S, t), t += S.length, _ = 0, y = M.length; _ < y; _++) X(g = M[_], t), t += g.length;
                J.addGroup(e, $.length / 3 - e, 1)
            }()
        }
        this.setAttribute("position", new Hr($, 3)), this.setAttribute("uv", new Hr(ee, 2)), this.computeVertexNormals()
    }((Ql.prototype = Object.create(Ei.prototype)).constructor = Ql).prototype.toJSON = function () {
        var e = Ei.prototype.toJSON.call(this);
        return $l(this.parameters.shapes, this.parameters.options, e)
    }, ((Kl.prototype = Object.create(ni.prototype)).constructor = Kl).prototype.toJSON = function () {
        var e = ni.prototype.toJSON.call(this);
        return $l(this.parameters.shapes, this.parameters.options, e)
    };
    var Jl = {
        generateTopUV: function (e, t, n, r, i) {
            var a = t[3 * n],
                o = t[3 * n + 1],
                s = t[3 * r],
                l = t[3 * r + 1],
                c = t[3 * i],
                u = t[3 * i + 1];
            return [new qt(a, o), new qt(s, l), new qt(c, u)]
        },
        generateSideWallUV: function (e, t, n, r, i, a) {
            var o = t[3 * n],
                s = t[3 * n + 1],
                l = t[3 * n + 2],
                c = t[3 * r],
                u = t[3 * r + 1],
                d = t[3 * r + 2],
                h = t[3 * i],
                p = t[3 * i + 1],
                f = t[3 * i + 2],
                m = t[3 * a],
                v = t[3 * a + 1],
                g = t[3 * a + 2];
            return Math.abs(s - u) < .01 ? [new qt(o, 1 - l), new qt(c, 1 - d), new qt(h, 1 - f), new qt(m, 1 - g)] : [new qt(s, 1 - l), new qt(u, 1 - d), new qt(p, 1 - f), new qt(v, 1 - g)]
        }
    };

    function $l(e, t, n) {
        if (n.shapes = [], Array.isArray(e))
            for (var r = 0, i = e.length; r < i; r++) {
                var a = e[r];
                n.shapes.push(a.uuid)
            } else n.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
    }

    function ec(e, t) {
        Ei.call(this), this.type = "TextGeometry", this.parameters = {
            text: e,
            parameters: t
        }, this.fromBufferGeometry(new tc(e, t)), this.mergeVertices()
    }

    function tc(e, t) {
        var n = (t = t || {}).font;
        if (!n || !n.isFont) return console.error("v3d.TextGeometry: font parameter is not an instance of v3d.Font."), new Ei;
        var r = n.generateShapes(e, t.size);
        t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Kl.call(this, r, t), this.type = "TextBufferGeometry"
    }

    function nc(e, t, n, r, i, a, o) {
        Ei.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: a,
            thetaLength: o
        }, this.fromBufferGeometry(new rc(e, t, n, r, i, a, o)), this.mergeVertices()
    }

    function rc(e, t, n, r, i, a, o) {
        ni.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: a,
            thetaLength: o
        }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : Math.PI;
        var s, l, c = Math.min(a + o, Math.PI),
            u = 0,
            d = [],
            h = new on,
            p = new on,
            f = [],
            m = [],
            v = [],
            g = [];
        for (l = 0; l <= n; l++) {
            var _ = [],
                y = l / n,
                x = 0;
            for (0 == l && 0 == a ? x = .5 / t : l == n && c == Math.PI && (x = -.5 / t), s = 0; s <= t; s++) {
                var b = s / t;
                h.x = -e * Math.cos(r + b * i) * Math.sin(a + y * o), h.y = e * Math.cos(a + y * o), h.z = e * Math.sin(r + b * i) * Math.sin(a + y * o), m.push(h.x, h.y, h.z), p.copy(h).normalize(), v.push(p.x, p.y, p.z), g.push(b + x, 1 - y), _.push(u++)
            }
            d.push(_)
        }
        for (l = 0; l < n; l++)
            for (s = 0; s < t; s++) {
                var w = d[l][s + 1],
                    M = d[l][s],
                    A = d[l + 1][s],
                    S = d[l + 1][s + 1];
                (0 !== l || 0 < a) && f.push(w, M, S), (l !== n - 1 || c < Math.PI) && f.push(M, A, S)
            }
        this.setIndex(f), this.setAttribute("position", new Hr(m, 3)), this.setAttribute("normal", new Hr(v, 3)), this.setAttribute("uv", new Hr(g, 2))
    }

    function ic(e, t, n, r, i, a) {
        Ei.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: a
        }, this.fromBufferGeometry(new ac(e, t, n, r, i, a)), this.mergeVertices()
    }

    function ac(e, t, n, r, i, a) {
        ni.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: a
        }, e = e || .5, t = t || 1, i = void 0 !== i ? i : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
        var o, s, l, c = [],
            u = [],
            d = [],
            h = [],
            p = e,
            f = (t - e) / (r = void 0 !== r ? Math.max(1, r) : 1),
            m = new on,
            v = new qt;
        for (s = 0; s <= r; s++) {
            for (l = 0; l <= n; l++) o = i + l / n * a, m.x = p * Math.cos(o), m.y = p * Math.sin(o), u.push(m.x, m.y, m.z), d.push(0, 0, 1), v.x = (m.x / t + 1) / 2, v.y = (m.y / t + 1) / 2, h.push(v.x, v.y);
            p += f
        }
        for (s = 0; s < r; s++) {
            var g = s * (n + 1);
            for (l = 0; l < n; l++) {
                var _ = o = l + g,
                    y = o + n + 1,
                    x = o + n + 2,
                    b = o + 1;
                c.push(_, y, b), c.push(y, x, b)
            }
        }
        this.setIndex(c), this.setAttribute("position", new Hr(u, 3)), this.setAttribute("normal", new Hr(d, 3)), this.setAttribute("uv", new Hr(h, 2))
    }

    function oc(e, t, n, r) {
        Ei.call(this), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: r
        }, this.fromBufferGeometry(new sc(e, t, n, r)), this.mergeVertices()
    }

    function sc(e, t, n, r) {
        ni.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: r
        }, t = Math.floor(t) || 12, n = n || 0, r = r || 2 * Math.PI, r = Yt.clamp(r, 0, 2 * Math.PI);
        var i, a, o, s = [],
            l = [],
            c = [],
            u = 1 / t,
            d = new on,
            h = new qt;
        for (a = 0; a <= t; a++) {
            var p = n + a * u * r,
                f = Math.sin(p),
                m = Math.cos(p);
            for (o = 0; o <= e.length - 1; o++) d.x = e[o].x * f, d.y = e[o].y, d.z = e[o].x * m, l.push(d.x, d.y, d.z), h.x = a / t, h.y = o / (e.length - 1), c.push(h.x, h.y)
        }
        for (a = 0; a < t; a++)
            for (o = 0; o < e.length - 1; o++) {
                var v = i = o + a * e.length,
                    g = i + e.length,
                    _ = i + e.length + 1,
                    y = i + 1;
                s.push(v, g, y), s.push(g, _, y)
            }
        if (this.setIndex(s), this.setAttribute("position", new Hr(l, 3)), this.setAttribute("uv", new Hr(c, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
            var x = this.attributes.normal.array,
                b = new on,
                w = new on,
                M = new on;
            for (i = t * e.length * 3, o = a = 0; a < e.length; a++, o += 3) b.x = x[o + 0], b.y = x[o + 1], b.z = x[o + 2], w.x = x[i + o + 0], w.y = x[i + o + 1], w.z = x[i + o + 2], M.addVectors(b, w).normalize(), x[o + 0] = x[i + o + 0] = M.x, x[o + 1] = x[i + o + 1] = M.y, x[o + 2] = x[i + o + 2] = M.z
        }
    }

    function lc(e, t) {
        Ei.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("v3d.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
            shapes: e,
            curveSegments: t
        }, this.fromBufferGeometry(new cc(e, t)), this.mergeVertices()
    }

    function cc(e, f) {
        ni.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: e,
            curveSegments: f
        }, f = f || 12;
        var m = [],
            v = [],
            g = [],
            _ = [],
            t = 0,
            y = 0;
        if (!1 === Array.isArray(e)) r(e);
        else
            for (var n = 0; n < e.length; n++) r(e[n]), this.addGroup(t, y, n), t += y, y = 0;

        function r(e) {
            var t, n, r, i = v.length / 3,
                a = e.extractPoints(f),
                o = a.shape,
                s = a.holes;
            for (!1 === Yl.isClockWise(o) && (o = o.reverse()), t = 0, n = s.length; t < n; t++) r = s[t], !0 === Yl.isClockWise(r) && (s[t] = r.reverse());
            var l = Yl.triangulateShape(o, s);
            for (t = 0, n = s.length; t < n; t++) r = s[t], o = o.concat(r);
            for (t = 0, n = o.length; t < n; t++) {
                var c = o[t];
                v.push(c.x, c.y, 0), g.push(0, 0, 1), _.push(c.x, c.y)
            }
            for (t = 0, n = l.length; t < n; t++) {
                var u = l[t],
                    d = u[0] + i,
                    h = u[1] + i,
                    p = u[2] + i;
                m.push(d, h, p), y += 3
            }
        }
        this.setIndex(m), this.setAttribute("position", new Hr(v, 3)), this.setAttribute("normal", new Hr(g, 3)), this.setAttribute("uv", new Hr(_, 2))
    }

    function uc(e, t) {
        if (t.shapes = [], Array.isArray(e))
            for (var n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                t.shapes.push(i.uuid)
            } else t.shapes.push(e.uuid);
        return t
    }

    function dc(e, t) {
        ni.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: t
        }, t = void 0 !== t ? t : 1;
        var n, r, i, a, o = [],
            s = Math.cos(Yt.DEG2RAD * t),
            l = [0, 0],
            c = {},
            u = ["a", "b", "c"];
        e.isBufferGeometry ? (a = new Ei).fromBufferGeometry(e) : a = e.clone(), a.mergeVertices(), a.computeFaceNormals();
        for (var d = a.vertices, h = a.faces, p = 0, f = h.length; p < f; p++)
            for (var m = h[p], v = 0; v < 3; v++) n = m[u[v]], r = m[u[(v + 1) % 3]], l[0] = Math.min(n, r), l[1] = Math.max(n, r), void 0 === c[i = l[0] + "," + l[1]] ? c[i] = {
                index1: l[0],
                index2: l[1],
                face1: p,
                face2: void 0
            } : c[i].face2 = p;
        for (i in c) {
            var g = c[i];
            if (void 0 === g.face2 || h[g.face1].normal.dot(h[g.face2].normal) <= s) {
                var _ = d[g.index1];
                o.push(_.x, _.y, _.z), _ = d[g.index2], o.push(_.x, _.y, _.z)
            }
        }
        this.setAttribute("position", new Hr(o, 3))
    }

    function hc(e, t, n, r, i, a, o, s) {
        Ei.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: a,
            thetaStart: o,
            thetaLength: s
        }, this.fromBufferGeometry(new pc(e, t, n, r, i, a, o, s)), this.mergeVertices()
    }

    function pc(g, _, y, x, b, e, w, M) {
        ni.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: g,
            radiusBottom: _,
            height: y,
            radialSegments: x,
            heightSegments: b,
            openEnded: e,
            thetaStart: w,
            thetaLength: M
        };
        var A = this;
        g = void 0 !== g ? g : 1, _ = void 0 !== _ ? _ : 1, y = y || 1, x = Math.floor(x) || 8, b = Math.floor(b) || 1, e = void 0 !== e && e, w = void 0 !== w ? w : 0, M = void 0 !== M ? M : 2 * Math.PI;
        var S = [],
            T = [],
            E = [],
            C = [],
            P = 0,
            L = [],
            R = y / 2,
            D = 0;

        function t(e) {
            var t, n, r, i = new qt,
                a = new on,
                o = 0,
                s = !0 === e ? g : _,
                l = !0 === e ? 1 : -1;
            for (n = P, t = 1; t <= x; t++) T.push(0, R * l, 0), E.push(0, l, 0), C.push(.5, .5), P++;
            for (r = P, t = 0; t <= x; t++) {
                var c = t / x * M + w,
                    u = Math.cos(c),
                    d = Math.sin(c);
                a.x = s * d, a.y = R * l, a.z = s * u, T.push(a.x, a.y, a.z), E.push(0, l, 0), i.x = .5 * u + .5, i.y = .5 * d * l + .5, C.push(i.x, i.y), P++
            }
            for (t = 0; t < x; t++) {
                var h = n + t,
                    p = r + t;
                !0 === e ? S.push(p, p + 1, h) : S.push(p + 1, p, h), o += 3
            }
            A.addGroup(D, o, !0 === e ? 1 : 2), D += o
        }! function () {
            var e, t, n = new on,
                r = new on,
                i = 0,
                a = (_ - g) / y;
            for (t = 0; t <= b; t++) {
                var o = [],
                    s = t / b,
                    l = s * (_ - g) + g;
                for (e = 0; e <= x; e++) {
                    var c = e / x,
                        u = c * M + w,
                        d = Math.sin(u),
                        h = Math.cos(u);
                    r.x = l * d, r.y = -s * y + R, r.z = l * h, T.push(r.x, r.y, r.z), n.set(d, a, h).normalize(), E.push(n.x, n.y, n.z), C.push(c, 1 - s), o.push(P++)
                }
                L.push(o)
            }
            for (e = 0; e < x; e++)
                for (t = 0; t < b; t++) {
                    var p = L[t][e],
                        f = L[t + 1][e],
                        m = L[t + 1][e + 1],
                        v = L[t][e + 1];
                    S.push(p, f, v), S.push(f, m, v), i += 6
                }
            A.addGroup(D, i, 0), D += i
        }(), !1 === e && (0 < g && t(!0), 0 < _ && t(!1)), this.setIndex(S), this.setAttribute("position", new Hr(T, 3)), this.setAttribute("normal", new Hr(E, 3)), this.setAttribute("uv", new Hr(C, 2))
    }

    function fc(e, t, n, r, i, a, o) {
        hc.call(this, 0, e, t, n, r, i, a, o), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: a,
            thetaLength: o
        }
    }

    function mc(e, t, n, r, i, a, o) {
        pc.call(this, 0, e, t, n, r, i, a, o), this.type = "ConeBufferGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: a,
            thetaLength: o
        }
    }

    function vc(e, t, n, r) {
        Ei.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: r
        }, this.fromBufferGeometry(new gc(e, t, n, r)), this.mergeVertices()
    }

    function gc(e, t, n, r) {
        ni.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: r
        }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
        var i, a, o = [],
            s = [],
            l = [],
            c = [],
            u = new on,
            d = new qt;
        for (s.push(0, 0, 0), l.push(0, 0, 1), c.push(.5, .5), a = 0, i = 3; a <= t; a++, i += 3) {
            var h = n + a / t * r;
            u.x = e * Math.cos(h), u.y = e * Math.sin(h), s.push(u.x, u.y, u.z), l.push(0, 0, 1), d.x = (s[i] / e + 1) / 2, d.y = (s[i + 1] / e + 1) / 2, c.push(d.x, d.y)
        }
        for (i = 1; i <= t; i++) o.push(i, i + 1, 0);
        this.setIndex(o), this.setAttribute("position", new Hr(s, 3)), this.setAttribute("normal", new Hr(l, 3)), this.setAttribute("uv", new Hr(c, 2))
    }(ec.prototype = Object.create(Ei.prototype)).constructor = ec, (tc.prototype = Object.create(Kl.prototype)).constructor = tc, (nc.prototype = Object.create(Ei.prototype)).constructor = nc, (rc.prototype = Object.create(ni.prototype)).constructor = rc, (ic.prototype = Object.create(Ei.prototype)).constructor = ic, (ac.prototype = Object.create(ni.prototype)).constructor = ac, (oc.prototype = Object.create(Ei.prototype)).constructor = oc, (sc.prototype = Object.create(ni.prototype)).constructor = sc, ((lc.prototype = Object.create(Ei.prototype)).constructor = lc).prototype.toJSON = function () {
        var e = Ei.prototype.toJSON.call(this);
        return uc(this.parameters.shapes, e)
    }, ((cc.prototype = Object.create(ni.prototype)).constructor = cc).prototype.toJSON = function () {
        var e = ni.prototype.toJSON.call(this);
        return uc(this.parameters.shapes, e)
    }, (dc.prototype = Object.create(ni.prototype)).constructor = dc, (hc.prototype = Object.create(Ei.prototype)).constructor = hc, (pc.prototype = Object.create(ni.prototype)).constructor = pc, (fc.prototype = Object.create(hc.prototype)).constructor = fc, (mc.prototype = Object.create(pc.prototype)).constructor = mc, (vc.prototype = Object.create(Ei.prototype)).constructor = vc, (gc.prototype = Object.create(ni.prototype)).constructor = gc;
    var _c = Object.freeze({
        __proto__: null,
        WireframeGeometry: sl,
        ParametricGeometry: ll,
        ParametricBufferGeometry: cl,
        TetrahedronGeometry: hl,
        TetrahedronBufferGeometry: pl,
        OctahedronGeometry: fl,
        OctahedronBufferGeometry: ml,
        IcosahedronGeometry: vl,
        IcosahedronBufferGeometry: gl,
        DodecahedronGeometry: _l,
        DodecahedronBufferGeometry: yl,
        PolyhedronGeometry: ul,
        PolyhedronBufferGeometry: dl,
        TubeGeometry: xl,
        TubeBufferGeometry: bl,
        TorusKnotGeometry: wl,
        TorusKnotBufferGeometry: Ml,
        TorusGeometry: Al,
        TorusBufferGeometry: Sl,
        TextGeometry: ec,
        TextBufferGeometry: tc,
        SphereGeometry: nc,
        SphereBufferGeometry: rc,
        RingGeometry: ic,
        RingBufferGeometry: ac,
        PlaneGeometry: Zi,
        PlaneBufferGeometry: Qi,
        LatheGeometry: oc,
        LatheBufferGeometry: sc,
        ShapeGeometry: lc,
        ShapeBufferGeometry: cc,
        ExtrudeGeometry: Ql,
        ExtrudeBufferGeometry: Kl,
        EdgesGeometry: dc,
        ConeGeometry: fc,
        ConeBufferGeometry: mc,
        CylinderGeometry: hc,
        CylinderBufferGeometry: pc,
        CircleGeometry: vc,
        CircleBufferGeometry: gc,
        BoxGeometry: Ci,
        BoxBufferGeometry: Pi
    });

    function yc(e) {
        Or.call(this), this.type = "ShadowMaterial", this.color = new Pr(0), this.transparent = !0, this.setValues(e)
    }

    function xc(e) {
        Oi.call(this, e), this.type = "RawShaderMaterial"
    }

    function bc(e) {
        Or.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Pr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new qt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function wc(e) {
        bc.call(this), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearcoat = 0, this.clearcoatRoughness = 0, this.sheen = null, this.clearcoatNormalScale = new qt(1, 1), this.clearcoatNormalMap = null, this.transparency = 0, this.setValues(e)
    }

    function Mc(e) {
        Or.call(this), this.type = "MeshPhongMaterial", this.color = new Pr(16777215), this.specular = new Pr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new qt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = U, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Ac(e) {
        Or.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new Pr(16777215), this.specular = new Pr(1118481), this.shininess = 30, this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new qt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Sc(e) {
        Or.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new qt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Tc(e) {
        Or.call(this), this.type = "MeshLambertMaterial", this.color = new Pr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = U, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Ec(e) {
        Or.call(this), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new Pr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ft, this.normalScale = new qt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Cc(e) {
        Us.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }

    function Pc(e) {
        Or.call(this), this.type = "MeshMaskMaterial", this.skinning = !1, this.morphTargets = !1, this.side = ie, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e)
    }

    function Lc(e, t, n, r) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n
    }

    function Rc(e, t, n, r) {
        Lc.call(this, e, t, n, r)
    }((yc.prototype = Object.create(Or.prototype)).constructor = yc).prototype.isShadowMaterial = !0, yc.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.color.copy(e.color), this
    }, ((xc.prototype = Object.create(Oi.prototype)).constructor = xc).prototype.isRawShaderMaterial = !0, ((bc.prototype = Object.create(Or.prototype)).constructor = bc).prototype.isMeshStandardMaterial = !0, bc.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((wc.prototype = Object.create(bc.prototype)).constructor = wc).prototype.isMeshPhysicalMaterial = !0, wc.prototype.copy = function (e) {
        return bc.prototype.copy.call(this, e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.reflectivity = e.reflectivity, this.clearcoat = e.clearcoat, this.clearcoatRoughness = e.clearcoatRoughness, e.sheen ? this.sheen = (this.sheen || new Pr).copy(e.sheen) : this.sheen = null, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.transparency = e.transparency, this
    }, ((Mc.prototype = Object.create(Or.prototype)).constructor = Mc).prototype.isMeshPhongMaterial = !0, Mc.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((Ac.prototype = Object.create(Or.prototype)).constructor = Ac).prototype.isMeshToonMaterial = !0, Ac.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((Sc.prototype = Object.create(Or.prototype)).constructor = Sc).prototype.isMeshNormalMaterial = !0, Sc.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((Tc.prototype = Object.create(Or.prototype)).constructor = Tc).prototype.isMeshLambertMaterial = !0, Tc.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((Ec.prototype = Object.create(Or.prototype)).constructor = Ec).prototype.isMeshMatcapMaterial = !0, Ec.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((Cc.prototype = Object.create(Us.prototype)).constructor = Cc).prototype.isLineDashedMaterial = !0, Cc.prototype.copy = function (e) {
        return Us.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    }, ((Pc.prototype = Object.create(Or.prototype)).constructor = Pc).prototype.isMeshMaskMaterial = !0, Pc.prototype.copy = function (e) {
        return Or.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }, Object.assign(Lc.prototype, {
        evaluate: function (e) {
            var t = this.parameterPositions,
                n = this._cachedIndex,
                r = t[n],
                i = t[n - 1];
            e: {
                t: {
                    var a;n: {
                        r: if (!(e < r)) {
                            for (var o = n + 2;;) {
                                if (void 0 === r) {
                                    if (e < i) break r;
                                    return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, i)
                                }
                                if (n === o) break;
                                if (i = r, e < (r = t[++n])) break t
                            }
                            a = t.length;
                            break n
                        }if (i <= e) break e;
                        var s = t[1];e < s && (n = 2, i = s);
                        for (o = n - 2;;) {
                            if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                            if (n === o) break;
                            if (r = i, (i = t[--n - 1]) <= e) break t
                        }
                        a = n,
                        n = 0
                    }
                    for (; n < a;) {
                        var l = n + a >>> 1;
                        e < t[l] ? a = l : n = 1 + l
                    }
                    if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0,
                    this.beforeStart_(0, e, r);
                    if (void 0 === r) return n = t.length,
                    this._cachedIndex = n,
                    this.afterEnd_(n - 1, i, e)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, i, r)
            }
            return this.interpolate_(n, i, e, r)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function () {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function (e) {
            for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, a = 0; a !== r; ++a) t[a] = n[i + a];
            return t
        },
        interpolate_: function () {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function () {}
    }), Object.assign(Lc.prototype, {
        beforeStart_: Lc.prototype.copySampleValue_,
        afterEnd_: Lc.prototype.copySampleValue_
    }), Rc.prototype = Object.assign(Object.create(Lc.prototype), {
        constructor: Rc,
        interpolate_: function (e) {
            return this.copySampleValue_(e - 1)
        }
    });
    var Dc = {};
    ! function (c) {
        c.less = function (e, t, n) {
            return n(e, t) < 0
        }, c.exchange = function (e, t, n) {
            var r = e[t];
            e[t] = e[n], e[n] = r
        };

        function u(e) {
            var t = {};
            for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
            return t
        }
        c.StackNode = function (e) {
            this.value = e, this.next = null
        };

        function e() {
            this.N = 0, this.first = null
        }
        e.prototype.push = function (e) {
            this.first = this._push(this.first, e)
        }, e.prototype._push = function (e, t) {
            if (null == e) return this.N++, new c.StackNode(t);
            var n = e;
            return this.N++, (e = new c.StackNode(t)).next = n, e
        }, e.prototype.pop = function () {
            if (null != this.first) {
                var e = this.first,
                    t = e.value;
                return this.first = e.next, this.N--, t
            }
        }, e.prototype.size = function () {
            return this.N
        }, e.prototype.isEmpty = function () {
            return 0 == this.N
        }, e.prototype.peep = function () {
            if (null != this.first) return this.first.value
        }, e.prototype.toArray = function () {
            for (var e = [], t = this.first; null != t;) e.push(t.value), t = t.next;
            return e
        }, c.Stack = e;
        c.QueueNode = function (e) {
            this.value = e, this.next = null
        };

        function t() {
            this.first = null, this.last = null, this.N = 0
        }
        t.prototype.enqueue = function (e) {
            var t = this.last;
            this.last = new c.QueueNode(e), null != t && (t.next = this.last), null == this.first && (this.first = this.last), this.N++
        }, t.prototype.dequeue = function () {
            if (null != this.first) {
                var e = this.first,
                    t = e.value;
                return this.first = e.next, null == this.first && (this.last = null), this.N--, t
            }
        }, t.prototype.size = function () {
            return this.N
        }, t.prototype.isEmpty = function () {
            return 0 == this.N
        }, t.prototype.toArray = function () {
            for (var e = [], t = this.first; null != t;) e.push(t.value), t = t.next;
            return e
        }, c.Queue = t;

        function n(e) {
            this.s = [], this.N = 0, e = e || function (e, t) {
                return e - t
            }, this.compare = e
        }
        n.prototype.enqueue = function (e) {
            for (; this.s.lengh <= this.N + 1;) this.s.push(0);
            this.s[++this.N] = e, this.swim(this.N)
        }, n.prototype.swim = function (e) {
            for (; 1 < e;) {
                var t = Math.floor(e / 2);
                if (!c.less(this.s[e], this.s[t], this.compare)) break;
                c.exchange(this.s, e, t), e = t
            }
        }, n.prototype.delMin = function () {
            if (0 != this.N) {
                var e = this.s[1];
                return c.exchange(this.s, 1, this.N--), this.sink(1), e
            }
        }, n.prototype.sink = function (e) {
            for (; 2 * e <= this.N;) {
                var t = 2 * e;
                if (t < this.N && c.less(this.s[t + 1], this.s[t], this.compare) && t++, !c.less(this.s[t], this.s[e], this.compare)) break;
                c.exchange(this.s, t, e), e = t
            }
        }, n.prototype.size = function () {
            return this.N
        }, n.prototype.isEmpty = function () {
            return 0 == this.N
        }, c.MinPQ = n;

        function r(e) {
            this.id = [];
            for (var t = 0; t < e; ++t) this.id.push(t)
        }
        r.prototype.union = function (e, t) {
            var n = this.root(e),
                r = this.root(t);
            r != n && (this.id[r] = n)
        }, r.prototype.root = function (e) {
            for (; this.id[e] != e;) e = this.id[e];
            return e
        }, r.prototype.connected = function (e, t) {
            return this.root(e) == this.root(t)
        }, c.QuickUnion = r;

        function i(e, t) {
            this.keys = [], this.pq = [], this.qp = [];
            for (var n = 0; n <= e; ++n) this.keys.push(null), this.pq.push(0), this.qp.push(-1);
            this.N = 0, t = t || function (e, t) {
                return e - t
            }, this.compare = t
        }
        i.prototype.insert = function (e, t) {
            this.keys[e] = t, this.pq[++this.N] = e, this.qp[e] = this.N, this.swim(this.N)
        }, i.prototype.decreaseKey = function (e, t) {
            c.less(t, this.keys[e], this.compare) && (this.keys[e] = t, this.swim(this.qp[e]))
        }, i.prototype.minKey = function () {
            return this.keys[this.pq[1]]
        }, i.prototype.min = function () {
            return this.pq[1]
        }, i.prototype.delMin = function () {
            var e = this.pq[1];
            return c.exchange(this.pq, 1, this.N), this.qp[this.pq[1]] = 1, this.qp[this.pq[this.N]] = -1, this.keys[this.pq[this.N]] = null, this.N--, this.sink(1), e
        }, i.prototype.swim = function (e) {
            for (; 1 < e;) {
                var t = Math.floor(e / 2);
                if (!c.less(this.keys[this.pq[e]], this.keys[this.pq[t]], this.compare)) break;
                c.exchange(this.pq, e, t), this.qp[this.pq[e]] = e, e = this.qp[this.pq[t]] = t
            }
        }, i.prototype.sink = function (e) {
            for (; 2 * e <= this.N;) {
                var t = 2 * e;
                if (t < this.N && c.less(this.keys[this.pq[t + 1]], this.keys[this.pq[t]], this.compare) && t++, !c.less(this.keys[this.pq[t]], this.keys[this.pq[e]], this.compare)) break;
                c.exchange(this.pq, e, t), this.qp[this.pq[e]] = e, e = this.qp[this.pq[t]] = t
            }
        }, i.prototype.containsIndex = function (e) {
            return -1 != this.qp[e]
        }, i.prototype.isEmpty = function () {
            return 0 == this.N
        }, i.prototype.size = function () {
            return this.N
        }, c.IndexMinPQ = i;
        c.LinkMapNode = function (e) {
            this.value = e, this.prev = null, this.next = null
        };

        function a() {
            this.first = null, this.last = null, this.map = {}
        }
        a.prototype.push = function (e, t) {
            this.map[t] = e, null === this.first ? this.first = e : (this.last.next = e).prev = this.last, this.last = e
        }, a.prototype.removeNodeByKey = function (e) {
            var t = this.map[e],
                n = t.prev,
                r = t.next;
            null !== n && null !== r ? (n.next = r).prev = n : null === n && null !== r ? (this.first = r).prev = null : null !== n && null === r ? (this.last = n).next = null : (this.first = null, this.last = null), delete this.map[e]
        }, c.LinkMap = a;

        function o(e) {
            this.V = e, this.adjList = [], this.nodeInfo = [], this.edges = {};
            for (var t = 0; t < e; ++t) this.adjList.push([]), this.nodeInfo.push({})
        }
        o.prototype.addNewEdge = function (e, t) {
            this.adjList[e].push(t), this.adjList[t].push(e);
            var n = e + "_" + t;
            t < e && (n = t + "_" + e), this.edges[n] = new c.Edge(e, t, 0)
        }, o.prototype.adj = function (e) {
            return this.adjList[e]
        }, o.prototype.node = function (e) {
            return this.nodeInfo[e]
        }, o.prototype.len = function () {
            return this.V
        }, o.prototype.edge = function (e, t) {
            var n = e + "_" + t;
            return t < e && (n = t + "_" + e), n in this.edges ? this.edges[n] : null
        }, c.Graph = o;

        function d(e) {
            this.V = e, this.adjList = [], this.nodeInfo = [], this.edges = {};
            for (var t = 0; t < e; ++t) this.adjList.push([]), this.nodeInfo.push({})
        }
        d.prototype.removeAll = function () {
            this.V = 0, this.adjList = [], this.nodeInfo = [], this.edges = {}
        }, d.prototype.addNode = function (e) {
            e = e || {}, this.V++, this.adjList.push([]), this.nodeInfo.push(e)
        }, d.prototype.addNewEdge = function (e, t) {
            this.adjList[e].push(t);
            var n = e + "_" + t,
                r = new c.Edge(e, t, 0);
            return this.edges[n] = r
        }, d.prototype.addEdge = function (e) {
            var t = e.v,
                n = e.w;
            this.adjList[t].push(n);
            var r = t + "_" + n;
            this.edges[r] = e
        }, d.prototype.removeEdge = function (e, t) {
            for (var n = this.adjList[e], r = 0; r < n.length; r++) n[r] == t && (n.splice(r, 1), r--);
            var i = e + "_" + t;
            i in this.edges && delete this.edges[i]
        }, d.prototype.edge = function (e, t) {
            var n = e + "_" + t;
            return n in this.edges ? this.edges[n] : null
        }, d.prototype.adj = function (e) {
            return this.adjList[e]
        }, d.prototype.node = function (e) {
            return this.nodeInfo[e]
        }, d.prototype.nodeIndex = function (e) {
            for (var t = 0; t < this.V; ++t)
                if (this.nodeInfo[t] == e) return t;
            return -1
        }, d.prototype.reverse = function () {
            for (var e = new d(this.V), t = 0; t < this.V; ++t)
                for (var n = this.adjList[t], r = 0; r < n.length; ++r) {
                    var i = n[r];
                    e.addNewEdge(i, t)
                }
            return e
        }, d.prototype.len = function () {
            return this.V
        }, d.prototype.findInEdges = function (e) {
            for (var t = [], n = 0; n < this.V; n++)
                for (var r = this.adjList[n], i = 0; i < r.length; i++) r[i] == e && t.push(this.edge(n, e));
            return t
        }, d.prototype.findOutEdges = function (e) {
            for (var t = [], n = this.adjList[e], r = 0; r < n.length; r++) t.push(this.edge(e, n[r]));
            return t
        }, d.prototype.disconnect = function (e, t) {
            this.adjList[e].splice(0);
            for (var n = 0; n < this.V; n++) {
                for (var r = this.adjList[n], i = 0; i < r.length; i++) r[i] == e && (r.splice(i, 1), i--);
                var a = n + "_" + e;
                a in this.edges && delete this.edges[a], (a = e + "_" + n) in this.edges && delete this.edges[a]
            }
            if (t) {
                var o = new d(this.V - 1);
                for (n = 0; n < this.V; n++)
                    if (n != e)
                        for (r = this.adjList[n], i = 0; i < r.length; i++) {
                            var s = r[i],
                                l = e < n ? n - 1 : n,
                                c = e < s ? s - 1 : s,
                                u = this.edge(n, s).copy();
                            u.v = l, u.w = c, o.addEdge(u)
                        }
                this.V--, this.adjList = o.adjList, this.nodeInfo.splice(e, 1), this.edges = o.edges
            }
        }, d.prototype.insert = function (e, t, n) {
            for (var r = this.V, i = e.V, a = 0; a < i; a++) {
                this.adjList.push([]), this.nodeInfo.push(u(e.nodeInfo[a]));
                for (var o = e.adjList[a], s = 0; s < o.length; s++) {
                    var l = o[s];
                    (c = e.edge(a, l).copy()).v += r, c.w += r, this.addEdge(c)
                }
            }
            this.V += i;
            for (s = 0; s < t.length; s++) {
                (c = t[s].copy()).w += r, this.addEdge(c)
            }
            for (s = 0; s < n.length; s++) {
                var c;
                (c = n[s].copy()).v += r, this.addEdge(c)
            }
        }, d.prototype.vis = function (e) {
            e = e || function (e, t) {
                return String(e)
            };
            for (var t = "digraph G {", n = 0; n < this.V; n++) {
                t += n + ' [label="' + e(n, this.nodeInfo[n]) + '"];';
                for (var r = this.adjList[n], i = 0; i < r.length; i++) {
                    t += n + " -> " + r[i] + ";"
                }
            }
            t += "}", console.log(t)
        }, c.DiGraph = d;

        function s(e, t, n) {
            this.v = e, this.w = t, this.weight = n
        }
        s.prototype.either = function () {
            return this.v
        }, s.prototype.other = function (e) {
            return e == this.v ? this.w : this.v
        }, s.prototype.from = function () {
            return this.v
        }, s.prototype.to = function () {
            return this.w
        }, s.prototype.copy = function () {
            var e = new s(0, 0, 0);
            for (var t in this) this.hasOwnProperty(t) && (e[t] = this[t]);
            return e
        }, c.Edge = s;

        function l(e) {
            this.V = e, this.adjList = [], this.nodeInfo = [];
            for (var t = 0; t < e; ++t) this.adjList.push([]), this.nodeInfo.push({})
        }
        l.prototype.adj = function (e) {
            return this.adjList[e]
        }, l.prototype.edge = function (e, t) {
            for (var n = this.adjList[e], r = 0; r < n.length; ++r) {
                if (n[r].other(e) == t) return n[r]
            }
            return null
        }, l.prototype.node = function (e) {
            return this.nodeInfo[e]
        }, l.prototype.addNewEdge = function (e) {
            var t = e.either(),
                n = e.other(t);
            this.adjList[t].push(e), this.adjList[n].push(e)
        }, c.WeightedGraph = l;

        function h(e) {
            l.call(this, e)
        }(h.prototype = Object.create(c.WeightedGraph.prototype)).addNewEdge = function (e) {
            var t = e.from();
            this.adjList[t].push(e)
        }, h.prototype.edge = function (e, t) {
            for (var n = this.adjList[e], r = 0; r < n.length; ++r) {
                if (n[r].other(e) == t) return n[r]
            }
            return null
        }, h.prototype.toDiGraph = function () {
            for (var e = new c.DiGraph(this.V), t = 0; t < this.V; ++t)
                for (var n = this.adjList[t], r = 0; r < n.length; ++r) {
                    var i = n[r].other(t);
                    e.addNewEdge(t, i)
                }
            return e
        }, c.WeightedDiGraph = h;

        function p(e, t, n) {
            this.v = e, this.w = t, this.capacity = n, this.flow = 0
        }
        p.prototype.residualCapacityTo = function (e) {
            return e == this.v ? this.flow : this.capacity - this.flow
        }, p.prototype.addResidualFlowTo = function (e, t) {
            e == this.v ? this.flow -= t : e == this.w && (this.flow += t)
        }, p.prototype.from = function () {
            return this.v
        }, p.prototype.to = function () {
            return this.w
        }, p.prototype.other = function (e) {
            return e == this.v ? this.w : this.v
        }, c.FlowEdge = p;

        function f(e) {
            this.V = e, this.adjList = [], this.nodeInfo = [];
            for (var t = 0; t < e; ++t) this.adjList.push([]), this.nodeInfo.push({})
        }
        f.prototype.node = function (e) {
            return this.nodeInfo[e]
        }, f.prototype.edge = function (e, t) {
            for (var n = this.adjList[e], r = 0; r < n.length; ++r) {
                if (n[r].other(e) == t) return n[r]
            }
            return null
        }, f.prototype.addNewEdge = function (e) {
            var t = e.from();
            this.adjList[t].push(e);
            var n = e.other(t);
            this.adjList[n].push(e)
        }, f.prototype.adj = function (e) {
            return this.adjList[e]
        }, c.FlowNetwork = f;

        function m(e, t) {
            this.s = t;
            var n = e.V;
            this.marked = [], this.edgeTo = [];
            for (var r = 0; r < n; ++r) this.marked.push(!1), this.edgeTo.push(-1);
            this.dfs(e, t)
        }
        m.prototype.dfs = function (e, t) {
            this.marked[t] = !0;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r];
                this.marked[i] || (this.edgeTo[i] = t, this.dfs(e, i))
            }
        }, m.prototype.hasPathTo = function (e) {
            return this.marked[e]
        }, m.prototype.pathTo = function (e) {
            var t = new c.Stack;
            if (e == this.s) return [e];
            for (var n = e; n != this.s; n = this.edgeTo[n]) t.push(n);
            return t.push(this.s), t.toArray()
        }, c.DepthFirstSearch = m;

        function v(e, t) {
            var n = e.V;
            this.s = t;
            var r = new c.Queue;
            r.enqueue(t), this.marked = [], this.edgeTo = [];
            for (var i = 0; i < n; ++i) this.marked.push(!1), this.edgeTo.push(-1);
            for (; !r.isEmpty();) {
                i = r.dequeue();
                this.marked[i] = !0;
                for (var a = e.adj(i), o = 0; o < a.length; ++o) {
                    var s = a[o];
                    this.marked[s] || (this.edgeTo[s] = i, r.enqueue(s))
                }
            }
        }
        v.prototype.hasPathTo = function (e) {
            return this.marked[e]
        }, v.prototype.pathTo = function (e) {
            var t = new c.Stack;
            if (e == this.s) return [e];
            for (var n = e; n != this.s; n = this.edgeTo[n]) t.push(n);
            return t.push(this.s), t.toArray()
        }, c.BreadthFirstSearch = v;

        function g(e) {
            this.count = 0;
            var t = e.V;
            this.marked = [], this.id = [];
            for (var n = 0; n < t; ++n) this.marked.push(!1), this.id.push(-1);
            for (n = 0; n < t; ++n) this.marked[n] || (this.dfs(e, n), this.count++)
        }
        g.prototype.dfs = function (e, t) {
            this.marked[t] = !0, this.id[t] = this.count;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r];
                this.marked[i] || this.dfs(e, i)
            }
        }, g.prototype.componentId = function (e) {
            return this.id[e]
        }, g.prototype.componentCount = function () {
            return this.count
        }, c.ConnectedComponents = g;

        function _(e) {
            this.postOrder = new c.Stack, this.marked = [];
            for (var t = e.V, n = 0; n < t; ++n) this.marked.push(!1);
            for (n = 0; n < t; ++n) this.marked[n] || this.dfs(e, n)
        }
        _.prototype.dfs = function (e, t) {
            this.marked[t] = !0;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r];
                this.marked[i] || this.dfs(e, i)
            }
            this.postOrder.push(t)
        }, _.prototype.order = function () {
            return this.postOrder.toArray()
        }, c.TopologicalSort = _;

        function y(e) {
            var t = e.V;
            this.count = 0, this.marked = [], this.id = [];
            for (var n = 0; n < t; ++n) this.marked.push(!1), this.id.push(-1);
            for (var r = new c.TopologicalSort(e.reverse()).order(), i = 0; i < r.length; ++i) {
                n = r[i];
                this.marked[n] || (this.dfs(e, n), this.count++)
            }
        }
        y.prototype.dfs = function (e, t) {
            this.marked[t] = !0, this.id[t] = this.count;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r];
                this.marked[i] || this.dfs(e, i)
            }
        }, y.prototype.componentId = function (e) {
            return this.id[e]
        }, y.prototype.componentCount = function () {
            return this.count
        }, c.StronglyConnectedComponents = y;
        c.KruskalMST = function (e) {
            for (var t = e.V, n = new c.MinPQ(function (e, t) {
                    return e.weight - t.weight
                }), r = 0; r < e.V; ++r)
                for (var i = e.adj(r), a = 0; a < i.length; ++a) {
                    (s = i[a]).either() == r && n.enqueue(s)
                }
            this.mst = [];
            for (var o = new c.QuickUnion(t); !n.isEmpty() && this.mst.length < t - 1;) {
                r = (s = n.delMin()).either();
                var s, l = s.other(r);
                o.connected(r, l) || (o.union(r, l), this.mst.push(s))
            }
        };

        function x(e) {
            var t = e.V;
            this.marked = [];
            for (var n = 0; n < t; ++n) this.marked.push(!1);
            for (this.pq = new c.MinPQ(function (e, t) {
                    return e.weight - t.weight
                }), this.mst = [], this.visit(e, 0); !this.pq.isEmpty() && this.mst.length < t - 1;) {
                var r = this.pq.delMin(),
                    i = (n = r.either(), r.other(n));
                this.marked[n] && this.marked[i] || (this.mst.push(r), this.marked[n] || this.visit(e, n), this.marked[i] || this.visit(e, i))
            }
        }
        x.prototype.visit = function (e, t) {
            this.marked[t] = !0;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r];
                this.marked[i.other(t)] || this.pq.enqueue(i)
            }
        }, c.LazyPrimMST = x;

        function b(e) {
            var t = e.V;
            this.pq = new c.IndexMinPQ(t, function (e, t) {
                return e.weight - t.weight
            }), this.marked = [];
            for (var n = 0; n < t; ++n) this.marked.push(!1);
            for (this.mst = [], this.visit(e, 0); !this.pq.isEmpty();) {
                var r = this.pq.minKey(),
                    i = this.pq.delMin();
                this.mst.push(r), this.marked[i] || this.visit(e, i)
            }
        }
        b.prototype.visit = function (e, t) {
            this.marked[t] = !0;
            for (var n = e.adj(t), r = 0; r < n.length; ++r) {
                var i = n[r],
                    a = i.other(t);
                this.marked[a] || (this.pq.containsIndex(a) ? this.pq.decreaseKey(a, i) : this.pq.insert(a, i))
            }
        }, c.EagerPrimMST = b;

        function w(e, t) {
            var n = e.V;
            this.s = t, this.marked = [], this.edgeTo = [], this.cost = [], this.pq = new c.IndexMinPQ(n, function (e, t) {
                return t
            });
            for (var r = 0; r < n; ++r) this.marked.push(!1), this.edgeTo.push(null), this.cost.push(Number.MAX_VALUE);
            for (this.cost[t] = 0, this.pq.insert(t, this.cost[t]); !this.pq.isEmpty();) {
                r = this.pq.delMin();
                this.marked[r] = !0;
                for (var i = e.adj(r), a = 0; a < i.length; ++a) {
                    var o = i[a];
                    this.relax(o)
                }
            }
        }
        w.prototype.relax = function (e) {
            var t = e.from(),
                n = e.to();
            this.cost[n] > this.cost[t] + e.weight && (this.cost[n] = this.cost[t] + e.weight, this.edgeTo[n] = e, this.pq.containsIndex(n) ? this.pq.decreaseKey(n, this.cost[n]) : this.pq.insert(n, this.cost[n]))
        }, w.prototype.hasPathTo = function (e) {
            return this.marked[e]
        }, w.prototype.pathTo = function (e) {
            for (var t = new c.Stack, n = e; n != this.s; n = this.edgeTo[n].from()) t.push(this.edgeTo[n]);
            return t.toArray()
        }, w.prototype.distanceTo = function (e) {
            return this.cost[e]
        }, c.Dijkstra = w;

        function M(e, t) {
            var n = e.V;
            this.s = t, this.marked = [], this.edgeTo = [], this.cost = [];
            for (var r = 0; r < n; ++r) this.marked.push(!1), this.edgeTo.push(null), this.cost.push(Number.MAX_VALUE);
            this.cost[t] = 0, this.marked[t] = !0;
            for (var i = 0; i < n; ++i)
                for (r = 0; r < n; ++r)
                    for (var a = e.adj(r), o = 0; o < a.length; ++o) {
                        var s = a[o];
                        this.relax(s)
                    }
        }
        M.prototype.relax = function (e) {
            var t = e.from(),
                n = e.to();
            this.cost[n] > this.cost[t] + e.weight && (this.cost[n] = this.cost[t] + e.weight, this.marked[n] = !0, this.edgeTo[n] = e)
        }, M.prototype.hasPathTo = function (e) {
            return this.marked[e]
        }, M.prototype.pathTo = function (e) {
            for (var t = new c.Stack, n = e; n != this.s; n = this.edgeTo[n].from()) t.push(this.edgeTo[n]);
            return t.toArray()
        }, M.prototype.distanceTo = function (e) {
            return this.cost[e]
        }, c.BellmanFord = M;

        function A(e, t) {
            var n = e.V;
            this.s = t, this.marked = [], this.edgeTo = [], this.cost = [];
            for (var r = 0; r < n; ++r) this.marked.push(!1), this.edgeTo.push(null), this.cost.push(Number.MAX_VALUE);
            this.cost[t] = 0, this.marked[t] = !0;
            for (var i = new c.TopologicalSort(e.toDiGraph()).order(), a = 0; a < i.length; ++a) {
                r = i[a];
                for (var o = e.adj(r), s = 0; s < o.length; ++s) {
                    var l = o[s];
                    this.relax(l)
                }
            }
        }
        A.prototype.relax = function (e) {
            var t = e.from(),
                n = e.to();
            this.cost[n] > this.cost[t] + e.weight && (this.cost[n] = this.cost[t] + e.weight, this.marked[n] = !0, this.edgeTo[n] = e)
        }, A.prototype.hasPathTo = function (e) {
            return this.marked[e]
        }, A.prototype.pathTo = function (e) {
            for (var t = new c.Stack, n = e; n != this.s; n = this.edgeTo[n].from()) t.push(this.edgeTo[n]);
            return t.toArray()
        }, A.prototype.distanceTo = function (e) {
            return this.cost[e]
        }, c.TopologicalSortShortestPaths = A;

        function S(e, t, n) {
            this.value = 0, e.V;
            var r = Number.MAX_VALUE;
            for (this.marked = null, this.edgeTo = null, this.s = t, this.t = n; this.hasAugmentedPath(e);) {
                for (var i = this.t; i != this.s; i = this.edgeTo[i].from()) r = Math.min(r, this.edgeTo[i].residualCapacityTo(i));
                for (i = this.t; i != this.s; i = this.edgeTo[i].from()) this.edgeTo[i].addResidualFlowTo(i, r);
                this.value += r
            }
        }
        S.prototype.hasAugmentedPath = function (e) {
            var t = e.V;
            this.marked = [], this.edgeTo = [];
            for (var n = 0; n < t; ++n) this.marked.push(!1), this.edgeTo.push(null);
            var r = new c.Queue;
            for (r.enqueue(this.s), this.marked[this.s] = !0; !r.isEmpty();) {
                n = r.dequeue();
                for (var i = e.adj(n), a = 0; a < i.length; ++a) {
                    var o = i[a],
                        s = o.other(n);
                    if (!this.marked[s] && 0 < o.residualCapacityTo(s)) {
                        if (this.edgeTo[s] = o, this.marked[s] = !0, s == this.t) return !0;
                        r.enqueue(s)
                    }
                }
            }
            return !1
        }, S.prototype.minCut = function (e) {
            for (var t = [], n = e.V, r = 0; r < n; ++r)
                for (var i = e.adj(r), a = 0; a < i.length; ++a) {
                    var o = i[a];
                    o.from() == r && 0 == o.residualCapacityTo(o.other(r)) && t.push(o)
                }
            return t
        }, c.FordFulkerson = S
    }(Dc);
    var Ic = [
            [-1.117001, -.1867262, -11.13505, 12.59865, -.03937339, 1.167571, .007100686, 3.592678, .6083296, -1.152006, -.1926669, 6.152049, -4.770802, -.08704701, .7483626, .03372718, 4.464592, .4036546, -1.072371, -.2696632, .2816168, 1.820571, -.3742666, 2.080607, -.07675295, -2.835366, 1.129329, -1.109935, -.1532764, 1.198787, -.9015183, .005173015, .5749178, .1075633, 4.387949, .2650413, -1.052297, -.2229452, 1.952347, .5727205, -4.88507, 1.984016, -.1106197, -.4898361, .8907873, -1.070108, -.1600465, 1.593886, -4479251e-11, -3.306541, .9390193, .09513168, 2.343583, .5335404, -1.113253, -.16996, -10.38822, 11.37513, -.04040911, 1.037455, .04991792, 4.801919, .630271, -1.135747, -.1678594, 4.970755, -4.43023, -.06657408, .3636161, .1558009, 6.01337, .3959601, -1.095892, -.2732595, .7666496, 1.350731, -.4401401, 2.470135, -.1707929, -3.260793, 1.170337, -1.073668, -.02603929, -.1944589, .4575207, .6878164, -.139077, .3690299, 7.885781, .1877694, -1.070091, -.2798957, 2.338478, -2.647221, -7.387808, 2.32921, -.1644639, -2.00371, .9874527, -1.06712, -.1418866, 1.25409, 6.053048, -2.918892, .5322812, .1613053, 3.018161, .527409, -1.129483, -.1890619, -9.065101, 9.659923, -.03607819, .8314359, .08181661, 4.768868, .6339777, -1.14642, -.1883579, 3.309173, -3.127882, -.06938176, .3987113, .1400581, 6.283042, .5267076, -1.128348, -.2641305, 1.223176, .05514952, -.3490649, 1.997784, -.04123709, -2.251251, .9483466, -1.02582, .0140469, -1.187406, 2.7299, .5877588, -.276114, .4602633, 8.305125, .3945001, -1.083957, -.2606679, 2.207108, -7.202803, -5.968103, 2.129455, -.07789512, -1.137688, .8871769, -1.062465, -.1512189, 1.042881, 14.27839, -4.242214, .40381, .199778, 2.814449, .5803196, -1.175099, -.2410789, -11.08587, 11.33404, -.018193, .6772942, .09605043, 4.231166, .6239972, -1.224207, -.2883527, 3.002206, -2.649612, -.04795418, .4984398, .03251434, 4.851611, .6551019, -1.136955, -.2423048, 1.058823, -.2489236, -.2462179, 1.93314, .09106828, -.1905869, .8171065, -1.014535, -.0082625, -1.448017, 2.295788, .3510334, -1.477418, .5432449, 5.762796, .4908751, -1.070666, -.237978, 1.844589, -5.442448, -4.012768, 2.945275, .009854725, .08455959, .814503, -1.071525, -.1777132, .807659, 9.925865, -3.324623, -.6367437, .2844581, 2.248384, .6544022, -1.218818, -.2952382, -13.45975, 13.47153, -.006814585, .5079068, .119723, 3.776949, .5836961, -1.409868, -.511433, 2.776539, -2.039001, -.02673769, .4145288, .0007829342, 2.275883, .6629691, -1.069151, -.09434247, .7293972, -1.222473, -.1533461, 2.160357, .04626837, 3.852415, .859357, -1.021306, -.1149551, -1.108414, 4.178343, .4013665, -2.222814, .6929462, 1.392652, .4401662, -1.074251, -.2224002, 1.372356, -8.858704, -3.92266, 3.020018, -.01458724, 1.511186, .8288064, -1.062048, -.1526582, .4921067, 14.85522, -3.229936, -.8426604, .3916243, 2.678994, .6689264, -1.257023, -.33647, -15.27795, 15.04223, .002717715, .302991, .1636851, 3.561663, .5283161, -1.635124, -.7329993, 3.523939, -2.566337, -.01902543, .5505483, -.06242176, 1.065992, .6654236, -.9295823, .04845834, -.299299, -.2001327, -.08019339, 1.807806, .09020277, 5.095372, .8639936, -1.09374, -.2148608, -.521624, 2.119777, .09506454, -1.831439, .6961204, .1102084, .4384319, -1.044181, -.1849257, .9071246, -4.648901, -2.279385, 2.356502, -.04169147, 1.932557, .829655, -1.061451, -.1458745, .2952267, 8.967214, -3.726228, -.5022316, .5684877, 3.102347, .6658443, -1.332391, -.4127769, -9.328643, 9.046194, .003457775, .3377425, .1530909, 3.301209, .4997917, -1.932002, -.9947777, -2.042329, 3.58694, -.05642182, .8130478, -.08195988, .1118294, .5617231, -.8707374, .1286999, 1.820054, -4.674706, .003317471, .5919018, .1975278, 6.686519, .9631727, -1.070378, -.3030579, -.9041938, 6.200201, .1232207, -.3650628, .5029403, -2.903162, .3811408, -1.063035, -.1637545, .5853072, -7.889906, -1.200641, 1.035018, .1192093, 3.267054, .8416151, -1.053655, -.1562286, .2423683, 11.28575, -4.363262, -.0731416, .5642088, 2.514023, .6670457, -1.366112, -.4718287, -7.876222, 7.7469, -.009182309, .4716076, .08320252, 3.165603, .5392334, -2.468204, -1.33634, -5.386723, 7.072672, -.08329266, .8636876, -.01978177, -.1326218, .2979222, -.9653522, -.02373416, 1.81025, -6.467262, .1410706, -.4753717, .3003095, 6.551163, 1.151083, -.8943186, -.2487152, -.230896, 8.512648, .1298402, 1.034705, .2303509, -3.924095, .2982717, -1.146999, -.2318784, .08992419, -9.933614, -.886092, -.03071656, .2852012, 3.046199, .8599001, -1.032399, -.1645145, .2683599, 13.27701, -4.40767, .07709869, .4951727, 1.957277, .6630943, -1.46907, -.6135092, -6.506263, 6.661315, -.03835383, .7150413, .007784318, 2.820577, .6756784, -2.501583, -1.247404, -15.23462, 16.33191, -.01204803, .5896471, -.02002023, 1.144647, .06177874, -2.438672, -1.127291, 5.731172, -10.2135, .0616561, -.7752641, .4708254, 4.176847, 1.200881, -.1513427, .09792731, -1.612349, 9.814289, .05188921, 1.716403, -.07039255, -2.815115, .3291874, -1.318511, -.3650554, .4221268, -9.294529, -.0439752, -.8100625, .3742719, 1.834166, .822345, -1.016009, -.1820264, .1278426, 11.82696, -4.801528, .4947899, .4660378, 1.601254, .6702359, -1.84131, -.9781779, -4.610903, 4.824662, -.05100806, .6463776, -6377724e-12, 2.216875, .861853, -2.376373, -1.108657, -14.89799, 15.46458, .04091025, .0976178, -.01048958, 2.165834, -.1609171, -4.710318, -2.261963, 6.947327, -10.34828, -.1325542, .7508674, .2247553, 2.873142, 1.2971, .216375, -.1944345, -2.43786, 10.11314, .44505, .3111492, .2751323, -1.627906, .2531213, -1.258794, -.3524641, .8425444, -10.85313, -1.154381, -.4638014, -.002781115, .4344498, .8507091, -1.018938, -.1804153, -.06354054, 15.7315, -4.386999, .6211115, .5294648, 1.580749, .6586655, -1.116416, -.1917524, -10.68233, 12.22221, -.03668978, 1.054022, .01592132, 3.180583, .562737, -1.132341, -.1671286, 5.976499, -4.227366, -.09542489, .8664938, .008351793, 4.876068, .4492779, -1.087635, -.3173679, .4314407, 1.100555, -.4410057, 1.677253, -.03005925, -4.201249, 1.070902, -1.083031, -.08847705, 1.291773, .4546776, .3091894, .726176, .04203659, 5.990615, .3704756, -1.057899, -.2246706, 2.329563, -1.219656, -5.33526, .8545378, -.03906209, -.9025499, .7797348, -1.073305, -.1522553, 1.767063, 1.90428, -3.101673, .3995856, .02905192, 2.563977, .5753067, -1.113674, -.1759694, -9.754125, 10.87391, -.03841093, .9524272, .05680219, 4.227034, .6029571, -1.126496, -.1680281, 5.332352, -4.575579, -.06761755, .3295335, .1194896, 5.570901, .4536185, -1.103074, -.2681801, .06571479, 2.396522, -.455128, 2.466331, -.1232022, -3.023201, 1.086379, -1.053299, -.02697173, .8379121, -.9681458, .5890692, -.4872027, .2936929, 7.510139, .3079122, -1.079553, -.2710448, 2.462379, -.3713554, -8.534512, 1.828242, -.1686398, -1.96134, .8941077, -1.069741, -.1396394, 1.657868, 3.236313, -2.706344, -.2948122, .1314816, 2.868457, .5413403, -1.131649, -.1954455, -7.751595, 8.685861, -.04910871, .8992952, .04710143, 4.254818, .6821116, -1.156689, -.1884324, 3.163519, -3.091522, -.06613927, -.02575883, .1640065, 6.073643, .4453468, -1.079224, -.2621389, .9446437, 1.448479, -.3969384, 2.626638, -.08101186, -3.016355, 1.076295, -1.080832, .01033057, -.3500156, -.03281419, .5655512, -1.156742, .453471, 8.774122, .2772869, -1.051202, -.2679975, 2.719109, -2.190316, -6.878798, 2.250481, -.2030252, -2.026527, .9701096, -1.089849, -.1598589, 1.564748, 6.869187, -3.05367, -.6110435, .1644472, 2.370452, .551177, -1.171419, -.2429746, -8.991334, 9.571216, -.02772861, .6688262, .07683478, 3.785611, .6347635, -1.228554, -.2917562, 2.753986, -2.49178, -.04663434, .3118303, .07546506, 4.463096, .5955071, -1.093124, -.2447767, .9097406, .5448296, -.2957824, 2.024167, -.0005152333, -1.069081, .9369565, -1.056994, .01569507, -.8217491, 1.870818, .706193, -1.483928, .5978206, 6.864902, .3673332, -1.054871, -.2758129, 2.712807, -5.95011, -6.554039, 2.447523, -.1895171, -1.454292, .9131738, -1.100218, -.1746241, 1.438505, 11.15481, -3.266076, -.8837357, .19701, 1.991595, .5907821, -1.207267, -.291361, -11.03767, 11.40724, -.014168, .5564047, .08476262, 3.371255, .6221335, -1.429698, -.5374218, 2.837524, -2.221936, -.02422337, .09313758, .0719025, 1.869022, .5609035, -1.002274, -.0697281, .4031308, -.3932997, -.1521923, 2.390646, -.0689399, 2.999661, 1.017843, -1.081168, -.1178666, -.496808, 3.919299, .6046866, -2.440615, .7891538, 2.140835, .274047, -1.050727, -.2307688, 2.276396, -9.454407, -5.505176, 2.99262, -.2450942, .6078372, .9606765, -1.103752, -.1810202, 1.375044, 15.89095, -3.438954, -1.265669, .2475172, 1.680768, .5978056, -1.244324, -.3378542, -11.11001, 11.37784, -.007896794, .4808023, .09249904, 3.025816, .5880239, -1.593165, -.7027621, 2.220896, -1.437709, -.01534738, .06286958, .06644555, 1.091727, .547008, -.9136506, .01344874, .7772636, -1.209396, -.1408978, 2.433718, -.1041938, 3.791244, 1.037916, -1.134968, -.1803315, -.9267335, 4.57667, .6851928, -2.805, .8687208, 1.161483, .2571688, -1.017037, -.2053943, 2.36164, -9.887818, -5.122889, 3.287088, -.2594102, .8578927, .959234, -1.118723, -.1934942, 1.226023, 16.7414, -3.277335, -1.629809, .2765232, 1.637713, .6113963, -1.314779, -.4119915, -12.4115, 12.41578, .002344284, .2980837, .1414613, 2.781731, .4998556, -1.926199, -1.020038, 2.5692, -1.081159, -.02266833, .3588668, .008750078, -.2452171, .4796758, -.7780002, .1850647, .04445456, -2.409297, -.07816346, 1.54679, -.02807227, 5.998176, 1.132396, -1.179326, -.357833, -.2392933, 6.467883, .5904596, -1.869975, .8045839, -2.498121, .1610633, -1.009956, -.1311896, 1.726577, -12.19356, -3.466239, 2.343602, -.2252205, 2.573681, 1.027109, -1.11246, -.2063093, 1.233051, 20.58946, -4.578074, -1.145643, .3160192, 1.420159, .5860212, -1.371689, -.4914196, -10.7661, 11.07405, -.01485077, .5936218, .03685482, 2.599968, .6002204, -2.436997, -1.377939, .02130141, 1.079593, -.01796232, -.03933248, .1610711, -.6901181, .1206416, -.8743368, .0733137, .8734259, -3.743126, -.03151167, 1.297596, -.07634926, 6.532873, 1.435737, -.9810197, -.3521634, -.2855205, 7.134674, .6839748, -1.394841, .6952036, -4.633104, -.02173401, -1.122958, -.1691536, 1.38236, -11.02913, -2.608171, 1.865111, -.1345154, 3.112342, 1.094134, -1.075586, -.2077415, 1.171477, 17.9327, -4.656858, -1.036839, .3338295, 1.042793, .5739374, -1.465871, -.6364486, -8.833718, 9.34365, -.032236, .7552848, -3121341e-12, 2.249164, .8094662, -2.448924, -1.270878, -4.823703, 5.853058, -.02149127, .03581132, -.001230276, .4892553, -.1597657, -2.419809, -1.071337, 1.575648, -4.98358, .009545185, .5032615, .4186266, 4.634147, 1.433517, -.1383278, -.02797095, -.1943067, 6.679623, .411828, -.2744289, -.02118722, -4.337025, .1505072, -1.341872, -.2518572, 1.027009, -6.527103, -1.081271, 1.015465, .2845789, 2.470371, .927812, -1.04064, -.2367454, 1.100744, 8.827253, -4.560794, -.7287017, .2842503, .6336593, .6327335, -1.877993, -1.025135, -4.311037, 4.715016, -.04711631, .6335844, -7665398e-12, 1.788017, .9001409, -2.28154, -1.137668, -10.36869, 11.36254, .01961739, -.09836174, -.006734567, 1.320918, -.2400807, -4.904054, -2.315781, 5.735999, -8.626257, -.1255643, 1.545446, .139686, 2.972897, 1.429934, .4077067, -.1833688, -2.450939, 9.119433, .4505361, -1.340828, .397369, -1.78537, .09628711, -1.296052, -.3250526, 1.813294, -10.31485, -1.38869, 1.239733, -.08989196, -.3389637, .963956, -1.062181, -.2423444, .7577592, 15.66938, -4.462264, -.574281, .3262259, .9461672, .6232887],
            [-1.127942, -.1905548, -12.52356, 13.75799, -.03624732, 1.055453, .01385036, 4.17697, .5928345, -1.15526, -.1778135, 6.216056, -5.254116, -.08787445, .8434621, .04025734, 6.195322, .3111856, -1.125624, -.3217593, .5043919, 1.686284, -.3536071, 1.476321, -.07899019, -4.522531, 1.271691, -1.081801, -.1033234, .999555, .007482946, -.06776018, 1.463141, .09492021, 5.612723, .1298846, -1.07532, -.2402711, 2.141284, -1.203359, -4.945188, 1.437221, -.0809675, -1.028378, 1.004164, -1.073337, -.1516517, 1.639379, 2.304669, -3.214244, 1.286245, .05613957, 2.480902, .4999363, -1.128399, -.1857793, -10.89863, 11.72984, -.03768099, .9439285, .04869335, 4.845114, .6119211, -1.114002, -.139928, 4.9638, -4.6855, -.07780879, .4049736, .1586297, 7.770264, .3449006, -1.185472, -.3403543, .6588322, 1.133713, -.4118674, 2.061191, -.1882768, -4.372586, 1.22353, -1.002272, .02000703, .07073269, 1.485075, .5005589, .4301494, .3626541, 7.921098, .1574766, -1.121006, -.3007777, 2.242051, -4.571561, -7.761071, 2.053404, -.1524018, -1.886162, 1.018208, -1.058864, -.1358673, 1.389667, 8.633409, -3.437249, .7295429, .15147, 2.842513, .5014325, -1.144464, -.2043799, -10.20188, 10.71247, -.03256693, .7860205, .06872719, 4.824771, .6259836, -1.170104, -.2118626, 4.391405, -4.1989, -.07111559, .3890442, .1024831, 6.282535, .5365688, -1.129171, -.255288, .2238298, .7314295, -.356273, 1.881931, -.03078716, -1.03912, .9096301, -1.042294, .004450203, -.5116033, 2.627589, .6098996, -.1264638, .4325281, 7.080503, .4583646, -1.082293, -.2723056, 2.065076, -8.143133, -7.892212, 2.142231, -.0710624, -1.122398, .8338505, -1.071715, -.1426568, 1.095351, 17.29783, -3.851931, .4360514, .211444, 2.970832, .5944389, -1.195909, -.2590449, -11.91037, 12.07947, -.01589842, .6297846, .09054772, 4.285959, .5933752, -1.245763, -.3316637, 4.29366, -3.694011, -.04699947, .4843684, .02130425, 4.097549, .6530809, -1.148742, -.1902509, -.2393233, -.2441254, -.2610918, 1.846988, .03532866, 2.660106, .8358294, -1.01608, -.0744496, -.5053436, 4.388855, .6054987, -1.2083, .5817215, 2.54357, .4726568, -1.072027, -.210144, 1.518378, -10.60119, -6.016546, 2.649475, -.05166992, 1.571269, .8344622, -1.072365, -.1511201, .747801, 19.00732, -3.950387, -.3473907, .3797211, 2.782949, .6296808, -1.239423, -.3136289, -13.511, 13.49468, -.007070423, .5012315, .1106008, 3.803619, .5577948, -1.452524, -.5676944, 2.993153, -2.277288, -.02168954, .305672, .01152338, 1.852697, .6427228, -1.061421, -.04590521, .6057022, -1.096835, -.1504952, 2.344921, -.05491832, 5.268322, .9082253, -1.042373, -.1769498, -1.075388, 3.831712, .315414, -2.416458, .7909032, -.01492892, .3854049, -1.064159, -.1892684, 1.438685, -8.166362, -3.616364, 3.275206, -.1203825, 2.039491, .8688057, -1.07012, -.1569508, .412476, 13.99683, -3.547085, -1.046326, .4973825, 2.791231, .6503286, -1.283579, -.3609518, -13.35397, 13.15248, -.0004431938, .3769526, .1429824, 3.573613, .4998696, -1.657952, -.7627948, 1.958222, -.7949816, -.02882837, .5356149, -.05191946, .8869955, .626332, -.95276, .06494189, .5361303, -2.12959, -.0925863, 1.604776, .0506777, 6.376055, .9138052, -1.080827, -.252312, -.7154262, 4.120085, .1878228, -1.492158, .6881655, -1.446611, .4040631, -1.054075, -.1665498, .9191052, -6.636943, -1.894826, 2.10781, -.03680499, 2.655452, .841384, -1.061127, -.1448849, .2667493, 10.34103, -4.285769, -.3874504, .5998752, 3.132426, .6652753, -1.347345, -.4287832, -9.305553, 9.133813, -.003173527, .3977564, .115142, 3.320564, .4998134, -1.927296, -.9901372, -2.593499, 4.087421, -.05833993, .8158929, -.04681279, .2423716, .4938052, -.9470092, .07325237, 2.064735, -5.16754, -.01313751, .4832169, .1126295, 6.970522, 1.035022, -1.022557, -.2762616, -.9375748, 6.696739, .2200765, -.1133253, .5492505, -3.109391, .3321914, -1.087444, -.1836263, .6225024, -8.576765, -1.107637, .7859427, .09910909, 3.112938, .8596261, -1.051544, -.1546262, .2371731, 12.00502, -4.527291, .07268862, .5571478, 2.532873, .6662, -1.375576, -.4840019, -8.12129, 8.05814, -.01445661, .5123314, .05813321, 3.203219, .5442318, -2.325221, -1.241463, -7.06343, 8.741369, -.0782995, .8844273, -.03471106, .1740583, .2814079, -1.2287, -.2013412, 2.949042, -7.371945, .1071753, -.249197, .2265223, 6.391504, 1.172389, -.7601786, -.1680631, -.7584444, 8.541356, .08222291, .6729633, .3206615, -3.70094, .2710054, -1.191166, -.2672347, .2927498, -9.713613, -.4783721, .2352803, .2161949, 2.691481, .8745447, -1.030135, -.1653301, .2263443, 12.96157, -4.650644, .007055709, .5091975, 2.00037, .6603839, -1.508018, -.6460933, -6.402745, 6.545995, -.0375032, .6921803, .003309819, 2.797527, .6978446, -2.333308, -1.167837, -17.46787, 18.6863, -.008948229, .5621946, -.03402626, 1.217943, .01149865, -2.665953, -1.226307, 7.169725, -11.59434, .0358342, -.3074378, .3412248, 4.422122, 1.283791, -.09705116, .08312991, -2.160462, 10.28235, .03543357, 1.032049, .105831, -2.972898, .2418628, -1.329617, -.3699557, .5560117, -9.730113, .09938865, -.3071488, .2510691, 1.777111, .8705142, -1.019387, -.1893247, .1194079, 12.39436, -4.799224, .2940213, .4841268, 1.529724, .6582615, -1.896737, -1.005442, -6.411032, 6.54822, -.03227596, .5717262, -8115192e-12, 2.296704, .9000749, -2.411116, -1.225587, -17.53629, 18.29393, .01247555, .2364616, -.005114637, 1.603778, -.2224156, -4.707121, -2.074977, 7.9423, -11.32407, -.05415654, .5446811, .1032493, 4.010235, 1.369802, .1010482, -.4013305, -2.674579, 9.779409, .1782506, .7053045, .4200002, -2.400671, .1953165, -1.243526, -.3391255, .8848882, -9.789025, -.3997324, -.9546227, -.1044017, .6010593, .8714462, -1.014633, -.1730009, -.07738934, 13.90903, -4.847307, 1.076059, .5685743, 1.572992, .6561432, -1.122998, -.1881183, -10.30709, 11.58932, -.04079495, .9603774, .03079436, 4.009235, .5060745, -1.13479, -.1539688, 5.478405, -4.21727, -.1043858, .7165008, .01524765, 6.473623, .4207882, -1.134957, -.3513318, .7393837, 1.354415, -.4764078, 1.690441, -.0549264, -5.563523, 1.145743, -1.058344, -.05758503, 1.16823, .3269824, .1795193, .7849011, .07441853, 6.904804, .281879, -1.075194, -.2355813, 2.463685, -1.536505, -7.505771, .9619712, -.06465851, -1.355492, .8489847, -1.07903, -.1465328, 1.773838, 2.310131, -3.136065, .3507952, .04435014, 2.819225, .5689008, -1.125833, -.1870849, -9.555833, 10.59713, -.04225402, .9164663, .04338796, 4.40098, .6056119, -1.12744, -.1551891, 4.755621, -4.408806, -.07851763, .2268284, .146007, 7.048003, .3525997, -1.143788, -.3170178, .5480669, 2.04183, -.4532139, 2.302233, -.1887419, -4.489221, 1.250967, -1.032849, .007376031, .5666073, -.2312203, .4862894, -.1748294, .357287, 8.380522, .1302333, -1.093728, -.2786977, 2.641272, -1.507494, -8.731243, 1.684055, -.2023377, -2.176398, 1.013249, -1.076578, -.1456205, 1.693935, 2.945003, -2.822673, -.2520033, .1517034, 2.649109, .5179094, -1.146417, -.2119353, -7.187525, 8.058599, -.05256438, .8375733, .03887093, 4.222111, .6695347, -1.173674, -.2067025, 2.899359, -2.804918, -.08473899, .003944225, .1340641, 6.160887, .4527141, -1.090098, -.2599633, .9180856, 1.09271, -.4215019, 2.42766, -.09277667, -2.123523, 1.058159, -1.08446, .008056181, -.245351, .6619567, .4668118, -.9526719, .4648454, 8.001572, .3054194, -1.053728, -.2765784, 2.792388, -3.489517, -8.150535, 2.195757, -.2017234, -2.128017, .9326589, -1.099348, -.1593939, 1.568292, 7.247853, -2.933, -.5890481, .172444, 2.433484, .5736558, -1.185983, -.2581184, -7.761056, 8.317053, -.03351773, .6676667, .05941733, 3.820727, .6324032, -1.268591, -.3398067, 2.348503, -2.023779, -.05368458, .1083282, .08402858, 3.910254, .5577481, -1.071353, -.1992459, .7878387, .1974702, -.3033058, 2.335298, -.08205259, .7954454, .9972312, -1.089513, -.03104364, -.5995746, 2.330281, .6581939, -1.821467, .6679973, 5.090195, .3125161, -1.040214, -.2570934, 2.660489, -6.506045, -7.053586, 2.763153, -.2433632, -.7648176, .9452937, -1.116052, -.1831993, 1.457694, 11.63608, -3.216426, -1.045594, .2285002, 1.817407, .5810396, -1.230134, -.3136264, -8.909301, 9.145006, -.01055387, .4467317, .1016826, 3.342964, .563384, -1.442907, -.5593147, 2.156447, -1.241657, -.0351213, .3050274, .01797175, 1.742358, .5977153, -1.027627, -.06481539, .4351975, -1.051677, -.2030672, 1.942684, -.03615993, 4.050266, .9801624, -1.08211, -.1578209, -.3397511, 4.163851, .6650368, -1.84173, .7062544, .6789881, .3172623, -1.047447, -.197756, 2.183364, -8.805249, -5.483962, 2.551309, -.177964, 1.519501, .9212536, -1.111853, -.1935736, 1.394408, 13.92405, -3.46543, -1.068432, .2388671, 1.455336, .6233425, -1.262238, -.3546341, -10.08703, 10.20084, -.001852187, .353758, .1239199, 3.056093, .5132052, -1.61381, -.7355585, 2.760123, -1.685253, -.02517552, .2914258, .004743448, .8689596, .5674192, -.9462336, .02950767, -.2613816, -.7398653, -.1315558, 1.901042, -.06447844, 4.969341, 1.027342, -1.111481, -.2194054, -.09004538, 3.983442, .4871278, -1.965315, .7956121, -.2363225, .2718037, -1.036397, -.1827106, 1.964747, -8.870759, -4.208011, 2.461215, -.2158905, 1.561676, .9436866, -1.113769, -.1947819, 1.30072, 15.16476, -4.088732, -1.069384, .2836434, 1.671451, .6229612, -1.328069, -.4244047, -8.41704, 8.552244, -.006813504, .4127422, .09619897, 2.854227, .505988, -1.927552, -1.02529, .9529576, .425595, -.03738779, .2584586, .04911004, -.2640913, .4138626, -.8488094, .1435988, .6356807, -2.895732, -.08473961, 1.701305, -.1323908, 6.499338, 1.210928, -1.128313, -.3397048, -.404314, 6.265097, .5482395, -2.057614, .8884087, -2.943879, .09760301, -1.039764, -.1494772, 1.781915, -11.53012, -3.379232, 2.517231, -.2764393, 2.588849, 1.05212, -1.108447, -.2012251, 1.19864, 19.25331, -4.423892, -1.257122, .339569, 1.48122, .5880175, -1.374185, -.4967434, -7.401318, 7.724021, -.02345723, .5979653, .02436346, 2.65897, .6014891, -2.310933, -1.29029, -1.301909, 2.557806, -.03744449, .08982861, .1090613, -.4398363, .1184329, -1.12473, -.0992183, 1.366902, -4.172489, -.05078016, 1.393597, -.09323843, 6.452721, 1.435913, -.8468477, -.2744819, -.43472, 6.713362, .6127133, -1.685634, .7360941, -4.535502, -.02920866, -1.165242, -.2008697, 1.438778, -10.08936, -2.214771, 2.102909, -.1763085, 2.859075, 1.09347, -1.074614, -.2066374, 1.131891, 16.30063, -4.801441, -1.11259, .3595785, 1.122227, .579461, -1.521515, -.6835604, -5.571044, 6.028774, -.04253715, .6875746, -5279456e-12, 2.18015, .8487705, -2.240415, -1.171166, -7.182771, 8.417068, -.01932866, .1101887, -.01098862, .6242195, -.2393875, -2.712354, -1.19883, 3.1802, -6.76813, -.002563386, .7984607, .2764376, 4.695358, 1.557045, -.03655172, -.02142321, -.913812, 7.932786, .3516542, -.7994343, .1786761, -4.208399, .01820576, -1.36861, -.2656212, 1.249397, -8.317818, -.8962772, 1.423249, .1478381, 2.19166, 1.007748, -1.041753, -.2453366, 1.061102, 11.30172, -4.739312, -.9223334, .2982776, .6162931, .6080302, -1.989159, -1.09516, -2.91555, 3.275339, -.05735765, .5742174, -7683288e-12, 1.7634, .9001342, -2.07002, -1.086338, -10.95898, 12.0696, .03780123, -.01774699, -.0005881348, 1.333819, -.2605423, -5.249653, -2.38304, 6.160406, -9.097138, -.1955319, 1.651785, .0006016463, 3.021824, 1.493574, .4685432, -.2358662, -2.666433, 9.685763, .5804928, -1.521875, .5668989, -1.548136, .01688642, -1.296891, -.3449031, 1.928548, -11.6756, -1.627615, 1.355603, -.1929074, -.6568952, 1.009774, -1.067288, -.2410392, .7147961, 17.8384, -4.374399, -.6588777, .3329831, 1.012066, .6118645],
            [-1.310023, -.4407658, -36.4034, 36.83292, -.008124762, .5297961, .01188633, 3.13832, .5134778, -1.4241, -.5501606, -17.5351, 18.22769, -.01539272, .6366826, .002661996, 2.659915, .4071138, -1.103436, -.1884105, 6.425322, -6.910579, -.02019861, .3553271, -.01589061, 5.345985, .8790218, -1.1862, -.4307514, -3.957947, 5.979352, -.05348869, 1.736117, .03491346, -2.692261, .5610506, -1.006038, -.1305995, 4.473513, -3.806719, .1419407, -.02148238, -.05081185, 3.735362, .535828, -1.078507, -.1633754, -3.812368, 4.3817, .02988122, 1.754224, .1472376, 3.722798, .4999157, -1.333582, -.4649908, -33.59528, 34.04375, -.009384242, .5587511, .00572631, 3.073145, .5425529, -1.562624, -.7107068, -14.7817, 15.59839, -.01462375, .5050133, .02516017, 1.604696, .2902403, -.8930158, .04068077, 1.373481, -2.342752, -.02098058, .6248686, -.05258363, 7.058214, 1.150373, -1.262823, -.4818353, 889261e-9, 1.92312, -.04979718, 1.040693, .1558103, -2.85248, .2420691, -.9968383, -.1200648, 1.324342, -.9430889, .1931098, .4436916, -.07320456, 4.215931, .7898019, -1.078185, -.1718192, -1.720191, 2.358918, .02765637, 1.260245, .2021941, 3.395483, .5173628, -1.353023, -.4813523, -31.0492, 31.40156, -.009510741, .554203, .008135471, 3.136646, .5215989, -1.624704, -.7990201, -21.67125, 22.46341, -.01163533, .5415746, .02618378, 1.139214, .3444357, -.798361, .1417476, 9.914841, -10.81503, -.01218845, .3411392, -.06137698, 7.445848, 1.18008, -1.266679, -.4288977, -5.818701, 6.986437, -.08180711, 1.397403, .2016916, -1.275731, .2592773, -1.009707, -.1537754, 3.496378, -3.013726, .242115, -.2831925, .03003395, 3.702862, .774632, -1.075646, -.1768747, -1.347762, 1.989004, .01375836, 1.76481, .1330018, 3.230864, .662621, -1.375269, -.5103569, -34.42661, 34.78703, -.008460009, .5408643, .004813323, 3.016078, .5062069, -1.821679, -.9766461, -19.26488, 19.97912, -.009822567, .3649556, .04316092, .893019, .4166527, -.6633542, .1997841, 2.395592, -3.117175, -.01080884, .8983814, -.1375825, 6.673463, 1.115663, -1.30324, -.3612712, .08292959, .3381364, -.06078648, .3229247, .3680987, .7046755, .3144924, -.9952598, -.2039076, .4026851, .2686684, .1640712, .5186341, -.0120552, 2.659613, .8030394, -1.098579, -.2151992, .6558198, -74369e-8, -.001421817, 1.073701, .1886875, 2.536857, .6673923, -1.457986, -.5906842, -38.12464, 38.38539, -.006024357, .4741484, .01209223, 2.818432, .5012433, -1.835728, -1.003405, -6.848129, 7.601943, -.01277375, .4785598, .03366853, 1.097701, .4636635, -.8491348, .009466365, -2.685226, 2.00406, -.01168708, .6752316, -.1543371, 5.674759, 1.039534, -1.083379, -.150679, .7328236, -.5095568, -.08609153, .444882, .4174662, 1.481556, .3942551, -1.117089, -.3337605, .2502281, .4036323, .2673899, .2829817, .0224245, 2.043207, .7706902, -1.071648, -.21262, .6069466, -.00145629, -.551596, 1.046755, .1985021, 2.290245, .6876058, -1.483903, -.6309647, -43.80213, 44.10537, -.005712161, .5195992, .002028428, 2.687114, .5098321, -2.053976, -1.141473, .5109183, .08060391, -.01033983, .4066532, .04869627, 1.161722, .4039525, -.6348185, .07651292, -10.31327, 10.07598, -.02083688, .7359516, -.2029459, 5.013257, 1.077649, -1.22863, -.1650496, .04077157, -.7189167, -.0509222, .2959814, .5111496, 2.540433, .361533, -1.041883, -.3278413, -.06691911, 1.307364, .2166663, .3000595, -.003157136, 1.389208, .7999026, -1.103556, -.2443602, .4705347, -.0009296482, -.530992, .9654511, .2142587, 2.244723, .6839976, -1.555684, -.6962113, -46.47983, 46.7427, -.005034895, .475509, -9.502561e-7, 2.626569, .5056194, -1.998288, -1.12472, -1.629586, 2.187993, -.008284384, .3845258, .0572624, 1.185644, .4255812, -1.03257, -.251385, -3.721112, 3.506967, -.02186561, .9436049, -.2451412, 4.725724, 1.039256, -.8597532, .09073332, -2.553741, 1.993237, -.04390891, -.2046928, .5515623, 1.909127, .3948212, -1.210482, -.4477622, -.2267805, 1.219488, .1336186, .6866897, .02808997, 1.600403, .7816409, -1.078168, -.2699261, .2537282, .3820684, -.4425103, .5298235, .2185217, 1.728679, .6882743, -1.697968, -.8391488, -57.90105, 58.1412, -.00340476, .426514, -1796301e-12, 2.368442, .5324429, -2.141552, -1.17223, 16.77872, -16.4147, -.005732425, .2002199, .06841834, 1.485338, .3215763, -1.442946, -.7264245, -9.503706, 9.650462, -.02120995, 1.419263, -.2893098, 3.860731, 1.120857, -.5696752, .3411279, -.2931035, -.6512552, -.1068437, -1.085661, .6107549, 1.459503, .3210336, -1.313839, -.5921371, -.2332222, 1.648196, .2492787, 1.381033, -.01993392, .981256, .8316329, -1.087464, -.3195534, .2902095, .3383709, -.8798482, .01494668, .2529703, 1.452644, .669387, -2.068582, -1.118605, -50.81598, 50.97486, -.003280669, .4067371, -2544951e-12, 2.179497, .5778017, -1.744693, -.8537207, 22.34361, -22.08318, -.005932616, .1035049, .05742772, 1.97788, .2124846, -3.287515, -2.140268, -12.49566, 12.40091, -.02409349, 1.397821, -.2371627, 2.771192, 1.170496, .5502311, 1.04663, 2.193517, -2.2204, -.1064394, -1.017926, .4795457, 1.030644, .3177516, -1.719734, -.9536198, -.6586821, 1.386361, -.02513065, 1.187011, .06542539, .5296055, .808266, -1.0057, -.3028096, .04470957, 1.00776, -.8119016, .03153338, .2311321, 1.182208, .6824758, -2.728867, -1.580388, -30.79627, 30.92586, -.004197673, .3154759, -3897675e-12, 1.920567, .6664791, -1.322495, -.7249275, 14.7766, -14.68154, -.009044857, .05624314, .06498392, 2.047389, .0636754, -6.102376, -3.473018, -9.926071, 9.637797, -.01097909, 1.103498, -.2424521, 2.520748, 1.24026, 1.351796, 1.018588, 2.009081, -1.333394, -.1979125, -.3318292, .4476624, .9095235, .2955611, -1.774467, -1.07988, -.0808468, .2577697, -.1149295, .4975303, .002931611, -.3803171, .8002794, -.9898401, -.2542513, -.07530911, 1.870355, -1.521918, .2405164, .2964615, 1.3348, .6789053, -1.27973, -.4290674, -42.77972, 43.43305, -.006541826, .4945086, .01425338, 2.685244, .5011313, -1.449506, -.5766374, -16.88496, 17.81118, -.01121649, .354502, .02287338, 1.904281, .4936998, -1.02198, -.1897574, 2.482462, -2.941725, -.01570448, .7532578, -.042568, 5.23966, .4983116, -1.162608, -.3428049, 3.974358, -1.527935, -.03919201, .8758593, .07291363, -3.455257, .8007426, -.9929985, -.08712006, -.7397313, 1.348372, .09511685, .3233584, -.07549148, 5.806452, .4990042, -1.084996, -.1739767, .1580475, .908818, .06871433, .5933079, .1188921, 3.074079, .4999327, -1.317009, -.4661946, -42.55347, 43.12782, -.005727235, .4285447, .02189854, 2.60831, .51907, -1.469236, -.6282139, -12.41404, 13.48765, -.0120477, .5070285, -.0007280216, 1.491533, .3635064, -.9713808, -.08138038, .3709854, -1.041174, -.01814075, .506086, -.02053756, 6.161431, 1.093736, -1.159057, -.3698074, 2.711209, -.6006479, -.04896926, .9273957, .1137712, -3.496828, .2867109, -1.011601, -.0820189, .2105725, .459752, .1478925, .213894, -.0566067, 6.057755, .7859121, -1.07802, -.181158, .1646622, .8348426, .1149064, .4985738, .1376605, 2.746607, .4999626, -1.325672, -.4769313, -41.11215, 41.68293, -.006274997, .4649469, .01119411, 2.631267, .5234546, -1.619391, -.8000253, -15.34098, 16.32706, -.01012023, .4242255, .02931597, .8925807, .3314765, -.7356979, .1368406, 2.972579, -3.535359, -.01318948, .460762, -.07182778, 6.2541, 1.236299, -1.316217, -.4194427, .03489902, 1.289849, -.0475596, 1.138222, .1975992, -.8991542, .2290572, -.9502188, -.1172703, 1.405202, -.3061919, .1058772, -.3760592, -.01983179, 3.562353, .7895959, -1.100117, -.1900567, .492503, .5250225, .1576804, 1.042701, .07330743, 2.796064, .6749783, -1.354183, -.5130625, -42.19268, 42.71772, -.005365373, .4136743, .01235172, 2.520122, .5187269, -1.741434, -.9589761, -8.230339, 9.296799, -.009600162, .4994969, .02955452, .3667099, .3526999, -.6917347, .2154887, -.8760264, .2334121, -.01909621, .4748033, -.1138514, 6.51536, 1.225097, -1.293189, -.42187, 1.620952, -.7858597, -.0376941, .6636786, .3364945, -.5341017, .2128347, -.9735521, -.1325495, 1.007517, .2598258, .06762169, .001421018, -.06915987, 3.185897, .8641956, -1.0948, -.1962062, .5755591, .2906259, .2625748, .7644049, .1347492, 2.677126, .646546, -1.393063, -.5578338, -41.85249, 42.33504, -.00543564, .4743765, .007422477, 2.442801, .5211707, -1.939487, -1.128509, -8.974257, 9.978383, -.007965597, .294883, .04436763, .2839868, .3440424, -.6011562, .2354877, -3.07982, 2.585094, -.02002701, .7793909, -.1598414, 5.834678, 1.202856, -1.315676, -.3903446, 1.7019, -1.304609, -.01045121, .2747707, .4143967, .3197102, .263758, -.9618628, -.1625841, 1.187138, .1497802, -5590954e-12, .03178475, -.04153145, 2.496096, .8195082, -1.111554, -.2365546, .7831875, .2018684, .2074369, .7395978, .122573, 1.876478, .6821167, -1.427879, -.5994879, -35.31016, 35.81581, -.006431497, .4554192, .0007348731, 2.334619, .5233377, -1.998177, -1.206633, -21.4651, 22.42237, -.005857596, .2755663, .06384795, .1358244, .3328437, -.644063, .2058571, 2.155499, -2.587968, -.01840023, .8826555, -.2222452, 5.847073, 1.228387, -1.229071, -.3360441, -.3429599, .6179469, .00202961, .08899319, .5041624, .1882964, .225204, -1.022905, -.2101621, 1.915689, -.6498794, -.03463651, .08954605, -.06797854, 2.417705, .8568618, -1.082538, -.2007723, .4731009, .4077267, .1324289, .651488, .1702912, 2.309383, .6600895, -1.472139, -.6499815, -34.28465, 34.69659, -.005747023, .4174167, .001688597, 2.323046, .5395191, -2.161176, -1.353089, -22.26827, 23.29138, -.005583808, .2364793, .06096656, .001944666, .2861624, -.6593044, .1393558, 4.698373, -5.193883, -.0199839, 1.095635, -.2391254, 5.598103, 1.236193, -1.195717, -.2972715, .04648953, .3024588, .005003313, -.3754741, .5247265, -.1381312, .2493896, -1.020139, -.2253524, .3548437, .7030485, -.02107076, .4581395, -.03243757, 2.453259, .8323623, -1.09877, -.243578, .8761614, .1941613, -.1990692, .3761139, .1657412, 1.590503, .6741417, -1.648007, -.8205121, -44.35106, 44.79801, -.004181353, .385483, -1842385e-12, 2.000281, .5518363, -2.140986, -1.282239, -3.979213, 4.672459, -.005008582, .242192, .06253602, .6612713, .2555851, -1.300502, -.5137898, .5179821, -.4032341, -.02066785, 1.087929, -.2615309, 4.225887, 1.229237, -.696334, .0924106, .06936356, -.3588571, -.05461843, -.5616643, .5484166, -.04776267, .2414935, -1.233179, -.4325498, .6479813, .8368356, .2458875, .6464752, -.02897097, 1.561773, .8518598, -1.051023, -.253369, 1.004294, .3028083, -1.520108, .1607013, .1619975, 1.131094, .6706655, -1.948249, -1.097383, -44.53697, 44.94902, -.003579939, .3491605, -2500253e-12, 1.740442, .6188022, -2.154253, -1.209559, 4.144894, -3.562411, -.005638843, .1067169, .07594858, 1.00528, .1072543, -2.513259, -1.507208, -1.602979, 1.404154, -.00556075, 1.24049, -.2852117, 3.485252, 1.349321, -.07832214, .3655626, .3856288, .6867894, -.1609523, -.6704306, .5357301, -.6457935, .1479503, -1.354784, -.5454375, .8797469, -1.466514, .713442, .5934903, -.02911178, .8643737, .9030724, -1.048324, -.2738736, .8783074, 3.246188, -4.435369, .1251791, .1783486, 1.064657, .6522878, -2.770408, -1.618911, -25.04031, 25.31674, -.004239279, .3241013, -3764484e-12, 1.586843, .7035906, -1.9135, -1.144014, -10.80587, 11.53677, -.01003197, .1577515, .05217789, 1.225278, .005172771, -5.293208, -2.876463, 2.087053, -3.201552, .003892964, .532393, -.2034512, 2.61776, 1.273597, .906034, .3773409, -.6399945, 3.213979, -.09112172, .6494055, .395328, .5047796, .2998695, -1.482179, -.677831, 1.161775, -3.004872, .4774797, -.4969248, -.003512074, -1.30719, .7927378, -.9863181, -.1803364, .5810824, 4.58057, -3.863454, .5328174, .2272821, 1.771114, .6791814]
        ],
        Nc = [
            [1.560219, 1.417388, 1.206927, 10.91949, 5.931416, 7.304788, 1.533049, 1.560532, .3685059, 13.5504, 5.543711, 7.792189, 1.471043, 1.746088, -.9299697, 17.20362, 5.473384, 8.336416, 1.355991, 2.109348, -3.295855, 22.64843, 5.454607, 9.304656, 1.244963, 2.547533, -5.841485, 27.56879, 5.576104, 10.43287, 1.175532, 2.784634, -7.212225, 29.75347, 6.47298, 10.92331, 1.082973, 3.118094, -8.934293, 31.86879, 8.473885, 11.74019, .96925, 3.349574, -10.0381, 31.47654, 13.38931, 12.72547, .8547044, 3.151538, -9.095567, 25.54995, 22.73219, 14.10398, .758034, 2.311153, -5.170814, 12.29669, 36.86529, 15.98882, 1.664273, 1.574468, 1.422078, 9.768247, 14.47338, 16.44988, 1.638295, 1.719586, .5786675, 12.39846, 14.15419, 17.28605, 1.572623, 1.921559, -.7714802, 16.09246, 14.20954, 18.25908, 1.468395, 2.21197, -2.845869, 20.75027, 15.24822, 19.37622, 1.355047, 2.556469, -4.96092, 24.60237, 16.4836, 20.65648, 1.291642, 2.742036, -6.061967, 26.02002, 18.19144, 21.16712, 1.194565, 2.97212, -7.295779, 26.91805, 21.2488, 22.01819, 1.083631, 3.047021, -7.766096, 24.96261, 27.44264, 22.91875, .9707994, 2.736459, -6.308284, 17.6086, 37.76291, 23.9215, .8574294, 1.865155, -2.364707, 4.337793, 50.92831, 25.23432],
            [1.632341, 1.39523, 1.375634, 12.38193, 5.921102, 7.766508, 1.597115, 1.554617, .3932382, 15.05284, 5.725234, 8.158155, 1.522034, 1.844545, -1.322862, 19.18382, 5.440769, 8.837119, 1.403048, 2.290852, -4.013792, 24.851, 5.521888, 9.845547, 1.286364, 2.774498, -6.648221, 29.64151, 5.923777, 10.97075, 1.213544, 3.040195, -8.092676, 31.86082, 6.789782, 11.58899, 1.122622, 3.347465, -9.649016, 33.43824, 9.347715, 12.31374, 1.007356, 3.543858, -10.5352, 32.39842, 14.83962, 13.31718, .8956642, 3.2787, -9.254933, 25.57923, 24.89677, 14.76166, .7985143, 2.340404, -4.928274, 11.41787, 39.61501, 16.82448, 1.745162, 1.639467, 1.342721, 11.66033, 14.90124, 17.74031, 1.708439, 1.819144, .2834399, 14.48066, 14.59214, 18.58679, 1.63172, 2.094799, -1.378825, 18.43198, 14.63173, 19.62881, 1.516536, 2.438729, -3.624121, 22.98621, 15.99782, 20.70027, 1.405863, 2.785191, -5.705236, 26.45121, 17.6833, 21.91903, 1.344052, 2.951807, -6.683851, 27.44271, 19.85706, 22.29452, 1.245827, 3.182923, -7.82296, 27.91395, 23.27254, 23.1591, 1.132305, 3.202593, -8.008429, 25.21093, 30.00014, 24.05306, 1.02033, 2.820556, -6.238704, 17.09276, 40.77916, 25.09949, .903157, 1.863917, -1.955738, 3.032665, 54.3429, 26.4178],
            [1.168084, 2.156455, -3.980314, 19.89302, 13.28335, 14.35621, 1.135488, 2.294701, -4.585886, 20.90208, 13.4784, 14.67658, 1.107408, 2.382765, -5.112357, 21.47823, 14.93128, 14.60882, 1.054193, 2.592891, -6.115, 22.68967, 16.35672, 15.18999, 1.006946, 2.70542, -6.69893, 22.9183, 18.34324, 15.70651, .9794044, 2.74244, -6.805283, 22.25271, 20.50797, 15.6313, .9413577, 2.722009, -6.760707, 20.98242, 23.42588, 16.05011, .8917923, 2.59278, -6.152635, 17.74141, 28.58324, 16.5791, .8288391, 2.153434, -4.118327, 10.78118, 36.8171, 17.38139, .7623528, 1.418187, -.8845235, .7590129, 46.29859, 19.21657, 1.352858, 2.048862, -2.053393, 14.05874, 30.45344, 30.4443, 1.330497, 2.126497, -2.466296, 14.67559, 30.90738, 30.69707, 1.286344, 2.200436, -2.877228, 14.92701, 32.36288, 30.77223, 1.234428, 2.289628, -3.404699, 14.99436, 34.6839, 30.84842, 1.17866, 2.306071, -3.549159, 14.11006, 37.54188, 30.7973, 1.151366, 2.333005, -3.728627, 13.63374, 39.05894, 30.92599, 1.101593, 2.299422, -3.565787, 11.96745, 41.88472, 31.02755, 1.038322, 2.083539, -2.649585, 8.037389, 47.00869, 30.65948, .9596146, 1.67147, -.8751538, 1.679772, 53.45784, 30.5452, .8640731, .9858301, 1.854956, -6.798097, 59.36468, 31.10255]
        ],
        Oc = {
            getTableValue: function (e, t, n, r, i) {
                return Ic[e][540 * t + 54 * (n - 1) + 9 * r + i]
            },
            getTableValueRad: function (e, t, n, r) {
                return Nc[e][60 * t + 6 * (n - 1) + r]
            }
        };

    function Fc(e, r, i, a, o) {
        return zc(e).reduce(function (e, t, n) {
            return e + t * Oc.getTableValue(r, i, a, n, o)
        }, 0)
    }

    function Bc(e, r, i, a) {
        return zc(e).reduce(function (e, t, n) {
            return e + t * Oc.getTableValueRad(r, i, a, n)
        }, 0)
    }

    function zc(e) {
        var t = Math.pow(2 * e / Math.PI, 1 / 3);
        return [Math.pow(1 - t, 5), 5 * Math.pow(1 - t, 4) * t, 10 * Math.pow(1 - t, 3) * Math.pow(t, 2), 10 * Math.pow(1 - t, 2) * Math.pow(t, 3), 5 * (1 - t) * Math.pow(t, 4), Math.pow(t, 5)]
    }
    var Uc = {
        getDistParams: function (e, t, n, r) {
            for (var i = new Array(9), a = Math.trunc(e), o = e - a, s = 0; s < 9; s++) {
                var l = Fc(n, r, 0, a, s),
                    c = Fc(n, r, 1, a, s);
                if (i[s] = (1 - t) * (1 - o) * l + t * (1 - o) * c, 10 != a) {
                    var u = Fc(n, r, 0, a + 1, s),
                        d = Fc(n, r, 1, a + 1, s);
                    i[s] += (1 - t) * o * u + t * o * d
                }
            }
            return i
        },
        getRadiance: function (e, t, n, r) {
            var i = Math.trunc(e),
                a = e - i,
                o = (1 - t) * (1 - a) * Bc(n, r, 0, i) + t * (1 - a) * Bc(n, r, 1, i);
            10 != i && (o += (1 - t) * a * Bc(n, r, 0, i + 1) + t * a * Bc(n, r, 1, i + 1));
            return o
        }
    };

    function Vc(e, t, n, r) {
        Lc.call(this, e, t, n, r)
    }
    Vc.prototype = Object.assign(Object.create(Lc.prototype), {
        constructor: Vc,
        interpolate_: function (e, t, n, r) {
            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = (n - t) / (r - t), u = 1 - c, d = 0; d !== o; ++d) i[d] = a[l + d] * u + a[s + d] * c;
            return i
        }
    });
    var Gc = [
            [.1787, -1.463, -.3554, .4275, -.0227, 5.3251, .1206, -2.5771, -.067, .3703],
            [-.0193, -.2592, -.0665, 8e-4, -4e-4, .2125, -.0641, -.8989, -.0033, .0452],
            [-.0167, -.2608, -.095, .0092, -.0079, .2102, -.0441, -1.6537, -.0109, .0529]
        ],
        kc = [
            [4.0453, -4.971, -.2155, 2.4192],
            [.00166, -.00375, .00209, 0, -.02903, .06377, -.03202, .00394, .11693, -.21196, .06052, .25886],
            [.00275, -.0061, .00317, 0, -.04214, .0897, -.04153, .00516, .15346, -.26756, .0667, .26688]
        ],
        jc = function (e, t, n) {
            return Gc[e][2 * t + n]
        },
        Wc = function (e) {
            return kc[e]
        };

    function Xc(e, t, n) {
        return (1 + e[0] * Math.exp(e[1] / Math.cos(t))) * (1 + e[2] * Math.exp(e[3] * n) + e[4] * Math.pow(Math.cos(n), 2))
    }
    var Hc = {
        getDistParams: function (e, t) {
            for (var n = new Array(5), r = 0; r < 5; r++) n[r] = jc(t, r, 0) * e + jc(t, r, 1);
            return n
        },
        getZenithParams: function (e, t, n) {
            switch (n) {
                case 0:
                    var r = new $t((o = Wc(n))[0], o[1], o[2], o[3]),
                        i = Math.tan((4 / 9 - e / 120) * (Math.PI - 2 * t)),
                        a = new $t(e * i, i, e, 1);
                    return .06 * r.dot(a) / Xc(this.getDistParams(e, n), 0, t);
                case 1:
                case 2:
                    var o = Wc(n),
                        s = Math.pow(t, 2),
                        l = Math.pow(t, 3);
                    r = new on(o[0] * l + o[1] * s + o[2] * t + o[3], o[4] * l + o[5] * s + o[6] * t + o[7], o[8] * l + o[9] * s + o[10] * t + o[11]);
                    return new on(Math.pow(e, 2), e, 1).dot(r) / Xc(this.getDistParams(e, n), 0, t)
            }
        },
        getSunIlluminance: function (e, t) {
            var n = [0, 0, 0];
            if (e[1] < 0) return n;
            for (var r, i = [.605, .54, .445], a = [12.25, 7.5, .3], o = .04608 * t - .04586, s = 1 / (e[1] + .15 * Math.pow(93.885 - Math.acos(e[1]) * (180 / Math.PI), -1.253)), l = [1.05513096, .993359745, .903543472], c = 0; c < 3; c++) {
                var u = Math.exp(.008735 * -s * Math.pow(i[c], -4.08)),
                    d = Math.exp(-s * o * Math.pow(i[c], -1.3)),
                    h = Math.exp(.0035 * -a[c] * s);
                n[c] = 128e3 * l[c] / (.212671 * (r = l[c]) + .71516 * r + .072169 * r), n[c] *= u * d * h
            }
            return n
        },
        getSunIntegral: function (e, t, n, r) {
            var i = e,
                a = t,
                o = n;

            function s(e) {
                return e * e
            }
            var l = 1 - cos(i),
                c = ((s(Math.PI) - 2 * s(i - a)) * cos(i) - s(Math.PI) * cos(a)) / (2 * (i - a + Math.PI) * (-i + a + Math.PI)),
                u = o * ((.0892351 - .00247875 * s(o)) * sin(o) + cube(o) + 24 * o + .029745 * o * cos(o)) / s(s(o) + 36);
            return 2 * Math.PI * (l + c + r * u)
        }
    };

    function Yc(e, t, n) {
        return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this
    }
    Object.assign(Yc.prototype, {
        set: function (e, t, n) {
            return this.radius = e, this.phi = t, this.theta = n, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
        },
        makeSafe: function () {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        },
        setFromVector3: function (e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function (e, t, n) {
            return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Yt.clamp(t / this.radius, -1, 1))), this
        }
    });
    var qc = 4,
        Zc = 6,
        Qc = 3,
        Kc = 12,
        Jc = 20,
        $c = 0,
        eu = 2,
        tu = 22,
        nu = 5,
        ru = 2,
        iu = 8,
        au = 21,
        ou = 0,
        su = 9,
        lu = 10,
        cu = 256,
        uu = 512,
        du = {
            BEVEL_BL: 1,
            BSDF_DIFFUSE_BL: 2,
            BSDF_GLASS_BL: 3,
            BSDF_GLOSSY_BL: 2,
            BSDF_PRINCIPLED_BL: 19,
            "BSDF_PRINCIPLED_<2.80.64_BL": 17,
            BSDF_REFRACTION_BL: 3,
            BUMP_BL: 5,
            "BUMP_<2.81_BL": 3,
            FRESNEL_BL: 1,
            LAYER_WEIGHT_BL: 1
        };

    function hu(e) {
        Or.call(this);
        var t, n, pe = this;

        function x(e, t) {
            for (var n = e.node(t), r = (n.originData.type, 0); r < n.originData.inputs.length; r++) c(e, t, n.originData, r)
        }

        function c(e, t, n, r, i) {
            if (!be(e, t, r)) {
                i = i || "Input " + r;
                var a = n.inputs[r],
                    o = {
                        name: n.name + " " + i,
                        type: "",
                        inputs: [],
                        outputs: []
                    };
                switch (Re(a)) {
                    case "float":
                        o.type = "VALUE" + n.type.slice(-3), o.outputs.push(a);
                        break;
                    case "vec3":
                        o.type = "RGB" + n.type.slice(-3);
                        var s = a.slice();
                        s.push(1), o.outputs.push(s);
                        break;
                    case "vec4":
                        o.type = "RGB" + n.type.slice(-3), o.outputs.push(a);
                        break;
                    default:
                        throw new Error("Unsupported group input")
                }
                e.addNode({
                    originData: o
                });
                var l = new Dc.Edge(e.len() - 1, t, 0);
                l.connections = [];
                var c = {
                    from: 0,
                    to: r
                };
                return l.connections.push(c), e.addEdge(l), 1
            }
        }

        function b(e, t, n) {
            var r = {
                inputs: [],
                outputs: [],
                removedNodes: []
            };
            r.removedNodes.push(n);
            var i = w(t, "GROUP_INPUT_BL");
            if (-1 < i) {
                r.removedNodes.push(i + e.len());
                for (var a = e.findInEdges(n), o = t.findOutEdges(i), s = 0; s < a.length; s++)
                    for (var l = a[s], c = 0; c < o.length; c++)
                        for (var u = o[c], d = 0; d < l.connections.length; d++)
                            for (var h = l.connections[d], p = 0; p < u.connections.length; p++) {
                                var f = u.connections[p];
                                if (h.to == f.from) {
                                    (b = M(r.inputs, l.from(), u.to())) || ((b = new Dc.Edge(l.from(), u.to(), 0)).connections = [], r.inputs.push(b));
                                    var m = {
                                        from: h.from,
                                        to: f.to
                                    };
                                    b.connections.push(m)
                                }
                            }
            }
            var v = w(t, "GROUP_OUTPUT_BL");
            r.removedNodes.push(v + e.len());
            var g = e.findOutEdges(n),
                _ = t.findInEdges(v);
            for (s = 0; s < g.length; s++) {
                var y = g[s];
                for (c = 0; c < _.length; c++) {
                    var x = _[c];
                    for (d = 0; d < y.connections.length; d++)
                        for (h = y.connections[d], p = 0; p < x.connections.length; p++) {
                            f = x.connections[p];
                            if (h.from == f.to) {
                                var b;
                                (b = M(r.outputs, x.from(), y.to())) || ((b = new Dc.Edge(x.from(), y.to(), 0)).connections = [], r.outputs.push(b));
                                m = {
                                    from: f.from,
                                    to: h.to
                                };
                                b.connections.push(m)
                            }
                        }
                }
            }
            return r
        }

        function w(e, t) {
            for (var n = 0; n < e.len(); n++) {
                if (e.node(n).originData.type == t) return n
            }
            return -1
        }

        function fe(e, t) {
            Array.isArray(t) || (t = [t]);
            for (var n = 0, r = 0; r < e.len(); r++)
                for (var i = e.node(r), a = 0; a < t.length; a++) {
                    var o = t[a];
                    i.originData.type == o && n++
                }
            return n
        }

        function M(e, t, n) {
            for (var r = 0; r < e.length; r++) {
                var i = e[r];
                if (i.from() == t && i.to() == n) return i
            }
            return null
        }

        function u(e, t, n) {
            for (var r = n.type, i = e.findInEdges(t), a = 0; a < i.length; a++)
                for (var o = i[a], s = e.node(o.from()).originData, l = 0; l < o.connections.length; l++) {
                    var c = o.connections[l];
                    if ("MATERIAL_MX" == r && m(s.type) && (c.to == su ? s.reflectMode = "MAX_ENV_COORDS_REFLECT" : c.to == lu && (s.reflectMode = "MAX_ENV_COORDS_REFRACT")), me(r, c.to)) {
                        if ("BITMAP_MX" == s.type || "OUTPUT_MAP_MX" == s.type) {
                            e.removeEdge(o.from(), o.to()), "OUTPUT_MAP_MX" == s.type && (s = Me(e, o.from(), 0).originData);
                            var u = {
                                originData: {
                                    name: s.name + "Bump" + a,
                                    type: "BUMP_MX",
                                    texture: s.texture,
                                    uvIndex: s.uvIndex,
                                    inputs: [],
                                    outputs: [
                                        [0, 0, 0]
                                    ]
                                }
                            };
                            e.addNode(u), pu(e, e.len() - 1, 0, t, c.to), a = -1, i = e.findInEdges(t);
                            break
                        }
                        for (var d = 0; d < e.len(); d++) {
                            var h = e.node(d).originData;
                            if (f(h.type)) {
                                var p = h.inputs.length - 1;
                                pu(e, o.from(), c.from, d, p), h.inputFactors[p] = n.inputFactors[c.to]
                            }
                        }
                    }
                }
        }

        function f(e) {
            return !(!m(e) && "FALLOFF_MX" != e)
        }

        function m(e) {
            return "BITMAP_ENV_MX" == e || "REFLECT_REFRACT_MX" == e
        }

        function me(e, t) {
            switch (e) {
                case "BITMAP_ENV_MX":
                    return t == nu;
                case "FALLOFF_MX":
                    return t == ru;
                case "MATERIAL_MX":
                    return t == iu;
                case "PHYSICAL_MX":
                    return t == au || t == tu;
                case "REFLECT_REFRACT_MX":
                    return t == ou;
                default:
                    return !1
            }
        }

        function d(e, t, n) {
            for (var r = n.blendMode.length, i = e.findInEdges(t), a = e.findOutEdges(t), o = 0; o < r; o++) {
                var s = {
                    originData: {
                        name: n.name + "Layer" + o,
                        type: "COMPOSITE_LAYER_MX",
                        blendMode: 0 != o ? n.blendMode[o] : 0,
                        opacity: n.opacity[o],
                        inputs: [
                            [0, 0, 0, 0]
                        ].concat(n.inputs.slice(2 * o, 2 * o + 2)),
                        outputs: [n.outputs[o]]
                    }
                };
                e.addNode(s);
                for (var l = 0; l < i.length; l++)
                    for (var c = i[l], u = 0; u < c.connections.length; u++) {
                        (h = c.connections[u]).to == 2 * o && n.mapEnabled[o] ? pu(e, c.from(), h.from, e.len() - 1, 1) : h.to == 2 * o + 1 && n.maskEnabled[o] && pu(e, c.from(), h.from, e.len() - 1, 2)
                    }
                0 < o && pu(e, e.len() - 2, 0, e.len() - 1, 0)
            }
            for (o = 0; o < a.length; o++) {
                var d = a[o];
                for (l = 0; l < d.connections.length; l++) {
                    var h = d.connections[l];
                    pu(e, e.len() - 1, 0, d.to(), h.to)
                }
            }
        }

        function h(e, t, n) {
            var r = n.output,
                i = e.findInEdges(t),
                a = e.findOutEdges(t),
                o = {
                    originData: {
                        name: n.name + "Output",
                        type: "OUTPUT_MAP_MX",
                        invert: r.invert,
                        clamp: r.clamp,
                        alphaFromRGB: r.alphaFromRGB,
                        inputs: [
                            [0, 0, 0, 0], r.rgbLevel, r.rgbOffset, r.outputAmount, r.bumpAmount
                        ],
                        outputs: [
                            [0, 0, 0, 0]
                        ]
                    }
                };
            xn(r.colorMap) && (o.originData.colorMap = r.colorMap), e.addNode(o);
            for (var s = 0; s < a.length; s++)
                for (var l = a[s], c = 0; c < l.connections.length; c++) {
                    var u = l.connections[c];
                    pu(e, e.len() - 1, 0, l.to(), u.to)
                }
            e.disconnect(t, !1);
            for (s = 0; s < i.length; s++) e.addEdge(i[s]);
            pu(e, t, 0, e.len() - 1, 0), delete n.output
        }

        function A(e) {
            return -1 < e.type.indexOf("uniform")
        }

        function S(e) {
            return -1 < e.type.indexOf("varying")
        }

        function ve(e) {
            return pe.nodeUVAliases[e] || "uv"
        }

        function ge(e, t) {
            return t = xn(t) ? t : "color", pe.nodeVCAliases[e] || t
        }

        function _e(e, t, n, r) {
            var i = new Vi(e, t, 1, n, r, Jt.DEFAULT_MAPPING, Ye, Ye, Je, Je);
            return i.needsUpdate = !0, i
        }

        function ye(e) {
            switch (e) {
                case St:
                    return "1";
                case Et:
                    return "2";
                default:
                    return "0"
            }
        }

        function xe(e, t, n, r, i) {
            var a;
            return t == n ? a = e : "float" == t && "vec3" == n ? a = "vec3(" + [e, e, e].join(",") + ")" : "float" == t && "vec4" == n ? a = "vec4(" + [e, e, e, e].join(",") + ")" : "vec3" == t && "float" == n || "vec4" == t && "float" == n ? a = "(" + [e + "[0]", e + "[1]", e + "[2]"].join("+") + ")/3.0" : "vec3" == t && "vec4" == n ? a = "vec4(" + e + ", 1.0)" : "vec4" == t && "vec3" == n && (a = "vec3(" + [e + "[0]", e + "[1]", e + "[2]"].join(",") + ")"), (i < 1 || 1 != i && "normal" == r) && (a = "mix(" + r + "," + a + "," + o(i) + ")", "normal" == r && (a = "normalize(" + a + ")")), a
        }

        function be(e, t, n) {
            for (var r = e.findInEdges(t), i = 0; i < r.length; i++)
                for (var a = r[i], o = 0; o < a.connections.length; o++) {
                    if (a.connections[o].to == n) return 1
                }
        }

        function we(e, t, n) {
            for (var r in e.edges) {
                var i = e.edges[r];
                if (i.from() == t)
                    for (var a = 0; a < i.connections.length; a++) {
                        if (i.connections[a].from == n) return 1
                    }
            }
        }

        function Me(e, t, n) {
            for (var r in e.edges) {
                var i = e.edges[r];
                if (i.to() == t)
                    for (var a = e.node(i.from()), o = 0; o < i.connections.length; o++) {
                        if (i.connections[o].to == n) return a
                    }
            }
            return null
        }

        function Ae(e, t, n, r) {
            for (var i in e.edges) {
                var a = e.edges[i];
                if (a.to() == t)
                    for (var o = e.node(a.from()), s = 0; s < a.connections.length; s++) {
                        var l = a.connections[s];
                        if (l.to == n) {
                            var c = o.originData.type;
                            return "BITMAP_MX" != c && "BITMAP_ENV_MX" != c || "float" != Re(r) ? o.outputs[l.from] : o.outputs[l.from + 1]
                        }
                    }
            }
            return null
        }

        function Se(e, t, n, r) {
            return {
                name: e.toLowerCase() + "_par_" + r + "_n" + t,
                type: Re(n),
                value: "boolean" == typeof n ? Le(n) : n
            }
        }

        function Te(e, t) {
            var n = hu.nodeTexUniName(e, t);
            return {
                name: n,
                type: pe.nodeTextures[n].isCubeTexture ? "uniform samplerCube" : "uniform sampler2D",
                value: t
            }
        }

        function Ee(e) {
            return Ce(e ? "true" : "false")
        }

        function Ce(e) {
            return {
                name: e,
                type: "",
                value: null
            }
        }

        function Pe(e, t) {
            return {
                name: "_vary_par_" + e,
                type: "varying " + r(t),
                value: null
            }
        }

        function Le(e) {
            return e ? 1 : 0
        }

        function Re(e) {
            return "number" == typeof e ? "float" : "boolean" == typeof e ? "int" : r(e.length)
        }

        function r(e) {
            switch (e) {
                case 1:
                    return "float";
                case 2:
                    return "vec2";
                case 3:
                    return "vec3";
                case 4:
                    return "vec4";
                case 9:
                    return "mat3";
                case 16:
                    return "mat4"
            }
        }

        function De(e, t) {
            switch (e) {
                case "float":
                    return o(t);
                case "int":
                    return String(t);
                default:
                    for (var n = [], r = 0; r < t.length; r++) n.push(o(t[r]));
                    return e + "(" + n.join(",") + ")"
            }
        }

        function o(e) {
            return e % 1 ? String(e) : String(e) + ".0"
        }
        this.type = "MeshNodeMaterial", this.defines = {
                LIGHT_PATH_IS_CAM_RAY: 1,
                WORLD_NODES: 0
            }, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !0,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.profile = "blender", this.nodeTextures = {}, this.nodeRGB = [], this.nodeRGBMap = {}, this.nodeRGBArr = null, this.nodeTexCoordObject = [], this.nodeTexCoordObjectMap = {}, this.nodeTexCoordObjectArr = null, this.nodeValue = null, this.nodeValueMap = {}, this.needsBoundingBox = !1, this.nodeGraph = null, this.additionalNodeGraphs = {}, this.nodeChunks = {}, this.nodeChunksHash = 0, this.nodeVCAliases = {}, this.nodeUVAliases = {}, this.color = new Pr(16777215), this.envMap = null, this.envMapIntensity = 1, this.advancedPBR = !1, this.reflectivity = .5, xn(e) && this.setValues(e), this.nodeGraph || (this.nodeGraph = (t = new Dc.DiGraph(1), n = pe.color, t.node(0).originData = {
                name: "ShadelessOutput",
                type: "OUTPUT_BL",
                inputs: [
                    [n.r, n.g, n.b, 1], 1
                ],
                outputs: [],
                is_active_output: !0
            }, t)), this.updateNodeGraph = function () {
                pe.nodeRGB = [], pe.nodeRGBMap = {}, pe.nodeTexCoordObject = [], pe.nodeTexCoordObjectMap = {}, pe.nodeValueMap = {}, pe.needsBoundingBox = !1, pe.nodeChunks = {};
                var e = pe.nodeGraph;
                pe.nodeRGBArr = new Float32Array(4 * fe(e, ["RGB_BL", "RGB_GF", "RGB_MX"])), pe.nodeTexCoordObjectArr = new Float32Array(16 * fe(e, "TEX_COORD_BL")), pe.nodeValue = new Float32Array(fe(e, ["VALUE_BL", "VALUE_GF", "VALUE_MX"])),
                    function (e) {
                        for (var t = 0, n = 0, r = 0, i = 0, a = 0; a < e.len(); a++) {
                            var o = (oe = (ae = e.node(a)).originData).type;
                            ae.attributes = [], ae.params = [], ae.inputFactors = [], ae.inputs = [], ae.outputs = [], xn(oe.inputFactors) && (ae.inputFactors = oe.inputFactors.slice(0));
                            for (var s = 0; s < oe.outputs.length; s++) {
                                var l = oe.outputs[s];
                                ae.outputs.push({
                                    name: o.toLowerCase() + "_out" + s + "_n" + a,
                                    type: Re(l),
                                    clamp: !1,
                                    normalize: !1
                                })
                            }
                            switch ("OUTPUT_BL" != o && "OUTPUT_MATERIAL_BL" != o && "OUTPUT_WORLD_BL" != o && "OUTPUT_MX" != o && "OUTPUT_MY" != o && "MATERIAL_GF" != o || ae.outputs.push({
                                name: "outgoingLight",
                                type: "",
                                clamp: !1,
                                normalize: !1
                            }), o) {
                                case "ATTRIBUTE_BL":
                                    if (ie = ge(oe.colorLayer, "")) {
                                        var c = Pe(ie, 3);
                                        ae.attributes.push({
                                            name: ie,
                                            type: "attribute vec3",
                                            paramVary: c
                                        }), ae.params.push(c)
                                    } else ae.params.push(Ce("vec3(0.0)"));
                                    break;
                                case "BSDF_DIFFUSE_BL":
                                case "BSDF_GLASS_BL":
                                case "BSDF_GLOSSY_BL":
                                    ae.params.push(Ce("geometryNormal"));
                                    break;
                                case "BSDF_PRINCIPLED_BL":
                                    ae.params.push(Ce("geometryNormal")), (0 < oe.inputs[Kc] || be(e, a, Kc)) && (pe.advancedPBR = !0);
                                    break;
                                case "BSDF_REFRACTION_BL":
                                    ae.params.push(Ce("geometryNormal")), ae.params.push(Ce("BSDF_REFRACTION_" + oe.distribution));
                                    break;
                                case "BUMP_BL":
                                    ae.params.push(Se(o, a, oe.invert, "inv"));
                                    break;
                                case "CAMERA_BL":
                                    ae.params.push(Ce("vViewPosition")), 0 < fe(e, "OUTPUT_MATERIAL_BL") || 0 < fe(e, "OUTPUT_WORLD_BL") ? ae.params.push(Ce("1")) : ae.params.push(Ce("0"));
                                    break;
                                case "CURVE_RGB_BL":
                                case "CURVE_VEC_BL":
                                    if (pe.useHDR) var u = new Float32Array(4 * cu),
                                        d = 1;
                                    else u = new Uint8Array(4 * cu), d = 255;
                                    var h = oe.curveData.length / cu;
                                    for (s = 0; s < cu; s++) _ = 3 < h ? (m = d * oe.curveData[h * s], v = d * oe.curveData[h * s + 1], g = d * oe.curveData[h * s + 2], d * oe.curveData[h * s + 3]) : (m = d * (oe.curveData[h * s] / 2 + .5), v = d * (oe.curveData[h * s + 1] / 2 + .5), g = d * (oe.curveData[h * s + 2] / 2 + .5), d), u[4 * s] = Yt.clamp(m, 0, d), u[4 * s + 1] = Yt.clamp(v, 0, d), u[4 * s + 2] = Yt.clamp(g, 0, d), u[4 * s + 3] = Yt.clamp(_, 0, d);
                                    var p = _e(u, cu, lt, pe.useHDR ? it : tt),
                                        f = hu.nodeTexUniName(o, t);
                                    pe.nodeTextures[f] = p, ae.params.push(Te(o, t)), t++;
                                    break;
                                case "FRESNEL_BL":
                                case "LAYER_WEIGHT_BL":
                                    ae.params.push(Ce("vViewPosition"));
                                    break;
                                case "GEOMETRY_BL":
                                    if (ae.params.push(Ce("vViewPosition")), ae.params.push(Ce("normal")), ae.params.push(Ce("vec3(0.0)")), we(e, a, qc)) c = Pe(ie = ve(oe.uvLayer), 2), ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec2",
                                        paramVary: c
                                    }), ae.params.push(c);
                                    else ae.params.push(Ce("vec2(0.5)"));
                                    if (we(e, a, Zc)) c = Pe(ie = ge(oe.colorLayer), 4), ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec4",
                                        paramVary: c
                                    }), ae.params.push(c);
                                    else ae.params.push(Ce("vec4(0.0)"));
                                    break;
                                case "GRADIENT_RAMP_MX":
                                    if (pe.useHDR) u = new Float32Array(4 * uu), d = 1;
                                    else u = new Uint8Array(4 * uu), d = 255;
                                    var m, v, g, _;
                                    for (s = 0; s < uu; s++) m = d * oe.gradientData[3 * s], v = d * oe.gradientData[3 * s + 1], g = d * oe.gradientData[3 * s + 2], _ = 1, u[4 * s] = Yt.clamp(m, 0, d), u[4 * s + 1] = Yt.clamp(v, 0, d), u[4 * s + 2] = Yt.clamp(g, 0, d), u[4 * s + 3] = Yt.clamp(_, 0, d);
                                    p = _e(u, uu, lt, pe.useHDR ? it : tt), f = hu.nodeTexUniName(o, t);
                                    pe.nodeTextures[f] = p, ae.params.push(Te(o, t)), t++, ae.params.push(Ce(De("int", oe.gradientType)));
                                    c = Pe(ie = oe.uvIndex ? "uv" + String(oe.uvIndex + 1) : "uv", 2);
                                    ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec2",
                                        paramVary: c
                                    }), ae.params.push(c), ae.params.push(Ce("geometryNormal")), ae.params.push(Ce("vViewPosition")), -1 < ["SPHERICAL_ENVIRONMENT", "CYLINDRICAL_ENVIRONMENT", "SHRINK_WRAP_ENVIRONMENT", "SCREEN"].indexOf(oe.mapping) ? ae.params.push(Ce("MAPPING_EXPLICIT_MAP_CHANNEL")) : ae.params.push(Ce("MAPPING_" + oe.mapping)), ae.params.push(Ce("AXIS_" + oe.axis));
                                    var y = De("ivec2", [Le(oe.clampToEdgeNoExtend[0]), Le(oe.clampToEdgeNoExtend[1])]);
                                    ae.params.push(Ce(y));
                                    break;
                                case "MAPPING_BL":
                                    if (oe.rotation) {
                                        var x = new fn,
                                            b = new gn;
                                        switch (b.set(oe.rotation[0], oe.rotation[1], oe.rotation[2], "ZYX"), x.makeRotationFromEuler(b), x.scale((new on).fromArray(oe.scale)), oe.vectorType) {
                                            case "TEXTURE":
                                                x.setPosition((new on).fromArray(oe.translation)), x.getInverse(x);
                                                break;
                                            case "POINT":
                                                x.setPosition((new on).fromArray(oe.translation));
                                                break;
                                            case "VECTOR":
                                                break;
                                            case "NORMAL":
                                                ae.outputs[0].normalize = !0, x.getInverse(x), x.transpose();
                                                break;
                                            default:
                                                throw new Error("v3d.MeshNodeMaterial: Unknown MAPPING vector type")
                                        }
                                        ae.params.push(Se(o, a, x.toArray(), "mat")), ae.params.push(Se(o, a, oe.min, "min")), ae.params.push(Se(o, a, oe.max, "max")), ae.params.push(Se(o, a, oe.useMin, "use_min")), ae.params.push(Se(o, a, oe.useMax, "use_max"))
                                    } else ae.params.push(Ce("NODE_MAPPING_" + oe.vectorType));
                                    break;
                                case "MAP_RANGE_BL":
                                    ae.params.push(Ce("NODE_MAP_RANGE_INTERP_LINEAR")), ae.params.push(Ce(oe.clamp ? "1" : "0"));
                                    break;
                                case "MATERIAL_BL":
                                case "MATERIAL_EXT_BL":
                                    xn(oe.materialName) ? (ae.params.push(Se(o, a, oe.useDiffuse, "use_diff")), ae.params.push(Se(o, a, oe.useSpecular, "use_spec")), ae.params.push(Se(o, a, oe.invertNormal, "inv_nor")), ae.params.push(Se(o, a, oe.specularIntensity, "spec_int")), ae.params.push(Se(o, a, oe.specularHardness, "spec_hard")), "MATERIAL_BL" == o && (ae.params.push(Se(o, a, oe.ambient, "ambient")), ae.params.push(Se(o, a, oe.emit, "emit")), ae.params.push(Se(o, a, oe.alpha, "alpha"))), ae.params.push(Se(o, a, oe.useShadeless, "use_shless"))) : (ae.params.push(Se(o, a, !1, "use_diff")), ae.params.push(Se(o, a, !1, "use_spec")), ae.params.push(Se(o, a, !1, "inv_nor")), ae.params.push(Se(o, a, 0, "spec_int")), ae.params.push(Se(o, a, 0, "spec_hard")), "MATERIAL_BL" == o && (ae.params.push(Se(o, a, 0, "ambient")), ae.params.push(Se(o, a, 0, "emit")), ae.params.push(Se(o, a, 0, "alpha"))), ae.params.push(Se(o, a, !1, "use_shless"))), ae.params.push(Ce("1"));
                                    break;
                                case "NEW_GEOMETRY_BL":
                                    ae.params.push(Ce("FRONT_FACING_VALUE")), ae.params.push(Ce("vViewPosition")), ae.params.push(Ce("normal")), we(e, a, eu) && (pe.needsBoundingBox = !0);
                                    break;
                                case "NORMAL_MAP_BL":
                                    c = Pe(ie = "tangent", 4);
                                    ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec4",
                                        paramVary: c
                                    }), ae.params.push(c), ae.params.push(Ce("vNormal"));
                                    break;
                                case "TEX_COORD_BL":
                                    ae.params.push(Ce("nodeTexCoordObjectMatrices[".concat(r, "]"))), ae.params.push(Ce("vViewPosition")), ae.params.push(Ce("normal"));
                                    c = Pe(ie = "uv", 2);
                                    ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec2",
                                        paramVary: c
                                    }), ae.params.push(c), we(e, a, $c) && (pe.needsBoundingBox = !0), pe.nodeTexCoordObject.push(null), pe.nodeTexCoordObjectMap[oe.name] = r, r++;
                                    break;
                                case "TEX_ENVIRONMENT_BL":
                                case "TEX_ENVIRONMENT_MX":
                                case "TEX_IMAGE_BL":
                                    var w = Te(o, oe.texture);
                                    ae.params.push(w);
                                    var M = pe.nodeTextures[w.name].encoding;
                                    if (ae.params.push(Ce(ye(M))), "TEX_ENVIRONMENT_BL" == o) {
                                        var A = oe.projection;
                                        ae.params.push(Ce("TEX_PROJ_" + A))
                                    } else if ("TEX_IMAGE_BL" == o) {
                                        ae.params.push(Ce("normal"));
                                        A = oe.projection;
                                        ae.params.push(Ce("TEX_PROJ_" + A)), ae.params.push(Se(o, a, oe.projectionBlend, "proj_blend")), ae.params.push(Ee(oe.clampToEdgeNoExtend))
                                    }
                                    break;
                                case "TEX_GRADIENT_BL":
                                    ae.params.push(Ce("TEX_GRAD_" + oe.gradientType));
                                    break;
                                case "TEX_NOISE_BL":
                                    var S = xn(oe.falloffFactor) ? oe.falloffFactor : 0,
                                        T = xn(oe.dispersionFactor) ? oe.dispersionFactor : 1;
                                    ae.params.push(Ce(De("float", S))), ae.params.push(Ce(De("float", T)));
                                    break;
                                case "TEX_SKY_BL":
                                    var E = (new on).fromArray(oe.sunDirection).angleTo(new on(0, 0, 1));
                                    if ("PREETHAM" == oe.skyType) var C = Hc.getDistParams(oe.turbidity, 0).concat([0, 0, 0, 0]),
                                        P = Hc.getDistParams(oe.turbidity, 1).concat([0, 0, 0, 0]),
                                        L = Hc.getDistParams(oe.turbidity, 2).concat([0, 0, 0, 0]),
                                        R = Hc.getZenithParams(oe.turbidity, E, 0),
                                        D = Hc.getZenithParams(oe.turbidity, E, 1),
                                        I = Hc.getZenithParams(oe.turbidity, E, 2);
                                    else if ("HOSEK_WILKIE" == oe.skyType) {
                                        var N = Math.max(Math.PI / 2 - E, 0);
                                        C = Uc.getDistParams(oe.turbidity, oe.groundAlbedo, N, 0), P = Uc.getDistParams(oe.turbidity, oe.groundAlbedo, N, 1), L = Uc.getDistParams(oe.turbidity, oe.groundAlbedo, N, 2), R = Uc.getRadiance(oe.turbidity, oe.groundAlbedo, N, 0), D = Uc.getRadiance(oe.turbidity, oe.groundAlbedo, N, 1), I = Uc.getRadiance(oe.turbidity, oe.groundAlbedo, N, 2)
                                    }
                                    ae.params.push(Ce("TEX_SKY_" + oe.skyType)), ae.params.push(Se(o, a, [C[0], P[0], L[0]], "param0")), ae.params.push(Se(o, a, [C[1], P[1], L[1]], "param1")), ae.params.push(Se(o, a, [C[2], P[2], L[2]], "param2")), ae.params.push(Se(o, a, [C[3], P[3], L[3]], "param3")), ae.params.push(Se(o, a, [C[4], P[4], L[4]], "param4")), ae.params.push(Se(o, a, [C[5], P[5], L[5]], "param5")), ae.params.push(Se(o, a, [C[6], P[6], L[6]], "param6")), ae.params.push(Se(o, a, [C[7], P[7], L[7]], "param7")), ae.params.push(Se(o, a, [C[8], P[8], L[8]], "param8")), ae.params.push(Se(o, a, [R, D, I], "radiance")), ae.params.push(Se(o, a, oe.sunDirection, "sun_dir"));
                                    break;
                                case "TEX_VORONOI_BL":
                                    void 0 !== oe.coloring && ae.params.push(Ce("COLORING_" + oe.coloring)), ae.params.push(Ce("DISTANCE_" + oe.distance)), ae.params.push(Ce("FEATURE_" + oe.feature));
                                    break;
                                case "TEX_WAVE_BL":
                                    ae.params.push(Ce("TEX_WAVE_TYPE_" + oe.waveType)), ae.params.push(Ce("TEX_WAVE_PROFILE_" + oe.waveProfile)), void 0 === oe.bandsDirection && (oe.bandsDirection = "DIAGONAL"), void 0 === oe.ringsDirection && (oe.ringsDirection = "SPHERICAL"), ae.params.push(Ce("TEX_WAVE_BANDS_DIR_".concat(oe.bandsDirection))), ae.params.push(Ce("TEX_WAVE_RINGS_DIR_".concat(oe.ringsDirection)));
                                    break;
                                case "TEXTURE_BL":
                                case "TEXTURE_CUBE_BL":
                                    w = Te("TEXTURE_BL", oe.texture);
                                    ae.params.push(w);
                                    M = pe.nodeTextures[w.name].encoding;
                                    ae.params.push(Ce(ye(M))), oe.type = -1 < w.type.indexOf("samplerCube") ? "TEXTURE_CUBE_BL" : "TEXTURE_BL";
                                    break;
                                case "MATH_BL":
                                    ae.outputs[0].clamp = oe.useClamp;
                                    break;
                                case "MIX_RGB_BL":
                                    switch (ae.originData.blendType) {
                                        case "HUE":
                                        case "SATURATION":
                                        case "VALUE":
                                        case "COLOR":
                                            pe.defines.HSV_NODES = ""
                                    }
                                    ae.outputs[0].clamp = oe.useClamp;
                                    break;
                                case "MIX_SHADER_BL":
                                    var O = -1;
                                    for (s = 1; s < 3; s++) {
                                        var F = Me(e, a, s);
                                        F && "BSDF_TRANSPARENT_BL" == F.originData.type && (O = s - 1)
                                    }
                                    ae.params.push(Ce(String(O)));
                                    break;
                                case "NORMAL_BL":
                                    ae.params.push(Se(o, a, oe.outputs[0], "out"));
                                    break;
                                case "RGB_BL":
                                case "RGB_GF":
                                case "RGB_MX":
                                    w = (new $t).fromArray(oe.outputs[0]);
                                    pe.nodeRGB.push(w), pe.nodeRGBMap[oe.name] = n, ae.params.push(Ce("nodeRGB[" + n + "]")), n++;
                                    break;
                                case "UVMAP_BL":
                                    c = Pe(ie = ve(oe.uvLayer), 2);
                                    ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec2",
                                        paramVary: c
                                    }), ae.params.push(c);
                                    break;
                                case "VALUE_BL":
                                case "VALUE_GF":
                                case "VALUE_MX":
                                    w = oe.outputs[0];
                                    pe.nodeValue[i] = w, pe.nodeValueMap[oe.name] = i, ae.params.push(Ce("nodeValue[" + i + "]")), i++;
                                    break;
                                case "VALTORGB_BL":
                                    var B = new("STEP" == (K = oe.curve).interpolation ? Rc : Vc)(new Float32Array(K.input), new Float32Array(K.output), 4);
                                    if (pe.useHDR) u = new Float32Array(4 * cu), d = 1;
                                    else u = new Uint8Array(4 * cu), d = 255;
                                    for (s = 0; s < cu; s++) {
                                        var z = B.evaluate(s / (cu - 1));
                                        u[4 * s] = d * z[0], u[4 * s + 1] = d * z[1], u[4 * s + 2] = d * z[2], u[4 * s + 3] = d * z[3]
                                    }
                                    p = _e(u, cu, lt, pe.useHDR ? it : tt);
                                    "STEP" == K.interpolation && (p.minFilter = Ze, p.magFilter = Ze);
                                    f = hu.nodeTexUniName(o, t);
                                    pe.nodeTextures[f] = p, ae.params.push(Te(o, t)), t++;
                                    break;
                                case "VECT_TRANSFORM_BL":
                                    var U = oe.vectorType,
                                        V = oe.convertFrom,
                                        G = oe.convertTo;
                                    "NORMAL" == U && (ae.outputs[0].normalize = !0);
                                    var k = "";
                                    V == G ? k = "VEC_TRANS_NONE" : (k = "VEC_TRANS_" + V[0] + "_" + G[0], "VECTOR" != U && "NORMAL" != U || (k += "_DIR")), ae.params.push(Ce(k)), 0 < fe(e, "OUTPUT_MATERIAL_BL") || 0 < fe(e, "OUTPUT_WORLD_BL") ? ae.params.push(Ce("1")) : ae.params.push(Ce("0"));
                                    break;
                                case "BITMAP_MX":
                                case "BITMAP_ENV_MX":
                                case "REFLECT_REFRACT_MX":
                                    var j = Te(o, oe.texture);
                                    if (ae.params.push(j), "BITMAP_MX" == o) {
                                        c = Pe(ie = oe.uvIndex ? "uv" + String(oe.uvIndex + 1) : "uv", 2);
                                        ae.attributes.push({
                                            name: ie,
                                            type: "attribute vec2",
                                            paramVary: c
                                        }), ae.params.push(c), ae.params.push(Ce("MAPPING_" + oe.mapping)), ae.params.push(Ce("AXIS_" + oe.axis));
                                        y = De("ivec2", [Le(oe.clampToEdgeNoExtend[0]), Le(oe.clampToEdgeNoExtend[1])]);
                                        ae.params.push(Ce(y))
                                    } else ae.params.push(Ce(oe.reflectMode)), ae.params.push(Se(o, a, oe.IOR, "ior"));
                                    M = pe.nodeTextures[j.name].encoding;
                                    ae.params.push(Ce(ye(M))), "BITMAP_MX" != o && "BITMAP_ENV_MX" != o || (ae.params.push(Se(o, a, oe.alphaAsMono, "as_mono")), ae.params.push(Se(o, a, oe.alphaAsRGB, "as_rgb")), ae.outputs.push({
                                        name: o.toLowerCase() + "_out1_n" + a,
                                        type: "float",
                                        clamp: !1,
                                        normalize: !1
                                    }));
                                    break;
                                case "BLEND_MX":
                                    ae.params.push(Se(o, a, oe.useCurve, "use_curve")), ae.params.push(Se(o, a, oe.curveLower, "curve_lower")), ae.params.push(Se(o, a, oe.curveUpper, "curve_upper"));
                                    break;
                                case "BUMP_MX":
                                    j = Te("BITMAP_MX", oe.texture);
                                    ae.params.push(j), ae.params.push(Ce("-vViewPosition")), ae.params.push(Ce("normal"));
                                    c = Pe(ie = oe.uvIndex ? "uv" + String(oe.uvIndex + 1) : "uv", 2);
                                    ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec2",
                                        paramVary: c
                                    }), ae.params.push(c);
                                    break;
                                case "COLOR_CORRECTION_MX":
                                    var W = De("ivec4", [oe.rewireR, oe.rewireG, oe.rewireB, oe.rewireA]);
                                    ae.params.push(Ce(W));
                                    break;
                                case "COMPOSITE_LAYER_MX":
                                    ae.params.push(Ce(De("int", oe.blendMode)));
                                    var X = be(e, a, 1) ? oe.opacity : 0;
                                    ae.params.push(Se(o, a, X, "opacity"));
                                    break;
                                case "COLOR_MAP_MX":
                                    ae.params.push(Se(o, a, oe.reverseGamma, "rev"));
                                    break;
                                case "FALLOFF_MX":
                                    ae.params.push(Ce("-vViewPosition")), ae.params.push(Se(o, a, oe.IOR, "ior"));
                                    break;
                                case "MASK_MX":
                                    ae.params.push(Se(o, a, oe.maskInverted, "inv"));
                                    break;
                                case "MATERIAL_MX":
                                    ae.params.push(Se(o, a, oe.inputFactors[su], "refl_ratio")), ae.params.push(Se(o, a, oe.inputFactors[lu], "refr_ratio")), oe.inputFactors[su] = 1, oe.inputFactors[lu] = 1, ae.params.push(Se(o, a, oe.selfIllumColorOn, "self_ill_on"));
                                    break;
                                case "NORMAL_BUMP_MX":
                                    c = Pe(ie = "tangent", 4);
                                    ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec4",
                                        paramVary: c
                                    }), ae.params.push(c), ae.params.push(Ce("normal"));
                                    var H = "ivec2(" + Le(oe.flip[0]) + "," + Le(oe.flip[1]) + ")";
                                    ae.params.push(Ce(H));
                                    break;
                                case "OUTPUT_MAP_MX":
                                    if (ae.params.push(Ee(oe.invert)), ae.params.push(Ee(oe.clamp)), ae.params.push(Ee(oe.alphaFromRGB)), oe.colorMap) {
                                        if (pe.useHDR) {
                                            var Y = oe.colorMap;
                                            u = new Float32Array(4 * cu), d = 1
                                        } else Y = bn(oe.colorMap.slice(), 0, 1), u = new Uint8Array(4 * cu), d = 255;
                                        for (h = Y.length / cu, s = 0; s < cu; s++) u[4 * s] = d * Y[h * s], 3 == h ? (u[4 * s + 1] = d * Y[h * s + 1], u[4 * s + 2] = d * Y[h * s + 2]) : (u[4 * s + 1] = u[4 * s], u[4 * s + 2] = u[4 * s]), u[4 * s + 3] = d;
                                        p = _e(u, cu, lt, pe.useHDR ? it : tt), f = hu.nodeTexUniName(o, t);
                                        pe.nodeTextures[f] = p, ae.params.push(Te(o, t)), t++
                                    }
                                    break;
                                case "PHYSICAL_MX":
                                    ae.params.push(Ce("geometryNormal")), ae.params.push(Se(o, a, oe.emitLuminance, "lum"));
                                    var q = void 0 === oe.brdfMode || oe.brdfMode,
                                        Z = void 0 === oe.brdfLow ? 0 : oe.brdfLow,
                                        Q = void 0 === oe.brdfHigh ? 0 : oe.brdfHigh,
                                        K = void 0 === oe.brdfCurve ? 0 : oe.brdfCurve;
                                    ae.params.push(Ce(q ? "0" : "1")), ae.params.push(Ce(De("float", Z))), ae.params.push(Ce(De("float", Q))), ae.params.push(Ce(De("float", K))), ae.params.push(Ee(xn(oe.roughnessInv) && oe.roughnessInv)), ae.params.push(Ee(xn(oe.transRoughnessLock) && oe.transRoughnessLock)), ae.params.push(Ee(xn(oe.transRoughnessInv) && oe.transRoughnessInv)), ae.params.push(Ee(xn(oe.thinWalled) && oe.thinWalled)), pe.advancedPBR = !0;
                                    break;
                                case "PHY_SUN_SKY_ENV_MX":
                                    var J = 15 * oe.haze + 2,
                                        $ = new Yc,
                                        ee = (E = Math.PI / 2 - oe.sunPolarAngle, Math.PI - oe.sunAzimuthAngle);
                                    $.phi = E, $.theta = ee;
                                    var te = (new on).setFromSpherical($).toArray();
                                    C = Hc.getDistParams(J, 0), P = Hc.getDistParams(J, 1), L = Hc.getDistParams(J, 2), R = Hc.getZenithParams(J, E, 0), D = Hc.getZenithParams(J, E, 1), I = Hc.getZenithParams(J, E, 2);
                                    R /= .06, R *= 1e3, ae.params.push(Se(o, a, [C[0], P[0], L[0]], "param_a")), ae.params.push(Se(o, a, [C[1], P[1], L[1]], "param_b")), ae.params.push(Se(o, a, [C[2], P[2], L[2]], "param_c")), ae.params.push(Se(o, a, [C[3], P[3], L[3]], "param_d")), ae.params.push(Se(o, a, [C[4], P[4], L[4]], "param_e")), ae.params.push(Se(o, a, [R, D, I], "radiance"));
                                    var ne = Hc.getSunIlluminance(te, J);
                                    ae.params.push(Se(o, a, te, "sun_dir")), ae.params.push(Se(o, a, ne, "sun_illum")), ae.params.push(Se(o, a, [0, 0, 0], "sun_lum"));
                                    var re = 1500 / Math.PI;
                                    ae.params.push(Se(o, a, oe.globalIntensity / re, "glob_int")), ae.params.push(Se(o, a, oe.groundColor, "gr_col"));
                                    break;
                                case "REFLECT_REFRACT_COLOR_MX":
                                    w = oe.outputs[0];
                                    ae.params.push(Se(o, a, w, "col"));
                                    break;
                                case "VERTEX_COLOR_MX":
                                    c = Pe(ie = "color", 3);
                                    ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec3",
                                        paramVary: c
                                    }), ae.params.push(c);
                                    break;
                                case "AI_SKYDOME_LIGHT_MY":
                                    j = Te(o, oe.texture);
                                    ae.params.push(j);
                                    M = pe.nodeTextures[j.name].encoding;
                                    ae.params.push(Ce(ye(M))), ae.params.push(Ce("normal"));
                                    break;
                                case "MATERIAL_GF":
                                    ae.params.push(Ce("normal")), ae.params.push(Ce("geometryNormal"));
                                    c = Pe(ie = "tangent", 4);
                                    ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec4",
                                        paramVary: c
                                    }), ae.params.push(c);
                                    break;
                                case "TEXTURE_GF":
                                    j = Te(o, oe.texture);
                                    ae.params.push(j);
                                    var ie;
                                    c = Pe(ie = oe.uvIndex ? "uv" + String(oe.uvIndex + 1) : "uv", 2);
                                    ae.attributes.push({
                                        name: ie,
                                        type: "attribute vec2",
                                        paramVary: c
                                    }), ae.params.push(c);
                                    p = pe.nodeTextures[j.name];
                                    ae.params.push(Se(o, a, p.matrix.toArray(), "trans")), ae.params.push(Ce(ye(p.encoding)))
                            }
                        }
                        for (a = 0; a < e.len(); a++) {
                            var ae, oe;
                            for (o = (oe = (ae = e.node(a)).originData).type, s = 0; s < oe.inputs.length; s++) {
                                var se = oe.inputs[s],
                                    le = Ae(e, a, s, se),
                                    ce = me(o, s);
                                if (le) {
                                    if (ae.inputFactors.length) var ue = ae.inputFactors[s];
                                    else ue = 1;
                                    var de = Re(se);
                                    if (ce) var he = "normal";
                                    else he = De(de, se);
                                    ae.inputs.push({
                                        name: xe(le.name, le.type, de, he, ue),
                                        type: "",
                                        value: null
                                    })
                                } else "MATERIAL_BL" != o && "MATERIAL_EXT_BL" != o || s != Qc ? ce ? ae.inputs.push({
                                    name: "normal",
                                    type: "",
                                    value: null
                                }) : ae.inputs.push({
                                    name: o.toLowerCase() + "_in" + s + "_n" + a,
                                    type: Re(se),
                                    value: se
                                }) : (ae.inputs.push({
                                    name: "normal",
                                    type: "",
                                    value: null
                                }), ae.params[ae.params.length - 1].name = "0")
                            }
                        }
                    }(e),
                    function (e) {
                        var t = [],
                            n = [],
                            r = [],
                            i = [],
                            a = new Dc.TopologicalSort(e).order();
                        pe.defines.NODE_RGB_NUM = pe.nodeRGB.length, pe.defines.NODE_VALUE_NUM = pe.nodeValue.length, pe.defines.NODE_TEX_COORD_NUM = pe.nodeTexCoordObject.length;
                        for (var o = 0; o < a.length; o++) {
                            var s = (m = e.node(a[o])).originData.type;
                            pe.defines["NODE_" + s] = "", "OUTPUT_MATERIAL_BL" != s && "PHYSICAL_MX" != s && "MATERIAL_GF" != s || (pe.defines.STANDARD = "", pe.defines.PHYSICAL = "", pe.advancedPBR && (pe.defines.CLEARCOAT = ""));
                            var l = "node_" + s.toLowerCase() + "_vert";
                            (d = Ki[l]) && t.indexOf(d) < 0 && t.push(d);
                            var c = "node_" + s.toLowerCase() + "_frag";
                            (h = Ki[c]) && r.indexOf(h) < 0 && r.push(h);
                            for (var u = 0; u < m.attributes.length; u++) {
                                var d = (v = m.attributes[u]).type + " " + v.name + ";";
                                "uv" != v.name && t.indexOf(d) < 0 && t.push(d)
                            }
                            for (u = 0; u < m.params.length; u++) {
                                if (A(y = m.params[u])) {
                                    var h = y.type + " " + y.name + ";";
                                    r.indexOf(h) < 0 && r.push(h)
                                } else if (S(y)) {
                                    var p = y.type + " " + y.name + ";";
                                    t.indexOf(p) < 0 && t.push(p);
                                    var f = y.type + " " + y.name + ";";
                                    r.indexOf(f) < 0 && r.push(f)
                                } else y.type && i.push(y.type + " " + y.name + "=" + De(y.type, y.value) + ";")
                            }
                            for (u = 0; u < m.inputs.length; u++) {
                                (x = m.inputs[u]).type && i.push(x.type + " " + x.name + "=" + De(x.type, x.value) + ";")
                            }
                            for (u = 0; u < m.outputs.length; u++) {
                                (b = m.outputs[u]).type && i.push(b.type + " " + b.name + ";")
                            }
                        }
                        for (o = 0; o < a.length; o++) {
                            var m;
                            if ("ATTRIBUTE_BL" == (s = (m = e.node(a[o])).originData.type) || "GEOMETRY_BL" == s || "NEW_GEOMETRY_BL" == s || "NORMAL_MAP_BL" == s || "TEX_COORD_BL" == s || "UVMAP_BL" == s || "BITMAP_MX" == s || "NORMAL_BUMP_MX" == s || "BUMP_MX" == s || "VERTEX_COLOR_MX" == s || "GRADIENT_RAMP_MX" == s || "MATERIAL_GF" == s || "TEXTURE_GF" == s)
                                for (u = 0; u < m.attributes.length; u++) {
                                    var v, g = (v = m.attributes[u]).paramVary.name + "=" + v.name + ";";
                                    n.indexOf(g) < 0 && n.push(g)
                                }
                            var _ = [];
                            for (u = 0; u < m.params.length; u++) {
                                var y = m.params[u];
                                _.push(y.name)
                            }
                            for (u = 0; u < m.inputs.length; u++) {
                                var x = m.inputs[u];
                                _.push(x.name)
                            }
                            for (u = 0; u < m.outputs.length; u++) {
                                var b = m.outputs[u];
                                _.push(b.name)
                            }
                            var w = "node_" + s.toLowerCase().slice(0, -3);
                            switch (s) {
                                case "MATH_BL":
                                case "VECT_MATH_BL":
                                    w += "_" + m.originData.operation.toLowerCase();
                                    break;
                                case "MIX_RGB_BL":
                                    w += "_" + m.originData.blendType.toLowerCase()
                            }
                            i.push(w + "(" + _.join(",") + ");");
                            for (u = 0; u < m.outputs.length; u++) {
                                var M = (b = m.outputs[u]).name;
                                if (b.clamp) {
                                    s = b.type;
                                    i.push(M + "=clamp(" + M + "," + s + "(0.0)," + s + "(1.0));")
                                }
                                b.normalize && i.push(M + "=normalize(" + M + ");")
                            }
                        }
                        pe.nodeChunks.node_pars_vertex = t.join("\n"), pe.nodeChunks.node_vertex = n.join("\n"), pe.nodeChunks.node_pars_fragment = r.join("\n"), pe.nodeChunks.node_fragment = i.join("\n"), pe.nodeChunksHash = Yt.hashString(JSON.stringify(pe.nodeChunks))
                    }(e)
            },
            function (e) {
                for (var t = 0; t < e.len(); t++) {
                    var n = e.node(t),
                        r = n.originData.type;
                    if ("GROUP_BL" != r) {
                        if ("REROUTE_BL" == r) {
                            e.findInEdges(t).length < 1 && x(e, t);
                            for (o = e.findInEdges(t), s = e.findOutEdges(t), m = (d = o[0]).connections[0], c = 0; c < s.length; c++) {
                                h = s[c];
                                (u = new Dc.Edge(d.from(), h.to(), 0)).connections = [];
                                for (f = 0; f < h.connections.length; f++) {
                                    v = h.connections[f], g = {
                                        from: m.from,
                                        to: v.to
                                    };
                                    u.connections.push(g)
                                }
                                e.addEdge(u)
                            }
                            e.disconnect(t, !0), t = -1
                        }
                    } else {
                        var i = n.originData.nodeGraph,
                            a = pe.additionalNodeGraphs[i];
                        if (a.len() <= 2) {
                            for (var o = e.findInEdges(t), s = e.findOutEdges(t), l = Math.min(o.length, s.length), c = 0; c < l; c++) {
                                var u, d = o[c],
                                    h = s[c];
                                (u = new Dc.Edge(d.from(), h.to(), 0)).connections = [];
                                for (var p = Math.min(d.connections.length, h.connections.length), f = 0; f < p; f++) {
                                    var m = d.connections[f],
                                        v = h.connections[f],
                                        g = {
                                            from: m.from,
                                            to: v.to
                                        };
                                    u.connections.push(g)
                                }
                                e.addEdge(u)
                            }
                            e.disconnect(t, !0), t = -1;
                            continue
                        }
                        x(e, t);
                        var _ = b(e, a, t);
                        e.insert(a, _.inputs, _.outputs);
                        for (var y = _.removedNodes.sort(function (e, t) {
                                return t - e
                            }), c = 0; c < y.length; c++) e.disconnect(y[c], !0);
                        t = -1
                    }
                }
            }(pe.nodeGraph),
            function (e) {
                for (var t = 0; t < e.len(); t++) {
                    if ("TEX_IMAGE_BL" == (s = (l = e.node(t).originData).type) && !be(e, t, 0)) {
                        e.addNode({
                            originData: {
                                name: "UVMapGenerated",
                                type: "UVMAP_BL",
                                uvLayer: "",
                                inputs: [],
                                outputs: [
                                    [0, 0, 0]
                                ]
                            }
                        }), pu(e, e.len() - 1, 0, t, 0)
                    }
                    if (("TEX_CHECKER_BL" == s || "TEX_GRADIENT_BL" == s || "TEX_NOISE_BL" == s || "TEX_WAVE_BL" == s || "TEX_VORONOI_BL" == s || "TEX_SKY_BL" == s) && !be(e, t, 0)) {
                        var n = {
                            originData: {
                                name: "TexCoordGenerated",
                                type: "TEX_COORD_BL",
                                inputs: [],
                                outputs: [
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0]
                                ]
                            }
                        };
                        e.addNode(n), pu(e, e.len() - 1, 0, t, 0)
                    }
                    if (("TEX_ENVIRONMENT_BL" == s || "TEX_ENVIRONMENT_MX" == s) && !be(e, t, 0)) {
                        n = {
                            originData: {
                                name: "TexCoordObject",
                                type: "TEX_COORD_BL",
                                inputs: [],
                                outputs: [
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0]
                                ]
                            }
                        };
                        e.addNode(n), pu(e, e.len() - 1, 3, t, 0)
                    }
                    var r = s;
                    if ("BSDF_PRINCIPLED_BL" == r && 20 == l.inputs.length && (r = "BSDF_PRINCIPLED_<2.80.64_BL"), "BUMP_BL" == r && 4 == l.inputs.length && (r = "BUMP_<2.81_BL"), r in du && !be(e, t, du[r])) {
                        var i = {
                            originData: {
                                name: "NewGeomNormal",
                                type: "NEW_GEOMETRY_BL",
                                inputs: [],
                                outputs: [
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0], 0, 0, 0
                                ]
                            }
                        };
                        e.addNode(i), pu(e, e.len() - 1, 1, t, du[r])
                    }
                    if ("BSDF_PRINCIPLED_BL" == r && !be(e, t, Jc) && (0 < l.inputs[Kc] || be(e, t, Kc))) {
                        i = {
                            originData: {
                                name: "NewGeomCoatNormal",
                                type: "NEW_GEOMETRY_BL",
                                inputs: [],
                                outputs: [
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0],
                                    [0, 0, 0], 0, 0, 0
                                ]
                            }
                        };
                        e.addNode(i), pu(e, e.len() - 1, 1, t, Jc)
                    }
                    if ("BITMAP_MX" != s && "BITMAP_ENV_MX" != s || xn(l.mapping) || (l.mapping = "EXPLICIT_MAP_CHANNEL", l.axis = "XY", l.clampToEdgeNoExtend = [!1, !1], console.warn("v3d.MeshNodeMaterial: adding missing params to bitmap node, please reexport your scene")), "GRADIENT_RAMP_MX" == s && (xn(l.mapping) || (l.mapping = "EXPLICIT_MAP_CHANNEL", l.axis = "XY", l.clampToEdgeNoExtend = [!1, !1], console.warn("v3d.MeshNodeMaterial: adding missing params to gradient ramp node, please reexport your scene"))), xn(l.output) && h(e, t, l), f(s)) {
                        if (!xn(l.inputFactors)) {
                            l.inputFactors = [];
                            for (var a = 0; a < l.inputs.length; a++) l.inputFactors.push(1)
                        }
                        l.inputs.push([0, 0, 0]), l.inputFactors.push(0)
                    }
                }
                var o = 0;
                for (t = 0; t < e.len(); t++) {
                    "MATERIAL_MX" != (s = (l = e.node(t).originData).type) && "PHYSICAL_MX" != s || (u(e, t, l), "MATERIAL_MX" == s && (o = l.IOR))
                }
                for (t = 0; t < e.len(); t++) {
                    var s;
                    m(s = (l = e.node(t).originData).type) && (l.IOR = o), m(s) && !xn(l.reflectMode) && (l.reflectMode = "MAX_ENV_COORDS_REFLECT")
                }
                for (t = 0; t < e.len(); t++) {
                    "COMPOSITE_MX" == (l = e.node(t).originData).type && (d(e, t, l), e.disconnect(t, !0))
                }
                for (t = 0; t < e.len(); t++) {
                    var l;
                    switch ((l = e.node(t).originData).type) {
                        case "BSDF_DIFFUSE_BL":
                        case "BSDF_GLOSSY_BL":
                        case "MATERIAL_BL":
                        case "MATERIAL_EXT_BL":
                        case "BSDF_PRINCIPLED_BL":
                            c(e, t, l, 0, "Color");
                            break;
                        case "MATERIAL_GF":
                            c(e, t, l, 0, "Base Color"), c(e, t, l, 2, "Metallic"), c(e, t, l, 3, "Rougness"), c(e, t, l, 5, "Normal Map Scale"), c(e, t, l, 7, "Occlusion"), c(e, t, l, 8, "Direct Light Occlusion"), c(e, t, l, 10, "Emissive");
                            break;
                        case "MATERIAL_MX":
                            c(e, t, l, 0, "Ambient Color") && (l.inputFactors[0] = 1), c(e, t, l, 1, "Diffuse Color") && (l.inputFactors[1] = 1);
                            break;
                        case "PHYSICAL_MX":
                            c(e, t, l, 1, "Base Color") && (l.inputFactors[1] = 1)
                    }
                }
            }(pe.nodeGraph), fu(pe.nodeGraph), this.updateNodeGraph()
    }

    function pu(e, t, n, r, i) {
        e.edge(t, r) || e.addNewEdge(t, r);
        var a = e.edge(t, r);
        a.connections = a.connections || [], a.connections.push({
            from: n,
            to: i
        })
    }

    function fu(t) {
        for (var e = -1, n = 0; n < t.len(); n++)
            if (t.node(n).originData.is_active_output) {
                e = n;
                break
            } if (-1 == e) t.removeAll();
        else {
            var r = new Dc.DepthFirstSearch(t.reverse(), e),
                i = [];
            for (n = 0; n < t.len(); n++) r.hasPathTo(n) || i.push(t.node(n));
            i.forEach(function (e) {
                t.disconnect(t.nodeIndex(e), !0)
            })
        }
    }
    hu.nodeTexUniName = function (e, t) {
        return e.toLowerCase() + "_par_tex_idx" + t
    }, hu.nodeGraphFromGLTFMat = function (e, t) {
        var n = e.pbrMetallicRoughness || {},
            a = [];
        Array.isArray(n.baseColorFactor) ? a.push(n.baseColorFactor) : a.push([1, 1, 1, 1]), a.push([1, 1, 1, 1]), xn(n.metallicFactor) ? a.push(n.metallicFactor) : a.push(1), xn(n.roughnessFactor) ? a.push(n.roughnessFactor) : a.push(1), a.push([1, 1, 1]), xn(e.normalTexture) ? xn(e.normalTexture.scale) ? a.push(e.normalTexture.scale) : a.push(1) : a.push(0), a.push([0, 0, 0]), xn(e.occlusionTexture) ? (xn(e.occlusionTexture.strength) ? a.push(e.occlusionTexture.strength) : a.push(1), t && xn(t.directLightOcclusionFactor) ? a.push(t.directLightOcclusionFactor) : a.push(0)) : (a.push(1), a.push(0)), a.push([1, 1, 1]), xn(e.emissiveFactor) ? a.push(e.emissiveFactor) : a.push([0, 0, 0]), a.push([1, 1, 1]);
        var o = new Dc.DiGraph(1);

        function r(e, t, n) {
            if (!Array.isArray(a[n])) throw new Error("Wrong glTF material input");
            a[n].length;
            for (var r = [], i = 0; i < a[n].length; i++) r.push(0);
            o.addNode({
                originData: {
                    name: hu.nodeTexUniName("TEXTURE_GF", e),
                    type: "TEXTURE_GF",
                    texture: e,
                    uvIndex: t,
                    inputs: [],
                    outputs: [r]
                }
            }), pu(o, o.len() - 1, 0, 0, n)
        }
        o.node(0).originData = {
            name: "Material",
            type: "MATERIAL_GF",
            inputs: a,
            outputs: [],
            is_active_output: !0
        }, xn(n.baseColorTexture) && r(n.baseColorTexture.index, n.baseColorTexture.texCoord || 0, 1);
        xn(n.metallicRoughnessTexture) && r(n.metallicRoughnessTexture.index, n.metallicRoughnessTexture.texCoord || 0, 4);
        xn(e.normalTexture) && r(e.normalTexture.index, e.normalTexture.texCoord || 0, 6);
        xn(e.occlusionTexture) && r(e.occlusionTexture.index, e.occlusionTexture.texCoord || 0, 9);
        xn(e.emissiveTexture) && r(e.emissiveTexture.index, e.emissiveTexture.texCoord || 0, 11);
        return o
    }, hu.nodeGraphFromExtGraph = function (e) {
        for (var t = e.nodes, n = e.edges, r = new Dc.DiGraph(t.length), i = 0; i < t.length; i++) {
            t[i];
            r.node(i).originData = t[i];
            var a = r.node(i).originData,
                o = a.type;
            if (o.endsWith("_BL") || o.endsWith("_GL") || o.endsWith("_MX") || o.endsWith("_MY")) var s = o;
            else if (o.endsWith("_MAX")) s = o.replace("_MAX", "_MX");
            else s = o + "_BL";
            o != (a.type = s) && console.warn("v3d.MeshNodeMaterial: converting node type: " + o + "->" + s + ", please reexport your scene")
        }
        for (i = 0; i < n.length; i++) {
            var l = n[i];
            r.edge(l.fromNode, l.toNode) || r.addNewEdge(l.fromNode, l.toNode);
            var c = r.edge(l.fromNode, l.toNode);
            c.connections = c.connections || [], c.connections.push({
                from: l.fromOutput,
                to: l.toInput
            })
        }
        return fu(r), r
    }, hu.prototype = Object.assign(Object.create(Or.prototype), {
        constructor: hu,
        isMeshNodeMaterial: !0,
        hasNode: function (e) {
            for (var t = 0; t < this.nodeGraph.len(); t++) {
                if (this.nodeGraph.node(t).originData.type == e) return !0
            }
            return !1
        },
        traverseNodes: function (e) {
            for (var t = 0; t < this.nodeGraph.len(); t++) {
                e(this.nodeGraph.node(t))
            }
        },
        findNodeByName: function (e) {
            for (var t = 0; t < this.nodeGraph.len(); t++) {
                var n = this.nodeGraph.node(t);
                if (n.originData.name === e) return n
            }
            return null
        },
        copy: function (e) {
            Or.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Di.clone(e.uniforms), this.defines = e.defines, this.linewidth = e.linewidth, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.index0AttributeName = this.index0AttributeName, this.color.copy(e.color), this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.reflectivity = e.reflectivity, this.extensions = e.extensions, this.profile = e.profile, this.nodeTextures = e.nodeTextures, this.nodeRGB = e.nodeRGB.slice(), this.nodeRGBMap = Object.assign({}, e.nodeRGBMap), this.nodeRGBArr = e.nodeRGBArr.slice(), this.nodeTexCoordObject = e.nodeTexCoordObject.slice(), this.nodeTexCoordObjectMap = Object.assign({}, e.nodeTexCoordObjectMap), this.nodeTexCoordObjectArr = e.nodeTexCoordObjectArr.slice(), this.nodeValue = e.nodeValue.slice(), this.nodeValueMap = Object.assign({}, e.nodeValueMap), this.needsBoundingBox = e.needsBoundingBox, this.nodeGraph = new Dc.DiGraph(e.nodeGraph.len());
            for (var t = 0; t < this.nodeGraph.len(); t++) this.nodeGraph.node(t).originData = e.nodeGraph.node(t).originData;
            for (var n in e.nodeGraph.edges) {
                var r = e.nodeGraph.edges[n];
                this.nodeGraph.addNewEdge(r.from(), r.to()).connections = r.connections.slice()
            }
            return this.additionalNodeGraphs = Object.assign({}, e.additionalNodeGraphs), this.nodeChunks = Object.assign({}, e.nodeChunks), this.nodeChunksHash = e.nodeChunksHash, this.nodeVCAliases = Object.assign({}, e.nodeVCAliases), this.nodeUVAliases = Object.assign({}, e.nodeUVAliases), this
        },
        toJSON: function (e) {
            var t = Or.prototype.toJSON.call(this, e);
            return t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
        }
    });
    var mu = Object.freeze({
            __proto__: null,
            ShadowMaterial: yc,
            SpriteMaterial: ds,
            RawShaderMaterial: xc,
            ShaderMaterial: Oi,
            PointsMaterial: Qs,
            MeshPhysicalMaterial: wc,
            MeshStandardMaterial: bc,
            MeshPhongMaterial: Mc,
            MeshToonMaterial: Ac,
            MeshNormalMaterial: Sc,
            MeshLambertMaterial: Tc,
            MeshDepthMaterial: Uo,
            MeshDistanceMaterial: Vo,
            MeshBasicMaterial: Fr,
            MeshMatcapMaterial: Ec,
            LineDashedMaterial: Cc,
            LineBasicMaterial: Us,
            Material: Or,
            MeshMaskMaterial: Pc,
            MeshNodeMaterial: hu
        }),
        vu = {
            arraySlice: function (e, t, n) {
                return vu.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
            },
            convertArray: function (e, t, n) {
                return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
            },
            isTypedArray: function (e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            },
            getKeyframeOrder: function (n) {
                for (var e = n.length, t = new Array(e), r = 0; r !== e; ++r) t[r] = r;
                return t.sort(function (e, t) {
                    return n[e] - n[t]
                }), t
            },
            sortedArray: function (e, t, n) {
                for (var r = e.length, i = new e.constructor(r), a = 0, o = 0; o !== r; ++a)
                    for (var s = n[a] * t, l = 0; l !== t; ++l) i[o++] = e[s + l];
                return i
            },
            flattenJSON: function (e, t, n, r) {
                for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[r];) a = e[i++];
                if (void 0 !== a) {
                    var o = a[r];
                    if (void 0 !== o)
                        if (Array.isArray(o))
                            for (; void 0 !== (o = a[r]) && (t.push(a.time), n.push.apply(n, o)), void 0 !== (a = e[i++]););
                        else if (void 0 !== o.toArray)
                        for (; void 0 !== (o = a[r]) && (t.push(a.time), o.toArray(n, n.length)), void 0 !== (a = e[i++]););
                    else
                        for (; void 0 !== (o = a[r]) && (t.push(a.time), n.push(o)), void 0 !== (a = e[i++]););
                }
            },
            subclip: function (e, t, n, r, i) {
                i = i || 30;
                var a = e.clone();
                a.name = t;
                for (var o = [], s = 0; s < a.tracks.length; ++s) {
                    for (var l = a.tracks[s], c = l.getValueSize(), u = [], d = [], h = 0; h < l.times.length; ++h) {
                        var p = l.times[h] * i;
                        if (!(p < n || r <= p)) {
                            u.push(l.times[h]);
                            for (var f = 0; f < c; ++f) d.push(l.values[h * c + f])
                        }
                    }
                    0 !== u.length && (l.times = vu.convertArray(u, l.times.constructor), l.values = vu.convertArray(d, l.values.constructor), o.push(l))
                }
                a.tracks = o;
                var m = 1 / 0;
                for (s = 0; s < a.tracks.length; ++s) m > a.tracks[s].times[0] && (m = a.tracks[s].times[0]);
                for (s = 0; s < a.tracks.length; ++s) a.tracks[s].shift(-1 * m);
                return a.resetDuration(), a
            }
        };

    function gu(e, t, n, r) {
        Lc.call(this, e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }

    function _u(e, t, n, r) {
        if (void 0 === e) throw new Error("v3d.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length) throw new Error("v3d.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = vu.convertArray(t, this.TimeBufferType), this.values = vu.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
    }

    function yu(e, t, n) {
        _u.call(this, e, t, n)
    }

    function xu(e, t, n, r) {
        _u.call(this, e, t, n, r)
    }

    function bu(e, t, n, r) {
        _u.call(this, e, t, n, r)
    }

    function wu(e, t, n, r) {
        Lc.call(this, e, t, n, r)
    }

    function Mu(e, t, n, r) {
        _u.call(this, e, t, n, r)
    }

    function Au(e, t, n, r) {
        _u.call(this, e, t, n, r)
    }

    function Su(e, t, n, r) {
        _u.call(this, e, t, n, r)
    }

    function Tu(e, t, n) {
        this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = Yt.generateUUID(), this.duration < 0 && this.resetDuration()
    }

    function Eu(e) {
        if (void 0 === e.type) throw new Error("v3d.KeyframeTrack: track type undefined, can not parse");
        var t = function (e) {
            switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return bu;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Su;
                case "color":
                    return xu;
                case "quaternion":
                    return Mu;
                case "bool":
                case "boolean":
                    return yu;
                case "string":
                    return Au
            }
            throw new Error("v3d.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            var n = [],
                r = [];
            vu.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
    }
    gu.prototype = Object.assign(Object.create(Lc.prototype), {
        constructor: gu,
        DefaultSettings_: {
            endingStart: bt,
            endingEnd: bt
        },
        intervalChanged_: function (e, t, n) {
            var r = this.parameterPositions,
                i = e - 2,
                a = e + 1,
                o = r[i],
                s = r[a];
            if (void 0 === o) switch (this.getSettings_().endingStart) {
                case wt:
                    i = e, o = 2 * t - n;
                    break;
                case Mt:
                    o = t + r[i = r.length - 2] - r[i + 1];
                    break;
                default:
                    i = e, o = n
            }
            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                case wt:
                    a = e, s = 2 * n - t;
                    break;
                case Mt:
                    s = n + r[a = 1] - r[0];
                    break;
                default:
                    a = e - 1, s = t
            }
            var l = .5 * (n - t),
                c = this.valueSize;
            this._weightPrev = l / (t - o), this._weightNext = l / (s - n), this._offsetPrev = i * c, this._offsetNext = a * c
        },
        interpolate_: function (e, t, n, r) {
            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = this._offsetPrev, u = this._offsetNext, d = this._weightPrev, h = this._weightNext, p = (n - t) / (r - t), f = p * p, m = f * p, v = -d * m + 2 * d * f - d * p, g = (1 + d) * m + (-1.5 - 2 * d) * f + (-.5 + d) * p + 1, _ = (-1 - h) * m + (1.5 + h) * f + .5 * p, y = h * m - h * f, x = 0; x !== o; ++x) i[x] = v * a[c + x] + g * a[l + x] + _ * a[s + x] + y * a[u + x];
            return i
        }
    }), Object.assign(_u, {
        toJSON: function (e) {
            var t, n = e.constructor;
            if (void 0 !== n.toJSON) t = n.toJSON(e);
            else {
                t = {
                    name: e.name,
                    times: vu.convertArray(e.times, Array),
                    values: vu.convertArray(e.values, Array)
                };
                var r = e.getInterpolation();
                r !== e.DefaultInterpolation && (t.interpolation = r)
            }
            return t.type = e.ValueTypeName, t
        }
    }), Object.assign(_u.prototype, {
        constructor: _u,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: yt,
        InterpolantFactoryMethodDiscrete: function (e) {
            return new Rc(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodLinear: function (e) {
            return new Vc(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: function (e) {
            return new gu(this.times, this.values, this.getValueSize(), e)
        },
        setInterpolation: function (e) {
            var t;
            switch (e) {
                case _t:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case yt:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case xt:
                    t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 !== t) return this.createInterpolant = t, this;
            var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
                if (e === this.DefaultInterpolation) throw new Error(n);
                this.setInterpolation(this.DefaultInterpolation)
            }
            return console.warn("v3d.KeyframeTrack:", n), this
        },
        getInterpolation: function () {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return _t;
                case this.InterpolantFactoryMethodLinear:
                    return yt;
                case this.InterpolantFactoryMethodSmooth:
                    return xt
            }
        },
        getValueSize: function () {
            return this.values.length / this.times.length
        },
        shift: function (e) {
            if (0 !== e)
                for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
            return this
        },
        scale: function (e) {
            if (1 !== e)
                for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
            return this
        },
        trim: function (e, t) {
            for (var n = this.times, r = n.length, i = 0, a = r - 1; i !== r && n[i] < e;) ++i;
            for (; - 1 !== a && n[a] > t;) --a;
            if (++a, 0 !== i || a !== r) {
                a <= i && (i = (a = Math.max(a, 1)) - 1);
                var o = this.getValueSize();
                this.times = vu.arraySlice(n, i, a), this.values = vu.arraySlice(this.values, i * o, a * o)
            }
            return this
        },
        validate: function () {
            var e = !0,
                t = this.getValueSize();
            t - Math.floor(t) != 0 && (console.error("v3d.KeyframeTrack: Invalid value size in track.", this), e = !1);
            var n = this.times,
                r = this.values,
                i = n.length;
            0 === i && (console.error("v3d.KeyframeTrack: Track is empty.", this), e = !1);
            for (var a = null, o = 0; o !== i; o++) {
                var s = n[o];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("v3d.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1;
                    break
                }
                if (null !== a && s < a) {
                    console.error("v3d.KeyframeTrack: Out of order keys.", this, o, s, a), e = !1;
                    break
                }
                a = s
            }
            if (void 0 !== r && vu.isTypedArray(r)) {
                o = 0;
                for (var l = r.length; o !== l; ++o) {
                    var c = r[o];
                    if (isNaN(c)) {
                        console.error("v3d.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1;
                        break
                    }
                }
            }
            return e
        },
        optimize: function () {
            for (var e = vu.arraySlice(this.times), t = vu.arraySlice(this.values), n = this.getValueSize(), r = this.getInterpolation() === xt, i = 1, a = e.length - 1, o = 1; o < a; ++o) {
                var s = !1,
                    l = e[o];
                if (l !== e[o + 1] && (1 !== o || l !== l[0]))
                    if (r) s = !0;
                    else
                        for (var c = o * n, u = c - n, d = c + n, h = 0; h !== n; ++h) {
                            var p = t[c + h];
                            if (p !== t[u + h] || p !== t[d + h]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (o !== i) {
                        e[i] = e[o];
                        var f = o * n,
                            m = i * n;
                        for (h = 0; h !== n; ++h) t[m + h] = t[f + h]
                    }++i
                }
            }
            if (0 < a) {
                e[i] = e[a];
                for (f = a * n, m = i * n, h = 0; h !== n; ++h) t[m + h] = t[f + h];
                ++i
            }
            return i !== e.length ? (this.times = vu.arraySlice(e, 0, i), this.values = vu.arraySlice(t, 0, i * n)) : (this.times = e, this.values = t), this
        },
        clone: function () {
            var e = vu.arraySlice(this.times, 0),
                t = vu.arraySlice(this.values, 0),
                n = new this.constructor(this.name, e, t);
            return n.createInterpolant = this.createInterpolant, n
        }
    }), yu.prototype = Object.assign(Object.create(_u.prototype), {
        constructor: yu,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: _t,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), xu.prototype = Object.assign(Object.create(_u.prototype), {
        constructor: xu,
        ValueTypeName: "color"
    }), bu.prototype = Object.assign(Object.create(_u.prototype), {
        constructor: bu,
        ValueTypeName: "number"
    }), wu.prototype = Object.assign(Object.create(Lc.prototype), {
        constructor: wu,
        interpolate_: function (e, t, n, r) {
            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = (n - t) / (r - t), c = s + o; s !== c; s += 4) nn.slerpFlat(i, 0, a, s - o, a, s, l);
            return i
        }
    }), Mu.prototype = Object.assign(Object.create(_u.prototype), {
        constructor: Mu,
        ValueTypeName: "quaternion",
        DefaultInterpolation: yt,
        InterpolantFactoryMethodLinear: function (e) {
            return new wu(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), Au.prototype = Object.assign(Object.create(_u.prototype), {
        constructor: Au,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: _t,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), Su.prototype = Object.assign(Object.create(_u.prototype), {
        constructor: Su,
        ValueTypeName: "vector"
    }), Object.assign(Tu, {
        parse: function (e) {
            for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, a = n.length; i !== a; ++i) t.push(Eu(n[i]).scale(r));
            return new Tu(e.name, e.duration, t)
        },
        toJSON: function (e) {
            for (var t = [], n = e.tracks, r = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t,
                    uuid: e.uuid
                }, i = 0, a = n.length; i !== a; ++i) t.push(_u.toJSON(n[i]));
            return r
        },
        CreateFromMorphTargetSequence: function (e, t, n, r) {
            for (var i = t.length, a = [], o = 0; o < i; o++) {
                var s = [],
                    l = [];
                s.push((o + i - 1) % i, o, (o + 1) % i), l.push(0, 1, 0);
                var c = vu.getKeyframeOrder(s);
                s = vu.sortedArray(s, 1, c), l = vu.sortedArray(l, 1, c), r || 0 !== s[0] || (s.push(i), l.push(l[0])), a.push(new bu(".morphTargetInfluences[" + t[o].name + "]", s, l).scale(1 / n))
            }
            return new Tu(e, -1, a)
        },
        findByName: function (e, t) {
            var n = e;
            if (!Array.isArray(e)) {
                n = e.geometry && e.geometry.animations || e.animations
            }
            for (var r = 0; r < n.length; r++)
                if (n[r].name === t) return n[r];
            return null
        },
        CreateClipsFromMorphTargetSequences: function (e, t, n) {
            for (var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                var s = e[a],
                    l = s.name.match(i);
                if (l && 1 < l.length) {
                    var c = r[d = l[1]];
                    c || (r[d] = c = []), c.push(s)
                }
            }
            var u = [];
            for (var d in r) u.push(Tu.CreateFromMorphTargetSequence(d, r[d], t, n));
            return u
        },
        parseAnimation: function (e, t) {
            if (!e) return console.error("v3d.AnimationClip: No animation in JSONLoader data."), null;
            for (var n = function (e, t, n, r, i) {
                    if (0 !== n.length) {
                        var a = [],
                            o = [];
                        vu.flattenJSON(n, a, o, r), 0 !== a.length && i.push(new e(t, a, o))
                    }
                }, r = [], i = e.name || "default", a = e.length || -1, o = e.fps || 30, s = e.hierarchy || [], l = 0; l < s.length; l++) {
                var c = s[l].keys;
                if (c && 0 !== c.length)
                    if (c[0].morphTargets) {
                        for (var u = {}, d = 0; d < c.length; d++)
                            if (c[d].morphTargets)
                                for (var h = 0; h < c[d].morphTargets.length; h++) u[c[d].morphTargets[h]] = -1;
                        for (var p in u) {
                            var f = [],
                                m = [];
                            for (h = 0; h !== c[d].morphTargets.length; ++h) {
                                var v = c[d];
                                f.push(v.time), m.push(v.morphTarget === p ? 1 : 0)
                            }
                            r.push(new bu(".morphTargetInfluence[" + p + "]", f, m))
                        }
                        a = u.length * (o || 1)
                    } else {
                        var g = ".bones[" + t[l].name + "]";
                        n(Su, g + ".position", c, "pos", r), n(Mu, g + ".quaternion", c, "rot", r), n(Su, g + ".scale", c, "scl", r)
                    }
            }
            return 0 === r.length ? null : new Tu(i, a, r)
        }
    }), Object.assign(Tu.prototype, {
        resetDuration: function () {
            for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                var r = this.tracks[t];
                e = Math.max(e, r.times[r.times.length - 1])
            }
            return this.duration = e, this
        },
        trim: function () {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        },
        validate: function () {
            for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e
        },
        optimize: function () {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        },
        clone: function () {
            for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
            return new Tu(this.name, this.duration, e)
        }
    });
    var Cu = {
        enabled: !1,
        files: {},
        add: function (e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function (e) {
            if (!1 !== this.enabled) return this.files[e]
        },
        remove: function (e) {
            delete this.files[e]
        },
        clear: function () {
            this.files = {}
        }
    };

    function Pu(e, t, n) {
        var r = this,
            i = !1,
            a = 0,
            o = 0,
            s = void 0,
            l = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) {
            o++, !1 === i && void 0 !== r.onStart && r.onStart(e, a, o), i = !0
        }, this.itemEnd = function (e) {
            a++, void 0 !== r.onProgress && r.onProgress(e, a, o), a === o && (i = !1, void 0 !== r.onLoad && r.onLoad())
        }, this.itemError = function (e) {
            void 0 !== r.onError && r.onError(e)
        }, this.resolveURL = function (e) {
            return s ? s(e) : e
        }, this.setURLModifier = function (e) {
            return s = e, this
        }, this.addHandler = function (e, t) {
            return l.push(e, t), this
        }, this.removeHandler = function (e) {
            var t = l.indexOf(e);
            return -1 !== t && l.splice(t, 2), this
        }, this.getHandler = function (e) {
            for (var t = 0, n = l.length; t < n; t += 2) {
                var r = l[t],
                    i = l[t + 1];
                if (r.global && (r.lastIndex = 0), r.test(e)) return i
            }
            return null
        }
    }
    var Lu = new Pu;

    function Ru(e) {
        this.manager = void 0 !== e ? e : Lu, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = ""
    }
    Object.assign(Ru.prototype, {
        load: function () {},
        parse: function () {},
        setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        },
        setPath: function (e) {
            return this.path = e, this
        },
        setResourcePath: function (e) {
            return this.resourcePath = e, this
        }
    });
    var Du = {};

    function Iu(e) {
        Ru.call(this, e)
    }

    function Nu(e) {
        Ru.call(this, e)
    }

    function Ou(e) {
        Ru.call(this, e)
    }

    function Fu(e) {
        Ru.call(this, e)
    }

    function Bu(e) {
        Ru.call(this, e)
    }

    function zu(e) {
        Ru.call(this, e)
    }

    function Uu(e) {
        Ru.call(this, e)
    }

    function Vu() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function Gu(e, t, n, r, i, a, o, s) {
        Vu.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
    }

    function ku(e, t, n, r, i, a) {
        Gu.call(this, e, t, n, n, r, i, a), this.type = "ArcCurve"
    }

    function ju() {
        var i = 0,
            a = 0,
            o = 0,
            s = 0;

        function c(e, t, n, r) {
            o = -3 * (i = e) + 3 * t - 2 * (a = n) - r, s = 2 * e - 2 * t + n + r
        }
        return {
            initCatmullRom: function (e, t, n, r, i) {
                c(t, n, i * (n - e), i * (r - t))
            },
            initNonuniformCatmullRom: function (e, t, n, r, i, a, o) {
                var s = (t - e) / i - (n - e) / (i + a) + (n - t) / a,
                    l = (n - t) / a - (r - t) / (a + o) + (r - n) / o;
                c(t, n, s *= a, l *= a)
            },
            calc: function (e) {
                var t = e * e;
                return i + a * e + o * t + s * (t * e)
            }
        }
    }
    Iu.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Iu,
        load: function (o, e, t, n) {
            void 0 === o && (o = ""), void 0 !== this.path && (o = this.path + o), o = this.manager.resolveURL(o);
            var s = this,
                r = Cu.get(o);
            if (void 0 !== r) return s.manager.itemStart(o), setTimeout(function () {
                e && e(r), s.manager.itemEnd(o)
            }, 0), r;
            if (void 0 === Du[o]) {
                var i = o.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (i) {
                    var a = i[1],
                        l = !!i[2],
                        c = i[3];
                    c = decodeURIComponent(c), l && (c = atob(c));
                    try {
                        var u, d = (this.responseType || "").toLowerCase();
                        switch (d) {
                            case "arraybuffer":
                            case "blob":
                                for (var h = new Uint8Array(c.length), p = 0; p < c.length; p++) h[p] = c.charCodeAt(p);
                                u = "blob" === d ? new Blob([h.buffer], {
                                    type: a
                                }) : h.buffer;
                                break;
                            case "document":
                                var f = new DOMParser;
                                u = f.parseFromString(c, a);
                                break;
                            case "json":
                                u = JSON.parse(c);
                                break;
                            default:
                                u = c
                        }
                        setTimeout(function () {
                            e && e(u), s.manager.itemEnd(o)
                        }, 0)
                    } catch (e) {
                        setTimeout(function () {
                            n && n(e), s.manager.itemError(o), s.manager.itemEnd(o)
                        }, 0)
                    }
                } else {
                    Du[o] = [], Du[o].push({
                        onLoad: e,
                        onProgress: t,
                        onError: n
                    });
                    var m = new XMLHttpRequest;
                    for (var v in m.open("GET", o, !0), m.addEventListener("load", function (e) {
                            var t = this.response,
                                n = Du[o];
                            if (delete Du[o], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("v3d.FileLoader: HTTP Status 0 received."), Cu.add(o, t);
                                for (var r = 0, i = n.length; r < i; r++) {
                                    (a = n[r]).onLoad && a.onLoad(t)
                                }
                                s.manager.itemEnd(o)
                            } else {
                                for (r = 0, i = n.length; r < i; r++) {
                                    var a;
                                    (a = n[r]).onError && a.onError(e)
                                }
                                s.manager.itemError(o), s.manager.itemEnd(o)
                            }
                        }, !1), m.addEventListener("progress", function (e) {
                            for (var t = Du[o], n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                i.onProgress && i.onProgress(e)
                            }
                        }, !1), m.addEventListener("error", function (e) {
                            var t = Du[o];
                            delete Du[o];
                            for (var n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                i.onError && i.onError(e)
                            }
                            s.manager.itemError(o), s.manager.itemEnd(o)
                        }, !1), m.addEventListener("abort", function (e) {
                            var t = Du[o];
                            delete Du[o];
                            for (var n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                i.onError && i.onError(e)
                            }
                            s.manager.itemError(o), s.manager.itemEnd(o)
                        }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                    m.send(null)
                }
                return s.manager.itemStart(o), m
            }
            Du[o].push({
                onLoad: e,
                onProgress: t,
                onError: n
            })
        },
        setResponseType: function (e) {
            return this.responseType = e, this
        },
        setWithCredentials: function (e) {
            return this.withCredentials = e, this
        },
        setMimeType: function (e) {
            return this.mimeType = e, this
        },
        setRequestHeader: function (e) {
            return this.requestHeader = e, this
        }
    }), Nu.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Nu,
        load: function (e, t, n, r) {
            var i = this,
                a = new Iu(i.manager);
            a.setPath(i.path), a.load(e, function (e) {
                t(i.parse(JSON.parse(e)))
            }, n, r)
        },
        parse: function (e) {
            for (var t = [], n = 0; n < e.length; n++) {
                var r = Tu.parse(e[n]);
                t.push(r)
            }
            return t
        }
    }), Ou.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Ou,
        load: function (e, a, t, r) {
            var o = this,
                s = [],
                l = new il;
            l.image = s;
            var i = new Iu(this.manager);

            function n(n) {
                i.load(e[n], function (e) {
                    var t = o.parse(e, !0);
                    s[n] = {
                        width: t.width,
                        height: t.height,
                        format: t.format,
                        mipmaps: t.mipmaps
                    }, 6 === (c += 1) && (1 === t.mipmapCount && (l.minFilter = Je), l.format = t.format, l.needsUpdate = !0, a && a(l))
                }, t, r)
            }
            if (i.setPath(this.path), i.setResponseType("arraybuffer"), Array.isArray(e))
                for (var c = 0, u = 0, d = e.length; u < d; ++u) n(u);
            else i.load(e, function (e) {
                var t = o.parse(e, !0);
                if (t.isCubemap)
                    for (var n = t.mipmaps.length / t.mipmapCount, r = 0; r < n; r++) {
                        s[r] = {
                            mipmaps: []
                        };
                        for (var i = 0; i < t.mipmapCount; i++) s[r].mipmaps.push(t.mipmaps[r * t.mipmapCount + i]), s[r].format = t.format, s[r].width = t.width, s[r].height = t.height
                    } else l.image.width = t.width, l.image.height = t.height, l.mipmaps = t.mipmaps;
                1 === t.mipmapCount && (l.minFilter = Je), l.format = t.format, l.needsUpdate = !0, a && a(l)
            }, t, r);
            return l
        }
    }), Fu.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Fu,
        load: function (e, n, t, r) {
            var i = this,
                a = new Vi,
                o = new Iu(this.manager);
            return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(e, function (e) {
                var t = i.parse(e);
                t && (void 0 !== t.image ? a.image = t.image : void 0 !== t.data && (a.image.width = t.width, a.image.height = t.height, a.image.data = t.data), a.wrapS = void 0 !== t.wrapS ? t.wrapS : Ye, a.wrapT = void 0 !== t.wrapT ? t.wrapT : Ye, a.magFilter = void 0 !== t.magFilter ? t.magFilter : Je, a.minFilter = void 0 !== t.minFilter ? t.minFilter : Je, a.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (a.format = t.format), void 0 !== t.type && (a.type = t.type), void 0 !== t.mipmaps && (a.mipmaps = t.mipmaps, a.minFilter = et), 1 === t.mipmapCount && (a.minFilter = Je), a.needsUpdate = !0, n && n(a, t))
            }, t, r), a
        }
    }), Bu.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Bu,
        load: function (t, e, n, r) {
            void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var i = this,
                a = Cu.get(t);
            if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function () {
                e && e(a), i.manager.itemEnd(t)
            }, 0), a;
            var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

            function s() {
                o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), Cu.add(t, this), e && e(this), i.manager.itemEnd(t)
            }

            function l(e) {
                o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
            }
            return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(t), o.src = t, o
        }
    }), zu.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: zu,
        load: function (e, n, t, r) {
            var i = new ua,
                a = new Bu(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            var o = 0;

            function s(t) {
                a.load(e[t], function (e) {
                    i.images[t] = e, 6 === ++o && (i.needsUpdate = !0, n && n(i))
                }, void 0, r)
            }
            for (var l = 0; l < e.length; ++l) s(l);
            return i
        }
    }), Uu.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Uu,
        load: function (n, r, e, t) {
            var i = new Jt,
                a = new Bu(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(n, function (e) {
                i.image = e;
                var t = 0 < n.search(/\.jpe?g($|\?)/i) || 0 === n.search(/^data\:image\/jpeg/);
                i.format = t ? st : lt, i.needsUpdate = !0, void 0 !== r && r(i)
            }, e, t), i
        }
    }), Object.assign(Vu.prototype, {
        getPoint: function () {
            return console.warn("v3d.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function (e, t) {
            var n = this.getUtoTmapping(e);
            return this.getPoint(n, t)
        },
        getPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return t
        },
        getSpacedPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
            return t
        },
        getLength: function () {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function (e) {
            if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, n, r = [],
                i = this.getPoint(0),
                a = 0;
            for (r.push(0), n = 1; n <= e; n++) a += (t = this.getPoint(n / e)).distanceTo(i), r.push(a), i = t;
            return this.cacheArcLengths = r
        },
        updateArcLengths: function () {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function (e, t) {
            var n, r = this.getLengths(),
                i = 0,
                a = r.length;
            n = t || e * r[a - 1];
            for (var o, s = 0, l = a - 1; s <= l;)
                if ((o = r[i = Math.floor(s + (l - s) / 2)] - n) < 0) s = i + 1;
                else {
                    if (!(0 < o)) {
                        l = i;
                        break
                    }
                    l = i - 1
                } if (r[i = l] === n) return i / (a - 1);
            var c = r[i];
            return (i + (n - c) / (r[i + 1] - c)) / (a - 1)
        },
        getTangent: function (e) {
            var t = e - 1e-4,
                n = e + 1e-4;
            t < 0 && (t = 0), 1 < n && (n = 1);
            var r = this.getPoint(t);
            return this.getPoint(n).clone().sub(r).normalize()
        },
        getTangentAt: function (e) {
            var t = this.getUtoTmapping(e);
            return this.getTangent(t)
        },
        computeFrenetFrames: function (e, t) {
            var n, r, i, a = new on,
                o = [],
                s = [],
                l = [],
                c = new on,
                u = new fn;
            for (n = 0; n <= e; n++) r = n / e, o[n] = this.getTangentAt(r), o[n].normalize();
            s[0] = new on, l[0] = new on;
            var d = Number.MAX_VALUE,
                h = Math.abs(o[0].x),
                p = Math.abs(o[0].y),
                f = Math.abs(o[0].z);
            for (h <= d && (d = h, a.set(1, 0, 0)), p <= d && (d = p, a.set(0, 1, 0)), f <= d && a.set(0, 0, 1), c.crossVectors(o[0], a).normalize(), s[0].crossVectors(o[0], c), l[0].crossVectors(o[0], s[0]), n = 1; n <= e; n++) s[n] = s[n - 1].clone(), l[n] = l[n - 1].clone(), c.crossVectors(o[n - 1], o[n]), c.length() > Number.EPSILON && (c.normalize(), i = Math.acos(Yt.clamp(o[n - 1].dot(o[n]), -1, 1)), s[n].applyMatrix4(u.makeRotationAxis(c, i))), l[n].crossVectors(o[n], s[n]);
            if (!0 === t)
                for (i = Math.acos(Yt.clamp(s[0].dot(s[e]), -1, 1)), i /= e, 0 < o[0].dot(c.crossVectors(s[0], s[e])) && (i = -i), n = 1; n <= e; n++) s[n].applyMatrix4(u.makeRotationAxis(o[n], i * n)), l[n].crossVectors(o[n], s[n]);
            return {
                tangents: o,
                normals: s,
                binormals: l
            }
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        },
        toJSON: function () {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
        },
        fromJSON: function (e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        }
    }), ((Gu.prototype = Object.create(Vu.prototype)).constructor = Gu).prototype.isEllipseCurve = !0, Gu.prototype.getPoint = function (e, t) {
        for (var n = t || new qt, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, a = Math.abs(i) < Number.EPSILON; i < 0;) i += r;
        for (; r < i;) i -= r;
        i < Number.EPSILON && (i = a ? 0 : r), !0 !== this.aClockwise || a || (i === r ? i = -r : i -= r);
        var o = this.aStartAngle + e * i,
            s = this.aX + this.xRadius * Math.cos(o),
            l = this.aY + this.yRadius * Math.sin(o);
        if (0 !== this.aRotation) {
            var c = Math.cos(this.aRotation),
                u = Math.sin(this.aRotation),
                d = s - this.aX,
                h = l - this.aY;
            s = d * c - h * u + this.aX, l = d * u + h * c + this.aY
        }
        return n.set(s, l)
    }, Gu.prototype.copy = function (e) {
        return Vu.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, Gu.prototype.toJSON = function () {
        var e = Vu.prototype.toJSON.call(this);
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }, Gu.prototype.fromJSON = function (e) {
        return Vu.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, ((ku.prototype = Object.create(Gu.prototype)).constructor = ku).prototype.isArcCurve = !0;
    var Wu = new on,
        Xu = new ju,
        Hu = new ju,
        Yu = new ju;

    function qu(e, t, n, r) {
        Vu.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = r || .5
    }

    function Zu(e, t, n, r, i) {
        var a = .5 * (r - t),
            o = .5 * (i - n),
            s = e * e;
        return (2 * n - 2 * r + a + o) * (e * s) + (-3 * n + 3 * r - 2 * a - o) * s + a * e + n
    }

    function Qu(e, t, n, r) {
        return (o = 1 - e) * o * t + 2 * (1 - (a = e)) * a * n + (i = e) * i * r;
        var i, a, o
    }

    function Ku(e, t, n, r, i) {
        return (c = 1 - e) * c * c * t + 3 * (l = 1 - (s = e)) * l * s * n + 3 * (1 - (o = e)) * o * o * r + (a = e) * a * a * i;
        var a, o, s, l, c
    }

    function Ju(e, t, n, r) {
        Vu.call(this), this.type = "CubicBezierCurve", this.v0 = e || new qt, this.v1 = t || new qt, this.v2 = n || new qt, this.v3 = r || new qt
    }

    function $u(e, t, n, r) {
        Vu.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new on, this.v1 = t || new on, this.v2 = n || new on, this.v3 = r || new on
    }

    function ed(e, t) {
        Vu.call(this), this.type = "LineCurve", this.v1 = e || new qt, this.v2 = t || new qt
    }

    function td(e, t) {
        Vu.call(this), this.type = "LineCurve3", this.v1 = e || new on, this.v2 = t || new on
    }

    function nd(e, t, n) {
        Vu.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new qt, this.v1 = t || new qt, this.v2 = n || new qt
    }

    function rd(e, t, n) {
        Vu.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new on, this.v1 = t || new on, this.v2 = n || new on
    }

    function id(e) {
        Vu.call(this), this.type = "SplineCurve", this.points = e || []
    }((qu.prototype = Object.create(Vu.prototype)).constructor = qu).prototype.isCatmullRomCurve3 = !0, qu.prototype.getPoint = function (e, t) {
        var n, r, i, a, o = t || new on,
            s = this.points,
            l = s.length,
            c = (l - (this.closed ? 0 : 1)) * e,
            u = Math.floor(c),
            d = c - u;
        if (this.closed ? u += 0 < u ? 0 : (Math.floor(Math.abs(u) / l) + 1) * l : 0 === d && u === l - 1 && (u = l - 2, d = 1), n = this.closed || 0 < u ? s[(u - 1) % l] : (Wu.subVectors(s[0], s[1]).add(s[0]), Wu), r = s[u % l], i = s[(u + 1) % l], a = this.closed || u + 2 < l ? s[(u + 2) % l] : (Wu.subVectors(s[l - 1], s[l - 2]).add(s[l - 1]), Wu), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var h = "chordal" === this.curveType ? .5 : .25,
                p = Math.pow(n.distanceToSquared(r), h),
                f = Math.pow(r.distanceToSquared(i), h),
                m = Math.pow(i.distanceToSquared(a), h);
            f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), Xu.initNonuniformCatmullRom(n.x, r.x, i.x, a.x, p, f, m), Hu.initNonuniformCatmullRom(n.y, r.y, i.y, a.y, p, f, m), Yu.initNonuniformCatmullRom(n.z, r.z, i.z, a.z, p, f, m)
        } else "catmullrom" === this.curveType && (Xu.initCatmullRom(n.x, r.x, i.x, a.x, this.tension), Hu.initCatmullRom(n.y, r.y, i.y, a.y, this.tension), Yu.initCatmullRom(n.z, r.z, i.z, a.z, this.tension));
        return o.set(Xu.calc(d), Hu.calc(d), Yu.calc(d)), o
    }, qu.prototype.copy = function (e) {
        Vu.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, qu.prototype.toJSON = function () {
        var e = Vu.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, n = this.points.length; t < n; t++) {
            var r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }, qu.prototype.fromJSON = function (e) {
        Vu.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push((new on).fromArray(r))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, ((Ju.prototype = Object.create(Vu.prototype)).constructor = Ju).prototype.isCubicBezierCurve = !0, Ju.prototype.getPoint = function (e, t) {
        var n = t || new qt,
            r = this.v0,
            i = this.v1,
            a = this.v2,
            o = this.v3;
        return n.set(Ku(e, r.x, i.x, a.x, o.x), Ku(e, r.y, i.y, a.y, o.y)), n
    }, Ju.prototype.copy = function (e) {
        return Vu.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, Ju.prototype.toJSON = function () {
        var e = Vu.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, Ju.prototype.fromJSON = function (e) {
        return Vu.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, (($u.prototype = Object.create(Vu.prototype)).constructor = $u).prototype.isCubicBezierCurve3 = !0, $u.prototype.getPoint = function (e, t) {
        var n = t || new on,
            r = this.v0,
            i = this.v1,
            a = this.v2,
            o = this.v3;
        return n.set(Ku(e, r.x, i.x, a.x, o.x), Ku(e, r.y, i.y, a.y, o.y), Ku(e, r.z, i.z, a.z, o.z)), n
    }, $u.prototype.copy = function (e) {
        return Vu.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, $u.prototype.toJSON = function () {
        var e = Vu.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, $u.prototype.fromJSON = function (e) {
        return Vu.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, ((ed.prototype = Object.create(Vu.prototype)).constructor = ed).prototype.isLineCurve = !0, ed.prototype.getPoint = function (e, t) {
        var n = t || new qt;
        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
    }, ed.prototype.getPointAt = function (e, t) {
        return this.getPoint(e, t)
    }, ed.prototype.getTangent = function () {
        return this.v2.clone().sub(this.v1).normalize()
    }, ed.prototype.copy = function (e) {
        return Vu.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, ed.prototype.toJSON = function () {
        var e = Vu.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, ed.prototype.fromJSON = function (e) {
        return Vu.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((td.prototype = Object.create(Vu.prototype)).constructor = td).prototype.isLineCurve3 = !0, td.prototype.getPoint = function (e, t) {
        var n = t || new on;
        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
    }, td.prototype.getPointAt = function (e, t) {
        return this.getPoint(e, t)
    }, td.prototype.copy = function (e) {
        return Vu.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, td.prototype.toJSON = function () {
        var e = Vu.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, td.prototype.fromJSON = function (e) {
        return Vu.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((nd.prototype = Object.create(Vu.prototype)).constructor = nd).prototype.isQuadraticBezierCurve = !0, nd.prototype.getPoint = function (e, t) {
        var n = t || new qt,
            r = this.v0,
            i = this.v1,
            a = this.v2;
        return n.set(Qu(e, r.x, i.x, a.x), Qu(e, r.y, i.y, a.y)), n
    }, nd.prototype.copy = function (e) {
        return Vu.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, nd.prototype.toJSON = function () {
        var e = Vu.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, nd.prototype.fromJSON = function (e) {
        return Vu.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((rd.prototype = Object.create(Vu.prototype)).constructor = rd).prototype.isQuadraticBezierCurve3 = !0, rd.prototype.getPoint = function (e, t) {
        var n = t || new on,
            r = this.v0,
            i = this.v1,
            a = this.v2;
        return n.set(Qu(e, r.x, i.x, a.x), Qu(e, r.y, i.y, a.y), Qu(e, r.z, i.z, a.z)), n
    }, rd.prototype.copy = function (e) {
        return Vu.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, rd.prototype.toJSON = function () {
        var e = Vu.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, rd.prototype.fromJSON = function (e) {
        return Vu.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((id.prototype = Object.create(Vu.prototype)).constructor = id).prototype.isSplineCurve = !0, id.prototype.getPoint = function (e, t) {
        var n = t || new qt,
            r = this.points,
            i = (r.length - 1) * e,
            a = Math.floor(i),
            o = i - a,
            s = r[0 === a ? a : a - 1],
            l = r[a],
            c = r[a > r.length - 2 ? r.length - 1 : a + 1],
            u = r[a > r.length - 3 ? r.length - 1 : a + 2];
        return n.set(Zu(o, s.x, l.x, c.x, u.x), Zu(o, s.y, l.y, c.y, u.y)), n
    }, id.prototype.copy = function (e) {
        Vu.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }, id.prototype.toJSON = function () {
        var e = Vu.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, n = this.points.length; t < n; t++) {
            var r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }, id.prototype.fromJSON = function (e) {
        Vu.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push((new qt).fromArray(r))
        }
        return this
    };
    var ad, od, sd, ld = Object.freeze({
        __proto__: null,
        ArcCurve: ku,
        CatmullRomCurve3: qu,
        CubicBezierCurve: Ju,
        CubicBezierCurve3: $u,
        EllipseCurve: Gu,
        LineCurve: ed,
        LineCurve3: td,
        QuadraticBezierCurve: nd,
        QuadraticBezierCurve3: rd,
        SplineCurve: id
    });

    function cd() {
        Vu.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function ud(e) {
        cd.call(this), this.type = "Path", this.currentPoint = new qt, e && this.setFromPoints(e)
    }

    function dd(e) {
        ud.call(this, e), this.uuid = Yt.generateUUID(), this.type = "Shape", this.holes = []
    }

    function hd(e, t) {
        Fn.call(this), this.type = "Light", this.color = new Pr(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0, this.isFreeLight = void 0
    }

    function pd(e, t, n) {
        hd.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Fn.DefaultUp), this.updateMatrix(), this.groundColor = new Pr(t), this.target = new Fn
    }

    function fd(e, t, n, r, i, a) {
        hd.call(this, e, t), this.type = "SpotLight", this.position.copy(Fn.DefaultUp), this.updateMatrix(), this.target = new Fn, Object.defineProperty(this, "power", {
            get: function () {
                return this.intensity * Math.PI
            },
            set: function (e) {
                this.intensity = e / Math.PI
            }
        }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Do
    }

    function md() {
        Ro.call(this, new Bi(90, 1, .5, 500)), this._frameExtents = new qt(4, 2), this._viewportCount = 6, this._viewports = [new $t(2, 1, 1, 1), new $t(0, 1, 1, 1), new $t(3, 1, 1, 1), new $t(1, 1, 1, 1), new $t(3, 0, 1, 1), new $t(1, 0, 1, 1)], this._cubeDirections = [new on(1, 0, 0), new on(-1, 0, 0), new on(0, 0, 1), new on(0, 0, -1), new on(0, 1, 0), new on(0, -1, 0)], this._cubeUps = [new on(0, 1, 0), new on(0, 1, 0), new on(0, 1, 0), new on(0, 1, 0), new on(0, 0, 1), new on(0, 0, -1)]
    }

    function vd(e, t, n, r) {
        hd.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function () {
                return 4 * this.intensity * Math.PI
            },
            set: function (e) {
                this.intensity = e / (4 * Math.PI)
            }
        }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new md
    }

    function gd() {
        Ro.call(this, new qi(-5, 5, 5, -5, .5, 500))
    }

    function _d() {
        Ro.call(this, new qi(-5, 5, 5, -5, .5, 500)), this.maxDistance = 10
    }

    function yd(e, t) {
        hd.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Fn.DefaultUp), this.updateMatrix(), this.target = new Fn, this.shadow = new gd
    }

    function xd(e, t) {
        hd.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
    }

    function bd(e, t, n, r) {
        hd.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10
    }

    function wd(e) {
        Ru.call(this, e), this.textures = {}
    }
    cd.prototype = Object.assign(Object.create(Vu.prototype), {
        constructor: cd,
        add: function (e) {
            this.curves.push(e)
        },
        closePath: function () {
            var e = this.curves[0].getPoint(0),
                t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new ed(t, e))
        },
        getPoint: function (e) {
            for (var t = e * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                if (n[r] >= t) {
                    var i = n[r] - t,
                        a = this.curves[r],
                        o = a.getLength(),
                        s = 0 === o ? 0 : 1 - i / o;
                    return a.getPointAt(s)
                }
                r++
            }
            return null
        },
        getLength: function () {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function () {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function () {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);
            return this.cacheLengths = e
        },
        getSpacedPoints: function (e) {
            void 0 === e && (e = 40);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return this.autoClose && t.push(t[0]), t
        },
        getPoints: function (e) {
            e = e || 12;
            for (var t, n = [], r = 0, i = this.curves; r < i.length; r++)
                for (var a = i[r], o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e, s = a.getPoints(o), l = 0; l < s.length; l++) {
                    var c = s[l];
                    t && t.equals(c) || (n.push(c), t = c)
                }
            return this.autoClose && 1 < n.length && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
        },
        copy: function (e) {
            Vu.prototype.copy.call(this, e), this.curves = [];
            for (var t = 0, n = e.curves.length; t < n; t++) {
                var r = e.curves[t];
                this.curves.push(r.clone())
            }
            return this.autoClose = e.autoClose, this
        },
        toJSON: function () {
            var e = Vu.prototype.toJSON.call(this);
            e.autoClose = this.autoClose, e.curves = [];
            for (var t = 0, n = this.curves.length; t < n; t++) {
                var r = this.curves[t];
                e.curves.push(r.toJSON())
            }
            return e
        },
        fromJSON: function (e) {
            Vu.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
            for (var t = 0, n = e.curves.length; t < n; t++) {
                var r = e.curves[t];
                this.curves.push((new ld[r.type]).fromJSON(r))
            }
            return this
        }
    }), ud.prototype = Object.assign(Object.create(cd.prototype), {
        constructor: ud,
        setFromPoints: function (e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
            return this
        },
        moveTo: function (e, t) {
            return this.currentPoint.set(e, t), this
        },
        lineTo: function (e, t) {
            var n = new ed(this.currentPoint.clone(), new qt(e, t));
            return this.curves.push(n), this.currentPoint.set(e, t), this
        },
        quadraticCurveTo: function (e, t, n, r) {
            var i = new nd(this.currentPoint.clone(), new qt(e, t), new qt(n, r));
            return this.curves.push(i), this.currentPoint.set(n, r), this
        },
        bezierCurveTo: function (e, t, n, r, i, a) {
            var o = new Ju(this.currentPoint.clone(), new qt(e, t), new qt(n, r), new qt(i, a));
            return this.curves.push(o), this.currentPoint.set(i, a), this
        },
        splineThru: function (e) {
            var t = new id([this.currentPoint.clone()].concat(e));
            return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this
        },
        arc: function (e, t, n, r, i, a) {
            var o = this.currentPoint.x,
                s = this.currentPoint.y;
            return this.absarc(e + o, t + s, n, r, i, a), this
        },
        absarc: function (e, t, n, r, i, a) {
            return this.absellipse(e, t, n, n, r, i, a), this
        },
        ellipse: function (e, t, n, r, i, a, o, s) {
            var l = this.currentPoint.x,
                c = this.currentPoint.y;
            return this.absellipse(e + l, t + c, n, r, i, a, o, s), this
        },
        absellipse: function (e, t, n, r, i, a, o, s) {
            var l = new Gu(e, t, n, r, i, a, o, s);
            if (0 < this.curves.length) {
                var c = l.getPoint(0);
                c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
            }
            this.curves.push(l);
            var u = l.getPoint(1);
            return this.currentPoint.copy(u), this
        },
        copy: function (e) {
            return cd.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
        },
        toJSON: function () {
            var e = cd.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(), e
        },
        fromJSON: function (e) {
            return cd.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
        }
    }), dd.prototype = Object.assign(Object.create(ud.prototype), {
        constructor: dd,
        getPointsHoles: function (e) {
            for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
            return t
        },
        extractPoints: function (e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function (e) {
            ud.prototype.copy.call(this, e), this.holes = [];
            for (var t = 0, n = e.holes.length; t < n; t++) {
                var r = e.holes[t];
                this.holes.push(r.clone())
            }
            return this
        },
        toJSON: function () {
            var e = ud.prototype.toJSON.call(this);
            e.uuid = this.uuid, e.holes = [];
            for (var t = 0, n = this.holes.length; t < n; t++) {
                var r = this.holes[t];
                e.holes.push(r.toJSON())
            }
            return e
        },
        fromJSON: function (e) {
            ud.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
            for (var t = 0, n = e.holes.length; t < n; t++) {
                var r = e.holes[t];
                this.holes.push((new ud).fromJSON(r))
            }
            return this
        }
    }), hd.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: hd,
        isLight: !0,
        copy: function (e) {
            return Fn.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this.receiveShadow = e.receiveShadow, this.isFreeLight = e.isFreeLight, this
        },
        getWorldDirection: function (e) {
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        toJSON: function (e) {
            var t = Fn.prototype.toJSON.call(this, e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
        }
    }), pd.prototype = Object.assign(Object.create(hd.prototype), {
        constructor: pd,
        isHemisphereLight: !0,
        copy: function (e) {
            return hd.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this.target = e.target.clone(), this
        },
        updateMatrixWorld: function (e) {
            Fn.prototype.updateMatrixWorld.call(this, e), this.isFreeLight && this.updateFreeLightTarget()
        },
        updateFreeLightTarget: (ad = new on, function () {
            ad.set(0, 0, -1).applyQuaternion(this.quaternion).normalize(), this.target.position.addVectors(this.position, ad), this.target.updateMatrix()
        })
    }), fd.prototype = Object.assign(Object.create(hd.prototype), {
        constructor: fd,
        isSpotLight: !0,
        copy: function (e) {
            return hd.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        },
        updateMatrixWorld: function (e) {
            Fn.prototype.updateMatrixWorld.call(this, e), this.isFreeLight && this.updateFreeLightTarget()
        },
        updateFreeLightTarget: (od = new on, function () {
            od.set(0, 0, -1).applyQuaternion(this.quaternion).normalize(), this.target.position.addVectors(this.position, od), this.target.updateMatrix()
        })
    }), md.prototype = Object.assign(Object.create(Ro.prototype), {
        constructor: md,
        isPointLightShadow: !0,
        updateMatrices: function (e, t) {
            void 0 === t && (t = 0);
            var n = this.camera,
                r = this.matrix,
                i = this._lightPositionWorld,
                a = this._lookTarget,
                o = this._projScreenMatrix;
            i.setFromMatrixPosition(e.matrixWorld), n.position.copy(i), a.copy(n.position), a.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(a), n.updateMatrixWorld(), r.makeTranslation(-i.x, -i.y, -i.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o)
        }
    }), vd.prototype = Object.assign(Object.create(hd.prototype), {
        constructor: vd,
        isPointLight: !0,
        copy: function (e) {
            return hd.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }), gd.prototype = Object.assign(Object.create(Ro.prototype), {
        constructor: gd,
        isDirectionalLightShadow: !0,
        updateMatrices: function (e) {
            Ro.prototype.updateMatrices.call(this, e)
        }
    }), _d.prototype = Object.assign(Object.create(Ro.prototype), {
        constructor: _d,
        isDirectionalLightShadowCSM: !0,
        copy: function (e) {
            return Ro.prototype.copy.call(this, e), this.maxDistance = e.maxDistance, this
        }
    }), yd.prototype = Object.assign(Object.create(hd.prototype), {
        constructor: yd,
        isDirectionalLight: !0,
        copy: function (e) {
            return hd.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        },
        updateMatrixWorld: function (e) {
            Fn.prototype.updateMatrixWorld.call(this, e), this.isFreeLight && this.updateFreeLightTarget()
        },
        updateFreeLightTarget: (sd = new on, function () {
            sd.set(0, 0, -1).applyQuaternion(this.quaternion).normalize(), this.target.position.addVectors(this.position, sd), this.target.updateMatrix()
        })
    }), xd.prototype = Object.assign(Object.create(hd.prototype), {
        constructor: xd,
        isAmbientLight: !0
    }), bd.prototype = Object.assign(Object.create(hd.prototype), {
        constructor: bd,
        isRectAreaLight: !0,
        copy: function (e) {
            return hd.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
        },
        toJSON: function (e) {
            var t = hd.prototype.toJSON.call(this, e);
            return t.object.width = this.width, t.object.height = this.height, t
        }
    }), wd.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: wd,
        load: function (e, t, n, r) {
            var i = this,
                a = new Iu(i.manager);
            a.setPath(i.path), a.load(e, function (e) {
                t(i.parse(JSON.parse(e)))
            }, n, r)
        },
        parse: function (e) {
            var t = this.textures;

            function n(e) {
                return void 0 === t[e] && console.warn("v3d.MaterialLoader: Undefined texture", e), t[e]
            }
            var r = new mu[e.type];
            if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = (new Pr).setHex(e.sheen)), void 0 !== e.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.vertexColors && (r.vertexColors = e.vertexColors), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.morphNormals && (r.morphNormals = e.morphNormals), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.uniforms)
                for (var i in e.uniforms) {
                    var a = e.uniforms[i];
                    switch (r.uniforms[i] = {}, a.type) {
                        case "t":
                            r.uniforms[i].value = n(a.value);
                            break;
                        case "c":
                            r.uniforms[i].value = (new Pr).setHex(a.value);
                            break;
                        case "v2":
                            r.uniforms[i].value = (new qt).fromArray(a.value);
                            break;
                        case "v3":
                            r.uniforms[i].value = (new on).fromArray(a.value);
                            break;
                        case "v4":
                            r.uniforms[i].value = (new $t).fromArray(a.value);
                            break;
                        case "m3":
                            r.uniforms[i].value = (new Zt).fromArray(a.value);
                        case "m4":
                            r.uniforms[i].value = (new fn).fromArray(a.value);
                            break;
                        default:
                            r.uniforms[i].value = a.value
                    }
                }
            if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                for (var o in e.extensions) r.extensions[o] = e.extensions[o];
            if (void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap), r.transparent = !0), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                var s = e.normalScale;
                !1 === Array.isArray(s) && (s = [s, s]), r.normalScale = (new qt).fromArray(s)
            }
            return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new qt).fromArray(e.clearcoatNormalScale)), r
        },
        setTextures: function (e) {
            return this.textures = e, this
        }
    });
    var Md = {
        decodeText: function (e) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
            for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        },
        extractUrlBase: function (e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
    };

    function Ad() {
        ni.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function Sd(e, t, n, r) {
        "number" == typeof n && (r = n, n = !1, console.error("v3d.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), zr.call(this, e, t, n), this.meshPerAttribute = r || 1
    }

    function Td(e) {
        Ru.call(this, e)
    }
    Ad.prototype = Object.assign(Object.create(ni.prototype), {
        constructor: Ad,
        isInstancedBufferGeometry: !0,
        copy: function (e) {
            return ni.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        toJSON: function () {
            var e = ni.prototype.toJSON.call(this);
            return e.maxInstancedCount = this.maxInstancedCount, e.isInstancedBufferGeometry = !0, e
        }
    }), Sd.prototype = Object.assign(Object.create(zr.prototype), {
        constructor: Sd,
        isInstancedBufferAttribute: !0,
        copy: function (e) {
            return zr.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        },
        toJSON: function () {
            var e = zr.prototype.toJSON.call(this);
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
        }
    }), Td.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Td,
        load: function (e, t, n, r) {
            var i = this,
                a = new Iu(i.manager);
            a.setPath(i.path), a.load(e, function (e) {
                t(i.parse(JSON.parse(e)))
            }, n, r)
        },
        parse: function (e) {
            var t = new(e.isInstancedBufferGeometry ? Ad : ni),
                n = e.data.index;
            if (void 0 !== n) {
                var r = new Ed[n.type](n.array);
                t.setIndex(new zr(r, 1))
            }
            var i = e.data.attributes;
            for (var a in i) {
                var o = i[a],
                    s = (r = new Ed[o.type](o.array), new(o.isInstancedBufferAttribute ? Sd : zr)(r, o.itemSize, o.normalized));
                void 0 !== o.name && (s.name = o.name), t.setAttribute(a, s)
            }
            var l = e.data.morphAttributes;
            if (l)
                for (var a in l) {
                    for (var c = l[a], u = [], d = 0, h = c.length; d < h; d++) {
                        o = c[d], s = new zr(r = new Ed[o.type](o.array), o.itemSize, o.normalized);
                        void 0 !== o.name && (s.name = o.name), u.push(s)
                    }
                    t.morphAttributes[a] = u
                }
            e.data.morphTargetsRelative && (t.morphTargetsRelative = !0);
            var p = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== p) {
                d = 0;
                for (var f = p.length; d !== f; ++d) {
                    var m = p[d];
                    t.addGroup(m.start, m.count, m.materialIndex)
                }
            }
            var v = e.data.boundingSphere;
            if (void 0 !== v) {
                var g = new on;
                void 0 !== v.center && g.fromArray(v.center), t.boundingSphere = new nr(g, v.radius)
            }
            return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t
        }
    });
    var Ed = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };

    function Cd(e) {
        Ru.call(this, e)
    }
    Cd.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Cd,
        load: function (r, i, e, a) {
            var o = this,
                t = "" === this.path ? Md.extractUrlBase(r) : this.path;
            this.resourcePath = this.resourcePath || t;
            var n = new Iu(o.manager);
            n.setPath(this.path), n.load(r, function (e) {
                var t = null;
                try {
                    t = JSON.parse(e)
                } catch (e) {
                    return void 0 !== a && a(e), void console.error("v3d:ObjectLoader: Can't parse " + r + ".", e.message)
                }
                var n = t.metadata;
                void 0 !== n && void 0 !== n.type && "geometry" !== n.type.toLowerCase() ? o.parse(t, i) : console.error("v3d.ObjectLoader: Can't load " + r)
            }, e, a)
        },
        parse: function (e, t) {
            var n = this.parseShape(e.shapes),
                r = this.parseGeometries(e.geometries, n),
                i = this.parseImages(e.images, function () {
                    void 0 !== t && t(s)
                }),
                a = this.parseTextures(e.textures, i),
                o = this.parseMaterials(e.materials, a),
                s = this.parseObject(e.object, r, o);
            return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
        },
        parseShape: function (e) {
            var t = {};
            if (void 0 !== e)
                for (var n = 0, r = e.length; n < r; n++) {
                    var i = (new dd).fromJSON(e[n]);
                    t[i.uuid] = i
                }
            return t
        },
        parseGeometries: function (e, t) {
            var n = {};
            if (void 0 !== e)
                for (var r = new Td, i = 0, a = e.length; i < a; i++) {
                    var o, s = e[i];
                    switch (s.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            o = new _c[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            o = new _c[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            o = new _c[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            o = new _c[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            o = new _c[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            o = new _c[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            o = new _c[s.type](s.radius, s.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            o = new _c[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            o = new _c[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            o = new _c[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                            break;
                        case "TubeGeometry":
                        case "TubeBufferGeometry":
                            o = new _c[s.type]((new ld[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            o = new _c[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            o = new _c[s.type](s.vertices, s.indices, s.radius, s.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            for (var l = [], c = 0, u = s.shapes.length; c < u; c++) {
                                var d = t[s.shapes[c]];
                                l.push(d)
                            }
                            o = new _c[s.type](l, s.curveSegments);
                            break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                            for (l = [], c = 0, u = s.shapes.length; c < u; c++) {
                                d = t[s.shapes[c]];
                                l.push(d)
                            }
                            var h = s.options.extrudePath;
                            void 0 !== h && (s.options.extrudePath = (new ld[h.type]).fromJSON(h)), o = new _c[s.type](l, s.options);
                            break;
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            o = r.parse(s);
                            break;
                        case "Geometry":
                            if ("v3d" in window && "LegacyJSONLoader" in v3d) o = (new v3d.LegacyJSONLoader).parse(s, this.resourcePath).geometry;
                            else console.error('v3d.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                            break;
                        default:
                            console.warn('v3d.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                            continue
                    }
                    o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData), n[s.uuid] = o
                }
            return n
        },
        parseMaterials: function (e, t) {
            var n = {},
                r = {};
            if (void 0 !== e) {
                var i = new wd;
                i.setTextures(t);
                for (var a = 0, o = e.length; a < o; a++) {
                    var s = e[a];
                    if ("MultiMaterial" === s.type) {
                        for (var l = [], c = 0; c < s.materials.length; c++) {
                            var u = s.materials[c];
                            void 0 === n[u.uuid] && (n[u.uuid] = i.parse(u)), l.push(n[u.uuid])
                        }
                        r[s.uuid] = l
                    } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
                }
            }
            return r
        },
        parseAnimations: function (e) {
            for (var t = [], n = 0; n < e.length; n++) {
                var r = e[n],
                    i = Tu.parse(r);
                void 0 !== r.uuid && (i.uuid = r.uuid), t.push(i)
            }
            return t
        },
        parseImages: function (e, t) {
            var n = this,
                r = {};

            function i(e) {
                return n.manager.itemStart(e), a.load(e, function () {
                    n.manager.itemEnd(e)
                }, void 0, function () {
                    n.manager.itemError(e), n.manager.itemEnd(e)
                })
            }
            if (void 0 !== e && 0 < e.length) {
                var a = new Bu(new Pu(t));
                a.setCrossOrigin(this.crossOrigin);
                for (var o = 0, s = e.length; o < s; o++) {
                    var l = e[o],
                        c = l.url;
                    if (Array.isArray(c)) {
                        r[l.uuid] = [];
                        for (var u = 0, d = c.length; u < d; u++) {
                            var h = c[u],
                                p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h) ? h : n.resourcePath + h;
                            r[l.uuid].push(i(p))
                        }
                    } else {
                        p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : n.resourcePath + l.url;
                        r[l.uuid] = i(p)
                    }
                }
            }
            return r
        },
        parseTextures: function (e, t) {
            function n(e, t) {
                return "number" == typeof e ? e : (console.warn("v3d.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
            }
            var r = {};
            if (void 0 !== e)
                for (var i = 0, a = e.length; i < a; i++) {
                    var o, s = e[i];
                    void 0 === s.image && console.warn('v3d.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("v3d.ObjectLoader: Undefined image", s.image), (o = new(Array.isArray(t[s.image]) ? ua : Jt)(t[s.image])).needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = n(s.mapping, Ld)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = n(s.wrap[0], Rd), o.wrapT = n(s.wrap[1], Rd)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, Dd)), void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, Dd)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), r[s.uuid] = o
                }
            return r
        },
        parseObject: function (e, t, a) {
            var n;

            function r(e) {
                return void 0 === t[e] && console.warn("v3d.ObjectLoader: Undefined geometry", e), t[e]
            }

            function i(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], n = 0, r = e.length; n < r; n++) {
                            var i = e[n];
                            void 0 === a[i] && console.warn("v3d.ObjectLoader: Undefined material", i), t.push(a[i])
                        }
                        return t
                    }
                    return void 0 === a[e] && console.warn("v3d.ObjectLoader: Undefined material", e), a[e]
                }
            }
            switch (e.type) {
                case "Scene":
                    n = new Bn, void 0 !== e.background && Number.isInteger(e.background) && (n.background = new Pr(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? n.fog = new os(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (n.fog = new as(e.fog.color, e.fog.density)));
                    break;
                case "PerspectiveCamera":
                    n = new Bi(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (n.focus = e.focus), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.filmGauge && (n.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (n.filmOffset = e.filmOffset), void 0 !== e.view && (n.view = Object.assign({}, e.view));
                    break;
                case "OrthographicCamera":
                    n = new qi(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.view && (n.view = Object.assign({}, e.view));
                    break;
                case "AmbientLight":
                    n = new xd(e.color, e.intensity);
                    break;
                case "DirectionalLight":
                    n = new yd(e.color, e.intensity);
                    break;
                case "PointLight":
                    n = new vd(e.color, e.intensity, e.distance, e.decay);
                    break;
                case "RectAreaLight":
                    n = new bd(e.color, e.intensity, e.width, e.height);
                    break;
                case "SpotLight":
                    n = new fd(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                    break;
                case "HemisphereLight":
                    n = new pd(e.color, e.groundColor, e.intensity);
                    break;
                case "SkinnedMesh":
                    console.warn("v3d.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    var o = r(e.geometry),
                        s = i(e.material);
                    n = new(o.bones && 0 < o.bones.length ? Ps : xi)(o, s);
                    break;
                case "InstancedMesh":
                    o = r(e.geometry), s = i(e.material);
                    var l = e.count,
                        c = e.instanceMatrix;
                    (n = new zs(o, s, l)).instanceMatrix = new zr(new Float32Array(c.array), 16);
                    break;
                case "LOD":
                    n = new Cs;
                    break;
                case "Line":
                    n = new Xs(r(e.geometry), i(e.material), e.mode);
                    break;
                case "LineLoop":
                    n = new Zs(r(e.geometry), i(e.material));
                    break;
                case "LineSegments":
                    n = new qs(r(e.geometry), i(e.material));
                    break;
                case "PointCloud":
                case "Points":
                    n = new tl(r(e.geometry), i(e.material));
                    break;
                case "Sprite":
                    n = new As(i(e.material));
                    break;
                case "Group":
                    n = new Jo;
                    break;
                default:
                    n = new Fn
            }
            if (n.uuid = e.uuid, void 0 !== e.name && (n.name = e.name), void 0 !== e.matrix ? (n.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (n.matrixAutoUpdate = e.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position), void 0 !== e.rotation && n.rotation.fromArray(e.rotation), void 0 !== e.quaternion && n.quaternion.fromArray(e.quaternion), void 0 !== e.scale && n.scale.fromArray(e.scale)), void 0 !== e.castShadow && (n.castShadow = e.castShadow), void 0 !== e.receiveShadow && (n.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (n.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (n.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && n.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (n.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.frustumCulled && (n.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (n.renderOrder = e.renderOrder), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.layers && (n.layers.mask = e.layers), void 0 !== e.children)
                for (var u = e.children, d = 0; d < u.length; d++) n.add(this.parseObject(u[d], t, a));
            if ("LOD" === e.type) {
                void 0 !== e.autoUpdate && (n.autoUpdate = e.autoUpdate);
                for (var h = e.levels, p = 0; p < h.length; p++) {
                    var f = h[p],
                        m = n.getObjectByProperty("uuid", f.object);
                    void 0 !== m && n.addLevel(m, f.distance)
                }
            }
            return n
        }
    });
    var Pd, Ld = {
            UVMapping: 300,
            CubeReflectionMapping: Ue,
            CubeRefractionMapping: Ve,
            EquirectangularReflectionMapping: Ge,
            EquirectangularRefractionMapping: ke,
            SphericalReflectionMapping: je,
            CubeUVReflectionMapping: We,
            CubeUVRefractionMapping: Xe
        },
        Rd = {
            RepeatWrapping: He,
            ClampToEdgeWrapping: Ye,
            MirroredRepeatWrapping: qe
        },
        Dd = {
            NearestFilter: Ze,
            NearestMipmapNearestFilter: Qe,
            NearestMipmapLinearFilter: Ke,
            LinearFilter: Je,
            LinearMipmapNearestFilter: $e,
            LinearMipmapLinearFilter: et
        };

    function Id(e) {
        "undefined" == typeof createImageBitmap && console.warn("v3d.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("v3d.ImageBitmapLoader: fetch() not supported."), Ru.call(this, e), this.options = void 0
    }

    function Nd() {
        this.type = "ShapePath", this.color = new Pr, this.subPaths = [], this.currentPath = null
    }

    function Od(e) {
        this.type = "Font", this.data = e
    }

    function Fd(e, t, n, r, i) {
        var a = i.glyphs[e] || i.glyphs["?"];
        if (a) {
            var o, s, l, c, u, d, h, p, f = new Nd;
            if (a.o)
                for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, g = m.length; v < g;) {
                    switch (m[v++]) {
                        case "m":
                            o = m[v++] * t + n, s = m[v++] * t + r, f.moveTo(o, s);
                            break;
                        case "l":
                            o = m[v++] * t + n, s = m[v++] * t + r, f.lineTo(o, s);
                            break;
                        case "q":
                            l = m[v++] * t + n, c = m[v++] * t + r, u = m[v++] * t + n, d = m[v++] * t + r, f.quadraticCurveTo(u, d, l, c);
                            break;
                        case "b":
                            l = m[v++] * t + n, c = m[v++] * t + r, u = m[v++] * t + n, d = m[v++] * t + r, h = m[v++] * t + n, p = m[v++] * t + r, f.bezierCurveTo(u, d, h, p, l, c)
                    }
                }
            return {
                offsetX: a.ha * t,
                path: f
            }
        }
        console.error('v3d.Font: character "' + e + '" does not exists in font family ' + i.familyName + ".")
    }

    function Bd(e) {
        Ru.call(this, e)
    }
    Id.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Id,
        setOptions: function (e) {
            return this.options = e, this
        },
        load: function (t, n, e, r) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var i = this,
                a = Cu.get(t);
            if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function () {
                n && n(a), i.manager.itemEnd(t)
            }, 0), a;
            fetch(t).then(function (e) {
                return e.blob()
            }).then(function (e) {
                return void 0 === i.options ? createImageBitmap(e) : createImageBitmap(e, i.options)
            }).then(function (e) {
                Cu.add(t, e), n && n(e), i.manager.itemEnd(t)
            }).catch(function (e) {
                r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
            }), i.manager.itemStart(t)
        }
    }), Object.assign(Nd.prototype, {
        moveTo: function (e, t) {
            return this.currentPath = new ud, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
        },
        lineTo: function (e, t) {
            return this.currentPath.lineTo(e, t), this
        },
        quadraticCurveTo: function (e, t, n, r) {
            return this.currentPath.quadraticCurveTo(e, t, n, r), this
        },
        bezierCurveTo: function (e, t, n, r, i, a) {
            return this.currentPath.bezierCurveTo(e, t, n, r, i, a), this
        },
        splineThru: function (e) {
            return this.currentPath.splineThru(e), this
        },
        toShapes: function (e, t) {
            function n(e) {
                for (var t = [], n = 0, r = e.length; n < r; n++) {
                    var i = e[n],
                        a = new dd;
                    a.curves = i.curves, t.push(a)
                }
                return t
            }

            function r(e, t) {
                for (var n = t.length, r = !1, i = n - 1, a = 0; a < n; i = a++) {
                    var o = t[i],
                        s = t[a],
                        l = s.x - o.x,
                        c = s.y - o.y;
                    if (Math.abs(c) > Number.EPSILON) {
                        if (c < 0 && (o = t[a], l = -l, s = t[i], c = -c), e.y < o.y || e.y > s.y) continue;
                        if (e.y === o.y) {
                            if (e.x === o.x) return 1
                        } else {
                            var u = c * (e.x - o.x) - l * (e.y - o.y);
                            if (0 == u) return 1;
                            if (u < 0) continue;
                            r = !r
                        }
                    } else {
                        if (e.y !== o.y) continue;
                        if (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x) return 1
                    }
                }
                return r
            }
            var i = Yl.isClockWise,
                a = this.subPaths;
            if (0 === a.length) return [];
            if (!0 === t) return n(a);
            var o, s, l, c = [];
            if (1 === a.length) return s = a[0], (l = new dd).curves = s.curves, c.push(l), c;
            var u = !i(a[0].getPoints());
            u = e ? !u : u;
            var d, h, p = [],
                f = [],
                m = [],
                v = 0;
            f[v] = void 0, m[v] = [];
            for (var g = 0, _ = a.length; g < _; g++) o = i(d = (s = a[g]).getPoints()), (o = e ? !o : o) ? (!u && f[v] && v++, f[v] = {
                s: new dd,
                p: d
            }, f[v].s.curves = s.curves, u && v++, m[v] = []) : m[v].push({
                h: s,
                p: d[0]
            });
            if (!f[0]) return n(a);
            if (1 < f.length) {
                for (var y = !1, x = [], b = 0, w = f.length; b < w; b++) p[b] = [];
                for (b = 0, w = f.length; b < w; b++)
                    for (var M = m[b], A = 0; A < M.length; A++) {
                        for (var S = M[A], T = !0, E = 0; E < f.length; E++) r(S.p, f[E].p) && (b !== E && x.push({
                            froms: b,
                            tos: E,
                            hole: A
                        }), T ? (T = !1, p[E].push(S)) : y = !0);
                        T && p[b].push(S)
                    }
                0 < x.length && (y || (m = p))
            }
            g = 0;
            for (var C = f.length; g < C; g++) {
                l = f[g].s, c.push(l);
                for (var P = 0, L = (h = m[g]).length; P < L; P++) l.holes.push(h[P].h)
            }
            return c
        }
    }), Object.assign(Od.prototype, {
        isFont: !0,
        generateShapes: function (e, t) {
            void 0 === t && (t = 100);
            for (var n = [], r = function (e, t, n) {
                    for (var r = Array.from ? Array.from(e) : String(e).split(""), i = t / n.resolution, a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, o = [], s = 0, l = 0, c = 0; c < r.length; c++) {
                        var u = r[c];
                        if ("\n" === u) s = 0, l -= a;
                        else {
                            var d = Fd(u, i, s, l, n);
                            s += d.offsetX, o.push(d.path)
                        }
                    }
                    return o
                }(e, t, this.data), i = 0, a = r.length; i < a; i++) Array.prototype.push.apply(n, r[i].toShapes());
            return n
        }
    }), Bd.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Bd,
        load: function (e, r, t, n) {
            var i = this,
                a = new Iu(this.manager);
            a.setPath(this.path), a.load(e, function (t) {
                var n;
                try {
                    n = JSON.parse(t)
                } catch (e) {
                    console.warn("v3d.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                }
                var e = i.parse(n);
                r && r(e)
            }, t, n)
        },
        parse: function (e) {
            return new Od(e)
        }
    });
    var zd = {
        getContext: function () {
            return void 0 === Pd && (Pd = new(window.AudioContext || window.webkitAudioContext)), Pd
        },
        setContext: function (e) {
            Pd = e
        }
    };

    function Ud(e) {
        Ru.call(this, e)
    }

    function Vd() {
        this.coefficients = [];
        for (var e = 0; e < 9; e++) this.coefficients.push(new on)
    }

    function Gd(e, t) {
        hd.call(this, void 0, t), this.sh = void 0 !== e ? e : new Vd
    }

    function kd(e, t, n) {
        Gd.call(this, void 0, n);
        var r = (new Pr).set(e),
            i = (new Pr).set(t),
            a = new on(r.r, r.g, r.b),
            o = new on(i.r, i.g, i.b),
            s = Math.sqrt(Math.PI),
            l = s * Math.sqrt(.75);
        this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s), this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(l)
    }

    function jd(e, t) {
        Gd.call(this, void 0, t);
        var n = (new Pr).set(e);
        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    Ud.prototype = Object.assign(Object.create(Ru.prototype), {
        constructor: Ud,
        load: function (e, n, t, r) {
            var i = new Iu(this.manager);
            i.setResponseType("arraybuffer"), i.setPath(this.path), i.load(e, function (e) {
                var t = e.slice(0);
                zd.getContext().decodeAudioData(t, function (e) {
                    n(e)
                })
            }, t, r)
        }
    }), Object.assign(Vd.prototype, {
        isSphericalHarmonics3: !0,
        set: function (e) {
            for (var t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
            return this
        },
        zero: function () {
            for (var e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
            return this
        },
        getAt: function (e, t) {
            var n = e.x,
                r = e.y,
                i = e.z,
                a = this.coefficients;
            return t.copy(a[0]).multiplyScalar(.282095), t.addScale(a[1], .488603 * r), t.addScale(a[2], .488603 * i), t.addScale(a[3], .488603 * n), t.addScale(a[4], n * r * 1.092548), t.addScale(a[5], r * i * 1.092548), t.addScale(a[6], .315392 * (3 * i * i - 1)), t.addScale(a[7], n * i * 1.092548), t.addScale(a[8], .546274 * (n * n - r * r)), t
        },
        getIrradianceAt: function (e, t) {
            var n = e.x,
                r = e.y,
                i = e.z,
                a = this.coefficients;
            return t.copy(a[0]).multiplyScalar(.886227), t.addScale(a[1], 1.023328 * r), t.addScale(a[2], 1.023328 * i), t.addScale(a[3], 1.023328 * n), t.addScale(a[4], .858086 * n * r), t.addScale(a[5], .858086 * r * i), t.addScale(a[6], .743125 * i * i - .247708), t.addScale(a[7], .858086 * n * i), t.addScale(a[8], .429043 * (n * n - r * r)), t
        },
        add: function (e) {
            for (var t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
            return this
        },
        scale: function (e) {
            for (var t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
            return this
        },
        lerp: function (e, t) {
            for (var n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
            return this
        },
        equals: function (e) {
            for (var t = 0; t < 9; t++)
                if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
            return !0
        },
        copy: function (e) {
            return this.set(e.coefficients)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var n = this.coefficients, r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
            return this
        },
        toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            for (var n = this.coefficients, r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
            return e
        }
    }), Object.assign(Vd, {
        getBasisAt: function (e, t) {
            var n = e.x,
                r = e.y,
                i = e.z;
            t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r)
        }
    }), Gd.prototype = Object.assign(Object.create(hd.prototype), {
        constructor: Gd,
        isLightProbe: !0,
        copy: function (e) {
            return hd.prototype.copy.call(this, e), this.sh.copy(e.sh), this.intensity = e.intensity, this
        },
        toJSON: function (e) {
            return hd.prototype.toJSON.call(this, e)
        }
    }), kd.prototype = Object.assign(Object.create(Gd.prototype), {
        constructor: kd,
        isHemisphereLightProbe: !0,
        copy: function (e) {
            return Gd.prototype.copy.call(this, e), this
        },
        toJSON: function (e) {
            return Gd.prototype.toJSON.call(this, e)
        }
    }), jd.prototype = Object.assign(Object.create(Gd.prototype), {
        constructor: jd,
        isAmbientLightProbe: !0,
        copy: function (e) {
            return Gd.prototype.copy.call(this, e), this
        },
        toJSON: function (e) {
            return Gd.prototype.toJSON.call(this, e)
        }
    });
    var Wd = new fn,
        Xd = new fn;

    function Hd() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Bi, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Bi, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    Object.assign(Hd.prototype, {
        update: function (e) {
            var t = this._cache;
            if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep;
                var n, r, i = e.projectionMatrix.clone(),
                    a = t.eyeSep / 2,
                    o = a * t.near / t.focus,
                    s = t.near * Math.tan(Yt.DEG2RAD * t.fov * .5) / t.zoom;
                Xd.elements[12] = -a, Wd.elements[12] = a, n = -s * t.aspect + o, r = s * t.aspect + o, i.elements[0] = 2 * t.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraL.projectionMatrix.copy(i), n = -s * t.aspect - o, r = s * t.aspect - o, i.elements[0] = 2 * t.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraR.projectionMatrix.copy(i)
            }
            this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Xd), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Wd)
        }
    });
    var Yd, qd, Zd, Qd = {
        calcCameraZoomToObjectsParams: (qd = new Kn, Zd = new nr, function (e, t, n, r) {
            var i = qd.makeEmpty();
            t.forEach(function (e) {
                i.expandByObject(e)
            });
            var a = i.getBoundingSphere(Zd);
            Qd.calcCameraZoomToSphereParams(e, a, n, r)
        }),
        calcCameraZoomToSphereParams: (Yd = new on, function (e, t, n, r) {
            var i = Yt.degToRad(e.fov / 2);
            e.aspect < 1 && (i = Math.atan(e.aspect * Math.tan(i)));
            var a = t.radius / Math.sin(i),
                o = e.getWorldDirection(Yd);
            n.copy(t.center).addScaledVector(o, -a), r.copy(t.center)
        })
    };

    function Kd(e) {
        this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }
    Object.assign(Kd.prototype, {
        start: function () {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
        },
        stop: function () {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1
        },
        getElapsedTime: function () {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function () {
            var e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now();
                e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
            }
            return e
        }
    });
    var Jd = new on,
        $d = new nn,
        eh = new on,
        th = new on;

    function nh() {
        Fn.call(this), this.type = "AudioListener", this.context = zd.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Kd
    }

    function rh(e) {
        Fn.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._pausedAt = 0, this.filters = []
    }
    nh.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: nh,
        getInput: function () {
            return this.gain
        },
        removeFilter: function () {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
        },
        getFilter: function () {
            return this.filter
        },
        setFilter: function (e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
        },
        getMasterVolume: function () {
            return this.gain.gain.value
        },
        setMasterVolume: function (e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        },
        updateMatrixWorld: function (e) {
            Fn.prototype.updateMatrixWorld.call(this, e);
            var t = this.context.listener,
                n = this.up;
            if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Jd, $d, eh), th.set(0, 0, -1).applyQuaternion($d), t.positionX) {
                var r = this.context.currentTime + this.timeDelta;
                t.positionX.linearRampToValueAtTime(Jd.x, r), t.positionY.linearRampToValueAtTime(Jd.y, r), t.positionZ.linearRampToValueAtTime(Jd.z, r), t.forwardX.linearRampToValueAtTime(th.x, r), t.forwardY.linearRampToValueAtTime(th.y, r), t.forwardZ.linearRampToValueAtTime(th.z, r), t.upX.linearRampToValueAtTime(n.x, r), t.upY.linearRampToValueAtTime(n.y, r), t.upZ.linearRampToValueAtTime(n.z, r)
            } else t.setPosition(Jd.x, Jd.y, Jd.z), t.setOrientation(th.x, th.y, th.z, n.x, n.y, n.z)
        }
    }), rh.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: rh,
        getOutput: function () {
            return this.gain
        },
        setNodeSource: function (e) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
        },
        setMediaElementSource: function (e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
        },
        setMediaStreamSource: function (e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
        },
        setBuffer: function (e) {
            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
        },
        play: function (e) {
            if (void 0 === e && (e = 0), !0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    this._startedAt = this.context.currentTime + e;
                    var t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._pausedAt + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                console.warn("v3d.Audio: this Audio has no playback control.")
            } else console.warn("v3d.Audio: Audio is already playing.")
        },
        pause: function () {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate, this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
            console.warn("v3d.Audio: this Audio has no playback control.")
        },
        stop: function () {
            if (!1 !== this.hasPlaybackControl) return this._pausedAt = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
            console.warn("v3d.Audio: this Audio has no playback control.")
        },
        connect: function () {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function () {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function () {
            return this.filters
        },
        setFilters: function (e) {
            return e = e || [], !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
        },
        setDetune: function (e) {
            if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
        },
        getDetune: function () {
            return this.detune
        },
        getFilter: function () {
            return this.getFilters()[0]
        },
        setFilter: function (e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function (e) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
            console.warn("v3d.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function () {
            return this.playbackRate
        },
        onEnded: function () {
            this.isPlaying = !1
        },
        getLoop: function () {
            return !1 === this.hasPlaybackControl ? (console.warn("v3d.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function (e) {
            if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("v3d.Audio: this Audio has no playback control.")
        },
        setLoopStart: function (e) {
            return this.loopStart = e, this
        },
        setLoopEnd: function (e) {
            return this.loopEnd = e, this
        },
        getVolume: function () {
            return this.gain.gain.value
        },
        setVolume: function (e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        }
    });
    var ih = new on,
        ah = new nn,
        oh = new on,
        sh = new on;

    function lh(e) {
        rh.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }

    function ch(e, t) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }

    function uh(e, t, n) {
        this.binding = e, this.valueSize = n;
        var r, i = Float64Array;
        switch (t) {
            case "quaternion":
                r = this._slerp;
                break;
            case "string":
            case "bool":
                i = Array, r = this._select;
                break;
            default:
                r = this._lerp
        }
        this.buffer = new i(4 * n), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
    }
    lh.prototype = Object.assign(Object.create(rh.prototype), {
        constructor: lh,
        getOutput: function () {
            return this.panner
        },
        getRefDistance: function () {
            return this.panner.refDistance
        },
        setRefDistance: function (e) {
            return this.panner.refDistance = e, this
        },
        getRolloffFactor: function () {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function (e) {
            return this.panner.rolloffFactor = e, this
        },
        getDistanceModel: function () {
            return this.panner.distanceModel
        },
        setDistanceModel: function (e) {
            return this.panner.distanceModel = e, this
        },
        getMaxDistance: function () {
            return this.panner.maxDistance
        },
        setMaxDistance: function (e) {
            return this.panner.maxDistance = e, this
        },
        setDirectionalCone: function (e, t, n) {
            return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
        },
        updateMatrixWorld: function (e) {
            if (Fn.prototype.updateMatrixWorld.call(this, e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                this.matrixWorld.decompose(ih, ah, oh), sh.set(0, 0, 1).applyQuaternion(ah);
                var t = this.panner;
                if (t.positionX) {
                    var n = this.context.currentTime + this.listener.timeDelta;
                    t.positionX.linearRampToValueAtTime(ih.x, n), t.positionY.linearRampToValueAtTime(ih.y, n), t.positionZ.linearRampToValueAtTime(ih.z, n), t.orientationX.linearRampToValueAtTime(sh.x, n), t.orientationY.linearRampToValueAtTime(sh.y, n), t.orientationZ.linearRampToValueAtTime(sh.z, n)
                } else t.setPosition(ih.x, ih.y, ih.z), t.setOrientation(sh.x, sh.y, sh.z)
            }
        }
    }), Object.assign(ch.prototype, {
        getFrequencyData: function () {
            return this.analyser.getByteFrequencyData(this.data), this.data
        },
        getAverageFrequency: function () {
            for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
            return e / t.length
        }
    }), Object.assign(uh.prototype, {
        accumulate: function (e, t) {
            var n = this.buffer,
                r = this.valueSize,
                i = e * r + r,
                a = this.cumulativeWeight;
            if (0 === a) {
                for (var o = 0; o !== r; ++o) n[i + o] = n[o];
                a = t
            } else {
                var s = t / (a += t);
                this._mixBufferRegion(n, i, 0, s, r)
            }
            this.cumulativeWeight = a
        },
        apply: function (e) {
            var t = this.valueSize,
                n = this.buffer,
                r = e * t + t,
                i = this.cumulativeWeight,
                a = this.binding;
            if (this.cumulativeWeight = 0, i < 1) {
                var o = 3 * t;
                this._mixBufferRegion(n, r, o, 1 - i, t)
            }
            for (var s = t, l = t + t; s !== l; ++s)
                if (n[s] !== n[s + t]) {
                    a.setValue(n, r);
                    break
                }
        },
        saveOriginalState: function () {
            var e = this.binding,
                t = this.buffer,
                n = this.valueSize,
                r = 3 * n;
            e.getValue(t, r);
            for (var i = n, a = r; i !== a; ++i) t[i] = t[r + i % n];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function () {
            var e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
        },
        _select: function (e, t, n, r, i) {
            if (.5 <= r)
                for (var a = 0; a !== i; ++a) e[t + a] = e[n + a]
        },
        _slerp: function (e, t, n, r) {
            nn.slerpFlat(e, t, e, t, e, n, r)
        },
        _lerp: function (e, t, n, r, i) {
            for (var a = 1 - r, o = 0; o !== i; ++o) {
                var s = t + o;
                e[s] = e[s] * a + e[n + o] * r
            }
        }
    });
    var dh = "\\[\\]\\.",
        hh = new RegExp("[" + dh + "]", "g"),
        ph = "[^" + dh + "]",
        fh = "[^" + dh.replace("\\.", "") + "]",
        mh = (/((?:WC+[\/:])*)/.source.replace("WC", ph), /(WCOD+)?/.source.replace("WCOD", fh)),
        vh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ph),
        gh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ph),
        _h = new RegExp("^" + mh + vh + gh + "$"),
        yh = ["material", "materials", "bones"];

    function xh(e, t, n) {
        var r = n || bh.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, r)
    }

    function bh(e, t, n) {
        this.path = t, this.parsedPath = n || bh.parseTrackName(t), this.node = bh.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
    }

    function wh() {
        this.uuid = Yt.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var r = this;
        this.stats = {
            objects: {
                get total() {
                    return r._objects.length
                },
                get inUse() {
                    return this.total - r.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return r._bindings.length
            }
        }
    }

    function Mh(e, t, n) {
        this._mixer = e, this._clip = t, this._localRoot = n || null;
        for (var r = t.tracks, i = r.length, a = new Array(i), o = {
                endingStart: bt,
                endingEnd: bt
            }, s = 0; s !== i; ++s) {
            var l = r[s].createInterpolant(null);
            (a[s] = l).settings = o
        }
        this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._pingIsEven = !0, this._startTime = null, this.time = 0, this.timeStart = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    function Ah(e) {
        this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    function Sh(e) {
        "string" == typeof e && (console.warn("v3d.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
    }

    function Th(e, t, n) {
        ss.call(this, e, t), this.meshPerAttribute = n || 1
    }

    function Eh(e, t, n) {
        return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
    }
    Object.assign(xh.prototype, {
        getValue: function (e, t) {
            this.bind();
            var n = this._targetGroup.nCachedObjects_,
                r = this._bindings[n];
            void 0 !== r && r.getValue(e, t)
        },
        setValue: function (e, t) {
            for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
        },
        bind: function () {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
        },
        unbind: function () {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
        }
    }), Object.assign(bh, {
        Composite: xh,
        create: function (e, t, n) {
            return e && e.isAnimationObjectGroup ? new bh.Composite(e, t, n) : new bh(e, t, n)
        },
        sanitizeNodeName: function (e) {
            return e.replace(/\s/g, "_").replace(hh, "")
        },
        parseTrackName: function (e) {
            var t = _h.exec(e);
            if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            var n = {
                    nodeName: t[1],
                    objectName: t[2],
                    objectIndex: t[3],
                    propertyName: t[4],
                    propertyIndex: t[5]
                },
                r = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== r && -1 !== r) {
                var i = n.nodeName.substring(r + 1); - 1 !== yh.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)
            }
            if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n
        },
        findNode: function (e, i) {
            if (!i || "" === i || "root" === i || "." === i || -1 === i || i === e.name || i === e.uuid) return e;
            if (e.skeleton) {
                var t = e.skeleton.getBoneByName(i);
                if (void 0 !== t) return t
            }
            if (e.children) {
                var a = function (e) {
                        for (var t = 0; t < e.length; t++) {
                            var n = e[t];
                            if (n.name === i || n.uuid === i) return n;
                            var r = a(n.children);
                            if (r) return r
                        }
                        return null
                    },
                    n = a(e.children);
                if (n) return n
            }
            return null
        }
    }), Object.assign(bh.prototype, {
        _getValue_unavailable: function () {},
        _setValue_unavailable: function () {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function (e, t) {
            e[t] = this.node[this.propertyName]
        }, function (e, t) {
            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
        }, function (e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }, function (e, t) {
            this.resolvedProperty.toArray(e, t)
        }],
        SetterByBindingTypeAndVersioning: [
            [function (e, t) {
                this.targetObject[this.propertyName] = e[t]
            }, function (e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
            }, function (e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (e, t) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
            }, function (e, t) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                this.targetObject.needsUpdate = !0
            }, function (e, t) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }, function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
            }, function (e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function (e, t) {
                this.resolvedProperty.fromArray(e, t)
            }, function (e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
            }, function (e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
            }]
        ],
        getValue: function (e, t) {
            this.bind(), this.getValue(e, t)
        },
        setValue: function (e, t) {
            this.bind(), this.setValue(e, t)
        },
        bind: function () {
            var e = this.node,
                t = this.parsedPath,
                n = t.objectName,
                r = t.propertyName,
                i = t.propertyIndex;
            if (e || (e = bh.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                if (n) {
                    var a = t.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!e.material) return void console.error("v3d.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials) return void console.error("v3d.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return void console.error("v3d.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            e = e.skeleton.bones;
                            for (var o = 0; o < e.length; o++)
                                if (e[o].name === a) {
                                    a = o;
                                    break
                                } break;
                        default:
                            if (void 0 === e[n]) return void console.error("v3d.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[n]
                    }
                    if (void 0 !== a) {
                        if (void 0 === e[a]) return void console.error("v3d.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[a]
                    }
                }
                var s = e[r];
                if (void 0 !== s) {
                    var l = this.Versioning.None;
                    void 0 !== (this.targetObject = e).needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                    var c = this.BindingType.Direct;
                    if (void 0 !== i) {
                        if ("morphTargetInfluences" === r) {
                            if (!e.geometry) return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes) return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (o = 0; o < this.node.geometry.morphAttributes.position.length; o++)
                                    if (e.geometry.morphAttributes.position[o].name === i) {
                                        i = o;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets) return void console.error("v3d.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (o = 0; o < this.node.geometry.morphTargets.length; o++)
                                    if (e.geometry.morphTargets[o].name === i) {
                                        i = o;
                                        break
                                    }
                            }
                        } else if ("nodeValue" == r) {
                            if (i = i.replace(/"/g, ""), !e.nodeValueMap) return void console.error("v3d.PropertyBinding: Trying to animate nodes in non-node material", this);
                            if (void 0 === (i = e.nodeValueMap[i])) return void console.error("v3d.PropertyBinding: Animated node not found ", this)
                        }
                        if (c = this.BindingType.ArrayElement, "nodeRGB" == r) {
                            if (i = i.replace(/"/g, ""), !e.nodeRGBMap) return void console.error("v3d.PropertyBinding: Trying to animate nodes in non-node material", this);
                            if (void 0 === (i = e.nodeRGBMap[i])) return void console.error("v3d.PropertyBinding: Animated node not found ", this);
                            c = this.BindingType.HasFromToArray, s = e.nodeRGB[i]
                        }
                        this.resolvedProperty = s, this.propertyIndex = i
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l]
                } else {
                    var u = t.nodeName;
                    console.error("v3d.PropertyBinding: Trying to update property for track: " + u + "." + r + " but it wasn't found.", e)
                }
            } else console.error("v3d.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function () {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(bh.prototype, {
        _getValue_unbound: bh.prototype.getValue,
        _setValue_unbound: bh.prototype.setValue
    }), Object.assign(wh.prototype, {
        isAnimationObjectGroup: !0,
        add: function () {
            for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, l = void 0, c = 0, u = arguments.length; c !== u; ++c) {
                var d = arguments[c],
                    h = d.uuid,
                    p = r[h];
                if (void 0 === p) {
                    p = t++, r[h] = p, e.push(d);
                    for (var f = 0, m = s; f !== m; ++f) o[f].push(new bh(d, i[f], a[f]))
                } else if (p < n) {
                    l = e[p];
                    var v = --n,
                        g = e[v];
                    e[r[g.uuid] = p] = g, e[r[h] = v] = d;
                    for (f = 0, m = s; f !== m; ++f) {
                        var _ = o[f],
                            y = _[v],
                            x = _[p];
                        _[p] = y, void 0 === x && (x = new bh(d, i[f], a[f])), _[v] = x
                    }
                } else e[p] !== l && console.error("v3d.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = n
        },
        remove: function () {
            for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, i = r.length, a = 0, o = arguments.length; a !== o; ++a) {
                var s = arguments[a],
                    l = s.uuid,
                    c = n[l];
                if (void 0 !== c && t <= c) {
                    var u = t++,
                        d = e[u];
                    e[n[d.uuid] = c] = d, e[n[l] = u] = s;
                    for (var h = 0, p = i; h !== p; ++h) {
                        var f = r[h],
                            m = f[u],
                            v = f[c];
                        f[c] = m, f[u] = v
                    }
                }
            }
            this.nCachedObjects_ = t
        },
        uncache: function () {
            for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, a = i.length, o = 0, s = arguments.length; o !== s; ++o) {
                var l = arguments[o].uuid,
                    c = r[l];
                if (void 0 !== c)
                    if (delete r[l], c < n) {
                        var u = --n,
                            d = e[u],
                            h = e[g = --t];
                        e[r[d.uuid] = c] = d, e[r[h.uuid] = u] = h, e.pop();
                        for (var p = 0, f = a; p !== f; ++p) {
                            var m = (_ = i[p])[u],
                                v = _[g];
                            _[c] = m, _[u] = v, _.pop()
                        }
                    } else {
                        var g;
                        e[r[(h = e[g = --t]).uuid] = c] = h, e.pop();
                        for (p = 0, f = a; p !== f; ++p) {
                            var _;
                            (_ = i[p])[c] = _[g], _.pop()
                        }
                    }
            }
            this.nCachedObjects_ = n
        },
        subscribe_: function (e, t) {
            var n = this._bindingsIndicesByPath,
                r = n[e],
                i = this._bindings;
            if (void 0 !== r) return i[r];
            var a = this._paths,
                o = this._parsedPaths,
                s = this._objects,
                l = s.length,
                c = this.nCachedObjects_,
                u = new Array(l);
            r = i.length, n[e] = r, a.push(e), o.push(t), i.push(u);
            for (var d = c, h = s.length; d !== h; ++d) {
                var p = s[d];
                u[d] = new bh(p, e, t)
            }
            return u
        },
        unsubscribe_: function (e) {
            var t = this._bindingsIndicesByPath,
                n = t[e];
            if (void 0 !== n) {
                var r = this._paths,
                    i = this._parsedPaths,
                    a = this._bindings,
                    o = a.length - 1,
                    s = a[o];
                a[t[e[o]] = n] = s, a.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop()
            }
        }
    }), Object.assign(Mh.prototype, {
        play: function () {
            return this._mixer._activateAction(this), this
        },
        stop: function () {
            return this._mixer._deactivateAction(this), this.reset()
        },
        reset: function () {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this._pingIsEven = !0, this.stopFading().stopWarping()
        },
        isRunning: function () {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function () {
            return this._mixer._isActiveAction(this)
        },
        startAt: function (e) {
            return this._startTime = e, this
        },
        setLoop: function (e, t) {
            return this.loop = e, this.repetitions = t, this
        },
        setEffectiveWeight: function (e) {
            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
        },
        getEffectiveWeight: function () {
            return this._effectiveWeight
        },
        fadeIn: function (e) {
            return this._scheduleFading(e, 0, 1)
        },
        fadeOut: function (e) {
            return this._scheduleFading(e, 1, 0)
        },
        crossFadeFrom: function (e, t, n) {
            if (e.fadeOut(t), this.fadeIn(t), n) {
                var r = this._clip.duration,
                    i = e._clip.duration,
                    a = i / r,
                    o = r / i;
                e.warp(1, a, t), this.warp(o, 1, t)
            }
            return this
        },
        crossFadeTo: function (e, t, n) {
            return e.crossFadeFrom(this, t, n)
        },
        stopFading: function () {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        },
        setEffectiveTimeScale: function (e) {
            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
        },
        getEffectiveTimeScale: function () {
            return this._effectiveTimeScale
        },
        setDuration: function (e) {
            return this.timeScale = this._clip.duration / e, this.stopWarping()
        },
        syncWith: function (e) {
            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
        },
        halt: function (e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        },
        warp: function (e, t, n) {
            var r = this._mixer,
                i = r.time,
                a = this._timeScaleInterpolant,
                o = this.timeScale;
            null === a && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
            var s = a.parameterPositions,
                l = a.sampleValues;
            return s[0] = i, s[1] = i + n, l[0] = e / o, l[1] = t / o, this
        },
        stopWarping: function () {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        },
        getMixer: function () {
            return this._mixer
        },
        getClip: function () {
            return this._clip
        },
        getRoot: function () {
            return this._localRoot || this._mixer._root
        },
        _update: function (e, t, n, r) {
            if (this.enabled) {
                var i = this._startTime;
                if (null !== i) {
                    var a = (e - i) * n;
                    if (a < 0 || 0 === n) return;
                    this._startTime = null, t = n * a
                }
                t *= this._updateTimeScale(e);
                var o = this._updateTime(t),
                    s = this._updateWeight(e);
                if (0 < s)
                    for (var l = this._interpolants, c = this._propertyBindings, u = 0, d = l.length; u !== d; ++u) l[u].evaluate(o), c[u].accumulate(r, s)
            } else this._updateWeight(e)
        },
        _updateWeight: function (e) {
            var t = 0;
            if (this.enabled) {
                t = this.weight;
                var n = this._weightInterpolant;
                if (null !== n) {
                    var r = n.evaluate(e)[0];
                    t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t
        },
        _updateTimeScale: function (e) {
            var t = 0;
            if (!this.paused) {
                t = this.timeScale;
                var n = this._timeScaleInterpolant;
                if (null !== n) t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
            }
            return this._effectiveTimeScale = t
        },
        _loopIsPing: function (e) {
            return 2202 !== this.loop || (-1 == e || 0 == (1 & e) === this._pingIsEven)
        },
        _updateTime: function (e) {
            if (0 === e) return this.time;
            if (2200 !== this.loop && this.repetitions <= 0) return this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e < 0 ? -1 : 1
            }), this.time;
            var t = this.timeStart,
                n = Math.max(t, this._clip.duration),
                r = n - t;
            if (2200 === this.loop) return this.time += e, -1 === this._loopCount && (this._loopCount = 0, this._setEndings(!0, !0, !1)), (this.time < t || this.time > n) && (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = Yt.clamp(this.time, t, n), this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e < 0 ? -1 : 1
            })), this.time;
            var i = 2202 === this.loop,
                a = this._loopIsPing(this._loopCount) ? 1 : -1;
            this.time += a * e;
            var o = this.time < t || this.time > n,
                s = !1;
            if (-1 === this._loopCount && (s = o, this._loopCount = s ? -1 : 0, this._pingIsEven = !s, 0 <= e ? this._setEndings(!0, 0 === this.repetitions, i) : this._setEndings(0 === this.repetitions, !0, i)), o) {
                var l = Math.floor((this.time - t) / r);
                this._loopCount += Math.abs(l);
                var c = this.repetitions - this._loopCount;
                if (c <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = Yt.clamp(this.time, t, n), this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                });
                else {
                    if (1 == c) {
                        var u = e < 0;
                        this._setEndings(u, !u, i)
                    } else this._setEndings(!1, !1, i);
                    var d = (this.time - t) % r;
                    d < 0 && (d += r), this.time = i ? n - d : d + t, s || this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: l
                    })
                }
            }
            return this.time
        },
        _setEndings: function (e, t, n) {
            var r = this._interpolantSettings;
            n ? (r.endingStart = wt, r.endingEnd = wt) : (r.endingStart = e ? this.zeroSlopeAtStart ? wt : bt : Mt, r.endingEnd = t ? this.zeroSlopeAtEnd ? wt : bt : Mt)
        },
        _scheduleFading: function (e, t, n) {
            var r = this._mixer,
                i = r.time,
                a = this._weightInterpolant;
            null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a);
            var o = a.parameterPositions,
                s = a.sampleValues;
            return o[0] = i, s[0] = t, o[1] = i + e, s[1] = n, this
        }
    }), Ah.prototype = Object.assign(Object.create(o.prototype), {
        constructor: Ah,
        _bindAction: function (e, t) {
            var n = e._localRoot || this._root,
                r = e._clip.tracks,
                i = r.length,
                a = e._propertyBindings,
                o = e._interpolants,
                s = n.uuid,
                l = this._bindingsByRootAndName,
                c = l[s];
            void 0 === c && (c = {}, l[s] = c);
            for (var u = 0; u !== i; ++u) {
                var d = r[u],
                    h = d.name,
                    p = c[h];
                if (void 0 !== p) a[u] = p;
                else {
                    if (void 0 !== (p = a[u])) {
                        null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, h));
                        continue
                    }
                    var f = t && t._propertyBindings[u].binding.parsedPath;
                    ++(p = new uh(bh.create(n, h, f), d.ValueTypeName, d.getValueSize())).referenceCount, this._addInactiveBinding(p, s, h), a[u] = p
                }
                o[u].resultBuffer = p.buffer
            }
        },
        _activateAction: function (e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid,
                        n = e._clip.uuid,
                        r = this._actionsByClip[n];
                    this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                }
                for (var i = e._propertyBindings, a = 0, o = i.length; a !== o; ++a) {
                    var s = i[a];
                    0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function (e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                    var i = t[n];
                    0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function () {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function (e) {
            var t = e._cacheIndex;
            return null !== t && t < this._nActiveActions
        },
        _addInactiveAction: function (e, t, n) {
            var r = this._actions,
                i = this._actionsByClip,
                a = i[t];
            if (void 0 === a) a = {
                knownActions: [e],
                actionByRoot: {}
            }, e._byClipCacheIndex = 0, i[t] = a;
            else {
                var o = a.knownActions;
                e._byClipCacheIndex = o.length, o.push(e)
            }
            e._cacheIndex = r.length, r.push(e), a.actionByRoot[n] = e
        },
        _removeInactiveAction: function (e) {
            var t = this._actions,
                n = t[t.length - 1],
                r = e._cacheIndex;
            t[n._cacheIndex = r] = n, t.pop(), e._cacheIndex = null;
            var i = e._clip.uuid,
                a = this._actionsByClip,
                o = a[i],
                s = o.knownActions,
                l = s[s.length - 1],
                c = e._byClipCacheIndex;
            s[l._byClipCacheIndex = c] = l, s.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete a[i], this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function (e) {
            for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                var i = t[n];
                0 == --i.referenceCount && this._removeInactiveBinding(i)
            }
        },
        _lendAction: function (e) {
            var t = this._actions,
                n = e._cacheIndex,
                r = this._nActiveActions++,
                i = t[r];
            t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
        },
        _takeBackAction: function (e) {
            var t = this._actions,
                n = e._cacheIndex,
                r = --this._nActiveActions,
                i = t[r];
            t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
        },
        _addInactiveBinding: function (e, t, n) {
            var r = this._bindingsByRootAndName,
                i = r[t],
                a = this._bindings;
            void 0 === i && (i = {}, r[t] = i), (i[n] = e)._cacheIndex = a.length, a.push(e)
        },
        _removeInactiveBinding: function (e) {
            var t = this._bindings,
                n = e.binding,
                r = n.rootNode.uuid,
                i = n.path,
                a = this._bindingsByRootAndName,
                o = a[r],
                s = t[t.length - 1],
                l = e._cacheIndex;
            t[s._cacheIndex = l] = s, t.pop(), delete o[i], 0 === Object.keys(o).length && delete a[r]
        },
        _lendBinding: function (e) {
            var t = this._bindings,
                n = e._cacheIndex,
                r = this._nActiveBindings++,
                i = t[r];
            t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
        },
        _takeBackBinding: function (e) {
            var t = this._bindings,
                n = e._cacheIndex,
                r = --this._nActiveBindings,
                i = t[r];
            t[e._cacheIndex = r] = e, t[i._cacheIndex = n] = i
        },
        _lendControlInterpolant: function () {
            var e = this._controlInterpolants,
                t = this._nActiveControlInterpolants++,
                n = e[t];
            return void 0 === n && (e[(n = new Vc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t] = n), n
        },
        _takeBackControlInterpolant: function (e) {
            var t = this._controlInterpolants,
                n = e.__cacheIndex,
                r = --this._nActiveControlInterpolants,
                i = t[r];
            t[e.__cacheIndex = r] = e, t[i.__cacheIndex = n] = i
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function (e, t) {
            var n = t || this._root,
                r = n.uuid,
                i = "string" == typeof e ? Tu.findByName(n, e) : e,
                a = null !== i ? i.uuid : e,
                o = this._actionsByClip[a],
                s = null;
            if (void 0 !== o) {
                var l = o.actionByRoot[r];
                if (void 0 !== l) return l;
                s = o.knownActions[0], null === i && (i = s._clip)
            }
            if (null === i) return null;
            var c = new Mh(this, i, t);
            return this._bindAction(c, s), this._addInactiveAction(c, a, r), c
        },
        existingAction: function (e, t) {
            var n = t || this._root,
                r = n.uuid,
                i = "string" == typeof e ? Tu.findByName(n, e) : e,
                a = i ? i.uuid : e,
                o = this._actionsByClip[a];
            return void 0 !== o && o.actionByRoot[r] || null
        },
        stopAllAction: function () {
            var e = this._actions,
                t = this._nActiveActions,
                n = this._bindings,
                r = this._nActiveBindings;
            this._nActiveActions = 0;
            for (var i = this._nActiveBindings = 0; i !== t; ++i) e[i].reset();
            for (i = 0; i !== r; ++i) n[i].useCount = 0;
            return this
        },
        update: function (e) {
            e *= this.timeScale;
            for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
                t[o]._update(r, e, i, a)
            }
            var s = this._bindings,
                l = this._nActiveBindings;
            for (o = 0; o !== l; ++o) s[o].apply(a);
            return this
        },
        setTime: function (e) {
            for (var t = this.time = 0; t < this._actions.length; t++) this._actions[t].time = 0;
            return this.update(e)
        },
        getRoot: function () {
            return this._root
        },
        uncacheClip: function (e) {
            var t = this._actions,
                n = e.uuid,
                r = this._actionsByClip,
                i = r[n];
            if (void 0 !== i) {
                for (var a = i.knownActions, o = 0, s = a.length; o !== s; ++o) {
                    var l = a[o];
                    this._deactivateAction(l);
                    var c = l._cacheIndex,
                        u = t[t.length - 1];
                    l._cacheIndex = null, l._byClipCacheIndex = null, t[u._cacheIndex = c] = u, t.pop(), this._removeInactiveBindingsForAction(l)
                }
                delete r[n]
            }
        },
        uncacheRoot: function (e) {
            var t = e.uuid,
                n = this._actionsByClip;
            for (var r in n) {
                var i = n[r].actionByRoot[t];
                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
            var a = this._bindingsByRootAndName[t];
            if (void 0 !== a)
                for (var o in a) {
                    var s = a[o];
                    s.restoreOriginalState(), this._removeInactiveBinding(s)
                }
        },
        uncacheAction: function (e, t) {
            var n = this.existingAction(e, t);
            null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
        }
    }), Sh.prototype.clone = function () {
        return new Sh(void 0 === this.value.clone ? this.value : this.value.clone())
    }, Th.prototype = Object.assign(Object.create(ss.prototype), {
        constructor: Th,
        isInstancedInterleavedBuffer: !0,
        copy: function (e) {
            return ss.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        }
    }), Object.assign(Eh.prototype, {
        set: function (e, t, n) {
            return this.radius = e, this.theta = t, this.y = n, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
        },
        setFromVector3: function (e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function (e, t, n) {
            return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
        }
    });
    var Ch = new qt;

    function Ph(e, t) {
        this.min = void 0 !== e ? e : new qt(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new qt(-1 / 0, -1 / 0)
    }
    Object.assign(Ph.prototype, {
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromPoints: function (e) {
            this.makeEmpty();
            for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function (e, t) {
            var n = Ch.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function (e) {
            return void 0 === e && (console.warn("v3d.Box2: .getCenter() target is now required"), e = new qt), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function (e) {
            return void 0 === e && (console.warn("v3d.Box2: .getSize() target is now required"), e = new qt), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function (e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function (e, t) {
            return void 0 === t && (console.warn("v3d.Box2: .getParameter() target is now required"), t = new qt), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function (e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function (e, t) {
            return void 0 === t && (console.warn("v3d.Box2: .clampPoint() target is now required"), t = new qt), t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function (e) {
            return Ch.copy(e).clamp(this.min, this.max).sub(e).length()
        },
        intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        translate: function (e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    });
    var Lh = new on,
        Rh = new on;

    function Dh(e, t) {
        this.start = void 0 !== e ? e : new on, this.end = void 0 !== t ? t : new on
    }

    function Ih(e) {
        Fn.call(this), this.material = e, this.render = function () {}
    }
    Object.assign(Dh.prototype, {
        set: function (e, t) {
            return this.start.copy(e), this.end.copy(t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        },
        getCenter: function (e) {
            return void 0 === e && (console.warn("v3d.Line3: .getCenter() target is now required"), e = new on), e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function (e) {
            return void 0 === e && (console.warn("v3d.Line3: .delta() target is now required"), e = new on), e.subVectors(this.end, this.start)
        },
        distanceSq: function () {
            return this.start.distanceToSquared(this.end)
        },
        distance: function () {
            return this.start.distanceTo(this.end)
        },
        at: function (e, t) {
            return void 0 === t && (console.warn("v3d.Line3: .at() target is now required"), t = new on), this.delta(t).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function (e, t) {
            Lh.subVectors(e, this.start), Rh.subVectors(this.end, this.start);
            var n = Rh.dot(Rh),
                r = Rh.dot(Lh) / n;
            return t && (r = Yt.clamp(r, 0, 1)), r
        },
        closestPointToPoint: function (e, t, n) {
            var r = this.closestPointToPointParameter(e, t);
            return void 0 === n && (console.warn("v3d.Line3: .closestPointToPoint() target is now required"), n = new on), this.delta(n).multiplyScalar(r).add(this.start)
        },
        applyMatrix4: function (e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        },
        equals: function (e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }), ((Ih.prototype = Object.create(Fn.prototype)).constructor = Ih).prototype.isImmediateRenderObject = !0;
    var Nh = new on;

    function Oh(e, t) {
        Fn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
        for (var n = new ni, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, a = 1; i < 32; i++, a++) {
            var o = i / 32 * Math.PI * 2,
                s = a / 32 * Math.PI * 2;
            r.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1)
        }
        n.setAttribute("position", new Hr(r, 3));
        var l = new Us({
            fog: !1
        });
        this.cone = new qs(n, l), this.add(this.cone), this.update()
    }((Oh.prototype = Object.create(Fn.prototype)).constructor = Oh).prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, Oh.prototype.update = function () {
        this.light.updateMatrixWorld();
        var e = this.light.distance ? this.light.distance : 1e3,
            t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e), Nh.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Nh), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    };
    var Fh = new on,
        Bh = new fn,
        zh = new fn;

    function Uh(e) {
        for (var t = function e(t) {
                var n = [];
                t && t.isBone && n.push(t);
                for (var r = 0; r < t.children.length; r++) n.push.apply(n, e(t.children[r]));
                return n
            }(e), n = new ni, r = [], i = [], a = new Pr(0, 0, 1), o = new Pr(0, 1, 0), s = 0; s < t.length; s++) {
            var l = t[s];
            l.parent && l.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(a.r, a.g, a.b), i.push(o.r, o.g, o.b))
        }
        n.setAttribute("position", new Hr(r, 3)), n.setAttribute("color", new Hr(i, 3));
        var c = new Us({
            vertexColors: _,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        qs.call(this, n, c), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }

    function Vh(e, t, n) {
        this.light = e, this.light.updateMatrixWorld(), this.color = n;
        var r = new rc(t, 4, 2),
            i = new Fr({
                wireframe: !0,
                fog: !1
            });
        xi.call(this, r, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }((Uh.prototype = Object.create(qs.prototype)).constructor = Uh).prototype.updateMatrixWorld = function (e) {
        var t = this.bones,
            n = this.geometry,
            r = n.getAttribute("position");
        zh.getInverse(this.root.matrixWorld);
        for (var i = 0, a = 0; i < t.length; i++) {
            var o = t[i];
            o.parent && o.parent.isBone && (Bh.multiplyMatrices(zh, o.matrixWorld), Fh.setFromMatrixPosition(Bh), r.setXYZ(a, Fh.x, Fh.y, Fh.z), Bh.multiplyMatrices(zh, o.parent.matrixWorld), Fh.setFromMatrixPosition(Bh), r.setXYZ(a + 1, Fh.x, Fh.y, Fh.z), a += 2)
        }
        n.getAttribute("position").needsUpdate = !0, Fn.prototype.updateMatrixWorld.call(this, e)
    }, ((Vh.prototype = Object.create(xi.prototype)).constructor = Vh).prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose()
    }, Vh.prototype.update = function () {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    };
    var Gh = new on,
        kh = new Pr,
        jh = new Pr;

    function Wh(e, t, n) {
        Fn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
        var r = new ml(t);
        r.rotateY(.5 * Math.PI), this.material = new Fr({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = _);
        var i = r.getAttribute("position"),
            a = new Float32Array(3 * i.count);
        r.setAttribute("color", new zr(a, 3)), this.add(new xi(r, this.material)), this.update()
    }

    function Xh(e, t, n, r) {
        e = e || 10, t = t || 10, n = new Pr(void 0 !== n ? n : 4473924), r = new Pr(void 0 !== r ? r : 8947848);
        for (var i = t / 2, a = e / t, o = e / 2, s = [], l = [], c = 0, u = 0, d = -o; c <= t; c++, d += a) {
            s.push(-o, 0, d, o, 0, d), s.push(d, 0, -o, d, 0, o);
            var h = c === i ? n : r;
            h.toArray(l, u), u += 3, h.toArray(l, u), u += 3, h.toArray(l, u), u += 3, h.toArray(l, u), u += 3
        }
        var p = new ni;
        p.setAttribute("position", new Hr(s, 3)), p.setAttribute("color", new Hr(l, 3));
        var f = new Us({
            vertexColors: _
        });
        qs.call(this, p, f)
    }

    function Hh(e, t, n, r, i, a) {
        e = e || 10, t = t || 16, n = n || 8, r = r || 64, i = new Pr(void 0 !== i ? i : 4473924), a = new Pr(void 0 !== a ? a : 8947848);
        var o, s, l, c, u, d, h, p = [],
            f = [];
        for (c = 0; c <= t; c++) l = c / t * (2 * Math.PI), o = Math.sin(l) * e, s = Math.cos(l) * e, p.push(0, 0, 0), p.push(o, 0, s), h = 1 & c ? i : a, f.push(h.r, h.g, h.b), f.push(h.r, h.g, h.b);
        for (c = 0; c <= n; c++)
            for (h = 1 & c ? i : a, d = e - e / n * c, u = 0; u < r; u++) l = u / r * (2 * Math.PI), o = Math.sin(l) * d, s = Math.cos(l) * d, p.push(o, 0, s), f.push(h.r, h.g, h.b), l = (u + 1) / r * (2 * Math.PI), o = Math.sin(l) * d, s = Math.cos(l) * d, p.push(o, 0, s), f.push(h.r, h.g, h.b);
        var m = new ni;
        m.setAttribute("position", new Hr(p, 3)), m.setAttribute("color", new Hr(f, 3));
        var v = new Us({
            vertexColors: _
        });
        qs.call(this, m, v)
    }((Wh.prototype = Object.create(Fn.prototype)).constructor = Wh).prototype.dispose = function () {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Wh.prototype.update = function () {
        var e = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
            var t = e.geometry.getAttribute("color");
            kh.copy(this.light.color), jh.copy(this.light.groundColor);
            for (var n = 0, r = t.count; n < r; n++) {
                var i = n < r / 2 ? kh : jh;
                t.setXYZ(n, i.r, i.g, i.b)
            }
            t.needsUpdate = !0
        }
        e.lookAt(Gh.setFromMatrixPosition(this.light.matrixWorld).negate())
    }, Xh.prototype = Object.assign(Object.create(qs.prototype), {
        constructor: Xh,
        copy: function (e) {
            return qs.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        }
    }), (Hh.prototype = Object.create(qs.prototype)).constructor = Hh;
    var Yh = new on,
        qh = new on,
        Zh = new on;

    function Qh(e, t, n) {
        Fn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
        var r = new ni;
        r.setAttribute("position", new Hr([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
        var i = new Us({
            fog: !1
        });
        this.lightPlane = new Xs(r, i), this.add(this.lightPlane), (r = new ni).setAttribute("position", new Hr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Xs(r, i), this.add(this.targetLine), this.update()
    }((Qh.prototype = Object.create(Fn.prototype)).constructor = Qh).prototype.dispose = function () {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, Qh.prototype.update = function () {
        Yh.setFromMatrixPosition(this.light.matrixWorld), qh.setFromMatrixPosition(this.light.target.matrixWorld), Zh.subVectors(qh, Yh), this.lightPlane.lookAt(qh), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(qh), this.targetLine.scale.z = Zh.length()
    };
    var Kh = new on,
        Jh = new Fi;

    function $h(e) {
        var t = new ni,
            n = new Us({
                color: 16777215,
                vertexColors: 1
            }),
            r = [],
            i = [],
            a = {},
            o = new Pr(16755200),
            s = new Pr(16711680),
            l = new Pr(43775),
            c = new Pr(16777215),
            u = new Pr(3355443);

        function d(e, t, n) {
            h(e, n), h(t, n)
        }

        function h(e, t) {
            r.push(0, 0, 0), i.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(r.length / 3 - 1)
        }
        d("n1", "n2", o), d("n2", "n4", o), d("n4", "n3", o), d("n3", "n1", o), d("f1", "f2", o), d("f2", "f4", o), d("f4", "f3", o), d("f3", "f1", o), d("n1", "f1", o), d("n2", "f2", o), d("n3", "f3", o), d("n4", "f4", o), d("p", "n1", s), d("p", "n2", s), d("p", "n3", s), d("p", "n4", s), d("u1", "u2", l), d("u2", "u3", l), d("u3", "u1", l), d("c", "t", c), d("p", "c", u), d("cn1", "cn2", u), d("cn3", "cn4", u), d("cf1", "cf2", u), d("cf3", "cf4", u), t.setAttribute("position", new Hr(r, 3)), t.setAttribute("color", new Hr(i, 3)), qs.call(this, t, n), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
    }

    function ep(e, t, n, r, i, a, o) {
        Kh.set(i, a, o).unproject(r);
        var s = t[e];
        if (void 0 !== s)
            for (var l = n.getAttribute("position"), c = 0, u = s.length; c < u; c++) l.setXYZ(s[c], Kh.x, Kh.y, Kh.z)
    }(($h.prototype = Object.create(qs.prototype)).constructor = $h).prototype.update = function () {
        var e = this.geometry,
            t = this.pointMap;
        Jh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), ep("c", t, e, Jh, 0, 0, -1), ep("t", t, e, Jh, 0, 0, 1), ep("n1", t, e, Jh, -1, -1, -1), ep("n2", t, e, Jh, 1, -1, -1), ep("n3", t, e, Jh, -1, 1, -1), ep("n4", t, e, Jh, 1, 1, -1), ep("f1", t, e, Jh, -1, -1, 1), ep("f2", t, e, Jh, 1, -1, 1), ep("f3", t, e, Jh, -1, 1, 1), ep("f4", t, e, Jh, 1, 1, 1), ep("u1", t, e, Jh, .7, 1.1, -1), ep("u2", t, e, Jh, -.7, 1.1, -1), ep("u3", t, e, Jh, 0, 2, -1), ep("cf1", t, e, Jh, -1, 0, 1), ep("cf2", t, e, Jh, 1, 0, 1), ep("cf3", t, e, Jh, 0, -1, 1), ep("cf4", t, e, Jh, 0, 1, 1), ep("cn1", t, e, Jh, -1, 0, -1), ep("cn2", t, e, Jh, 1, 0, -1), ep("cn3", t, e, Jh, 0, -1, -1), ep("cn4", t, e, Jh, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
    };
    var tp = new Kn;

    function np(e, t) {
        this.object = e, void 0 === t && (t = 16776960);
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            r = new Float32Array(24),
            i = new ni;
        i.setIndex(new zr(n, 1)), i.setAttribute("position", new zr(r, 3)), qs.call(this, i, new Us({
            color: t
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function rp(e, t) {
        this.type = "Box3Helper", this.box = e, t = t || 16776960;
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            r = new ni;
        r.setIndex(new zr(n, 1)), r.setAttribute("position", new Hr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), qs.call(this, r, new Us({
            color: t
        })), this.geometry.computeBoundingSphere()
    }

    function ip(e, t, n) {
        this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
        var r = void 0 !== n ? n : 16776960,
            i = new ni;
        i.setAttribute("position", new Hr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), Xs.call(this, i, new Us({
            color: r
        }));
        var a = new ni;
        a.setAttribute("position", new Hr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new xi(a, new Fr({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }((np.prototype = Object.create(qs.prototype)).constructor = np).prototype.update = function (e) {
        if (void 0 !== e && console.warn("v3d.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && tp.setFromObject(this.object), !tp.isEmpty()) {
            var t = tp.min,
                n = tp.max,
                r = this.geometry.attributes.position,
                i = r.array;
            i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
        }
    }, np.prototype.setFromObject = function (e) {
        return this.object = e, this.update(), this
    }, np.prototype.copy = function (e) {
        return qs.prototype.copy.call(this, e), this.object = e.object, this
    }, np.prototype.clone = function () {
        return (new this.constructor).copy(this)
    }, ((rp.prototype = Object.create(qs.prototype)).constructor = rp).prototype.updateMatrixWorld = function (e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), Fn.prototype.updateMatrixWorld.call(this, e))
    }, ((ip.prototype = Object.create(Xs.prototype)).constructor = ip).prototype.updateMatrixWorld = function (e) {
        var t = -this.plane.constant;
        Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? Pe : re, this.lookAt(this.plane.normal), Fn.prototype.updateMatrixWorld.call(this, e)
    };
    var ap, op, sp = new on;

    function lp(e, t, n, r, i, a) {
        Fn.call(this), void 0 === e && (e = new on(0, 0, 1)), void 0 === t && (t = new on(0, 0, 0)), void 0 === n && (n = 1), void 0 === r && (r = 16776960), void 0 === i && (i = .2 * n), void 0 === a && (a = .2 * i), void 0 === ap && ((ap = new ni).setAttribute("position", new Hr([0, 0, 0, 0, 1, 0], 3)), (op = new pc(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new Xs(ap, new Us({
            color: r
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new xi(op, new Fr({
            color: r
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, a)
    }

    function cp(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            n = new ni;
        n.setAttribute("position", new Hr(t, 3)), n.setAttribute("color", new Hr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
        var r = new Us({
            vertexColors: _
        });
        qs.call(this, n, r)
    }((lp.prototype = Object.create(Fn.prototype)).constructor = lp).prototype.setDirection = function (e) {
        if (.99999 < e.y) this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            sp.set(e.z, 0, -e.x).normalize();
            var t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(sp, t)
        }
    }, lp.prototype.setLength = function (e, t, n) {
        void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
    }, lp.prototype.setColor = function (e) {
        this.line.material.color.set(e), this.cone.material.color.set(e)
    }, lp.prototype.copy = function (e) {
        return Fn.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    }, lp.prototype.clone = function () {
        return (new this.constructor).copy(this)
    }, (cp.prototype = Object.create(qs.prototype)).constructor = cp;

    function up(e) {
        console.warn("v3d.ClosedSplineCurve3 has been deprecated. Use v3d.CatmullRomCurve3 instead."), qu.call(this, e), this.type = "catmullrom", this.closed = !0
    }

    function dp(e) {
        console.warn("v3d.SplineCurve3 has been deprecated. Use v3d.CatmullRomCurve3 instead."), qu.call(this, e), this.type = "catmullrom"
    }

    function hp(e) {
        console.warn("v3d.Spline has been removed. Use v3d.CatmullRomCurve3 instead."), qu.call(this, e), this.type = "catmullrom"
    }
    Vu.create = function (e, t) {
        return console.log("v3d.Curve.create() has been deprecated"), e.prototype = Object.create(Vu.prototype), (e.prototype.constructor = e).prototype.getPoint = t, e
    }, Object.assign(cd.prototype, {
        createPointsGeometry: function (e) {
            console.warn("v3d.CurvePath: .createPointsGeometry() has been removed. Use new v3d.Geometry().setFromPoints(points) instead.");
            var t = this.getPoints(e);
            return this.createGeometry(t)
        },
        createSpacedPointsGeometry: function (e) {
            console.warn("v3d.CurvePath: .createSpacedPointsGeometry() has been removed. Use new v3d.Geometry().setFromPoints(points) instead.");
            var t = this.getSpacedPoints(e);
            return this.createGeometry(t)
        },
        createGeometry: function (e) {
            console.warn("v3d.CurvePath: .createGeometry() has been removed. Use new v3d.Geometry().setFromPoints(points) instead.");
            for (var t = new Ei, n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                t.vertices.push(new on(i.x, i.y, i.z || 0))
            }
            return t
        }
    }), Object.assign(ud.prototype, {
        fromPoints: function (e) {
            return console.warn("v3d.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
        }
    }), up.prototype = Object.create(qu.prototype), dp.prototype = Object.create(qu.prototype), hp.prototype = Object.create(qu.prototype), Object.assign(hp.prototype, {
        initFromArray: function () {
            console.error("v3d.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function () {
            console.error("v3d.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function () {
            console.error("v3d.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), Xh.prototype.setColors = function () {
        console.error("v3d.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, Uh.prototype.update = function () {
        console.error("v3d.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(Ru.prototype, {
        extractUrlBase: function (e) {
            return console.warn("v3d.Loader: .extractUrlBase() has been deprecated. Use v3d.LoaderUtils.extractUrlBase() instead."), Md.extractUrlBase(e)
        }
    }), Ru.Handlers = {
        add: function () {
            console.error("v3d.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function () {
            console.error("v3d.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    }, Object.assign(Cd.prototype, {
        setTexturePath: function (e) {
            return console.warn("v3d.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
        }
    }), Object.assign(Ph.prototype, {
        center: function (e) {
            return console.warn("v3d.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function () {
            return console.warn("v3d.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function (e) {
            return console.warn("v3d.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        size: function (e) {
            return console.warn("v3d.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Object.assign(Kn.prototype, {
        center: function (e) {
            return console.warn("v3d.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function () {
            return console.warn("v3d.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function (e) {
            return console.warn("v3d.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionSphere: function (e) {
            return console.warn("v3d.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        },
        size: function (e) {
            return console.warn("v3d.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), ji.prototype.setFromMatrix = function (e) {
        return console.warn("v3d.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e)
    }, Dh.prototype.center = function (e) {
        return console.warn("v3d.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
    }, Object.assign(Yt, {
        random16: function () {
            return console.warn("v3d.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        nearestPowerOfTwo: function (e) {
            return console.warn("v3d.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Yt.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function (e) {
            return console.warn("v3d.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Yt.ceilPowerOfTwo(e)
        }
    }), Object.assign(Zt.prototype, {
        flattenToArrayOffset: function (e, t) {
            return console.warn("v3d.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        multiplyVector3: function (e) {
            return console.warn("v3d.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3(matrix) instead."), e.applyMatrix3(this)
        },
        multiplyVector3Array: function () {
            console.error("v3d.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBufferAttribute: function (e) {
            return console.warn("v3d.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3(matrix) instead."), e.applyMatrix3(this)
        },
        applyToVector3Array: function () {
            console.error("v3d.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(fn.prototype, {
        extractPosition: function (e) {
            return console.warn("v3d.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        },
        flattenToArrayOffset: function (e, t) {
            return console.warn("v3d.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        getPosition: function () {
            return console.warn("v3d.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition(matrix) instead."), (new on).setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function (e) {
            return console.warn("v3d.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function () {
            console.warn("v3d.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function (e) {
            return console.warn("v3d.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4(matrix) instead."), e.applyMatrix4(this)
        },
        multiplyVector4: function (e) {
            return console.warn("v3d.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4(matrix) instead."), e.applyMatrix4(this)
        },
        multiplyVector3Array: function () {
            console.error("v3d.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function (e) {
            console.warn("v3d.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection(matrix) instead."), e.transformDirection(this)
        },
        crossVector: function (e) {
            return console.warn("v3d.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4(matrix) instead."), e.applyMatrix4(this)
        },
        translate: function () {
            console.error("v3d.Matrix4: .translate() has been removed.")
        },
        rotateX: function () {
            console.error("v3d.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function () {
            console.error("v3d.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function () {
            console.error("v3d.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function () {
            console.error("v3d.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBufferAttribute: function (e) {
            return console.warn("v3d.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4(matrix) instead."), e.applyMatrix4(this)
        },
        applyToVector3Array: function () {
            console.error("v3d.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function (e, t, n, r, i, a) {
            return console.warn("v3d.Matrix4: .makeFrustum() has been removed. Use .makePerspective(left, right, top, bottom, near, far) instead."), this.makePerspective(e, t, r, n, i, a)
        }
    }), fr.prototype.isIntersectionLine = function (e) {
        return console.warn("v3d.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
    }, nn.prototype.multiplyVector3 = function (e) {
        return console.warn("v3d.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion(quaternion) instead."), e.applyQuaternion(this)
    }, Object.assign(ur.prototype, {
        isIntersectionBox: function (e) {
            return console.warn("v3d.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionPlane: function (e) {
            return console.warn("v3d.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
        },
        isIntersectionSphere: function (e) {
            return console.warn("v3d.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        }
    }), Object.assign(Sr.prototype, {
        area: function () {
            return console.warn("v3d.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        },
        barycoordFromPoint: function (e, t) {
            return console.warn("v3d.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
        },
        midpoint: function (e) {
            return console.warn("v3d.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
        },
        normal: function (e) {
            return console.warn("v3d.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
        },
        plane: function (e) {
            return console.warn("v3d.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
        }
    }), Object.assign(Sr, {
        barycoordFromPoint: function (e, t, n, r, i) {
            return console.warn("v3d.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Sr.getBarycoord(e, t, n, r, i)
        },
        normal: function (e, t, n, r) {
            return console.warn("v3d.Triangle: .normal() has been renamed to .getNormal()."), Sr.getNormal(e, t, n, r)
        }
    }), Object.assign(dd.prototype, {
        extractAllPoints: function (e) {
            return console.warn("v3d.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
        },
        extrude: function (e) {
            return console.warn("v3d.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Ql(this, e)
        },
        makeGeometry: function (e) {
            return console.warn("v3d.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new lc(this, e)
        }
    }), Object.assign(qt.prototype, {
        fromAttribute: function (e, t, n) {
            return console.warn("v3d.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        },
        distanceToManhattan: function (e) {
            return console.warn("v3d.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function () {
            return console.warn("v3d.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(on.prototype, {
        setEulerFromRotationMatrix: function () {
            console.error("v3d.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function () {
            console.error("v3d.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function (e) {
            return console.warn("v3d.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function (e) {
            return console.warn("v3d.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function (e, t) {
            return console.warn("v3d.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        },
        applyProjection: function (e) {
            return console.warn("v3d.Vector3: .applyProjection() has been removed. Use .applyMatrix4(m) instead."), this.applyMatrix4(e)
        },
        fromAttribute: function (e, t, n) {
            return console.warn("v3d.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        },
        distanceToManhattan: function (e) {
            return console.warn("v3d.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function () {
            return console.warn("v3d.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign($t.prototype, {
        fromAttribute: function (e, t, n) {
            return console.warn("v3d.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        },
        lengthManhattan: function () {
            return console.warn("v3d.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(Ei.prototype, {
        computeTangents: function () {
            console.error("v3d.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function () {
            console.error("v3d.Geometry: .computeLineDistances() has been removed. Use v3d.Line.computeLineDistances() instead.")
        },
        applyMatrix: function (e) {
            return console.warn("v3d.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
        }
    }), Object.assign(Fn.prototype, {
        getChildByName: function (e) {
            return console.warn("v3d.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
        },
        renderDepth: function () {
            console.warn("v3d.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function (e, t) {
            return console.warn("v3d.Object3D: .translate() has been removed. Use .translateOnAxis(axis, distance) instead."), this.translateOnAxis(t, e)
        },
        getWorldRotation: function () {
            console.error("v3d.Object3D: .getWorldRotation() has been removed. Use v3d.Object3D.getWorldQuaternion(target) instead.")
        },
        applyMatrix: function (e) {
            return console.warn("v3d.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
        }
    }), Object.defineProperties(Fn.prototype, {
        eulerOrder: {
            get: function () {
                return console.warn("v3d.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function (e) {
                console.warn("v3d.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function () {
                console.warn("v3d.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function () {
                console.warn("v3d.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.assign(xi.prototype, {
        setDrawMode: function () {
            console.error("v3d.Mesh: .setDrawMode() has been removed. The renderer now always assumes v3d.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }), Object.defineProperties(xi.prototype, {
        drawMode: {
            get: function () {
                return console.error("v3d.Mesh: .drawMode has been removed. The renderer now always assumes v3d.TrianglesDrawMode."), 0
            },
            set: function () {
                console.error("v3d.Mesh: .drawMode has been removed. The renderer now always assumes v3d.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }), Object.defineProperties(Cs.prototype, {
        objects: {
            get: function () {
                return console.warn("v3d.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(Ds.prototype, "useVertexTexture", {
        get: function () {
            console.warn("v3d.Skeleton: useVertexTexture has been removed.")
        },
        set: function () {
            console.warn("v3d.Skeleton: useVertexTexture has been removed.")
        }
    }), Ps.prototype.initBones = function () {
        console.error("v3d.SkinnedMesh: initBones() has been removed.")
    }, Object.defineProperty(Vu.prototype, "__arcLengthDivisions", {
        get: function () {
            return console.warn("v3d.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function (e) {
            console.warn("v3d.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
        }
    }), Bi.prototype.setLens = function (e, t) {
        console.warn("v3d.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
    }, Object.defineProperties(hd.prototype, {
        onlyShadow: {
            set: function () {
                console.warn("v3d.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function (e) {
                console.warn("v3d.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function (e) {
                console.warn("v3d.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function (e) {
                console.warn("v3d.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function (e) {
                console.warn("v3d.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function (e) {
                console.warn("v3d.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function (e) {
                console.warn("v3d.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function (e) {
                console.warn("v3d.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function () {
                console.warn("v3d.Light: .shadowCameraVisible has been removed. Use new v3d.CameraHelper(light.shadow.camera) instead.")
            }
        },
        shadowBias: {
            set: function (e) {
                console.warn("v3d.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function () {
                console.warn("v3d.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function (e) {
                console.warn("v3d.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function (e) {
                console.warn("v3d.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
            }
        }
    }), Object.defineProperties(zr.prototype, {
        length: {
            get: function () {
                return console.warn("v3d.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        },
        dynamic: {
            get: function () {
                return console.warn("v3d.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Gt
            },
            set: function () {
                console.warn("v3d.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Gt)
            }
        }
    }), Object.assign(zr.prototype, {
        setDynamic: function (e) {
            return console.warn("v3d.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? Gt : Vt), this
        },
        copyIndicesArray: function () {
            console.error("v3d.BufferAttribute: .copyIndicesArray() has been removed.")
        },
        setArray: function () {
            console.error("v3d.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }), Object.assign(ni.prototype, {
        addIndex: function (e) {
            console.warn("v3d.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
        },
        addAttribute: function (e, t) {
            return console.warn("v3d.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("v3d.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("v3d.BufferGeometry: .addAttribute() now expects (name, attribute)."), this.setAttribute(e, new zr(t, arguments[2])))
        },
        addDrawCall: function (e, t, n) {
            void 0 !== n && console.warn("v3d.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("v3d.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
        },
        clearDrawCalls: function () {
            console.warn("v3d.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function () {
            console.warn("v3d.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function () {
            console.warn("v3d.BufferGeometry: .computeOffsets() has been removed.")
        },
        removeAttribute: function (e) {
            return console.warn("v3d.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e)
        },
        applyMatrix: function (e) {
            return console.warn("v3d.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
        }
    }), Object.defineProperties(ni.prototype, {
        drawcalls: {
            get: function () {
                return console.error("v3d.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function () {
                return console.warn("v3d.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.defineProperties(ss.prototype, {
        dynamic: {
            get: function () {
                return console.warn("v3d.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === Gt
            },
            set: function (e) {
                console.warn("v3d.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e)
            }
        }
    }), Object.assign(ss.prototype, {
        setDynamic: function (e) {
            return console.warn("v3d.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? Gt : Vt), this
        },
        setArray: function () {
            console.error("v3d.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }), Object.assign(Kl.prototype, {
        getArrays: function () {
            console.error("v3d.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function () {
            console.error("v3d.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function () {
            console.error("v3d.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.defineProperties(Sh.prototype, {
        dynamic: {
            set: function () {
                console.warn("v3d.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function () {
                return console.warn("v3d.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(Or.prototype, {
        wrapAround: {
            get: function () {
                console.warn("v3d.Material: .wrapAround has been removed.")
            },
            set: function () {
                console.warn("v3d.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function () {
                console.warn("v3d.Material: .overdraw has been removed.")
            },
            set: function () {
                console.warn("v3d.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function () {
                return console.warn("v3d.Material: .wrapRGB has been removed."), new Pr
            }
        },
        shading: {
            get: function () {
                console.error("v3d." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function (e) {
                console.warn("v3d." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
            }
        },
        stencilMask: {
            get: function () {
                return console.warn("v3d." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
            },
            set: function (e) {
                console.warn("v3d." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
            }
        }
    }), Object.defineProperties(Mc.prototype, {
        metal: {
            get: function () {
                return console.warn("v3d.MeshPhongMaterial: .metal has been removed. Use v3d.MeshStandardMaterial instead."), !1
            },
            set: function () {
                console.warn("v3d.MeshPhongMaterial: .metal has been removed. Use v3d.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(Oi.prototype, {
        derivatives: {
            get: function () {
                return console.warn("v3d.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function (e) {
                console.warn("v3d. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
            }
        }
    }), Object.assign(is.prototype, {
        clearTarget: function (e, t, n, r) {
            console.warn("v3d.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r)
        },
        animate: function (e) {
            console.warn("v3d.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function () {
            return console.warn("v3d.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function () {
            return console.warn("v3d.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function () {
            return console.warn("v3d.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        resetGLState: function () {
            return console.warn("v3d.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },
        supportsFloatTextures: function () {
            return console.warn("v3d.WebGLRenderer: .supportsFloatTextures() is now .extensions.get('OES_texture_float')."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function () {
            return console.warn("v3d.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get('OES_texture_half_float')."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function () {
            return console.warn("v3d.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get('OES_standard_derivatives')."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function () {
            return console.warn("v3d.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get('WEBGL_compressed_texture_s3tc')."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function () {
            return console.warn("v3d.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get('WEBGL_compressed_texture_pvrtc')."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function () {
            return console.warn("v3d.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get('EXT_blend_minmax')."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function () {
            return console.warn("v3d.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function () {
            return console.warn("v3d.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get('ANGLE_instanced_arrays')."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function (e) {
            console.warn("v3d.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
        },
        initMaterial: function () {
            console.warn("v3d.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function () {
            console.warn("v3d.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function () {
            console.warn("v3d.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function () {
            console.warn("v3d.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function () {
            console.warn("v3d.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function () {
            console.warn("v3d.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function () {
            console.warn("v3d.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function () {
            console.warn("v3d.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function () {
            console.warn("v3d.WebGLRenderer: .setTextureCube() has been removed.")
        },
        getActiveMipMapLevel: function () {
            return console.warn("v3d.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
        }
    }), Object.defineProperties(is.prototype, {
        shadowMapEnabled: {
            get: function () {
                return this.shadowMap.enabled
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function () {
                return this.shadowMap.type
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function () {
                console.warn("v3d.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("v3d.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function () {
                return console.warn("v3d.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
            }
        },
        vr: {
            get: function () {
                return console.warn("v3d.WebGLRenderer: .vr has been renamed to .xr"), this.xr
            }
        },
        gammaInput: {
            get: function () {
                return console.warn("v3d.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
            },
            set: function () {
                console.warn("v3d.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        },
        gammaOutput: {
            get: function () {
                return console.warn("v3d.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? St : At
            }
        }
    }), Object.defineProperties(Xo.prototype, {
        cullFace: {
            get: function () {
                console.warn("v3d.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("v3d.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function () {
                console.warn("v3d.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("v3d.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function () {
                console.warn("v3d.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function () {
                console.warn("v3d.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(en.prototype, {
        wrapS: {
            get: function () {
                return console.warn("v3d.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function () {
                return console.warn("v3d.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function () {
                return console.warn("v3d.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function () {
                return console.warn("v3d.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function () {
                return console.warn("v3d.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
            }
        },
        offset: {
            get: function () {
                return console.warn("v3d.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
            }
        },
        repeat: {
            get: function () {
                return console.warn("v3d.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
            }
        },
        format: {
            get: function () {
                return console.warn("v3d.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
            }
        },
        type: {
            get: function () {
                return console.warn("v3d.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function () {
                return console.warn("v3d.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function (e) {
                console.warn("v3d.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
            }
        }
    }), Object.defineProperties(rh.prototype, {
        load: {
            value: function (e) {
                console.warn("v3d.Audio: .load has been deprecated. Use v3d.AudioLoader instead.");
                var t = this;
                return (new Ud).load(e, function (e) {
                    t.setBuffer(e)
                }), this
            }
        },
        startTime: {
            set: function () {
                console.warn("v3d.Audio: .startTime is now .play(delay).")
            }
        }
    }), ch.prototype.getData = function () {
        return console.warn("v3d.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, zi.prototype.updateCubeMap = function (e, t) {
        return console.warn("v3d.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
    };
    var pp = {
        merge: function (e, t, n) {
            var r;
            console.warn("v3d.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge(geometry2, matrix, materialIndexOffset) instead."), t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
        },
        center: function (e) {
            return console.warn("v3d.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
        }
    };
    Qt.crossOrigin = void 0, Qt.loadTexture = function (e, t, n, r) {
        console.warn("v3d.ImageUtils.loadTexture has been deprecated. Use v3d.TextureLoader() instead.");
        var i = new Uu;
        i.setCrossOrigin(this.crossOrigin);
        var a = i.load(e, n, void 0, r);
        return t && (a.mapping = t), a
    }, Qt.loadTextureCube = function (e, t, n, r) {
        console.warn("v3d.ImageUtils.loadTextureCube has been deprecated. Use v3d.CubeTextureLoader() instead.");
        var i = new zu;
        i.setCrossOrigin(this.crossOrigin);
        var a = i.load(e, n, void 0, r);
        return t && (a.mapping = t), a
    }, Qt.loadCompressedTexture = function () {
        console.error("v3d.ImageUtils.loadCompressedTexture has been removed. Use v3d.DDSLoader instead.")
    }, Qt.loadCompressedTextureCube = function () {
        console.error("v3d.ImageUtils.loadCompressedTextureCube has been removed. Use v3d.DDSLoader instead.")
    };
    var fp = new on,
        mp = new on,
        vp = new on,
        gp = new qt,
        _p = new qt,
        yp = new qt,
        xp = new on,
        bp = new on;

    function wp(e, t, n, r, i, a, o, s) {
        fp.fromBufferAttribute(r, a), mp.fromBufferAttribute(r, o), vp.fromBufferAttribute(r, s);
        var l = function (e, t, n, r, i, a, o, s) {
            if (null === (t.side === Pe ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, t.side !== ie, s))) return null;
            bp.copy(s), bp.applyMatrix4(e.matrixWorld);
            var l = n.ray.origin.distanceTo(bp);
            return l < n.near || l > n.far ? null : {
                distance: l,
                point: bp.clone(),
                object: e
            }
        }(e, e.material, t, n, fp, mp, vp, xp);
        if (l) {
            i && (gp.fromBufferAttribute(i, a), _p.fromBufferAttribute(i, o), yp.fromBufferAttribute(i, s), l.uv = Sr.getUV(xp, fp, mp, vp, gp, _p, yp, new qt));
            var c = new on;
            l.face = new Ir(a, o, s, Sr.getNormal(fp, mp, vp, c)), l.faceIndex = a
        }
        return l
    }

    function Mp(e, t, n, r, i, a) {
        var o = 3 * i,
            s = t.index.getX(o),
            l = t.index.getX(1 + o),
            c = t.index.getX(2 + o),
            u = wp(e, n, r, t.attributes.position, t.attributes.uv, s, l, c);
        return u ? (u.faceIndex = i, a && a.push(u), u) : null
    }

    function Ap(e, t) {
        return t.min.x = e[0], t.min.y = e[1], t.min.z = e[2], t.max.x = e[3], t.max.y = e[4], t.max.z = e[5], t
    }

    function Sp(e) {
        for (var t = -1, n = -1 / 0, r = 0; r < 3; r++) {
            var i = e[r + 3] - e[r];
            n < i && (n = i, t = r)
        }
        return t
    }
    var Tp, Ep = function () {
        function e() {
            _classCallCheck(this, e), this.min = 1 / 0, this.max = -1 / 0
        }
        return _createClass(e, [{
            key: "setFromPointsField",
            value: function (e, t) {
                for (var n = 1 / 0, r = -1 / 0, i = 0, a = e.length; i < a; i++) {
                    var o = e[i][t];
                    n = Math.min(o, n), r = Math.max(o, r)
                }
                this.min = n, this.max = r
            }
        }, {
            key: "setFromPoints",
            value: function (e, t) {
                for (var n = 1 / 0, r = -1 / 0, i = 0, a = t.length; i < a; i++) {
                    var o = t[i],
                        s = e.dot(o);
                    n = Math.min(s, n), r = Math.max(s, r)
                }
                this.min = n, this.max = r
            }
        }, {
            key: "isSeparated",
            value: function (e) {
                return this.min > e.max || e.min > this.max
            }
        }]), e
    }();
    Ep.prototype.setFromBox = (Tp = new on, function (e, t) {
        for (var n = t.min, r = t.max, i = 1 / 0, a = -1 / 0, o = 0; o <= 1; o++)
            for (var s = 0; s <= 1; s++)
                for (var l = 0; l <= 1; l++) {
                    Tp.x = n.x * o + r.x * (1 - o), Tp.y = n.y * s + r.y * (1 - s), Tp.z = n.z * l + r.z * (1 - l);
                    var c = e.dot(Tp);
                    i = Math.min(c, i), a = Math.max(c, a)
                }
        this.min = i, this.max = a
    });
    var Cp, Pp, Lp, Rp, Dp, Ip, Np, Op, Fp, Bp, zp, Up, Vp, Gp, kp, jp, Wp, Xp, Hp, Yp, qp, Zp, Qp, Kp = (Cp = new on, Pp = new on, Lp = new on, function (e, t, n) {
            var r = e.start,
                i = Cp,
                a = t.start,
                o = Pp;
            Lp.subVectors(r, a), Cp.subVectors(e.end, t.start), Pp.subVectors(t.end, t.start);
            var s, l, c = Lp.dot(o),
                u = o.dot(i),
                d = o.dot(o),
                h = Lp.dot(i),
                p = i.dot(i) * d - u * u;
            l = (c + (s = 0 != p ? (c * u - h * d) / p : 0) * u) / d, n.x = s, n.y = l
        }),
        Jp = (Rp = new qt, Dp = new on, Ip = new on, function (e, t, n, r) {
            Kp(e, t, Rp);
            var i, a, o = Rp.x,
                s = Rp.y;
            if (0 <= o && o <= 1 && 0 <= s && s <= 1) return e.at(o, n), void t.at(s, r);
            if (0 <= o && o <= 1) return s < 0 ? t.at(0, r) : t.at(1, r), void e.closestPointToPoint(r, !0, n);
            if (0 <= s && s <= 1) return o < 0 ? e.at(0, n) : e.at(1, n), void t.closestPointToPoint(n, !0, r);
            i = o < 0 ? e.start : e.end, a = s < 0 ? t.start : t.end;
            var l = Dp,
                c = Ip;
            return e.closestPointToPoint(a, !0, Dp), t.closestPointToPoint(i, !0, Ip), l.distanceToSquared(a) <= c.distanceToSquared(i) ? (n.copy(l), void r.copy(a)) : (n.copy(i), void r.copy(c))
        }),
        $p = (Np = new on, Op = new on, Fp = new fr, Bp = new Dh, function (e, t) {
            var n = e.radius,
                r = e.center,
                i = t.a,
                a = t.b,
                o = t.c;
            if (Bp.start = i, Bp.end = a, Bp.closestPointToPoint(r, !0, Np).distanceTo(r) <= n) return !0;
            if (Bp.start = i, Bp.end = o, Bp.closestPointToPoint(r, !0, Np).distanceTo(r) <= n) return !0;
            if (Bp.start = a, Bp.end = o, Bp.closestPointToPoint(r, !0, Np).distanceTo(r) <= n) return !0;
            var s = t.getPlane(Fp);
            if (Math.abs(s.distanceToPoint(r)) <= n) {
                var l = s.projectPoint(r, Op);
                if (t.containsPoint(l)) return !0
            }
            return !1
        }),
        ef = function () {
            function a() {
                var e, t;
                _classCallCheck(this, a);
                for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
                return (t = _possibleConstructorReturn(this, (e = _getPrototypeOf(a)).call.apply(e, [this].concat(r)))).isSeparatingAxisTriangle = !0, t.satAxes = new Array(4).fill().map(function () {
                    return new on
                }), t.satBounds = new Array(4).fill().map(function () {
                    return new Ep
                }), t.points = [t.a, t.b, t.c], t.sphere = new nr, t
            }
            return _inherits(a, Sr), a
        }();
    ef.prototype.update = (zp = new Array(3), function () {
        var e = this.a,
            t = this.b,
            n = this.c;
        zp[0] = this.a, zp[1] = this.b, zp[2] = this.c;
        var r = this.satAxes,
            i = this.satBounds,
            a = r[0],
            o = i[0];
        this.getNormal(a), o.setFromPoints(a, zp);
        var s = r[1],
            l = i[1];
        s.subVectors(e, t), l.setFromPoints(s, zp);
        var c = r[2],
            u = i[2];
        c.subVectors(t, n), u.setFromPoints(c, zp);
        var d = r[3],
            h = i[3];
        d.subVectors(n, e), h.setFromPoints(d, zp), this.sphere.setFromPoints(this.points)
    }), ef.prototype.intersectsTriangle = (Up = new ef, Vp = new Array(3), Gp = new Array(3), kp = new Ep, jp = new Ep, Wp = new on, function (e) {
        e.isSeparatingAxisTriangle || (Up.copy(e), Up.update(), e = Up);
        var t = this.satBounds,
            n = this.satAxes;
        Gp[0] = e.a, Gp[1] = e.b, Gp[2] = e.c;
        for (var r = 0; r < 4; r++) {
            var i = t[r],
                a = n[r];
            if (kp.setFromPoints(a, Gp), i.isSeparated(kp)) return !1
        }
        var o = e.satBounds,
            s = e.satAxes;
        Vp[0] = this.a, Vp[1] = this.b, Vp[2] = this.c;
        for (var l = 0; l < 4; l++) {
            var c = o[l],
                u = s[l];
            if (kp.setFromPoints(u, Vp), c.isSeparated(kp)) return !1
        }
        for (var d = 0; d < 4; d++)
            for (var h = n[d], p = 0; p < 4; p++) {
                var f = s[p];
                if (Wp.crossVectors(h, f), kp.setFromPoints(Wp, Vp), jp.setFromPoints(Wp, Gp), kp.isSeparated(jp)) return !1
            }
        return !0
    }), ef.prototype.distanceToPoint = (Xp = new on, function (e) {
        return this.closestPointToPoint(e, Xp), e.distanceTo(Xp)
    }), ef.prototype.distanceToTriangle = (Hp = new on, Yp = new on, qp = ["a", "b", "c"], Zp = new Dh, Qp = new Dh, function (e, t, n) {
        var r = 1 < arguments.length && void 0 !== t ? t : null,
            i = 2 < arguments.length && void 0 !== n ? n : null;
        if (this.intersectsTriangle(e)) return (r || i) && (this.getMidpoint(Hp), e.closestPointToPoint(Hp, Yp), this.closestPointToPoint(Yp, Hp), r && r.copy(Hp), i && i.copy(Yp)), 0;
        for (var a = 1 / 0, o = 0; o < 3; o++) {
            var s = void 0,
                l = qp[o],
                c = e[l];
            this.closestPointToPoint(c, Hp), (s = c.distanceToSquared(Hp)) < a && (a = s, r && r.copy(Hp), i && i.copy(c));
            var u = this[l];
            e.closestPointToPoint(u, Hp), (s = u.distanceToSquared(Hp)) < a && (a = s, r && r.copy(u), i && i.copy(Hp))
        }
        for (var d = 0; d < 3; d++) {
            var h = qp[d],
                p = qp[(d + 1) % 3];
            Zp.set(this[h], this[p]);
            for (var f = 0; f < 3; f++) {
                var m = qp[f],
                    v = qp[(f + 1) % 3];
                Qp.set(e[m], e[v]), Jp(Zp, Qp, Hp, Yp);
                var g = Hp.distanceToSquared(Yp);
                g < a && (a = g, r && r.copy(Hp), i && i.copy(Yp))
            }
        }
        return Math.sqrt(a)
    });
    var tf, nf, rf, af, of , sf, lf, cf, uf, df, hf, pf, ff = function () {
        function a() {
            var e, t;
            _classCallCheck(this, a);
            for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
            return (t = _possibleConstructorReturn(this, (e = _getPrototypeOf(a)).call.apply(e, [this].concat(r)))).isOrientedBox = !0, t.matrix = new fn, t.invMatrix = new fn, t.points = new Array(8).fill().map(function () {
                return new on
            }), t.satAxes = new Array(3).fill().map(function () {
                return new on
            }), t.satBounds = new Array(3).fill().map(function () {
                return new Ep
            }), t.alignedSatBounds = new Array(3).fill().map(function () {
                return new Ep
            }), t.sphere = new nr, t
        }
        return _inherits(a, Kn), _createClass(a, [{
            key: "set",
            value: function (e, t, n) {
                _get(_getPrototypeOf(a.prototype), "set", this).call(this, e, t), this.matrix = n
            }
        }, {
            key: "copy",
            value: function (e) {
                _get(_getPrototypeOf(a.prototype), "copy", this).call(this, e), this.matrix.copy(e.matrix)
            }
        }]), a
    }();
    ff.prototype.update = function () {
        for (var e = this.matrix, t = this.min, n = this.max, r = this.points, i = 0; i <= 1; i++)
            for (var a = 0; a <= 1; a++)
                for (var o = 0; o <= 1; o++) {
                    var s = r[+i | 2 * a | 4 * o];
                    s.x = i ? n.x : t.x, s.y = a ? n.y : t.y, s.z = o ? n.z : t.z, s.applyMatrix4(e)
                }
        this.sphere.setFromPoints(this.points);
        for (var l = this.satBounds, c = this.satAxes, u = r[0], d = 0; d < 3; d++) {
            var h = c[d],
                p = l[d],
                f = r[1 << d];
            h.subVectors(u, f), p.setFromPoints(h, r)
        }
        var m = this.alignedSatBounds;
        m[0].setFromPointsField(r, "x"), m[1].setFromPointsField(r, "y"), m[2].setFromPointsField(r, "z"), this.invMatrix.getInverse(this.matrix)
    }, ff.prototype.intersectsBox = (tf = new Ep, function (e) {
        if (!e.intersectsSphere(this.sphere)) return !1;
        var t = e.min,
            n = e.max,
            r = this.satBounds,
            i = this.satAxes,
            a = this.alignedSatBounds;
        if (tf.min = t.x, tf.max = n.x, a[0].isSeparated(tf)) return !1;
        if (tf.min = t.y, tf.max = n.y, a[1].isSeparated(tf)) return !1;
        if (tf.min = t.z, tf.max = n.z, a[2].isSeparated(tf)) return !1;
        for (var o = 0; o < 3; o++) {
            var s = i[o],
                l = r[o];
            if (tf.setFromBox(s, e), l.isSeparated(tf)) return !1
        }
        return !0
    }), ff.prototype.intersectsTriangle = (nf = new ef, rf = new Array(3), af = new Ep, of = new Ep, sf = new on, function (e) {
        e.isSeparatingAxisTriangle || (nf.copy(e), nf.update(), e = nf);
        var t = this.satBounds,
            n = this.satAxes;
        rf[0] = e.a, rf[1] = e.b, rf[2] = e.c;
        for (var r = 0; r < 3; r++) {
            var i = t[r],
                a = n[r];
            if (af.setFromPoints(a, rf), i.isSeparated(af)) return !1
        }
        for (var o = e.satBounds, s = e.satAxes, l = this.points, c = 0; c < 3; c++) {
            var u = o[c],
                d = s[c];
            if (af.setFromPoints(d, l), u.isSeparated(af)) return !1
        }
        for (var h = 0; h < 3; h++)
            for (var p = n[h], f = 0; f < 4; f++) {
                var m = s[f];
                if (sf.crossVectors(p, m), af.setFromPoints(sf, rf), of .setFromPoints(sf, l), af.isSeparated( of )) return !1
            }
        return !0
    }), ff.prototype.closestPointToPoint = function (e, t) {
        return t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t
    }, ff.prototype.distanceToPoint = (lf = new on, function (e) {
        return this.closestPointToPoint(e, lf), e.distanceTo(lf)
    }), ff.prototype.distanceToBox = (cf = ["x", "y", "z"], uf = new Array(12).fill().map(function () {
        return new Dh
    }), df = new Array(12).fill().map(function () {
        return new Dh
    }), hf = new on, pf = new on, function (e, t, n, r) {
        var i = 1 < arguments.length && void 0 !== t ? t : 0,
            a = 2 < arguments.length && void 0 !== n ? n : null,
            o = 3 < arguments.length && void 0 !== r ? r : null;
        if (this.intersectsBox(e)) return (a || o) && (e.getCenter(pf), this.closestPointToPoint(pf, hf), e.closestPointToPoint(hf, pf), a && a.copy(hf), o && o.copy(pf)), 0;
        for (var s = i * i, l = e.min, c = e.max, u = this.points, d = 1 / 0, h = 0; h < 8; h++) {
            var p = u[h];
            pf.copy(p).clamp(l, c);
            var f = p.distanceToSquared(pf);
            if (f < d && (d = f, a && a.copy(p), o && o.copy(pf), f < s)) return Math.sqrt(f)
        }
        for (var m = 0, v = 0; v < 3; v++)
            for (var g = 0; g <= 1; g++)
                for (var _ = 0; _ <= 1; _++) {
                    var y = (v + 1) % 3,
                        x = (v + 2) % 3,
                        b = 1 << v | g << y | _ << x,
                        w = u[g << y | _ << x],
                        M = u[b];
                    uf[m].set(w, M);
                    var A = cf[v],
                        S = cf[y],
                        T = cf[x],
                        E = df[m],
                        C = E.start,
                        P = E.end;
                    C[A] = l[A], C[S] = g ? l[S] : c[S], C[T] = _ ? l[T] : c[S], P[A] = c[A], P[S] = g ? l[S] : c[S], P[T] = _ ? l[T] : c[S], m++
                }
        for (var L = 0; L <= 1; L++)
            for (var R = 0; R <= 1; R++)
                for (var D = 0; D <= 1; D++) {
                    pf.x = L ? c.x : l.x, pf.y = R ? c.y : l.y, pf.z = D ? c.z : l.z, this.closestPointToPoint(pf, hf);
                    var I = pf.distanceToSquared(hf);
                    if (I < d && (d = I, a && a.copy(hf), o && o.copy(pf), I < s)) return Math.sqrt(I)
                }
        for (var N = 0; N < 12; N++)
            for (var O = uf[N], F = 0; F < 12; F++) {
                var B = df[F];
                Jp(O, B, hf, pf);
                var z = hf.distanceToSquared(pf);
                if (z < d && (d = z, a && a.copy(hf), o && o.copy(pf), z < s)) return Math.sqrt(z)
            }
        return Math.sqrt(d)
    });
    var mf = new Kn,
        vf = new on,
        gf = ["x", "y", "z"];

    function _f(e, t, n, r) {
        var i = e.a,
            a = e.b,
            o = e.c,
            s = n.getX(t);
        i.x = r.getX(s), i.y = r.getY(s), i.z = r.getZ(s), s = n.getX(t + 1), a.x = r.getX(s), a.y = r.getY(s), a.z = r.getZ(s), s = n.getX(t + 2), o.x = r.getX(s), o.y = r.getY(s), o.z = r.getZ(s)
    }
    var yf, xf, bf, wf, Mf, Af, Sf, Tf, Ef, Cf, Pf, Lf, Rf, Df, If, Nf = function () {
        function e() {
            _classCallCheck(this, e)
        }
        return _createClass(e, [{
            key: "intersectRay",
            value: function (e, t) {
                return Ap(this.boundingData, mf), e.intersectBox(mf, t)
            }
        }, {
            key: "raycast",
            value: function (e, t, n, r) {
                this.count ? function (e, t, n, r, i, a, o) {
                    for (var s = i, l = i + a; s < l; s++) Mp(e, t, n, r, s, o)
                }(e, e.geometry, t, n, this.offset, this.count, r) : (this.left.intersectRay(n, vf) && this.left.raycast(e, t, n, r), this.right.intersectRay(n, vf) && this.right.raycast(e, t, n, r))
            }
        }, {
            key: "raycastFirst",
            value: function (e, t, n) {
                if (this.count) return function (e, t, n, r, i, a) {
                    for (var o = 1 / 0, s = null, l = i, c = i + a; l < c; l++) {
                        var u = Mp(e, t, n, r, l);
                        u && u.distance < o && (o = (s = u).distance)
                    }
                    return s
                }(e, e.geometry, t, n, this.offset, this.count);
                var r, i, a = this.splitAxis,
                    o = gf[a];
                i = 0 <= n.direction[o] ? (r = this.left, this.right) : (r = this.right, this.left);
                var s = r.intersectRay(n, vf) ? r.raycastFirst(e, t, n) : null;
                if (s) {
                    var l = n.origin[o],
                        c = l - s.point[o],
                        u = l - i.boundingData[a],
                        d = l - i.boundingData[a + 3],
                        h = c * c;
                    if (h <= u * u && h <= d * d) return s
                }
                var p = i.intersectRay(n, vf) ? i.raycastFirst(e, t, n) : null;
                return s && p ? s.distance <= p.distance ? s : p : s || p || null
            }
        }]), e
    }();
    Nf.prototype.shapecast = (yf = new ef, xf = new Kn, bf = new Kn, function (e, t, n, r) {
        var i = 2 < arguments.length && void 0 !== n ? n : null,
            a = 3 < arguments.length && void 0 !== r ? r : null;
        if (this.count && i) {
            for (var o = e.geometry, s = o.index, l = o.attributes.position, c = this.offset, u = 3 * c, d = 3 * (this.count + c); u < d; u += 3)
                if (_f(yf, u, s, l), yf.update(), i(yf, u, u + 1, u + 2)) return !0;
            return !1
        }
        var h, p, f, m, v = this.left,
            g = this.right,
            _ = v,
            y = g;
        if (a && (f = xf, m = bf, Ap(_.boundingData, f), Ap(y.boundingData, m), h = a(f), (p = a(m)) < h)) {
            _ = g, y = v;
            var x = h;
            h = p, p = x;
            var b = f;
            f = m, m = b
        }
        return f || (f = xf, Ap(_.boundingData, f)), !!(t(f, !!_.count, h, _) && _.shapecast(e, t, i, a) || (m || (m = bf, Ap(y.boundingData, m)), t(m, !!y.count, p, y) && y.shapecast(e, t, i, a)))
    }), Nf.prototype.intersectsGeometry = (wf = new ef, Mf = new ef, Af = new xi, Sf = new fn, Tf = new ff, Ef = new ff, function (e, t, r, n) {
        var i = 3 < arguments.length && void 0 !== n ? n : null;
        if (null === i && (t.boundingBox || t.computeBoundingBox(), Tf.set(t.boundingBox.min, t.boundingBox.max, r), Tf.update(), i = Tf), !this.count) {
            var a = this.left,
                o = this.right;
            return Ap(a.boundingData, mf), !(!i.intersectsBox(mf) || !a.intersectsGeometry(e, t, r, i)) || (Ap(o.boundingData, mf), !(!i.intersectsBox(mf) || !o.intersectsGeometry(e, t, r, i)))
        }
        var s = e.geometry,
            l = s.index,
            c = s.attributes.position,
            u = t.index,
            d = t.attributes.position,
            h = this.offset,
            p = this.count;
        if (Sf.getInverse(r), t.boundsTree) {
            Ap(this.boundingData, Ef), Ef.matrix.copy(Sf), Ef.update();
            var f = (Af.geometry = t).boundsTree.shapecast(Af, function (e) {
                return Ef.intersectsBox(e)
            }, function (e) {
                e.a.applyMatrix4(r), e.b.applyMatrix4(r), e.c.applyMatrix4(r), e.update();
                for (var t = 3 * h, n = 3 * (p + h); t < n; t += 3)
                    if (_f(Mf, t, l, c), Mf.update(), e.intersectsTriangle(Mf)) return !0;
                return !1
            });
            return Af.geometry = null, f
        }
        for (var m = 3 * h, v = p + 3 * h; m < v; m += 3) {
            _f(wf, m, l, c), wf.a.applyMatrix4(Sf), wf.b.applyMatrix4(Sf), wf.c.applyMatrix4(Sf), wf.update();
            for (var g = 0, _ = u.count; g < _; g += 3)
                if (_f(Mf, g, u, d), Mf.update(), wf.intersectsTriangle(Mf)) return !0
        }
    }), Nf.prototype.intersectsBox = (Cf = new ff, function (e, t, n) {
        return Cf.set(t.min, t.max, n), Cf.update(), this.shapecast(e, function (e) {
            return Cf.intersectsBox(e)
        }, function (e) {
            return Cf.intersectsTriangle(e)
        })
    }), Nf.prototype.intersectsSphere = function (e, t) {
        return this.shapecast(e, function (e) {
            return t.intersectsBox(e)
        }, function (e) {
            return $p(t, e)
        })
    }, Nf.prototype.closestPointToPoint = (Pf = new on, function (e, n, t, r, i) {
        var a = 2 < arguments.length && void 0 !== t ? t : null,
            o = 3 < arguments.length && void 0 !== r ? r : 0,
            s = 4 < arguments.length && void 0 !== i ? i : 1 / 0,
            l = 1 / 0;
        return this.shapecast(e, function (e, t, n) {
            return n < l && n < s
        }, function (e) {
            e.closestPointToPoint(n, Pf);
            var t = n.distanceTo(Pf);
            return t < l && (a && a.copy(Pf), l = t), t < o
        }, function (e) {
            return e.distanceToPoint(n)
        }), l
    }), Nf.prototype.closestPointToGeometry = (Lf = new ef, Rf = new ff, Df = new on, If = new on, function (e, t, s, n, r, i, a) {
        var l = 3 < arguments.length && void 0 !== n ? n : null,
            c = 4 < arguments.length && void 0 !== r ? r : null,
            u = 5 < arguments.length && void 0 !== i ? i : 0,
            o = 6 < arguments.length && void 0 !== a ? a : 1 / 0;
        t.boundingBox || t.computeBoundingBox(), Rf.set(t.boundingBox.min, t.boundingBox.max, s), Rf.update();
        var d, h, p = t.attributes.position,
            f = t.index;
        l && (d = Df), c && (h = If);
        var m = 1 / 0;
        return this.shapecast(e, function (e, t, n) {
            return n < m && n < o
        }, function (e) {
            for (var t = e.sphere, n = 0, r = f.count; n < r; n += 3) {
                _f(Lf, n, f, p), Lf.a.applyMatrix4(s), Lf.b.applyMatrix4(s), Lf.c.applyMatrix4(s), Lf.sphere.setFromPoints(Lf.points);
                var i = Lf.sphere,
                    a = i.center.distanceTo(t.center) - i.radius - t.radius;
                if (!(m < a)) {
                    Lf.update();
                    var o = e.distanceToTriangle(Lf, d, h);
                    if (o < m && (l && l.copy(d), c && c.copy(h), m = o), o < u) return !0
                }
            }
            return !1
        }, function (e) {
            return Rf.distanceToBox(e, Math.min(m, o))
        }), m
    });
    var Of = ["x", "y", "z"];
    var Ff = new Kn,
        Bf = function () {
            function a(e, t) {
                if (_classCallCheck(this, a), this.geo = e, this.options = t, this.bounds = function (e) {
                        for (var t = e.attributes.position.array, n = e.index.array, r = n.length / 3, i = new Float32Array(6 * r), a = 0; a < r; a++)
                            for (var o = 3 * n[3 * a + 0], s = 3 * n[3 * a + 1], l = 3 * n[3 * a + 2], c = 0; c < 3; c++) {
                                var u = t[o + c],
                                    d = t[s + c],
                                    h = t[l + c],
                                    p = Math.min(u, d, h),
                                    f = (Math.max(u, d, h) - p) / 2;
                                i[6 * a + 2 * c] = p + f, i[6 * a + 2 * c + 1] = f
                            }
                        return i
                    }(e), this.sahplanes = null, 2 === t.strategy) {
                    var n = e.index.count / 3;
                    this.sahplanes = [new Array(n), new Array(n), new Array(n)];
                    for (var r = 0; r < n; r++)
                        for (var i = 0; i < 3; i++) this.sahplanes[i][r] = {
                            p: this.bounds[6 * r + 2 * i],
                            tri: r
                        }
                }
            }
            return _createClass(a, [{
                key: "getAverage",
                value: function (e, t, n) {
                    for (var r = 0, i = this.bounds, a = e, o = e + t; a < o; a++) r += i[6 * a + 2 * n];
                    return r / t
                }
            }, {
                key: "getBounds",
                value: function (e, t, n) {
                    for (var r = 1 / 0, i = 1 / 0, a = 1 / 0, o = -1 / 0, s = -1 / 0, l = -1 / 0, c = this.bounds, u = e, d = e + t; u < d; u++) {
                        var h = c[6 * u + 0],
                            p = c[6 * u + 1];
                        r = Math.min(r, h - p), o = Math.max(o, h + p);
                        var f = c[6 * u + 2],
                            m = c[6 * u + 3];
                        i = Math.min(i, f - m), s = Math.max(s, f + m);
                        var v = c[6 * u + 4],
                            g = c[6 * u + 5];
                        a = Math.min(a, v - g), l = Math.max(l, v + g)
                    }
                    return n[0] = r, n[1] = i, n[2] = a, n[3] = o, n[4] = s, n[5] = l, n
                }
            }, {
                key: "partition",
                value: function (e, t, n) {
                    for (var r = e, i = e + t - 1, a = n.pos, o = 2 * n.axis, s = this.geo.index.array, l = this.bounds, c = this.sahplanes;;) {
                        for (; r <= i && l[6 * r + o] < a;) r++;
                        for (; r <= i && l[6 * i + o] >= a;) i--;
                        if (!(r < i)) return r;
                        for (var u = 0; u < 3; u++) {
                            var d = s[3 * r + u];
                            s[3 * r + u] = s[3 * i + u], s[3 * i + u] = d;
                            var h = l[6 * r + 2 * u];
                            l[6 * r + 2 * u] = l[6 * i + 2 * u], l[6 * i + 2 * u] = h;
                            var p = l[6 * r + 2 * u + 1];
                            l[6 * r + 2 * u + 1] = l[6 * i + 2 * u + 1], l[6 * i + 2 * u + 1] = p
                        }
                        if (c)
                            for (var f = 0; f < 3; f++) {
                                var m = c[f][r];
                                c[f][r] = c[f][i], c[f][i] = m
                            }
                        r++, i--
                    }
                }
            }, {
                key: "getOptimalSplit",
                value: function (e, t, n, r) {
                    var i, a = -1,
                        o = 0;
                    if (0 === r) - 1 !== (a = Sp(e)) && (o = (e[a + 3] + e[a]) / 2);
                    else if (1 === r) - 1 !== (a = Sp(e)) && (o = this.getAverage(t, n, a));
                    else if (2 === r) {
                        for (var s = Ap(e, Ff), l = [s.max.x - s.min.x, s.max.y - s.min.y, s.max.z - s.min.z], c = 2 * (l[0] * l[1] + l[0] * l[2] + l[1] * l[2]), u = [
                                [],
                                [],
                                []
                            ], d = t, h = t + n; d < h; d++)
                            for (var p = 0; p < 3; p++) u[p].push(this.sahplanes[p][d]);
                        u.forEach(function (e) {
                            return e.sort(function (e, t) {
                                return e.p - t.p
                            })
                        });
                        a = -1;
                        for (var f = +n, m = 0; m < 3; m++)
                            for (var v = (m + 1) % 3, g = (m + 2) % 3, _ = s.min[Of[m]], y = s.max[Of[m]], x = u[m], b = 0, w = n, M = 0; M < x.length; M++) {
                                var A = x[M];
                                b++, w--;
                                var S = A.p - _,
                                    T = y - A.p,
                                    E = l[v],
                                    C = l[v],
                                    P = l[g],
                                    L = l[g],
                                    R = 2 * (E * P + E * S + P * S) / (i = c) * b + 2 * (C * L + C * T + L * T) / i * w + 3;
                                R < f && (a = m, o = A.p, f = R)
                            }
                    }
                    return {
                        axis: a,
                        pos: o
                    }
                }
            }]), a
        }(),
        zf = function () {
            function n(e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
                if (_classCallCheck(this, n), !e.isBufferGeometry) throw new Error("MeshBVH: Only BufferGeometries are supported.");
                if (e.attributes.position.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the position attribute.");
                if (e.index && e.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
                (t = Object.assign({
                    strategy: 0,
                    maxDepth: 40,
                    maxLeafTris: 10,
                    verbose: !0
                }, t)).strategy = Math.max(0, Math.min(2, t.strategy)), this._roots = this._buildTree(e, t)
            }
            return _createClass(n, [{
                key: "_ensureIndex",
                value: function (e) {
                    if (!e.index) {
                        var t = e.attributes.position.count,
                            n = new(65535 < t ? Uint32Array : Uint16Array)(t);
                        e.setIndex(new zr(n, 1));
                        for (var r = 0; r < t; r++) n[r] = r
                    }
                }
            }, {
                key: "_getRootIndexRanges",
                value: function (e) {
                    if (!e.groups || !e.groups.length) return [{
                        offset: 0,
                        count: e.index.count / 3
                    }];
                    for (var t = [], n = new Set, r = 0, i = e.groups; r < i.length; r++) {
                        var a = i[r];
                        n.add(a.start), n.add(a.start + a.count)
                    }
                    for (var o = Array.from(n.values()).sort(function (e, t) {
                            return e - t
                        }), s = 0; s < o.length - 1; s++) {
                        var l = o[s],
                            c = o[s + 1];
                        t.push({
                            offset: l / 3,
                            count: (c - l) / 3
                        })
                    }
                    return t
                }
            }, {
                key: "_buildTree",
                value: function (e, h) {
                    this._ensureIndex(e);
                    var t, n, p = new Bf(e, h),
                        f = !1,
                        m = function (e, t, n) {
                            var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
                            if (r >= h.maxDepth && (f = !0), n <= h.maxLeafTris || r >= h.maxDepth) return e.offset = t, e.count = n, e;
                            var i = p.getOptimalSplit(e.boundingData, t, n, h.strategy);
                            if (-1 === i.axis) return e.offset = t, e.count = n, e;
                            var a = p.partition(t, n, i);
                            if (a === t || a === t + n) e.offset = t, e.count = n;
                            else {
                                e.splitAxis = i.axis;
                                var o = e.left = new Nf,
                                    s = t,
                                    l = a - t;
                                o.boundingData = p.getBounds(s, l, new Float32Array(6)), m(o, s, l, r + 1);
                                var c = e.right = new Nf,
                                    u = a,
                                    d = n - l;
                                c.boundingData = p.getBounds(u, d, new Float32Array(6)), m(c, u, d, r + 1)
                            }
                            return e
                        },
                        r = [],
                        i = this._getRootIndexRanges(e);
                    if (1 === i.length) {
                        var a = new Nf,
                            o = i[0];
                        null != e.boundingBox ? a.boundingData = (t = e.boundingBox, (n = new Float32Array(6))[0] = t.min.x, n[1] = t.min.y, n[2] = t.min.z, n[3] = t.max.x, n[4] = t.max.y, n[5] = t.max.z, n) : a.boundingData = p.getBounds(o.offset, o.count, new Float32Array(6)), m(a, o.offset, o.count), r.push(a)
                    } else
                        for (var s = 0; s < i.length; s++) {
                            var l = i[s],
                                c = new Nf;
                            c.boundingData = p.getBounds(l.offset, l.count, new Float32Array(6)), m(c, l.offset, l.count), r.push(c)
                        }
                    if (f && h.verbose && (console.warn("MeshBVH: Max depth of ".concat(h.maxDepth, " reached when generating BVH. Consider increasing maxDepth.")), console.warn(this, e)), null == e.boundingBox) {
                        var u = new Kn;
                        e.boundingBox = new Kn;
                        for (var d = 0; d < r.length; d++) {
                            var v = r[d];
                            e.boundingBox.union(Ap(v.boundingData, u))
                        }
                    }
                    return r
                }
            }, {
                key: "raycast",
                value: function (e, t, n, r) {
                    for (var i = 0, a = this._roots; i < a.length; i++) {
                        a[i].raycast(e, t, n, r)
                    }
                }
            }, {
                key: "raycastFirst",
                value: function (e, t, n) {
                    for (var r = null, i = 0, a = this._roots; i < a.length; i++) {
                        var o = a[i].raycastFirst(e, t, n);
                        null != o && (null == r || o.distance < r.distance) && (r = o)
                    }
                    return r
                }
            }, {
                key: "intersectsGeometry",
                value: function (e, t, n) {
                    for (var r = 0, i = this._roots; r < i.length; r++) {
                        if (i[r].intersectsGeometry(e, t, n)) return !0
                    }
                    return !1
                }
            }, {
                key: "shapecast",
                value: function (e, t, n, r) {
                    for (var i = 2 < arguments.length && void 0 !== n ? n : null, a = 3 < arguments.length && void 0 !== r ? r : null, o = 0, s = this._roots; o < s.length; o++) {
                        if (s[o].shapecast(e, t, i, a)) return !0
                    }
                    return !1
                }
            }, {
                key: "intersectsBox",
                value: function (e, t, n) {
                    for (var r = 0, i = this._roots; r < i.length; r++) {
                        if (i[r].intersectsBox(e, t, n)) return !0
                    }
                    return !1
                }
            }, {
                key: "intersectsSphere",
                value: function (e, t) {
                    for (var n = 0, r = this._roots; n < r.length; n++) {
                        if (r[n].intersectsSphere(e, t)) return !0
                    }
                    return !1
                }
            }, {
                key: "closestPointToGeometry",
                value: function (e, t, n, r, i, a, o) {
                    for (var s = 1 / 0, l = 0, c = this._roots; l < c.length; l++) {
                        var u = c[l].closestPointToGeometry(e, t, n, r, i, a, o);
                        if (u < s && (s = u), u < a) return u
                    }
                    return s
                }
            }, {
                key: "distanceToGeometry",
                value: function (e, t, n, r, i) {
                    return this.closestPointToGeometry(e, t, n, null, null, r, i)
                }
            }, {
                key: "closestPointToPoint",
                value: function (e, t, n, r, i) {
                    for (var a = 1 / 0, o = 0, s = this._roots; o < s.length; o++) {
                        var l = s[o].closestPointToPoint(e, t, n, r, i);
                        if (l < a && (a = l), l < r) return l
                    }
                    return a
                }
            }, {
                key: "distanceToPoint",
                value: function (e, t, n, r) {
                    return this.closestPointToPoint(e, t, null, n, r)
                }
            }]), n
        }(),
        Uf = new Us({
            color: 65416,
            transparent: !0,
            opacity: .3
        }),
        Vf = (new rp).geometry,
        Gf = new Kn,
        kf = function () {
            function i(e) {
                var t, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 10,
                    r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, "MeshBVHRootVisualizer"))).depth = n, t._oldDepth = -1, t._mesh = e, t._boundsTree = null, t._group = r, t.update(), t
            }
            return _inherits(i, Fn), _createClass(i, [{
                key: "update",
                value: function () {
                    var i = this;
                    if (this._mesh.geometry.boundsTree !== this._boundsTree || this._oldDepth !== this.depth) {
                        this._oldDepth = this.depth, this._boundsTree = this._mesh.geometry.boundsTree;
                        var a = 0;
                        if (this._boundsTree) {
                            var o = function (e, t) {
                                var n = "count" in e;
                                if (t !== i.depth) {
                                    if (t === i.depth - 1 || n) {
                                        var r = a < i.children.length ? i.children[a] : null;
                                        r || ((r = new qs(Vf, Uf)).raycast = function () {
                                            return []
                                        }, i.add(r)), a++, Ap(e.boundingData, Gf), Gf.getCenter(r.position), r.scale.subVectors(Gf.max, Gf.min).multiplyScalar(.5), 0 === r.scale.x && (r.scale.x = Number.EPSILON), 0 === r.scale.y && (r.scale.y = Number.EPSILON), 0 === r.scale.z && (r.scale.z = Number.EPSILON)
                                    }
                                    n || (o(e.left, t + 1), o(e.right, t + 1))
                                }
                            };
                            o(this._boundsTree._roots[this._group], 0)
                        }
                        for (; this.children.length > a;) this.remove(this.children.pop())
                    }
                }
            }]), i
        }(),
        jf = function () {
            function r(e) {
                var t, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 10;
                return _classCallCheck(this, r), (t = _possibleConstructorReturn(this, _getPrototypeOf(r).call(this, "MeshBVHVisualizer"))).depth = n, t._mesh = e, t._roots = [], t.update(), t
            }
            return _inherits(r, Fn), _createClass(r, [{
                key: "update",
                value: function () {
                    for (var e = this._mesh.geometry.boundsTree, t = e ? e._roots.length : 0; this._roots.length > t;) this._roots.pop();
                    for (var n = 0; n < t; n++)
                        if (n >= this._roots.length) {
                            var r = new kf(this._mesh, this.depth, n);
                            this.add(r), this._roots.push(r)
                        } else {
                            var i = this._roots[n];
                            i.depth = this.depth, i.update()
                        } this.position.copy(this._mesh.position), this.rotation.copy(this._mesh.rotation), this.scale.copy(this._mesh.scale)
                }
            }]), r
        }(),
        Wf = new ur,
        Xf = new fn,
        Hf = xi.prototype.raycast;

    function Yf(e, t) {
        if (this.geometry.boundsTree) {
            if (void 0 === this.material) return;
            try {
                Xf.getInverse(this.matrixWorld, !0)
            } catch (e) {
                return
            }
            if (Wf.copy(e.ray).applyMatrix4(Xf), !0 === e.firstHitOnly) {
                var n = this.geometry.boundsTree.raycastFirst(this, e, Wf);
                n && t.push(n)
            } else this.geometry.boundsTree.raycast(this, e, Wf, t)
        } else Hf.call(this, e, t)
    }

    function qf(e) {
        return this.boundsTree = new zf(this, e), this.boundsTree
    }

    function Zf() {
        this.boundsTree = null
    }
    var Qf, Kf, Jf, $f, em, tm, nm, rm, im, am, om, sm, lm, cm, um, dm, hm, pm, fm, mm, vm, gm, _m, ym, xm, bm, wm, Mm, Am, Sm, Tm = ["alphaMap", "aoMap", "bumpMap", "displacementMap", "emissiveMap", "envMap", "gradientMap", "lightMap", "map", "metalnessMap", "normalMap", "roughnessMap", "specularMap"],
        Em = {
            disposeTextures: function (t) {
                if (Tm.forEach(function (e) {
                        t[e] && t[e].isTexture && t[e].dispose()
                    }), "MeshNodeMaterial" == t.type)
                    for (var e in t.nodeTextures) t.nodeTextures[e] && t.nodeTextures[e].dispose()
            }
        };

    function Cm() {
        this.name = "", this.type = "Constraint", this.mute = !1
    }

    function Pm(e) {
        Cm.call(this), this.type = "TargetConstraint", this.target = e
    }

    function Lm(e) {
        Pm.call(this, e), this.type = "ChildOfConstraint", this.offsetMatrix = new fn
    }

    function Rm(e) {
        Pm.call(this, e), this.type = "CopyLocationConstraint"
    }

    function Dm(e) {
        Pm.call(this, e), this.type = "CopyRotationConstraint"
    }

    function Im(e) {
        Pm.call(this, e), this.type = "CopyScaleConstraint"
    }

    function Nm(e) {
        Pm.call(this, e), this.type = "FloorConstraint", this.floorLocation = "Y", this.offset = 0
    }

    function Om() {
        Cm.call(this), this.type = "LimitLocationConstraint", this.min = (new on).setScalar(-1 / 0), this.max = (new on).setScalar(1 / 0)
    }

    function Fm() {
        Cm.call(this), this.type = "LimitRotationConstraint", this.axis = "Y", this.min = 0, this.max = 2 * Math.PI
    }

    function Bm() {
        Cm.call(this), this.type = "LimitScaleConstraint", this.min = (new on).setScalar(-1 / 0), this.max = (new on).setScalar(1 / 0)
    }

    function zm(e) {
        Pm.call(this, e), this.type = "LockedTrackConstraint", this.trackAxis = "X", this.lockAxis = "Y"
    }

    function Um(e) {
        Pm.call(this, e), this.type = "TrackToConstraint", this.trackAxis = "X", this.upAxis = "Y"
    }
    Object.assign(Cm.prototype, {
        isConstraint: !0,
        update: function (e) {
            this.mute
        },
        copy: function (e) {
            return this.name = e.name, this.mute = e.mute, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        }
    }), Pm.prototype = Object.assign(Object.create(Cm.prototype), {
        constructor: Pm,
        isTargetConstraint: !0,
        copy: function (e) {
            Cm.prototype.copy.call(this, e), this.target = e.target
        }
    }), Lm.prototype = Object.assign(Object.create(Pm.prototype), {
        constructor: Lm,
        isChildOfConstraint: !0,
        copy: function (e) {
            Pm.prototype.copy.call(this, e), this.offsetMatrix.copy(e.offsetMatrix)
        },
        update: (Qf = new fn, Kf = (new nn).setFromAxisAngle(new on(1, 0, 0), -Math.PI / 2), function (e) {
            Pm.prototype.update.call(this, e), this.mute || (Qf.multiplyMatrices(this.target.matrixWorld, this.offsetMatrix), Qf.decompose(e.position, e.quaternion, e.scale), e.isCamera && e.quaternion.multiply(Kf))
        })
    }), Rm.prototype = Object.assign(Object.create(Pm.prototype), {
        constructor: Rm,
        isCopyLocationConstraint: !0,
        update: (Jf = new nn, $f = new on, function (e) {
            Pm.prototype.update.call(this, e), this.mute || (this.target.matrixWorld.decompose(e.position, Jf, $f), e.parent && e.parent.worldToLocal(e.position))
        })
    }), Dm.prototype = Object.assign(Object.create(Pm.prototype), {
        constructor: Dm,
        isCopyRotationConstraint: !0,
        update: (em = new on, tm = new nn, nm = new on, rm = (new nn).setFromAxisAngle(new on(1, 0, 0), -Math.PI / 2), function (e) {
            Pm.prototype.update.call(this, e), this.mute || (this.target.matrixWorld.decompose(em, e.quaternion, nm), e.parent && (e.parent.matrixWorld.decompose(em, tm, nm), e.quaternion.premultiply(tm.inverse())), e.isCamera && e.quaternion.multiply(rm))
        })
    }), Im.prototype = Object.assign(Object.create(Pm.prototype), {
        constructor: Im,
        isCopyScaleConstraint: !0,
        update: function (e) {
            Pm.prototype.update.call(this, e), this.mute || e.scale.copy(this.target.scale)
        }
    }), Nm.prototype = Object.assign(Object.create(Pm.prototype), {
        constructor: Nm,
        isFloorConstraint: !0,
        copy: function (e) {
            Pm.prototype.copy.call(this, e), this.floorLocation = e.floorLocation, this.offset = e.offset
        },
        update: function (e) {
            if (Pm.prototype.update.call(this, e), !this.mute) {
                var t = e.position,
                    n = this.target.position,
                    r = this.offset;
                switch (this.floorLocation) {
                    case "X":
                        t.x = Math.max(t.x, n.x + r);
                        break;
                    case "Y":
                        t.y = Math.max(t.y, n.y + r);
                        break;
                    case "Z":
                        t.z = Math.max(t.z, n.z + r);
                        break;
                    case "-X":
                        t.x = Math.min(t.x, n.x + r);
                        break;
                    case "-Y":
                        t.y = Math.min(t.y, n.y + r);
                        break;
                    case "-Z":
                        t.z = Math.min(t.z, n.z + r)
                }
            }
        }
    }), Om.prototype = Object.assign(Object.create(Cm.prototype), {
        constructor: Om,
        isLimitLocationConstraint: !0,
        copy: function (e) {
            Cm.prototype.copy.call(this, e), this.min.copy(e.min), this.max.copy(e.max)
        },
        update: function (e) {
            Cm.prototype.update.call(this, e), this.mute || e.position.clamp(this.min, this.max)
        }
    }), Fm.prototype = Object.assign(Object.create(Cm.prototype), {
        constructor: Fm,
        isLimitRotationConstraint: !0,
        copy: function (e) {
            Cm.prototype.copy.call(this, e), this.axis = e.axis, this.min = e.min, this.max = e.max
        },
        update: (im = new gn, function (e) {
            Cm.prototype.update.call(this, e), this.mute || ("X" == this.axis ? (im.setFromQuaternion(e.quaternion, "XYZ"), im.x = this._clampAngle(im.x, this.min, this.max)) : "Y" == this.axis ? (im.setFromQuaternion(e.quaternion, "YZX"), im.y = this._clampAngle(im.y, this.min, this.max)) : "Z" == this.axis && (im.setFromQuaternion(e.quaternion, "ZXY"), im.z = this._clampAngle(im.z, this.min, this.max)), e.quaternion.setFromEuler(im))
        }),
        _clampAngle: function (e, t, n) {
            return Math.abs(n - t) < 2 * Math.PI && (e = Yt.clampAngle(e, t, n)), e
        }
    }), Bm.prototype = Object.assign(Object.create(Cm.prototype), {
        constructor: Bm,
        isLimitScaleConstraint: !0,
        copy: function (e) {
            Cm.prototype.copy.call(this, e), this.min.copy(e.min), this.max.copy(e.max)
        },
        update: function (e) {
            Cm.prototype.update.call(this, e), this.mute || e.scale.clamp(this.min, this.max)
        }
    }), zm.prototype = Object.assign(Object.create(Pm.prototype), {
        constructor: zm,
        isLockedTrackConstraint: !0,
        copy: function (e) {
            Pm.prototype.copy.call(this, e), this.trackAxis = e.trackAxis, this.lockAxis = e.lockAxis
        },
        update: (am = new on, om = new on, sm = new on, lm = new on, cm = new on, um = new fr, dm = new on, hm = new on, pm = new nn, fm = (new nn).setFromAxisAngle(new on(1, 0, 0), -Math.PI / 2), function (e) {
            if (Pm.prototype.update.call(this, e), !this.mute && (sm.set("X" == this.trackAxis ? 1 : "-X" == this.trackAxis ? -1 : 0, "Y" == this.trackAxis ? 1 : "-Y" == this.trackAxis ? -1 : 0, "Z" == this.trackAxis ? 1 : "-Z" == this.trackAxis ? -1 : 0), lm.set("X" == this.lockAxis ? 1 : 0, "Y" == this.lockAxis ? 1 : 0, "Z" == this.lockAxis ? 1 : 0), 1 != Math.abs(sm.dot(lm)))) {
                am.setFromMatrixPosition(e.matrixWorld), om.setFromMatrixPosition(this.target.matrixWorld), um.setFromNormalAndCoplanarPoint(lm, am), um.projectPoint(om, cm).sub(am);
                var t = 0 < dm.crossVectors(sm, cm).dot(lm) ? 1 : -1;
                e.setRotationFromAxisAngle(um.normal, t * sm.angleTo(cm)), e.parent && (e.parent.matrixWorld.decompose(hm, pm, hm), e.quaternion.premultiply(pm.inverse())), e.isCamera && e.quaternion.multiply(fm)
            }
        })
    }), Um.prototype = Object.assign(Object.create(Pm.prototype), {
        constructor: Um,
        isTrackToConstraint: !0,
        copy: function (e) {
            Pm.prototype.copy.call(this, e), this.trackAxis = e.trackAxis, this.upAxis = e.upAxis
        },
        update: (mm = new fr, vm = new on, gm = new on, _m = new on, ym = new on, xm = new on, bm = new fn, wm = new on, Mm = new nn, Am = new on(0, 1, 0), Sm = (new nn).setFromAxisAngle(new on(1, 0, 0), -Math.PI / 2), function (e) {
            if (Pm.prototype.update.call(this, e), !this.mute) {
                var t = this.trackAxis[this.trackAxis.length - 1],
                    n = this.upAxis[this.upAxis.length - 1],
                    r = "-" == this.trackAxis[0],
                    i = "-" == this.upAxis[0];
                if (t != n) {
                    vm.setFromMatrixPosition(e.matrixWorld), gm.setFromMatrixPosition(this.target.matrixWorld), _m.subVectors(gm, vm), _m.lengthSq() ? _m.normalize() : _m.set(0, -1, 0), mm.set(_m, 0), 1 != Math.abs(_m.dot(Am)) ? mm.projectPoint(Am, ym).normalize() : ym.set(0, 0, -1), r && _m.negate(), i && ym.negate();
                    var a = "X" == t ? _m : "X" == n ? ym : null,
                        o = "Y" == t ? _m : "Y" == n ? ym : null,
                        s = "Z" == t ? _m : "Z" == n ? ym : null;
                    a ? o ? s = s || xm.crossVectors(a, o) : o = xm.crossVectors(s, a) : a = xm.crossVectors(o, s), bm.makeBasis(a, o, s), e.setRotationFromMatrix(bm), e.parent && (e.parent.matrixWorld.decompose(wm, Mm, wm), e.quaternion.premultiply(Mm.inverse())), e.isCamera && e.quaternion.multiply(Sm)
                }
            }
        })
    });
    var Vm = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAUSE_BREAK: 19,
        CAPS_LOCK: 20,
        ESCAPE: 27,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT_ARROW: 37,
        UP_ARROW: 38,
        RIGHT_ARROW: 39,
        DOWN_ARROW: 40,
        INSERT: 45,
        DELETE: 46,
        0: 48,
        1: 49,
        2: 50,
        3: 51,
        4: 52,
        5: 53,
        6: 54,
        7: 55,
        8: 56,
        9: 57,
        A: 65,
        B: 66,
        C: 67,
        D: 68,
        E: 69,
        F: 70,
        G: 71,
        H: 72,
        I: 73,
        J: 74,
        K: 75,
        L: 76,
        M: 77,
        N: 78,
        O: 79,
        P: 80,
        Q: 81,
        R: 82,
        S: 83,
        T: 84,
        U: 85,
        V: 86,
        W: 87,
        X: 88,
        Y: 89,
        Z: 90,
        LEFT_WINDOW_KEY: 91,
        RIGHT_WINDOW_KEY: 92,
        SELECT_KEY: 93,
        NUMPAD_0: 96,
        NUMPAD_1: 97,
        NUMPAD_2: 98,
        NUMPAD_3: 99,
        NUMPAD_4: 100,
        NUMPAD_5: 101,
        NUMPAD_6: 102,
        NUMPAD_7: 103,
        NUMPAD_8: 104,
        NUMPAD_9: 105,
        MULTIPLY: 106,
        ADD: 107,
        SUBTRACT: 109,
        DECIMAL_POINT: 110,
        DIVIDE: 111,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        NUM_LOCK: 144,
        SCROLL_LOCK: 145,
        SEMI_COLON: 186,
        EQUAL_SIGN: 187,
        COMMA: 188,
        DASH: 189,
        PERIOD: 190,
        FORWARD_SLASH: 191,
        GRAVE_ACCENT: 192,
        OPEN_BRACKET: 219,
        BACK_SLASH: 220,
        CLOSE_BRAKET: 221,
        SINGLE_QUOTE: 222
    };

    function Gm(e) {
        for (var t in this.isKeyDown = {}, Vm) this.isKeyDown[Vm[t]] = !1;
        this.onKeyDown = null, this.onKeyUp = null, this._domElement = e, this._keydownCb = function (e) {
            this.isKeyDown[e.keyCode] = !0, this.onKeyDown && this.onKeyDown(e)
        }.bind(this), this._keyupCb = function (e) {
            this.isKeyDown[e.keyCode] = !1, this.onKeyUp && this.onKeyUp(e)
        }.bind(this), this._domElement.addEventListener("keydown", this._keydownCb, !1), this._domElement.addEventListener("keyup", this._keyupCb, !1)
    }
    Object.assign(Gm.prototype, {
        dispose: function () {
            this._domElement.removeEventListener("keydown", this._keydownCb, !1), this._domElement.removeEventListener("keyup", this._keyupCb, !1)
        }
    });

    function km(e, t) {
        var c = this;
        this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.screen = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
        }, this.enableDamping = !0, this.enableRotate = !0, this.rotateSpeed = .9, this.rotateSpeedTouch = .75, this.rotateInertia = .05, this.rotateInertiaTouch = .05, this.enableZoom = !0, this.zoomSpeed = 30, this.zoomSpeedKey = .2, this.zoomInertia = .05, this.enablePan = !0, this.panSpeedKey = .15, this.panInertia = .05, this.gazeLevel = 1.8, this.storyHeight = 3, this.collisionMeshes = [];
        var l = new Kd,
            a = new on,
            o = new on,
            s = new on,
            u = new on,
            d = new nn,
            h = new on,
            p = {};
        p[Vm.W] = p[Vm.S] = p[Vm.A] = p[Vm.D] = p[Vm.UP_ARROW] = p[Vm.DOWN_ARROW] = p[Vm.LEFT_ARROW] = p[Vm.RIGHT_ARROW] = 0;
        var f = new Gm(window),
            n = !(f.onKeyDown = function (e) {
                e.keyCode in p && (p[e.keyCode] = 1)
            }),
            m = new Yc,
            v = new Yc,
            g = new qt,
            _ = 1,
            y = 1,
            r = new qt,
            i = new qt,
            x = 0,
            b = 0,
            w = 1,
            M = 1,
            A = new qt,
            S = new qt,
            T = 1,
            E = 1,
            C = new es(new on, new on(0, -1, 0)),
            P = C.params.checkVisibility = !1,
            L = !1,
            R = function () {},
            D = new on,
            I = new on,
            N = new on,
            O = new on,
            F = 0,
            B = new Kd,
            z = {
                type: "change"
            },
            U = {
                type: "start"
            },
            V = {
                type: "end"
            };
        this.handleResize = function () {
            if (this.domElement === document) this.screen.left = 0, this.screen.top = 0, this.screen.width = window.innerWidth, this.screen.height = window.innerHeight;
            else {
                var e = this.domElement.getBoundingClientRect(),
                    t = this.domElement.ownerDocument.documentElement;
                this.screen.left = e.left + window.pageXOffset - t.clientLeft, this.screen.top = e.top + window.pageYOffset - t.clientTop, this.screen.width = e.width, this.screen.height = e.height
            }
        }, this.handleEvent = function (e) {
            "function" == typeof this[e.type] && this[e.type](e)
        };
        var G, k, j, W, X, H = (G = new qt, function (e, t) {
            return G.set((e - .5 * c.screen.width - c.screen.left) / (.5 * c.screen.width), (c.screen.height + 2 * (c.screen.top - t)) / c.screen.width), G
        });

        function Y(e) {
            !1 !== c.enabled && (e.preventDefault(), !1 !== c.enableRotate && (i.copy(H(e.pageX, e.pageY).negate()), r.copy(i), n = !0, document.addEventListener("mousemove", q, !1), document.addEventListener("mouseup", Z, !1), document.addEventListener("mouseleave", Z, !1), c.dispatchEvent(U)))
        }

        function q(e) {
            if (!1 !== c.enabled && (e.preventDefault(), n)) {
                if (!1 === c.enableRotate) return;
                i.copy(H(e.pageX, e.pageY).negate()), g.add(i).sub(r), r.copy(i), _ = c.rotateSpeed, y = c.rotateInertia
            }
        }

        function Z(e) {
            !1 !== c.enabled && (e.preventDefault(), n = !1, document.removeEventListener("mousemove", q), document.removeEventListener("mouseup", Z), document.removeEventListener("mouseleave", Z), c.dispatchEvent(V))
        }

        function Q(e) {
            if (!1 !== c.enabled && !1 !== c.enableZoom) {
                switch (e.preventDefault(), e.stopPropagation(), e.deltaMode) {
                    case 2:
                        b -= .025 * e.deltaY, w = c.zoomSpeed, M = c.zoomInertia;
                        break;
                    case 1:
                        b -= .01 * e.deltaY, w = c.zoomSpeed, M = c.zoomInertia;
                        break;
                    default:
                        b -= 25e-5 * e.deltaY, w = c.zoomSpeed, M = c.zoomInertia
                }
                c.dispatchEvent(U), c.dispatchEvent(V)
            }
        }

        function K(e) {
            if (!1 !== c.enabled) {
                var t = e.touches[0];
                n = !0, i.copy(H(t.pageX, t.pageY).negate()), r.copy(i), c.dispatchEvent(U)
            }
        }

        function J(e) {
            if (!1 !== c.enabled) {
                e.preventDefault();
                var t = e.touches[0];
                !1 !== c.enableRotate && (i.copy(H(t.pageX, t.pageY).negate()), g.add(i).sub(r), r.copy(i), _ = c.rotateSpeedTouch, y = c.rotateInertiaTouch)
            }
        }

        function $(e) {
            if (!1 !== c.enabled) {
                switch (e.touches.length) {
                    case 0:
                        n = !1;
                        break;
                    default:
                        if (!1 === c.enableRotate) return;
                        n = !0, i.copy(H(e.touches[0].pageX, e.touches[0].pageY).negate()), r.copy(i)
                }
                c.dispatchEvent(V)
            }
        }

        function ee(e) {
            !1 !== c.enabled && e.preventDefault()
        }
        this.update = (k = new on, function () {
            if (L) {
                var e = B.getElapsedTime() / F;
                if (e = Yt.smootherstep(e, 0, 1), c.object.position.lerpVectors(D, N, e), c.object.lookAt(k.lerpVectors(I, O, e)), 1 <= e) {
                    for (var t in L = !1, R(), v.set(0, 0, 0), g.set(0, 0), b = x = 0, A.set(0, 0), S.set(0, 0), p) p[t] = 0;
                    l.getDelta()
                }
            } else c.object.isCamera || c.object.isLight ? h.set(0, 0, -1) : h.set(0, 0, 1), h.applyQuaternion(c.object.quaternion).normalize(), m.setFromVector3(h), m.theta += v.theta * _, m.phi += v.phi * _, m.makeSafe(), h.setFromSpherical(m), a.copy(h).add(c.object.position), c.object.lookAt(a), c.object.isPerspectiveCamera ? c.object.position.addScaledVector(h, x) : c.object.isOrthographicCamera && (c.object.zoom *= 1 + .15 * x, c.object.updateProjectionMatrix()), o.copy(h).cross(c.object.up).setLength(-A.x), o.add(s.copy(c.object.up).setLength(A.y)), c.object.position.add(o),
                function () {
                    var e = l.getDelta();
                    for (var t in v.set(v.radius, g.y, g.x), g.x = c.enableDamping ? Yt.expAverage(g.x, 0, e, y) : 0, g.y = c.enableDamping ? Yt.expAverage(g.y, 0, e, y) : 0, v.set(v.radius, v.phi - g.y, v.theta - g.x), A.copy(S), S.x = c.enableDamping ? Yt.expAverage(S.x, 0, e, E) : 0, S.y = c.enableDamping ? Yt.expAverage(S.y, 0, e, E) : 0, A.sub(S), A.multiplyScalar(T), x = b, b = c.enableDamping ? Yt.expAverage(b, 0, e, M) : 0, x -= b, x *= w, p) {
                        var n = t == Vm.A || t == Vm.LEFT_ARROW || t == Vm.D || t == Vm.RIGHT_ARROW,
                            r = t == Vm.W || t == Vm.UP_ARROW || t == Vm.S || t == Vm.DOWN_ARROW,
                            i = n ? c.panInertia : c.zoomInertia,
                            a = n ? c.panSpeedKey : c.zoomSpeedKey;
                        if (f.isKeyDown[t]) var o = p[t] = 1;
                        else {
                            var s = p[t];
                            p[t] = Yt.expAverage(p[t], 0, e, i), o = s - p[t]
                        }
                        c.enabled && (n && !c.enablePan || r && !c.enableZoom || (o *= 60 * e * a, t == Vm.A || t == Vm.LEFT_ARROW ? A.x += o : t == Vm.D || t == Vm.RIGHT_ARROW ? A.x -= o : t == Vm.W || t == Vm.UP_ARROW ? x += o : t != Vm.S && t != Vm.DOWN_ARROW || (x -= o)))
                    }
                }();
            if (c.collisionMeshes.length) {
                C.ray.origin.copy(c.object.position), C.far = c.storyHeight;
                var n = C.intersectObjects(c.collisionMeshes);
                if (0 < n.length) {
                    var r = n[0];
                    c.object.position.y = r.point.y + c.gazeLevel, P = !0
                } else P && c.object.position.copy(u)
            }
            var i = !1;
            1e-6 < u.distanceToSquared(c.object.position) && (u.copy(c.object.position), i = !0), d.dot(c.object.quaternion) < 1 - 1e-6 && (d.copy(c.object.quaternion), i = !0), i && c.dispatchEvent(z)
        }), this.dispose = function () {
            this.domElement.removeEventListener("contextmenu", ee, !1), this.domElement.removeEventListener("mousedown", Y, !1), this.domElement.removeEventListener("wheel", Q, !1), this.domElement.removeEventListener("touchstart", K, !1), this.domElement.removeEventListener("touchend", $, !1), this.domElement.removeEventListener("touchmove", J, !1), document.removeEventListener("mousemove", q, !1), document.removeEventListener("mouseup", Z, !1), document.removeEventListener("mouseleave", Z, !1), f.dispose()
        }, this.releaseFromCollision = function () {
            P = !1
        }, this.tween = (j = new on, W = new on, X = new on, function (e, t, n, r) {
            c.object.parent && (e = j.copy(e), c.object.parent.worldToLocal(e));
            var i = c.object.getWorldPosition(W),
                a = X.subVectors(t, i).length(),
                o = c.object.getWorldDirection(X).multiplyScalar(a).add(i),
                s = e.manhattanDistanceTo(c.object.position),
                l = t.manhattanDistanceTo(o);
            s < 1e-5 && l < 1e-5 || (L = !0, R = "function" == typeof r ? r : function () {}, D.copy(c.object.position), I.copy(o), N.copy(e), O.copy(t), F = n, B.start())
        }), this.domElement.addEventListener("contextmenu", ee, !1), this.domElement.addEventListener("mousedown", Y, !1), this.domElement.addEventListener("wheel", Q, !1), this.domElement.addEventListener("touchstart", K, !1), this.domElement.addEventListener("touchend", $, !1), this.domElement.addEventListener("touchmove", J, !1), this.handleResize(), this.update()
    }
    Object.assign(km.prototype, o.prototype);

    function jm(e, t) {
        var c = this,
            a = {
                NONE: -1,
                ROTATE: 0,
                ZOOM: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_ZOOM_PAN: 4
            };
        this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.screen = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
        }, this.enableDamping = !0, this.enableRotate = !0, this.rotateSpeed = .9, this.rotateSpeedTouch = .75, this.rotateInertia = .05, this.rotateInertiaTouch = .05, this.enableZoom = !0, this.zoomSpeed = 150, this.zoomSpeedKey = .5, this.zoomSpeedTouch = 20, this.zoomInertia = .05, this.zoomInertiaTouch = .05, this.enablePan = !0, this.panSpeed = 20, this.panSpeedKey = .15, this.panSpeedTouch = 15, this.panInertia = .05, this.panInertiaTouch = .05, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.mouseButtons = {
            ROTATE: v3d.MOUSE.LEFT,
            ZOOM: v3d.MOUSE.MIDDLE,
            PAN: v3d.MOUSE.RIGHT
        };
        var l = new Kd,
            r = new on,
            i = new on,
            o = new on,
            u = new qt,
            s = new on,
            d = new nn,
            h = a.NONE,
            p = new on,
            f = {};
        f[Vm.W] = f[Vm.S] = f[Vm.A] = f[Vm.D] = f[Vm.UP_ARROW] = f[Vm.DOWN_ARROW] = f[Vm.LEFT_ARROW] = f[Vm.RIGHT_ARROW] = 0;
        var m = new Gm(window);
        m.onKeyDown = function (e) {
            e.keyCode in f && (f[e.keyCode] = 1)
        };
        var v = new Yc,
            g = new Yc,
            _ = new qt,
            y = 1,
            x = 1,
            b = new qt,
            w = new qt,
            M = 0,
            A = 0,
            S = 1,
            T = 1,
            E = 0,
            C = 0,
            P = new qt,
            L = new qt,
            R = 1,
            D = 1,
            I = new qt,
            N = new qt,
            O = !1,
            F = function () {},
            B = new on,
            z = new on,
            U = new on,
            V = new on,
            G = 0,
            k = new Kd,
            j = {
                type: "change"
            },
            W = {
                type: "start"
            },
            n = {
                type: "end"
            };
        this.handleResize = function () {
            if (this.domElement === document) this.screen.left = 0, this.screen.top = 0, this.screen.width = window.innerWidth, this.screen.height = window.innerHeight;
            else {
                var e = this.domElement.getBoundingClientRect(),
                    t = this.domElement.ownerDocument.documentElement;
                this.screen.left = e.left + window.pageXOffset - t.clientLeft, this.screen.top = e.top + window.pageYOffset - t.clientTop, this.screen.width = e.width, this.screen.height = e.height
            }
        }, this.handleEvent = function (e) {
            "function" == typeof this[e.type] && this[e.type](e)
        };
        var X, H, Y, q, Z, Q, K = (X = new qt, function (e, t) {
                return X.set((e - c.screen.left) / c.screen.width, (t - c.screen.top) / c.screen.height), X
            }),
            J = (H = new qt, function (e, t) {
                return H.set((e - .5 * c.screen.width - c.screen.left) / (.5 * c.screen.width), (c.screen.height + 2 * (c.screen.top - t)) / c.screen.width), H
            });

        function $(e) {
            if (!1 !== c.enabled) {
                switch (e.preventDefault(), e.button) {
                    case c.mouseButtons.ROTATE:
                        if (!1 === c.enableRotate) return;
                        w.copy(J(e.pageX, e.pageY).negate()), b.copy(w), h = a.ROTATE;
                        break;
                    case c.mouseButtons.ZOOM:
                    case c.mouseButtons.PAN:
                        if (!1 === c.enablePan) return;
                        I.copy(K(e.pageX, e.pageY)), N.copy(I), h = e.button == c.mouseButtons.PAN ? a.PAN : a.ZOOM
                }
                document.addEventListener("mousemove", ee, !1), document.addEventListener("mouseup", te, !1), document.addEventListener("mouseleave", te, !1), c.dispatchEvent(W)
            }
        }

        function ee(e) {
            if (!1 !== c.enabled)
                if (e.preventDefault(), h === a.ROTATE) {
                    if (!1 === c.enableRotate) return;
                    w.copy(J(e.pageX, e.pageY).negate()), _.add(w).sub(b), b.copy(w), y = c.rotateSpeed, x = c.rotateInertia
                } else if (h === a.PAN || h === a.ZOOM) {
                if (!1 === c.enablePan) return;
                N.copy(K(e.pageX, e.pageY)), L.add(N).sub(I), I.copy(N), R = c.panSpeed, D = c.panInertia
            }
        }

        function te(e) {
            !1 !== c.enabled && (e.preventDefault(), h = a.NONE, document.removeEventListener("mousemove", ee), document.removeEventListener("mouseup", te), document.removeEventListener("mouseleave", te), c.dispatchEvent(n))
        }

        function ne(e) {
            if (!1 !== c.enabled && !1 !== c.enableZoom) {
                switch (e.preventDefault(), e.stopPropagation(), e.deltaMode) {
                    case 2:
                        A -= .025 * e.deltaY, S = c.zoomSpeed, T = c.zoomInertia;
                        break;
                    case 1:
                        A -= .01 * e.deltaY, S = c.zoomSpeed, T = c.zoomInertia;
                        break;
                    default:
                        A -= 25e-5 * e.deltaY, S = c.zoomSpeed, T = c.zoomInertia
                }
                c.dispatchEvent(W), c.dispatchEvent(n)
            }
        }

        function re(e) {
            if (!1 !== c.enabled) {
                var t = e.touches[0],
                    n = e.touches[1];
                switch (e.touches.length) {
                    case 1:
                        if (!1 === c.enableRotate) return;
                        h = a.TOUCH_ROTATE, w.copy(J(t.pageX, t.pageY).negate()), b.copy(w);
                        break;
                    default:
                        if (!1 === c.enableZoom && !1 === c.enablePan) return;
                        if (h = a.TOUCH_ZOOM_PAN, c.enableZoom) {
                            var r = K(t.pageX - n.pageX, t.pageY - n.pageY);
                            E = C = r.length()
                        }
                        if (c.enablePan) {
                            var i = K((t.pageX + n.pageX) / 2, (t.pageY + n.pageY) / 2);
                            I.copy(i), N.copy(I)
                        }
                }
                c.dispatchEvent(W)
            }
        }

        function ie(e) {
            if (!1 !== c.enabled) {
                e.preventDefault();
                var t = e.touches[0],
                    n = e.touches[1];
                switch (e.touches.length) {
                    case 1:
                        if (!1 === c.enableRotate) return;
                        w.copy(J(t.pageX, t.pageY).negate()), _.add(w).sub(b), b.copy(w), y = c.rotateSpeedTouch, x = c.rotateInertiaTouch;
                        break;
                    default:
                        if (!1 === c.enableZoom && !1 === c.enablePan) return;
                        var r = K(t.pageX - n.pageX, t.pageY - n.pageY),
                            i = (C = r.length()) - E;
                        E = C;
                        var a = K((t.pageX + n.pageX) / 2, (t.pageY + n.pageY) / 2);
                        N.copy(a);
                        var o = u.subVectors(N, I),
                            s = o.length();
                        I.copy(N), c.enableZoom && Math.abs(i) > Math.abs(s) && (A += i, S = c.zoomSpeedTouch, T = c.zoomInertiaTouch), c.enablePan && Math.abs(i) <= Math.abs(s) && (L.add(o), R = c.panSpeedTouch, D = c.panInertiaTouch)
                }
            }
        }

        function ae(e) {
            if (!1 !== c.enabled) {
                switch (e.touches.length) {
                    case 0:
                        h = a.NONE;
                        break;
                    case 1:
                        if (!1 === c.enableRotate) return;
                        h = a.TOUCH_ROTATE, w.copy(J(e.touches[0].pageX, e.touches[0].pageY).negate()), b.copy(w)
                }
                c.dispatchEvent(n)
            }
        }

        function oe(e) {
            !1 !== c.enabled && e.preventDefault()
        }
        this.update = (Y = new on, function () {
            if (O) {
                var e = k.getElapsedTime() / G;
                if (e = Yt.smootherstep(e, 0, 1), c.object.position.lerpVectors(B, U, e), c.object.lookAt(Y.lerpVectors(z, V, e)), 1 <= e) {
                    for (var t in O = !1, F(), g.set(0, 0, 0), _.set(0, 0), A = M = 0, P.set(0, 0), L.set(0, 0), f) f[t] = 0;
                    l.getDelta()
                }
            } else c.object.isCamera || c.object.isLight ? p.set(0, 0, -1) : p.set(0, 0, 1), p.applyQuaternion(c.object.quaternion).normalize(), v.setFromVector3(p), v.theta += g.theta * y, v.phi += g.phi * y, v.theta = Math.max(c.minAzimuthAngle, Math.min(c.maxAzimuthAngle, v.theta)), v.phi = Math.max(c.minPolarAngle, Math.min(c.maxPolarAngle, v.phi)), v.makeSafe(), p.setFromSpherical(v), r.copy(p).add(c.object.position), c.object.lookAt(r), c.object.isPerspectiveCamera ? c.object.position.addScaledVector(p, M) : c.object.isOrthographicCamera && (c.object.zoom *= 1 + .15 * M, c.object.updateProjectionMatrix()), i.copy(p).cross(c.object.up).setLength(-P.x), i.add(o.copy(c.object.up).setLength(P.y)), c.object.position.add(i),
                function () {
                    var e = l.getDelta();
                    for (var t in g.set(g.radius, _.y, _.x), _.x = c.enableDamping ? Yt.expAverage(_.x, 0, e, x) : 0, _.y = c.enableDamping ? Yt.expAverage(_.y, 0, e, x) : 0, g.set(g.radius, g.phi - _.y, g.theta - _.x), P.copy(L), L.x = c.enableDamping ? Yt.expAverage(L.x, 0, e, D) : 0, L.y = c.enableDamping ? Yt.expAverage(L.y, 0, e, D) : 0, P.sub(L), P.multiplyScalar(R), M = A, A = c.enableDamping ? Yt.expAverage(A, 0, e, T) : 0, M -= A, M *= S, f) {
                        var n = t == Vm.A || t == Vm.LEFT_ARROW || t == Vm.D || t == Vm.RIGHT_ARROW,
                            r = t == Vm.W || t == Vm.UP_ARROW || t == Vm.S || t == Vm.DOWN_ARROW,
                            i = n ? c.panInertia : c.zoomInertia,
                            a = n ? c.panSpeedKey : c.zoomSpeedKey;
                        if (m.isKeyDown[t]) var o = f[t] = 1;
                        else {
                            var s = f[t];
                            f[t] = Yt.expAverage(f[t], 0, e, i), o = s - f[t]
                        }
                        c.enabled && (n && !c.enablePan || r && !c.enableZoom || (o *= 60 * e * a, t == Vm.A || t == Vm.LEFT_ARROW ? P.x += o : t == Vm.D || t == Vm.RIGHT_ARROW ? P.x -= o : t == Vm.W || t == Vm.UP_ARROW ? M += o : t != Vm.S && t != Vm.DOWN_ARROW || (M -= o)))
                    }
                }();
            var n = !1;
            1e-6 < s.distanceToSquared(c.object.position) && (s.copy(c.object.position), n = !0), d.dot(c.object.quaternion) < 1 - 1e-6 && (d.copy(c.object.quaternion), n = !0), n && c.dispatchEvent(j)
        }), this.dispose = function () {
            this.domElement.removeEventListener("contextmenu", oe, !1), this.domElement.removeEventListener("mousedown", $, !1), this.domElement.removeEventListener("wheel", ne, !1), this.domElement.removeEventListener("touchstart", re, !1), this.domElement.removeEventListener("touchend", ae, !1), this.domElement.removeEventListener("touchmove", ie, !1), document.removeEventListener("mousemove", ee, !1), document.removeEventListener("mouseup", te, !1), document.removeEventListener("mouseleave", te, !1), m.dispose()
        }, this.tween = (q = new on, Z = new on, Q = new on, function (e, t, n, r) {
            c.object.parent && (e = q.copy(e), c.object.parent.worldToLocal(e));
            var i = c.object.getWorldPosition(Z),
                a = Q.subVectors(t, i).length(),
                o = c.object.getWorldDirection(Q).multiplyScalar(a).add(i),
                s = e.manhattanDistanceTo(c.object.position),
                l = t.manhattanDistanceTo(o);
            s < 1e-5 && l < 1e-5 || (O = !0, F = "function" == typeof r ? r : function () {}, B.copy(c.object.position), z.copy(o), U.copy(e), V.copy(t), G = n, k.start())
        }), this.domElement.addEventListener("contextmenu", oe, !1), this.domElement.addEventListener("mousedown", $, !1), this.domElement.addEventListener("wheel", ne, !1), this.domElement.addEventListener("touchstart", re, !1), this.domElement.addEventListener("touchend", ae, !1), this.domElement.addEventListener("touchmove", ie, !1), this.handleResize(), this.update()
    }
    Object.assign(jm.prototype, o.prototype);

    function Wm(e, t) {
        var n, r, i, a, o, s, l, c, u;
        this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.targetObj = new Fn, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !0, this.enableZoom = !0, this.zoomSpeed = 5, this.zoomSpeedTouch = 1, this.zoomInertia = .05, this.zoomInertiaTouch = .05, this.enableRotate = !0, this.rotateSpeed = 1.2, this.rotateSpeedTouch = .7, this.rotateInertia = .05, this.rotateInertiaTouch = .05, this.enablePan = !0, this.panSpeed = 1.3, this.panSpeedKey = 15, this.panInertia = .05, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.mouseButtons = {
            ROTATE: v3d.MOUSE.LEFT,
            ZOOM: v3d.MOUSE.MIDDLE,
            PAN: v3d.MOUSE.RIGHT
        }, this.target0 = this.targetObj.position.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function () {
            return _.phi
        }, this.getAzimuthalAngle = function () {
            return _.theta
        }, this.saveState = function () {
            d.targetObj.updateWorldMatrix(!0, !1), d.target0.setFromMatrixPosition(d.targetObj.matrixWorld), d.position0.copy(d.object.position), d.zoom0 = d.object.zoom
        }, this.reset = (n = new on, function () {
            d.targetObj.updateWorldMatrix(!0, !1);
            var e = n.copy(d.target0);
            d.targetObj.worldToLocal(e), d.targetObj.position.add(e), d.object.position.copy(d.position0), d.object.zoom = d.zoom0, d.object.updateProjectionMatrix(), d.dispatchEvent(h), d.update(), v = m.NONE
        }), this.update = (r = new on, i = new on, a = (new nn).setFromUnitVectors(e.up, new on(0, 1, 0)), o = a.clone().inverse(), s = new on, l = new nn, function () {
            var e = d.object.position;
            if (d.targetObj.updateWorldMatrix(!0, !1), this.inTween) {
                var t = Y.getElapsedTime() / H;
                if (t = Yt.smootherstep(t, 0, 1), e.lerpVectors(k, W, t), i.lerpVectors(j, X, t), d.object.lookAt(i), 1 <= t) {
                    for (var n in this.inTween = !1, this.tweenCallback(), y.set(0, 0, 0), b.set(0, 0, 0), x = 1, N.set(0, 0), M) M[n] = 0;
                    C.set(0, 0), G.getDelta()
                }
            } else i.setFromMatrixPosition(d.targetObj.matrixWorld), r.copy(e).sub(i), r.applyQuaternion(a), _.setFromVector3(r), d.autoRotate && v === m.NONE && Z(2 * Math.PI / 60 / 60 * d.autoRotateSpeed), _.theta += y.theta, _.phi += y.phi, isFinite(d.minAzimuthAngle) && isFinite(d.maxAzimuthAngle) && (_.theta = Yt.clampAngle(_.theta, d.minAzimuthAngle, d.maxAzimuthAngle)), _.phi = Math.max(d.minPolarAngle, Math.min(d.maxPolarAngle, _.phi)), _.makeSafe(), d.object.isPerspectiveCamera ? (_.radius *= x, _.radius = Math.max(d.minDistance, Math.min(d.maxDistance, _.radius))) : d.object.isOrthographicCamera && (d.object.zoom /= x, d.object.zoom = Math.max(d.minZoom, Math.min(d.maxZoom, d.object.zoom)), d.object.updateProjectionMatrix()), i.add(b), r.setFromSpherical(_), r.applyQuaternion(o), e.copy(i).add(r), d.object.lookAt(i), y.set(0, 0, 0), b.set(0, 0, 0),
                function () {
                    var e = G.getDelta();
                    for (var t in E.copy(C), C.x = d.enableDamping ? Yt.expAverage(C.x, 0, e, L) : 0, C.y = d.enableDamping ? Yt.expAverage(C.y, 0, e, L) : 0, E.sub(C),
                            function () {
                                var e = d.domElement === document ? d.domElement.body : d.domElement,
                                    t = e.clientWidth,
                                    n = e.clientHeight;
                                t && n && (Z(2 * Math.PI * E.x / t * P), function (e) {
                                    y.phi -= e
                                }(2 * Math.PI * E.y / n * P))
                            }(), I.copy(N), N.x = d.enableDamping ? Yt.expAverage(N.x, 0, e, d.panInertia) : 0, N.y = d.enableDamping ? Yt.expAverage(N.y, 0, e, d.panInertia) : 0, I.sub(N), I.multiplyScalar(d.panSpeed), M) {
                        if (A.isKeyDown[t]) var n = M[t] = 1;
                        else {
                            var r = M[t];
                            M[t] = Yt.expAverage(M[t], 0, e, d.panInertia), n = r - M[t]
                        }
                        d.enabled && d.enableKeys && d.enablePan && (n *= 60 * e * d.panSpeedKey, t == Vm.A || t == Vm.LEFT_ARROW ? I.x += n : t == Vm.D || t == Vm.RIGHT_ARROW ? I.x -= n : t == Vm.W || t == Vm.UP_ARROW ? I.y += n : t != Vm.S && t != Vm.DOWN_ARROW || (I.y -= n))
                    }
                    re(I.x, I.y), x = z, z = d.enableDamping ? Yt.expAverage(z, 1, e, V) : 1, x /= z
                }();
            return d.targetObj.position.copy(i), !(!(w || s.distanceToSquared(d.object.position) > g || 8 * (1 - l.dot(d.object.quaternion)) > g) || (d.dispatchEvent(h), s.copy(d.object.position), l.copy(d.object.quaternion), w = !1))
        }), this.dispose = function () {
            d.domElement.removeEventListener("contextmenu", fe, !1), d.domElement.removeEventListener("mousedown", se, !1), d.domElement.removeEventListener("wheel", ue, !1), d.domElement.removeEventListener("touchstart", de, !1), d.domElement.removeEventListener("touchend", pe, !1), d.domElement.removeEventListener("touchmove", he, !1), document.removeEventListener("mousemove", le, !1), document.removeEventListener("mouseup", ce, !1), document.removeEventListener("mouseleave", ce, !1), A.dispose()
        }, this.tween = (c = new on, u = new on, function (e, t, n, r) {
            d.targetObj.updateWorldMatrix(!0, !1), u.setFromMatrixPosition(d.targetObj.matrixWorld), d.object.parent && (e = c.copy(e), d.object.parent.worldToLocal(e)), e.manhattanDistanceTo(d.object.position) < 1e-5 && t.manhattanDistanceTo(u) < 1e-5 || (d.inTween = !0, d.tweenCallback = "function" == typeof r ? r : function () {}, k.copy(d.object.position), j.copy(u), W.copy(e), X.copy(t), H = n, Y.start())
        });
        var d = this,
            h = {
                type: "change"
            },
            p = {
                type: "start"
            },
            f = {
                type: "end"
            },
            m = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_DOLLY_PAN: 4
            },
            v = m.NONE,
            g = 1e-6,
            _ = new Yc,
            y = new Yc,
            x = 1,
            b = new on,
            w = !1,
            M = {};
        M[Vm.W] = M[Vm.S] = M[Vm.A] = M[Vm.D] = M[Vm.UP_ARROW] = M[Vm.DOWN_ARROW] = M[Vm.LEFT_ARROW] = M[Vm.RIGHT_ARROW] = 0;
        var A = new Gm(window);
        A.onKeyDown = function (e) {
            e.keyCode in M && (M[e.keyCode] = 1)
        };
        var S = new qt,
            T = new qt,
            E = new qt,
            C = new qt,
            P = 1,
            L = 1,
            R = new qt,
            D = new qt,
            I = new qt,
            N = new qt,
            O = new qt,
            F = new qt,
            B = new qt,
            z = 1,
            U = 1,
            V = 1,
            G = new Kd,
            k = new on,
            j = new on,
            W = new on,
            X = new on,
            H = 0,
            Y = new Kd;

        function q() {
            return Math.pow(.95, U)
        }

        function Z(e) {
            y.theta -= e
        }

        function Q(e, t) {
            T.set(e, t), C.add(T).sub(S), S.copy(T)
        }
        var K, J, $, ee, te = (K = new on, function (e, t) {
                K.setFromMatrixColumn(t, 0), K.multiplyScalar(-e), b.add(K)
            }),
            ne = (J = new on, function (e, t) {
                J.setFromMatrixColumn(t, 1), J.multiplyScalar(e), b.add(J)
            }),
            re = ($ = new on, ee = new on, function (e, t) {
                var n = d.domElement === document ? d.domElement.body : d.domElement,
                    r = n.clientWidth,
                    i = n.clientHeight;
                if (r && i)
                    if (d.object.isPerspectiveCamera) {
                        d.targetObj.updateWorldMatrix(!0, !1), ee.setFromMatrixPosition(d.targetObj.matrixWorld);
                        var a = d.object.position;
                        $.copy(a).sub(ee);
                        var o = $.length();
                        o *= Math.tan(d.object.fov / 2 * Yt.DEG2RAD), te(2 * e * o / i, d.object.matrix), ne(2 * t * o / i, d.object.matrix)
                    } else d.object.isOrthographicCamera ? (te(e * (d.object.right - d.object.left) / d.object.zoom / r, d.object.matrix), ne(t * (d.object.top - d.object.bottom) / d.object.zoom / i, d.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), d.enablePan = !1)
            });

        function ie(e) {
            d.object.isPerspectiveCamera ? z /= e : d.object.isOrthographicCamera ? (z /= e, w = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), d.enableZoom = !1)
        }

        function ae(e) {
            d.object.isPerspectiveCamera ? z *= e : d.object.isOrthographicCamera ? (z *= e, w = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), d.enableZoom = !1)
        }

        function oe(e) {
            var t, n;
            t = e.clientX, n = e.clientY, D.set(t, n), N.add(D).sub(R), R.copy(D)
        }

        function se(e) {
            if (!1 !== d.enabled) {
                switch (e.preventDefault(), e.button) {
                    case d.mouseButtons.ROTATE:
                        if (!1 === d.enableRotate) return;
                        n = e, S.set(n.clientX, n.clientY), v = m.ROTATE;
                        break;
                    case d.mouseButtons.ZOOM:
                    case d.mouseButtons.PAN:
                        if (!1 === d.enablePan) return;
                        t = e, R.set(t.clientX, t.clientY), v = m.PAN
                }
                var t, n;
                v !== m.NONE && (document.addEventListener("mousemove", le, !1), document.addEventListener("mouseup", ce, !1), document.addEventListener("mouseleave", ce, !1), d.dispatchEvent(p))
            }
        }

        function le(e) {
            var t, n;
            if (!1 !== d.enabled) switch (e.preventDefault(), v) {
                case m.ROTATE:
                    if (!1 === d.enableRotate) return;
                    Q((n = e).clientX, n.clientY), P = d.rotateSpeed, L = d.rotateInertia;
                    break;
                case m.DOLLY:
                    if (!1 === d.enableZoom) return;
                    t = e, F.set(t.clientX, t.clientY), B.subVectors(F, O), 0 < B.y ? ie(q()) : B.y < 0 && ae(q()), O.copy(F), d.update();
                    break;
                case m.PAN:
                    if (!1 === d.enablePan) return;
                    oe(e)
            }
        }

        function ce(e) {
            !1 !== d.enabled && (document.removeEventListener("mousemove", le, !1), document.removeEventListener("mouseup", ce, !1), document.removeEventListener("mouseleave", ce, !1), d.dispatchEvent(f), v = m.NONE)
        }

        function ue(e) {
            var t;
            !1 === d.enabled || !1 === d.enableZoom || v !== m.NONE && v !== m.ROTATE || (e.preventDefault(), e.stopPropagation(), d.dispatchEvent(p), t = e, U = d.zoomSpeed, V = d.zoomInertia, t.deltaY < 0 ? ae(q()) : 0 < t.deltaY && ie(q()), d.update(), d.dispatchEvent(f))
        }

        function de(e) {
            if (!1 !== d.enabled) {
                switch (e.touches.length) {
                    case 1:
                        if (!1 === d.enableRotate) return;
                        t = e, S.set(t.touches[0].pageX, t.touches[0].pageY), v = m.TOUCH_ROTATE;
                        break;
                    case 2:
                        if (!1 === d.enableZoom && !1 === d.enablePan) return;
                        ! function (e) {
                            if (d.enableZoom) {
                                U = d.zoomSpeedTouch, V = d.zoomInertiaTouch;
                                var t = e.touches[0].pageX - e.touches[1].pageX,
                                    n = e.touches[0].pageY - e.touches[1].pageY,
                                    r = Math.sqrt(t * t + n * n);
                                O.set(0, r)
                            }
                            if (d.enablePan) {
                                var i = .5 * (e.touches[0].pageX + e.touches[1].pageX),
                                    a = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                                R.set(i, a)
                            }
                            d.update()
                        }(e), v = m.TOUCH_DOLLY_PAN;
                        break;
                    default:
                        v = m.NONE
                }
                var t;
                v !== m.NONE && d.dispatchEvent(p)
            }
        }

        function he(e) {
            var t;
            if (!1 !== d.enabled) switch (e.preventDefault(), e.touches.length) {
                case 1:
                    if (!1 === d.enableRotate) return;
                    if (v !== m.TOUCH_ROTATE) return;
                    Q((t = e).touches[0].pageX, t.touches[0].pageY), P = d.rotateSpeedTouch, L = d.rotateInertiaTouch;
                    break;
                case 2:
                    if (!1 === d.enableZoom && !1 === d.enablePan) return;
                    if (v !== m.TOUCH_DOLLY_PAN) return;
                    ! function (e) {
                        var t = e.touches[0].pageX - e.touches[1].pageX,
                            n = e.touches[0].pageY - e.touches[1].pageY,
                            r = Math.sqrt(t * t + n * n);
                        F.set(0, r), B.subVectors(F, O), O.copy(F);
                        var i = .5 * (e.touches[0].pageX + e.touches[1].pageX),
                            a = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                        D.set(i, a), I.subVectors(D, R), R.copy(D), d.enableZoom && Math.abs(B.length()) > Math.abs(I.length()) && (0 < B.y ? ae(q()) : B.y < 0 && ie(q())), d.enablePan && Math.abs(B.length()) < Math.abs(I.length()) && N.add(I), d.update()
                    }(e);
                    break;
                default:
                    v = m.NONE
            }
        }

        function pe(e) {
            !1 !== d.enabled && (d.dispatchEvent(f), v = m.NONE)
        }

        function fe(e) {
            !1 !== d.enabled && e.preventDefault()
        }
        d.domElement.addEventListener("contextmenu", fe, !1), d.domElement.addEventListener("mousedown", se, !1), d.domElement.addEventListener("wheel", ue, !1), d.domElement.addEventListener("touchstart", de, !1), d.domElement.addEventListener("touchend", pe, !1), d.domElement.addEventListener("touchmove", he, !1), this.update()
    }

    function Xm(e, t) {
        this.sourceTexture = e, this.resolution = void 0 !== t ? t : 256;
        var n = this.resolution,
            r = {
                format: this.sourceTexture.format,
                magFilter: this.sourceTexture.magFilter,
                minFilter: this.sourceTexture.minFilter,
                type: this.sourceTexture.type,
                generateMipmaps: this.sourceTexture.generateMipmaps,
                anisotropy: this.sourceTexture.anisotropy,
                encoding: this.sourceTexture.encoding
            };
        this.renderTarget = new Ui(n, n, r), this.renderTarget.texture.name = "EquiCube.cube", this.camera = new qi(-1, 1, 1, -1, 0, 1e3), this.shader = new Oi(Ji.equicube), this.planeMesh = new xi(new Qi(2, 2, 0), this.shader), this.planeMesh.material.side = ie, this.scene = new Bn, this.scene.add(this.planeMesh), this.scene.add(this.camera), this.invertU = !1, this.offsetU = 0, this.shader.uniforms.tEquirect.value = this.sourceTexture
    }(Wm.prototype = Object.create(o.prototype)).constructor = Wm, Object.defineProperties(Wm.prototype, {
        center: {
            get: function () {
                return console.warn("v3d.OrbitControls: .center has been deprecated, use .targetObj instead"), new on
            }
        },
        target: {
            get: function () {
                return console.warn("v3d.OrbitControls: .target has been deprecated, use .targetObj instead"), new on
            },
            set: function () {
                console.warn("v3d.OrbitControls: .target has been deprecated, use .targetObj instead")
            }
        },
        noZoom: {
            get: function () {
                return console.warn("v3d.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
            },
            set: function (e) {
                console.warn("v3d.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !e
            }
        },
        noRotate: {
            get: function () {
                return console.warn("v3d.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
            },
            set: function (e) {
                console.warn("v3d.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !e
            }
        },
        noPan: {
            get: function () {
                return console.warn("v3d.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
            },
            set: function (e) {
                console.warn("v3d.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !e
            }
        },
        noKeys: {
            get: function () {
                return console.warn("v3d.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
            },
            set: function (e) {
                console.warn("v3d.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !e
            }
        },
        staticMoving: {
            get: function () {
                return console.warn("v3d.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
            },
            set: function (e) {
                console.warn("v3d.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !e
            }
        }
    }), Xm.prototype = {
        constructor: Xm,
        update: function (e) {
            var t = e.gammaInput,
                n = e.gammaOutput,
                r = e.toneMapping,
                i = e.toneMappingExposure,
                a = e.getRenderTarget();
            e.toneMapping = Fe, e.toneMappingExposure = 1, e.gammaInput = !1, e.gammaOutput = !1, this.renderToCubeMapTarget(e, this.renderTarget), e.setRenderTarget(a), e.toneMapping = r, e.toneMappingExposure = i, e.gammaInput = t, e.gammaOutput = n
        },
        renderToCubeMapTarget: function (e, t) {
            this.shader.uniforms.invertU.value = this.invertU, this.shader.uniforms.offsetU.value = this.offsetU;
            for (var n = 0; n < 6; n++) this.renderToCubeMapTargetFace(e, t, n)
        },
        renderToCubeMapTargetFace: function (e, t, n) {
            this.shader.uniforms.faceIndex.value = n, e.setRenderTarget(t, n), e.render(this.scene, this.camera)
        },
        dispose: function () {
            this.renderTarget.dispose(), this.planeMesh.geometry.dispose(), this.planeMesh.material.dispose()
        }
    };
    var Hm, Ym, qm = {
        getPageParams: function (e) {
            e = e || window;
            var t = decodeURIComponent(e.location.href.toString()),
                n = {};
            if (-1 == t.indexOf("?")) return n;
            for (var r = t.split("#")[0].split("?")[1].split("&"), i = 0; i < r.length; i++) {
                var a = r[i].split("="),
                    o = a[0];
                1 == a.length ? n[o] = "" : n[o] = a[1]
            }
            return n
        },
        updatePageParam: function (e, t, n) {
            var r = null,
                i = "",
                a = e.split("?"),
                o = a[0],
                s = a[1],
                l = "";
            if (s) {
                var c = (d = s.split("#"))[0];
                (r = d[1]) && (s = c), a = s.split("&");
                for (var u = 0; u < a.length; u++) a[u].split("=")[0] != t && (i += l + a[u], l = "&")
            } else {
                var d;
                c = (d = o.split("#"))[0], r = d[1];
                c && (o = c)
            }
            return r && (n += "#" + r), o + "?" + i + (l + "" + t + "=" + n)
        },
        loadScript: function (e, t, n, r) {
            var i = document.createElement("script");
            i.addEventListener("load", n, !1), i.addEventListener("error", r, !1), t.appendChild(i), i.src = e
        },
        drawWatermark: function (e) {
            var t = e.container;
            if (3483952072 == Yt.hashString(kt)) {
                var n = ["color: #fff;", "opacity: 0;", "font-size: 18px;", "font-family: sans-serif;", "text-align: center;", "text-decoration: none;", "position: absolute;", "bottom: 1%;", "right: 1%;", "user-select: none;", "z-index: 9999;", "text-shadow: 1px 1px #000;"].join("\n"),
                    r = document.createElement("div");
                r.innerHTML = '<a href="https://www.soft8soft.com/verge3d-trial/" target="_blank" style="'.concat(n, '">').concat("MADE WITH VERGE3D TRIAL", "</a>"), t.appendChild(r), setTimeout(function () {
                    t.contains(r) && 890310108 == Yt.hashString(r.textContent) || e.dispose()
                }, 1e3)
            }
        },
        isXML: function (e) {
            return null !== e.match(/.*\.xml$/)
        },
        isJS: function (e) {
            return null !== e.match(/.*\.js$/)
        },
        createLineObjectHTML: function (m, v, g, e, t, _) {
            console.warn("v3d.AppUtils.createLineObjectHTML has been deprecated. Use v3d.LineHTML instead."), e = e || 2, t = t ? t.convertSRGBToLinear() : new v3d.Color(1, 0, .2), _ = _ || 5;
            var y = new v3d.Vector3(1, 0, 0),
                n = new v3d.MeshLine;
            n.setGeometry([0, 0, 0, y.x, y.y, y.z]);
            var r = new v3d.MeshLineMaterial({
                    color: t,
                    lineWidth: e,
                    sizeAttenuation: 0
                }),
                x = new v3d.Mesh(n.geometry, r);
            x.name = v.name + "_LINE", v.add(x);
            var b = new v3d.Vector3,
                w = new v3d.Vector3,
                M = new v3d.Quaternion;
            m.renderCallbacks.push(function () {
                m.camera.updateMatrixWorld(), v.traverseAncestors(function (e) {
                    e.updateMatrixWorld()
                });
                var e = g.getBoundingClientRect(),
                    t = (e.left + e.right) / 2,
                    n = (e.top + e.bottom) / 2,
                    r = v.getWorldPosition(b);
                r.project(m.camera);
                var i = (r.x + 1) / 2 * m.getWidth(),
                    a = (1 - r.y) / 2 * m.getHeight(),
                    o = (n - a) / (t - i),
                    s = (e.height + 2 * _) / (e.width + 2 * _);
                if (Math.abs(o) > s) var l = ((c = n < a ? Math.min(e.bottom + _, a) : Math.max(e.top - _, a)) - a) / o + i;
                else var c = ((l = i < t ? Math.max(e.left - _, i) : Math.min(e.right + _, i)) - i) * o + a;
                var u = 2 * l / m.getWidth() - 1,
                    d = 1 - 2 * c / m.getHeight(),
                    h = w.set(u, d, 0);
                h.unproject(m.camera), v.worldToLocal(h);
                var p = h.length();
                x.scale.set(p, p, p), h.normalize();
                var f = M.setFromUnitVectors(y, h);
                x.setRotationFromQuaternion(f)
            })
        },
        addToAppList: function (e) {
            v3d && (v3d.apps = v3d.apps || [], -1 == v3d.apps.indexOf(e) && v3d.apps.push(e))
        },
        removeFromAppList: function (e) {
            if (v3d && v3d.apps) {
                var t = v3d.apps.indexOf(e); - 1 < t && v3d.apps.splice(t, 1)
            }
        },
        requestDeviceMotionPermissions: function () {
            if (window.DeviceMotionEvent && window.DeviceMotionEvent.requestPermission) {
                var t = document.createElement("div");
                t.innerHTML = '<div class="v3d-device-motion-permissions-dialog">Click here to enable iOS VR mode</div>', t.onclick = function () {
                    window.DeviceMotionEvent.requestPermission().then(function (e) {
                        "granted" == e ? console.log("DeviceMotion permissions granted") : console.log("DeviceMotion permissions not granted"), document.querySelector("body").removeChild(t)
                    }).catch(function () {
                        console.error(e)
                    })
                }, document.querySelector("body").appendChild(t)
            }
        }
    };

    function Zm() {
        this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
    }

    function Qm(e) {
        this._mesh = new xi(Ym, e)
    }

    function Km(e, t, n, r, i) {
        Zm.call(this), this.strength = void 0 !== t ? t : 1, this.radius = n, this.threshold = r, this.resolution = void 0 !== e ? new qt(e.x, e.y) : new qt(256, 256), i = i || {
            minFilter: Je,
            magFilter: Je,
            format: lt
        }, this.clearColor = new Pr(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
        var a = Math.round(this.resolution.x / 2),
            o = Math.round(this.resolution.y / 2);
        this.renderTargetBright = new en(a, o, i), this.renderTargetBright.texture.name = "BloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
        for (var s = 0; s < this.nMips; s++) {
            var l;
            (l = new en(a, o, i)).texture.name = "BloomPass.h" + s, l.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(l), (l = new en(a, o, i)).texture.name = "BloomPass.v" + s, l.texture.generateMipmaps = !1, this.renderTargetsVertical.push(l), a = Math.round(a / 2), o = Math.round(o / 2)
        }
        var c = Ji.bloomLumHighPass;
        this.highPassUniforms = Di.clone(c.uniforms), this.highPassUniforms.luminosityThreshold.value = r, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new Oi({
            type: "BloomHighPass",
            uniforms: this.highPassUniforms,
            vertexShader: c.vertexShader,
            fragmentShader: c.fragmentShader,
            defines: {}
        }), this.separableBlurMaterials = [];
        var u = [3, 5, 7, 9, 11];
        for (a = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2), s = 0; s < this.nMips; s++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(u[s])), this.separableBlurMaterials[s].uniforms.texSize.value = new qt(a, o), a = Math.round(a / 2), o = Math.round(o / 2);
        this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0;
        this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], this.bloomTintColors = [new on(1, 1, 1), new on(1, 1, 1), new on(1, 1, 1), new on(1, 1, 1), new on(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
        var d = Ji.copy;
        this.copyUniforms = Di.clone(d.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new Oi({
            type: "BloomCopy",
            defines: d.defines,
            uniforms: this.copyUniforms,
            vertexShader: d.vertexShader,
            fragmentShader: d.fragmentShader,
            blending: ue,
            blendEquation: de,
            blendEquationAlpha: de,
            blendSrc: xe,
            blendDst: ge,
            blendSrcAlpha: ve,
            blendDstAlpha: ge,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), this.enabled = !0, this.needsSwap = !1, this.oldClearColor = new Pr, this.oldClearAlpha = 1, this.basic = new Fr, this.fsQuad = new Zm.FullScreenQuad(null)
    }

    function Jm(e, t) {
        Zm.call(this), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof Oi ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = Di.clone(e.uniforms), this.material = new Oi({
            type: "ShaderPass",
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader
        })), this.fsQuad = new Zm.FullScreenQuad(this.material)
    }

    function $m() {
        Jm.call(this, Ji.brightness_contrast), this.material.type = "Grayscale", Object.defineProperties(this, {
            brightness: {
                get: function () {
                    return this.uniforms.brightness.value
                },
                set: function (e) {
                    this.uniforms.brightness.value = e
                }
            },
            contrast: {
                get: function () {
                    return this.uniforms.contrast.value
                },
                set: function (e) {
                    this.uniforms.contrast.value = e
                }
            }
        })
    }

    function ev(e, t, n) {
        Zm.call(this), this.scene = e, this.camera = t;
        var r = new en(n.width || window.innerWidth || 1, n.height || window.innerHeight || 1, {
            minFilter: Je,
            magFilter: Je,
            format: lt
        });
        this.renderTargetDepth = r.clone(), this.renderTargetDepth.texture.name = "BokehPass.depth", this.materialDepth = new Uo, this.materialDepth.depthPacking = It, this.materialDepth.blending = ae;
        var i = Ji.bokeh,
            a = Di.clone(i.uniforms);
        a.tDepth.value = this.renderTargetDepth.texture, a.focus.value = xn(n.focus) ? n.focus : 1, a.aperture.value = xn(n.aperture) ? n.aperture : 1, a.maxblur.value = xn(n.maxblur) ? n.maxblur : 1, a.depthLeakThreshold.value = xn(n.depthLeakThreshold) ? n.depthLeakThreshold : .2, a.nearClip.value = t.near, a.farClip.value = t.far, a.aspect.value = t.aspect, Object.defineProperties(this, {
            focus: {
                get: function () {
                    return this.uniforms.focus.value
                },
                set: function (e) {
                    this.uniforms.focus.value = e
                }
            },
            aperture: {
                get: function () {
                    return this.uniforms.aperture.value
                },
                set: function (e) {
                    this.uniforms.aperture.value = e
                }
            },
            maxblur: {
                get: function () {
                    return this.uniforms.maxblur.value
                },
                set: function (e) {
                    this.uniforms.maxblur.value = e
                }
            },
            depthLeakThreshold: {
                get: function () {
                    return this.uniforms.depthLeakThreshold.value
                },
                set: function (e) {
                    this.uniforms.depthLeakThreshold.value = e
                }
            }
        }), this.materialBokeh = new Oi({
            type: "Bokeh",
            defines: i.defines,
            uniforms: a,
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader
        }), this.uniforms = a, this.camera2 = new qi(-1, 1, 1, -1, 0, 1), this.scene2 = new Bn, this.quad2 = new xi(new Qi(2, 2), null), this.quad2.frustumCulled = !1, this.scene2.add(this.quad2), this.oldClearColor = new Pr, this.oldClearAlpha = 1
    }
    Object.assign(Zm.prototype, {
        setCamera: function (e) {},
        setSize: function (e, t) {},
        dispose: function () {},
        render: function (e, t, n, r, i) {
            console.error("v3d.Pass: .render() must be implemented in derived pass.")
        }
    }), Zm.FullScreenQuad = (Hm = new qi(-1, 1, 1, -1, 0, 1), Ym = new Qi(2, 2), Object.defineProperty(Qm.prototype, "material", {
        get: function () {
            return this._mesh.material
        },
        set: function (e) {
            this._mesh.material = e
        }
    }), Object.assign(Qm.prototype, {
        render: function (e) {
            e.render(this._mesh, Hm)
        },
        dispose: function () {}
    }), Qm), Km.prototype = Object.assign(Object.create(Zm.prototype), {
        constructor: Km,
        dispose: function () {
            for (var e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose();
            for (e = 0; e < this.renderTargetsVertical.length; e++) this.renderTargetsVertical[e].dispose();
            this.renderTargetBright.dispose()
        },
        setSize: function (e, t) {
            var n = Math.round(e / 2),
                r = Math.round(t / 2);
            this.renderTargetBright.setSize(n, r);
            for (var i = 0; i < this.nMips; i++) this.renderTargetsHorizontal[i].setSize(n, r), this.renderTargetsVertical[i].setSize(n, r), this.separableBlurMaterials[i].uniforms.texSize.value = new qt(n, r), n = Math.round(n / 2), r = Math.round(r / 2)
        },
        render: function (e, t, n, r, i) {
            this.oldClearColor.copy(e.getClearColor()), this.oldClearAlpha = e.getClearAlpha();
            var a = e.autoClear;
            e.autoClear = !1, e.setClearColor(this.clearColor, 0), i && e.context.disable(e.context.STENCIL_TEST), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
            for (var o = this.renderTargetBright, s = 0; s < this.nMips; s++) this.fsQuad.material = this.separableBlurMaterials[s], this.separableBlurMaterials[s].uniforms.colorTexture.value = o.texture, this.separableBlurMaterials[s].uniforms.direction.value = Km.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[s]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[s].uniforms.colorTexture.value = this.renderTargetsHorizontal[s].texture, this.separableBlurMaterials[s].uniforms.direction.value = Km.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[s]), e.clear(), this.fsQuad.render(e), o = this.renderTargetsVertical[s];
            this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, i && e.context.enable(e.context.STENCIL_TEST), this.renderToScreen ? e.setRenderTarget(null) : e.setRenderTarget(n), this.fsQuad.render(e), e.setClearColor(this.oldClearColor, this.oldClearAlpha), e.autoClear = a
        },
        getSeperableBlurMaterial: function (e) {
            return new Oi({
                type: "BloomSeparableBlur",
                defines: {
                    KERNEL_RADIUS: e,
                    SIGMA: e
                },
                uniforms: {
                    colorTexture: {
                        value: null
                    },
                    texSize: {
                        value: new qt(.5, .5)
                    },
                    direction: {
                        value: new qt(.5, .5)
                    }
                },
                vertexShader: Ki.pp_plane_vert,
                fragmentShader: Ki.pp_bloom_separable_blur_frag
            })
        },
        getCompositeMaterial: function (e) {
            return new Oi({
                type: "BloomComposite",
                defines: {
                    NUM_MIPS: e
                },
                uniforms: {
                    blurTexture1: {
                        value: null
                    },
                    blurTexture2: {
                        value: null
                    },
                    blurTexture3: {
                        value: null
                    },
                    blurTexture4: {
                        value: null
                    },
                    blurTexture5: {
                        value: null
                    },
                    dirtTexture: {
                        value: null
                    },
                    bloomStrength: {
                        value: 1
                    },
                    bloomFactors: {
                        value: null
                    },
                    bloomTintColors: {
                        value: null
                    },
                    bloomRadius: {
                        value: 0
                    }
                },
                vertexShader: Ki.pp_plane_vert,
                fragmentShader: Ki.pp_bloom_composite_frag
            })
        }
    }), Km.BlurDirectionX = new qt(1, 0), Km.BlurDirectionY = new qt(0, 1), Jm.prototype = Object.assign(Object.create(Zm.prototype), {
        constructor: Jm,
        render: function (e, t, n, r, i) {
            this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? e.setRenderTarget(null) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil)), this.fsQuad.render(e)
        },
        dispose: function () {
            this.material.dispose()
        }
    }), $m.prototype = Object.assign(Object.create(Jm.prototype), {
        constructor: $m
    }), ev.prototype = Object.assign(Object.create(Zm.prototype), {
        constructor: ev,
        render: function (e, t, n, r, i) {
            this.quad2.material = this.materialBokeh, this.scene.overrideMaterial = this.materialDepth, this.oldClearColor.copy(e.getClearColor()), this.oldClearAlpha = e.getClearAlpha();
            e.autoClear;
            e.autoClear = !1, e.setClearColor(16777215), e.setClearAlpha(1), e.setRenderTarget(this.renderTargetDepth), e.clear(), e.render(this.scene, this.camera), this.uniforms.tColor.value = n.texture, this.uniforms.nearClip.value = this.camera.near, this.uniforms.farClip.value = this.camera.far, this.uniforms.aspect.value = this.camera.aspect, this.renderToScreen ? e.setRenderTarget(null) : (e.setRenderTarget(t), e.clear()), e.render(this.scene2, this.camera2), this.scene.overrideMaterial = null, e.setClearColor(this.oldClearColor), e.setClearAlpha(this.oldClearAlpha), e.autoClear = this.oldAutoClear
        },
        setCamera: function (e) {
            this.camera = e
        },
        setSize: function (e, t) {
            this.renderTargetDepth.setSize(e, t)
        },
        dispose: function () {
            this.renderTargetDepth.dispose()
        }
    });
    var tv = {
        prepareRenderer: function (e) {
            $o.checkAndroid() && "ARM" === $o.getGPUVendor(e) && "Mali-T760" === $o.getGPUModel(e) && (e.compatSettings.saturateSpecEnvBlenderApprox = !0)
        }
    };

    function nv(e, t) {
        Zm.call(this), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1
    }

    function rv() {
        Zm.call(this), this.needsSwap = !1
    }

    function iv(e, t) {
        if (this.renderer = e, void 0 === t) {
            var n = {
                    minFilter: Je,
                    magFilter: Je,
                    format: lt,
                    stencilBuffer: !1
                },
                r = e.getDrawingBufferSize();
            (t = new en(r.width, r.height, n)).texture.name = "EffectComposer.rt1", t.texture.encoding = St
        }
        this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new Jm(Ji.copy), this._previousFrameTime = Date.now()
    }

    function av(e, t, n, r) {
        Jm.call(this, Ji.fxaa), this.material.type = "FXAA", this.width = void 0 !== n ? n : 512, this.height = void 0 !== r ? r : 256, this.needsSwap = !1
    }
    nv.prototype = Object.assign(Object.create(Zm.prototype), {
        constructor: nv,
        render: function (e, t, n, r, i) {
            var a, o, s = e.context,
                l = e.state;
            l.buffers.color.setMask(!1), l.buffers.depth.setMask(!1), l.buffers.color.setLocked(!0), l.buffers.depth.setLocked(!0), o = this.inverse ? (a = 0, 1) : (a = 1, 0), l.buffers.stencil.setTest(!0), l.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), l.buffers.stencil.setFunc(s.ALWAYS, a, 4294967295), l.buffers.stencil.setClear(o), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), l.buffers.color.setLocked(!1), l.buffers.depth.setLocked(!1), l.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), l.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP)
        },
        setCamera: function (e) {
            this.camera = e
        }
    }), rv.prototype = Object.create(Zm.prototype), Object.assign(rv.prototype, {
        render: function (e, t, n, r, i) {
            e.state.buffers.stencil.setTest(!1)
        }
    }), Object.assign(iv.prototype, {
        swapBuffers: function () {
            var e = this.readBuffer;
            this.readBuffer = this.writeBuffer, this.writeBuffer = e
        },
        addPass: function (e) {
            this.passes.push(e);
            var t = this.renderer.getDrawingBufferSize(new qt);
            e.setSize(t.width, t.height)
        },
        insertPass: function (e, t) {
            this.passes.splice(t, 0, e)
        },
        isLastEnabledPass: function (e) {
            for (var t = e + 1; t < this.passes.length; t++)
                if (this.passes[t].enabled) return !1;
            return !0
        },
        render: function (e) {
            void 0 === e && (e = .001 * (Date.now() - this._previousFrameTime)), this._previousFrameTime = Date.now();
            var t, n, r = this.renderer.getRenderTarget(),
                i = !1,
                a = this.passes.length;
            for (n = 0; n < a; n++)
                if (!1 !== (t = this.passes[n]).enabled) {
                    if (t.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n), t.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), t.needsSwap) {
                        if (i) {
                            var o = this.renderer.context;
                            o.stencilFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), o.stencilFunc(o.EQUAL, 1, 4294967295)
                        }
                        this.swapBuffers()
                    }
                    t instanceof nv ? i = !0 : t instanceof rv && (i = !1)
                } this.renderer.setRenderTarget(r)
        },
        reset: function (e) {
            if (void 0 === e) {
                var t = this.renderer.getDrawingBufferSize(new qt);
                (e = this.renderTarget1.clone()).setSize(t.width, t.height)
            }
            this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
        },
        setSize: function (e, t) {
            this.renderTarget1.setSize(e, t), this.renderTarget2.setSize(e, t);
            for (var n = 0; n < this.passes.length; n++) this.passes[n].setSize(e, t)
        },
        dispose: function () {
            this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose()
        },
        insertPassAfter: function (e, t) {
            for (var n = 0, r = 0; r < this.passes.length; r++) - 1 < t.indexOf(this.passes[r]) && (n = r + 1);
            this.insertPass(e, n)
        }
    });
    var ov = [
        [0, 0, !((av.prototype = Object.create(Jm.prototype)).setSize = function (e, t) {
            this.width = e, this.height = t, this.uniforms.resolution.value.set(1 / e, 1 / t)
        }), !1],
        [2, 0, !1, !1],
        [1, 1, !0, !0],
        [0, 1, !0, !0],
        [1, 0, !1, !1],
        [2, 1, !1, !1]
    ];

    function sv(e) {
        this.manager = void 0 !== e ? e : Lu
    }
    Object.assign(sv.prototype, {
        crossOrigin: "Anonymous",
        load: function (e, s, t, n) {
            var l = new ua,
                r = new Bu(this.manager);
            r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
            var c = 0;
            return r.load(e, function (e) {
                for (var t = 0; t < ov.length; t++) {
                    var n = ov[t],
                        r = document.createElement("canvas"),
                        i = e.width / 3,
                        a = e.height / 2;
                    r.width = i, r.height = a;
                    var o = r.getContext("2d");
                    n[2] && (o.translate(i, 0), o.scale(-1, 1)), n[3] && (o.translate(0, a), o.scale(1, -1)), o.drawImage(e, n[0] * i, n[1] * a, i, a, 0, 0, i, a), l.images[t] = r, 6 === ++c && (l.needsUpdate = !0, s && s(l))
                }
            }, void 0, n), l
        },
        setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        },
        setPath: function (e) {
            return this.path = e, this
        }
    });
    var lv, cv = void 0 !== cv ? cv : {},
        uv = {};
    for (lv in cv) cv.hasOwnProperty(lv) && (uv[lv] = cv[lv]);
    var dv, hv, pv = !1,
        fv = !1,
        mv = !1;
    pv = "object" == typeof window, fv = "function" == typeof importScripts, dv = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, mv = dv && !pv && !fv, hv = !pv && !mv && !fv;
    var vv, gv, _v, yv, xv = "";
    mv ? (xv = __dirname + "/", vv = function (e, t) {
        var n = $v(e);
        return n ? t ? n : n.toString() : (_v = _v || require("fs"), e = (yv = yv || require("path")).normalize(e), _v.readFileSync(e, t ? null : "utf8"))
    }, gv = function (e) {
        var t = vv(e, !0);
        return t.buffer || (t = new Uint8Array(t)), Cv(t.buffer), t
    }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), "undefined" != typeof module && (module.exports = cv), process.on("uncaughtException", function (e) {
        if (!(e instanceof
                function (e) {
                    this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e
                })) throw e
    }), process.on("unhandledRejection", Xv), cv.inspect = function () {
        return "[Emscripten Module object]"
    }) : hv ? ("undefined" != typeof read && (vv = function (e) {
        var t = $v(e);
        return t ? Kv(t) : read(e)
    }), gv = function (e) {
        var t;
        return (t = $v(e)) ? t : "function" == typeof readbuffer ? new Uint8Array(readbuffer(e)) : (Cv("object" == typeof (t = read(e, "binary"))), t)
    }, "undefined" != typeof print && ("undefined" == typeof console && (console = {}), console.log = print, console.warn = console.error = "undefined" != typeof printErr ? printErr : print)) : (pv || fv) && (fv ? xv = self.location.href : document.currentScript && (xv = document.currentScript.src), xv = 0 !== xv.indexOf("blob:") ? xv.substr(0, xv.lastIndexOf("/") + 1) : "", vv = function (t) {
        try {
            var e = new XMLHttpRequest;
            return e.open("GET", t, !1), e.send(null), e.responseText
        } catch (e) {
            var n = $v(t);
            if (n) return Kv(n);
            throw e
        }
    }, fv && (gv = function (t) {
        try {
            var e = new XMLHttpRequest;
            return e.open("GET", t, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response)
        } catch (e) {
            var n = $v(t);
            if (n) return n;
            throw e
        }
    }));
    var bv, wv = cv.print || console.log.bind(console),
        Mv = cv.printErr || console.warn.bind(console);
    for (lv in uv) uv.hasOwnProperty(lv) && (cv[lv] = uv[lv]);
    uv = null, cv.arguments && cv.arguments, cv.thisProgram && cv.thisProgram, cv.wasmBinary && (bv = cv.wasmBinary);
    var Av, Sv = {
        Memory: function (e) {
            return {
                buffer: new ArrayBuffer(65536 * e.initial),
                grow: function (e) {
                    return sg(e)
                }
            }
        },
        Table: function (e) {
            var n = new Array(e.initial);
            return n.grow = function (e) {
                1 <= n.length && Xv("Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH."), n.push(null)
            }, n.set = function (e, t) {
                n[e] = t
            }, n.get = function (e) {
                return n[e]
            }, n
        },
        Module: function (e) {
            return {}
        },
        Instance: function (e, t) {
            var n, r, i, a, o, s = "function" == typeof s ? s : function (e) {
                var t, n, r, i, a, o, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    l = "",
                    c = 0;
                for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); t = s.indexOf(e.charAt(c++)) << 2 | (i = s.indexOf(e.charAt(c++))) >> 4, n = (15 & i) << 4 | (a = s.indexOf(e.charAt(c++))) >> 2, r = (3 & a) << 6 | (o = s.indexOf(e.charAt(c++))), l += String.fromCharCode(t), 64 !== a && (l += String.fromCharCode(n)), 64 !== o && (l += String.fromCharCode(r)), c < e.length;);
                return l
            };
            return {
                exports: (n = eg, i = (r = Av).buffer, a = new Uint8Array(i), (o = function (e, t) {
                    var n, r;
                    if ("undefined" == typeof Buffer)
                        for (n = s(t), r = 0; r < n.length; r++) a[e + r] = n.charCodeAt(r);
                    else
                        for (n = Buffer.from(t, "base64"), r = 0; r < n.length; r++) a[e + r] = n[r]
                })(1024, "/Td6WFo="), o(1041, "BAQECAgIEBAQICAgQEBA"), function (e, t, n) {
                    t.memory;
                    var x = new e.Int8Array(n),
                        g = new e.Int16Array(n),
                        b = new e.Int32Array(n),
                        w = new e.Uint8Array(n),
                        _ = new e.Uint16Array(n),
                        M = new e.Uint32Array(n),
                        y = (new e.Float32Array(n), new e.Float64Array(n), e.Math.imul),
                        r = (e.Math.fround, e.Math.abs, e.Math.clz32, e.Math.min, e.Math.max, e.Math.floor, e.Math.ceil, e.Math.sqrt, t.abort),
                        a = (e.NaN, e.Infinity, t.emscripten_memcpy_big),
                        i = t.emscripten_resize_heap,
                        h = 6296128,
                        A = 0;

                    function S(e, t, n) {
                        var r, i = 0;
                        if (8192 <= n >>> 0) a(0 | e, 0 | t, 0 | n);
                        else {
                            r = e + n | 0;
                            e: if (3 & (e ^ t))
                                if (r >>> 0 < 4) n = e;
                                else if ((i = r - 4 | 0) >>> 0 < e >>> 0) n = e;
                            else
                                for (n = e; x[0 | n] = w[0 | t], x[n + 1 | 0] = w[t + 1 | 0], x[n + 2 | 0] = w[t + 2 | 0], x[n + 3 | 0] = w[t + 3 | 0], t = t + 4 | 0, (n = n + 4 | 0) >>> 0 <= i >>> 0;);
                            else {
                                t: if ((0 | n) < 1) n = e;
                                    else if (3 & e)
                                    for (n = e;;) {
                                        if (x[0 | n] = w[0 | t], t = t + 1 | 0, r >>> 0 <= (n = n + 1 | 0) >>> 0) break t;
                                        if (!(3 & n)) break
                                    } else n = e;
                                if (!((e = -4 & r) >>> 0 < 64 || (i = e + -64 | 0) >>> 0 < n >>> 0))
                                    for (; b[n >> 2] = b[t >> 2], b[n + 4 >> 2] = b[t + 4 >> 2], b[n + 8 >> 2] = b[t + 8 >> 2], b[n + 12 >> 2] = b[t + 12 >> 2], b[n + 16 >> 2] = b[t + 16 >> 2], b[n + 20 >> 2] = b[t + 20 >> 2], b[n + 24 >> 2] = b[t + 24 >> 2], b[n + 28 >> 2] = b[t + 28 >> 2], b[n + 32 >> 2] = b[t + 32 >> 2], b[n + 36 >> 2] = b[t + 36 >> 2], b[n + 40 >> 2] = b[t + 40 >> 2], b[n + 44 >> 2] = b[t + 44 >> 2], b[n + 48 >> 2] = b[t + 48 >> 2], b[n + 52 >> 2] = b[t + 52 >> 2], b[n + 56 >> 2] = b[t + 56 >> 2], b[n + 60 >> 2] = b[t + 60 >> 2], t = t - -64 | 0, (n = n - -64 | 0) >>> 0 <= i >>> 0;);
                                if (e >>> 0 <= n >>> 0) break e;
                                for (; b[n >> 2] = b[t >> 2], t = t + 4 | 0, (n = n + 4 | 0) >>> 0 < e >>> 0;);
                            }
                            if (n >>> 0 < r >>> 0)
                                for (; x[0 | n] = w[0 | t], t = t + 1 | 0, (0 | r) != (0 | (n = n + 1 | 0)););
                        }
                    }

                    function T(e, t, n) {
                        if (n ^= -1, t)
                            for (; n = b[1056 + ((w[0 | e] ^ 255 & n) << 2) >> 2] ^ n >>> 8, e = e + 1 | 0, t = t + -1 | 0;);
                        return -1 ^ n
                    }

                    function o(e) {
                        var t = 0;
                        e && (t = b[e + 1200 >> 2], b[t + 60 >> 2] && s(b[t + 24 >> 2]), s(t), s(e))
                    }

                    function p(e) {
                        var t;
                        return (0 | (e = (t = b[263312]) + (e + 3 & -4) | 0)) <= -1 ? (b[263185] = 48, -1) : e >>> 0 <= (n.byteLength / 65536 | 0) << 16 >>> 0 || i(0 | e) ? (b[263312] = e, t) : (b[263185] = 48, -1)
                    }

                    function s(e) {
                        var t = 0,
                            n = 0,
                            r = 0,
                            i = 0,
                            a = 0,
                            o = 0,
                            s = 0;
                        e: if (e) {
                            a = (r = e + -8 | 0) + (e = -8 & (n = b[e + -4 >> 2])) | 0;
                            t: if (!(1 & n)) {
                                if (!(3 & n)) break e;
                                if ((r = r - (n = b[r >> 2]) | 0) >>> 0 < M[263190]) break e;
                                if (e = e + n | 0, b[263191] == (0 | r)) {
                                    if (3 == (3 & (n = b[a + 4 >> 2]))) return b[263188] = e, b[a + 4 >> 2] = -2 & n, b[r + 4 >> 2] = 1 | e, void(b[e + r >> 2] = e)
                                } else {
                                    if (n >>> 0 <= 255) {
                                        if (i = b[r + 8 >> 2], n = n >>> 3 | 0, (0 | (t = b[r + 12 >> 2])) == (0 | i)) {
                                            b[263186] = b[263186] & v(n);
                                            break t
                                        }
                                        b[i + 12 >> 2] = t, b[t + 8 >> 2] = i;
                                        break t
                                    }
                                    if (s = b[r + 24 >> 2], (0 | r) == (0 | (n = b[r + 12 >> 2])))
                                        if ((t = b[(i = r + 20 | 0) >> 2]) || (t = b[(i = r + 16 | 0) >> 2])) {
                                            for (; o = i, (t = b[(i = (n = t) + 20 | 0) >> 2]) || (i = n + 16 | 0, t = b[n + 16 >> 2]););
                                            b[o >> 2] = 0
                                        } else n = 0;
                                    else t = b[r + 8 >> 2], b[t + 12 >> 2] = n, b[n + 8 >> 2] = t;
                                    if (!s) break t;
                                    i = b[r + 28 >> 2];
                                    n: {
                                        if (b[(t = 1053048 + (i << 2) | 0) >> 2] == (0 | r)) {
                                            if (b[t >> 2] = n) break n;
                                            b[263187] = b[263187] & v(i);
                                            break t
                                        }
                                        if (!(b[s + (b[s + 16 >> 2] == (0 | r) ? 16 : 20) >> 2] = n)) break t
                                    }
                                    if (b[n + 24 >> 2] = s, (t = b[r + 16 >> 2]) && (b[n + 16 >> 2] = t, b[t + 24 >> 2] = n), !(t = b[r + 20 >> 2])) break t;
                                    b[n + 20 >> 2] = t, b[t + 24 >> 2] = n
                                }
                            }
                            if (!(a >>> 0 <= r >>> 0) && 1 & (n = b[a + 4 >> 2])) {
                                t: {
                                    if (!(2 & n)) {
                                        if (b[263192] == (0 | a)) {
                                            if (b[263192] = r, e = b[263189] + e | 0, b[263189] = e, b[r + 4 >> 2] = 1 | e, b[263191] != (0 | r)) break e;
                                            return b[263188] = 0, void(b[263191] = 0)
                                        }
                                        if (b[263191] == (0 | a)) return b[263191] = r, e = b[263188] + e | 0, b[263188] = e, b[r + 4 >> 2] = 1 | e, void(b[e + r >> 2] = e);
                                        e = (-8 & n) + e | 0;
                                        n: if (n >>> 0 <= 255) {
                                            if (n = n >>> 3 | 0, (0 | (t = b[a + 8 >> 2])) == (0 | (i = b[a + 12 >> 2]))) {
                                                b[263186] = b[263186] & v(n);
                                                break n
                                            }
                                            b[t + 12 >> 2] = i, b[i + 8 >> 2] = t
                                        } else {
                                            if (s = b[a + 24 >> 2], (0 | a) == (0 | (n = b[a + 12 >> 2])))
                                                if ((t = b[(i = a + 20 | 0) >> 2]) || (t = b[(i = a + 16 | 0) >> 2])) {
                                                    for (; o = i, (t = b[(i = (n = t) + 20 | 0) >> 2]) || (i = n + 16 | 0, t = b[n + 16 >> 2]););
                                                    b[o >> 2] = 0
                                                } else n = 0;
                                            else t = b[a + 8 >> 2], b[t + 12 >> 2] = n, b[n + 8 >> 2] = t;
                                            if (s) {
                                                i = b[a + 28 >> 2];
                                                r: {
                                                    if (b[(t = 1053048 + (i << 2) | 0) >> 2] == (0 | a)) {
                                                        if (b[t >> 2] = n) break r;
                                                        b[263187] = b[263187] & v(i);
                                                        break n
                                                    }
                                                    if (!(b[s + (b[s + 16 >> 2] == (0 | a) ? 16 : 20) >> 2] = n)) break n
                                                }
                                                b[n + 24 >> 2] = s, (t = b[a + 16 >> 2]) && (b[n + 16 >> 2] = t, b[t + 24 >> 2] = n), (t = b[a + 20 >> 2]) && (b[n + 20 >> 2] = t, b[t + 24 >> 2] = n)
                                            }
                                        }
                                        if (b[r + 4 >> 2] = 1 | e, b[e + r >> 2] = e, b[263191] != (0 | r)) break t;
                                        return void(b[263188] = e)
                                    }
                                    b[a + 4 >> 2] = -2 & n,
                                    b[r + 4 >> 2] = 1 | e,
                                    b[e + r >> 2] = e
                                }
                                if (e >>> 0 <= 255) return n = 1052784 + ((e = e >>> 3 | 0) << 3) | 0,
                                e = (t = b[263186]) & (e = 1 << e) ? b[n + 8 >> 2] : (b[263186] = e | t, n),
                                b[n + 8 >> 2] = r,
                                b[e + 12 >> 2] = r,
                                b[r + 12 >> 2] = n,
                                void(b[r + 8 >> 2] = e);b[r + 16 >> 2] = 0,
                                t = b[r + 20 >> 2] = 0,
                                (i = e >>> 8 | 0) && (t = 31, 16777215 < e >>> 0 || (t = i, t <<= i = i + 1048320 >>> 16 & 8, t = 28 + ((t = ((t <<= s = t + 520192 >>> 16 & 4) << (o = t + 245760 >>> 16 & 2) >>> 15 | 0) - (o | i | s) | 0) << 1 | e >>> t + 21 & 1) | 0)),
                                o = 1053048 + ((b[(n = r) + 28 >> 2] = t) << 2) | 0;t: {
                                    n: {
                                        if ((i = b[263187]) & (n = 1 << t)) {
                                            for (i = e << (31 == (0 | t) ? 0 : 25 - (t >>> 1 | 0) | 0), n = b[o >> 2];;) {
                                                if ((-8 & b[(t = n) + 4 >> 2]) == (0 | e)) break n;
                                                if (n = i >>> 29 | 0, i <<= 1, !(n = b[16 + (o = t + (4 & n) | 0) >> 2])) break
                                            }
                                            b[o + 16 >> 2] = r, b[r + 24 >> 2] = t
                                        } else b[263187] = n | i,
                                        b[o >> 2] = r,
                                        b[r + 24 >> 2] = o;b[r + 12 >> 2] = r,
                                        b[r + 8 >> 2] = r;
                                        break t
                                    }
                                    e = b[t + 8 >> 2],
                                    b[e + 12 >> 2] = r,
                                    b[t + 8 >> 2] = r,
                                    b[r + 24 >> 2] = 0,
                                    b[r + 12 >> 2] = t,
                                    b[r + 8 >> 2] = e
                                }
                                if (e = b[263194] + -1 | 0, !(b[263194] = e)) {
                                    for (r = 1053200; r = (e = b[r >> 2]) + 8 | 0, e;);
                                    b[263194] = -1
                                }
                            }
                        }
                    }

                    function E(e, t) {
                        var n = 0;
                        if (t && (x[(n = e + t | 0) - 1 | 0] = 0, !(t >>> (x[0 | e] = 0) < 3 || (x[n + -2 | 0] = 0, x[e + 1 | 0] = 0, x[n + -3 | 0] = 0, t >>> (x[e + 2 | 0] = 0) < 7 || (x[n + -4 | 0] = 0, t >>> (x[e + 3 | 0] = 0) < 9 || (b[(e = (n = 0 - e & 3) + e | 0) >> 2] = 0, (n = t - n & -4) >>> (b[(t = n + e | 0) - 4 >> 2] = 0) < 9 || (b[e + 8 >> 2] = 0, b[e + 4 >> 2] = 0, b[t + -8 >> 2] = 0, n >>> (b[t + -12 >> 2] = 0) < 25 || (b[e + 24 >> 2] = 0, b[e + 20 >> 2] = 0, b[e + 16 >> 2] = 0, b[e + 12 >> 2] = 0, b[t + -16 >> 2] = 0, b[t + -20 >> 2] = 0, b[t + -24 >> 2] = 0, b[t + -28 >> 2] = 0, (t = (t = n) - (n = 4 & e | 24) | 0) >>> 0 < 32))))))))
                            for (e = e + n | 0; b[e + 24 >> 2] = 0, b[e + 28 >> 2] = 0, b[e + 16 >> 2] = 0, b[e + 20 >> 2] = 0, b[e + 8 >> 2] = 0, b[e + 12 >> 2] = 0, b[e >> 2] = 0, e = e + 32 | (b[e + 4 >> 2] = 0), 31 < (t = t + -32 | 0) >>> 0;);
                    }

                    function l(e) {
                        var t, n = 0,
                            r = 0,
                            i = 0,
                            a = 0,
                            o = 0,
                            s = 0,
                            l = 0,
                            c = 0,
                            u = 0,
                            d = 0;
                        h = t = h - 16 | 0;
                        e: {
                            t: {
                                n: {
                                    r: {
                                        i: {
                                            a: {
                                                o: {
                                                    s: {
                                                        l: {
                                                            c: {
                                                                u: {
                                                                    if (e >>> 0 <= 244) {
                                                                        if (3 & (n = (o = b[263186]) >>> (e = (s = e >>> 0 < 11 ? 16 : e + 11 & -8) >>> 3 | 0) | 0)) {
                                                                            e = (n = b[1052792 + (a = (r = e + (1 & (-1 ^ n)) | 0) << 3) >> 2]) + 8 | 0, (0 | (i = b[n + 8 >> 2])) != (0 | (a = a + 1052784 | 0)) ? (b[i + 12 >> 2] = a, b[a + 8 >> 2] = i) : b[263186] = v(r) & o, r <<= 3, b[n + 4 >> 2] = 3 | r, b[4 + (n = n + r | 0) >> 2] = 1 | b[n + 4 >> 2];
                                                                            break e
                                                                        }
                                                                        if (s >>> 0 <= (c = b[263188]) >>> 0) break u;
                                                                        if (n) {
                                                                            r = n = (e = (0 - (e = (0 - (r = 2 << e) | r) & n << e) & e) - 1 | 0) >>> 12 & 16, r |= n = (e = e >>> n | 0) >>> 5 & 8, r |= n = (e = e >>> n | 0) >>> 2 & 4, n = b[1052792 + (i = (r = ((r |= n = (e = e >>> n | 0) >>> 1 & 2) | (n = (e = e >>> n | 0) >>> 1 & 1)) + (e >>> n | 0) | 0) << 3) >> 2], (0 | (e = b[n + 8 >> 2])) != (0 | (i = i + 1052784 | 0)) ? (b[e + 12 >> 2] = i, b[i + 8 >> 2] = e) : (o = v(r) & o, b[263186] = o), e = n + 8 | 0, b[n + 4 >> 2] = 3 | s, a = (r <<= 3) - s | 0, b[4 + (l = n + s | 0) >> 2] = 1 | a, b[n + r >> 2] = a, c && (n = 1052784 + ((r = c >>> 3 | 0) << 3) | 0, i = b[263191], r = (r = 1 << r) & o ? b[n + 8 >> 2] : (b[263186] = r | o, n), b[n + 8 >> 2] = i, b[r + 12 >> 2] = i, b[i + 12 >> 2] = n, b[i + 8 >> 2] = r), b[263191] = l, b[263188] = a;
                                                                            break e
                                                                        }
                                                                        if (!(d = b[263187])) break u;
                                                                        for (r = n = (e = (d & 0 - d) - 1 | 0) >>> 12 & 16, r |= n = (e = e >>> n | 0) >>> 5 & 8, r |= n = (e = e >>> n | 0) >>> 2 & 4, n = b[1053048 + (((r |= n = (e = e >>> n | 0) >>> 1 & 2) | (n = (e = e >>> n | 0) >>> 1 & 1)) + (e >>> n | 0) << 2) >> 2], i = (-8 & b[n + 4 >> 2]) - s | 0, r = n; e = (e = b[r + 16 >> 2]) || b[r + 20 >> 2];) i = (r = (a = (-8 & b[e + 4 >> 2]) - s | 0) >>> 0 < i >>> 0) ? a : i, n = r ? e : n, r = e;
                                                                        if (u = b[n + 24 >> 2], (0 | (a = b[n + 12 >> 2])) != (0 | n)) {
                                                                            e = b[n + 8 >> 2], b[e + 12 >> 2] = a, b[a + 8 >> 2] = e;
                                                                            break t
                                                                        }
                                                                        if (!(e = b[(r = n + 20 | 0) >> 2])) {
                                                                            if (!(e = b[n + 16 >> 2])) break c;
                                                                            r = n + 16 | 0
                                                                        }
                                                                        for (; l = r, (e = b[(r = (a = e) + 20 | 0) >> 2]) || (r = a + 16 | 0, e = b[a + 16 >> 2]););
                                                                        b[l >> 2] = 0;
                                                                        break t
                                                                    }
                                                                    if (s = -1, !(4294967231 < e >>> 0) && (s = -8 & (n = e + 11 | 0), c = b[263187])) {
                                                                        r = 0 - s | 0, (n = n >>> 8 | (o = 0)) && (o = 31, 16777215 < s >>> 0 || (o = 28 + ((e = ((o = (n <<= i = n + 1048320 >>> 16 & 8) << (e = n + 520192 >>> 16 & 4)) << (n = o + 245760 >>> 16 & 2) >>> 15 | 0) - (n | e | i) | 0) << 1 | s >>> e + 21 & 1) | 0));
                                                                        d: {
                                                                            h: {
                                                                                if (i = b[1053048 + (o << 2) >> 2])
                                                                                    for (n = s << (31 == (0 | o) ? 0 : 25 - (o >>> 1 | 0) | 0), e = 0;;) {
                                                                                        if (!(r >>> 0 <= (l = (-8 & b[i + 4 >> 2]) - s | 0) >>> 0 || (a = i, r = l))) {
                                                                                            r = 0, e = i;
                                                                                            break h
                                                                                        }
                                                                                        if (l = b[i + 20 >> 2], i = b[16 + ((n >>> 29 & 4) + i | 0) >> 2], e = l ? (0 | l) == (0 | i) ? e : l : e, n <<= 0 != (0 | i), !i) break
                                                                                    } else e = 0;
                                                                                if (!(e | a)) {
                                                                                    if (!(e = (0 - (e = 2 << o) | e) & c)) break u;
                                                                                    i = n = (e = (e & 0 - e) - 1 | 0) >>> 12 & 16, i |= n = (e = e >>> n | 0) >>> 5 & 8, i |= n = (e = e >>> n | 0) >>> 2 & 4, e = b[1053048 + (((i |= n = (e = e >>> n | 0) >>> 1 & 2) | (n = (e = e >>> n | 0) >>> 1 & 1)) + (e >>> n | 0) << 2) >> 2]
                                                                                }
                                                                                if (!e) break d
                                                                            }
                                                                            for (; r = (n = (i = (-8 & b[e + 4 >> 2]) - s | 0) >>> 0 < r >>> 0) ? i : r, a = n ? e : a, e = (n = b[e + 16 >> 2]) || b[e + 20 >> 2];);
                                                                        }
                                                                        if (!(!a | r >>> 0 >= b[263188] - s >>> 0)) {
                                                                            if (l = b[a + 24 >> 2], (0 | a) != (0 | (n = b[a + 12 >> 2]))) {
                                                                                e = b[a + 8 >> 2], b[e + 12 >> 2] = n, b[n + 8 >> 2] = e;
                                                                                break n
                                                                            }
                                                                            if (!(e = b[(i = a + 20 | 0) >> 2])) {
                                                                                if (!(e = b[a + 16 >> 2])) break l;
                                                                                i = a + 16 | 0
                                                                            }
                                                                            for (; o = i, (e = b[(i = (n = e) + 20 | 0) >> 2]) || (i = n + 16 | 0, e = b[n + 16 >> 2]););
                                                                            b[o >> 2] = 0;
                                                                            break n
                                                                        }
                                                                    }
                                                                }
                                                                if (s >>> 0 <= (n = b[263188]) >>> 0) {
                                                                    e = b[263191], 16 <= (r = n - s | 0) >>> 0 ? (b[263188] = r, i = e + s | 0, b[263191] = i, b[i + 4 >> 2] = 1 | r, b[e + n >> 2] = r, b[e + 4 >> 2] = 3 | s) : (b[263191] = 0, b[263188] = 0, b[e + 4 >> 2] = 3 | n, b[4 + (n = e + n | 0) >> 2] = 1 | b[n + 4 >> 2]), e = e + 8 | 0;
                                                                    break e
                                                                }
                                                                if (s >>> 0 < (i = b[263189]) >>> 0) {
                                                                    n = i - s | 0, b[263189] = n, r = (e = b[263192]) + s | 0, b[263192] = r, b[r + 4 >> 2] = 1 | n, b[e + 4 >> 2] = 3 | s, e = e + 8 | 0;
                                                                    break e
                                                                }
                                                                if ((r = (o = (r = a = s + 47 | (e = 0)) + (n = b[263304] ? b[263306] : (b[263307] = -1, b[263308] = -1, b[263305] = 4096, b[263306] = 4096, b[263304] = 12 + t & -16 ^ 1431655768, b[263309] = 0, b[263297] = 0, 4096)) | 0) & (l = 0 - n | 0)) >>> 0 <= s >>> 0) break e;
                                                                if ((n = b[263296]) && (u = (c = b[263294]) + r | 0) >>> 0 <= c >>> 0 | n >>> 0 < u >>> 0) break e;
                                                                if (4 & w[1053188]) break a;u: {
                                                                    d: {
                                                                        if (n = b[263192])
                                                                            for (e = 1053192;;) {
                                                                                if ((c = b[e >> 2]) + b[e + 4 >> 2] >>> 0 > n >>> 0 && c >>> 0 <= n >>> 0) break d;
                                                                                if (!(e = b[e + 8 >> 2])) break
                                                                            }
                                                                        if (-1 == (0 | (n = p(0)))) break o;
                                                                        if (o = r, (i = (e = b[263305]) + -1 | 0) & n && (o = (r - n | 0) + (n + i & 0 - e) | 0), o >>> 0 <= s >>> 0 | 2147483646 < o >>> 0) break o;
                                                                        if ((e = b[263296]) && (l = (i = b[263294]) + o | 0) >>> 0 <= i >>> 0 | e >>> 0 < l >>> 0) break o;
                                                                        if ((0 | n) != (0 | (e = p(o)))) break u;
                                                                        break i
                                                                    }
                                                                    if (2147483646 < (o = l & o - i) >>> 0) break o;
                                                                    if ((0 | (n = p(o))) == (b[e >> 2] + b[e + 4 >> 2] | 0)) break s;e = n
                                                                }
                                                                if (!(s + 48 >>> 0 <= o >>> 0 | 2147483646 < o >>> 0 | -1 == (0 | (n = e)))) {
                                                                    if (2147483646 < (e = (e = b[263306]) + (a - o | 0) & 0 - e) >>> 0) break i;
                                                                    if (-1 != (0 | p(e))) {
                                                                        o = e + o | 0;
                                                                        break i
                                                                    }
                                                                    p(0 - o | 0);
                                                                    break o
                                                                }
                                                                if (-1 != (0 | n)) break i;
                                                                break o
                                                            }
                                                            a = 0;
                                                            break t
                                                        }
                                                        n = 0;
                                                        break n
                                                    }
                                                    if (-1 != (0 | n)) break i
                                                }
                                                b[263297] = 4 | b[263297]
                                            }
                                            if (2147483646 < r >>> 0) break r;
                                            if (n = p(r), (e = p(0)) >>> 0 <= n >>> 0 | -1 == (0 | n) | -1 == (0 | e)) break r;
                                            if ((o = e - n | 0) >>> 0 <= s + 40 >>> 0) break r
                                        }
                                        e = b[263294] + o | 0,
                                        (b[263294] = e) >>> 0 > M[263295] && (b[263295] = e);i: {
                                            a: {
                                                o: {
                                                    if (r = b[263192]) {
                                                        for (e = 1053192;;) {
                                                            if (((i = b[e >> 2]) + (a = b[e + 4 >> 2]) | 0) == (0 | n)) break o;
                                                            if (!(e = b[e + 8 >> 2])) break
                                                        }
                                                        break a
                                                    }
                                                    for ((e = b[263190]) >>> 0 <= n >>> 0 && e || (b[263190] = n), e = 0, b[263299] = o, b[263298] = n, b[263194] = -1, b[263195] = b[263304], b[263301] = 0; i = 1052784 + (r = e << 3) | 0, b[r + 1052792 >> 2] = i, b[r + 1052796 >> 2] = i, 32 != (0 | (e = e + 1 | 0)););i = (e = o + -40 | 0) - (r = n + 8 & 7 ? -8 - n & 7 : 0) | 0,
                                                    b[263189] = i,
                                                    r = n + r | 0,
                                                    b[263192] = r,
                                                    b[r + 4 >> 2] = 1 | i,
                                                    b[4 + (e + n | 0) >> 2] = 40,
                                                    b[263193] = b[263308];
                                                    break i
                                                }
                                                if (!(8 & w[e + 12 | 0] | n >>> 0 <= r >>> 0 | r >>> 0 < i >>> 0)) {
                                                    b[e + 4 >> 2] = a + o, n = (e = r + 8 & 7 ? -8 - r & 7 : 0) + r | 0, b[263192] = n, e = (i = b[263189] + o | 0) - e | 0, b[263189] = e, b[n + 4 >> 2] = 1 | e, b[4 + (r + i | 0) >> 2] = 40, b[263193] = b[263308];
                                                    break i
                                                }
                                            }
                                            n >>> 0 < (a = b[263190]) >>> 0 && (b[263190] = n, a = 0),
                                            i = n + o | 0,
                                            e = 1053192;a: {
                                                o: {
                                                    s: {
                                                        l: {
                                                            c: {
                                                                u: {
                                                                    for (;
                                                                        (0 | i) != b[e >> 2];)
                                                                        if (!(e = b[e + 8 >> 2])) break u;
                                                                    if (!(8 & w[e + 12 | 0])) break c
                                                                }
                                                                for (e = 1053192;;) {
                                                                    if ((i = b[e >> 2]) >>> 0 <= r >>> 0 && r >>> 0 < (a = i + b[e + 4 >> 2] | 0) >>> 0) break l;
                                                                    e = b[e + 8 >> 2]
                                                                }
                                                            }
                                                            if (b[e >> 2] = n, b[e + 4 >> 2] = b[e + 4 >> 2] + o, b[4 + (u = (n + 8 & 7 ? -8 - n & 7 : 0) + n | 0) >> 2] = 3 | s, e = ((n = i + (i + 8 & 7 ? -8 - i & 7 : 0) | 0) - u | 0) - s | 0, l = s + u | 0, (0 | n) == (0 | r)) {
                                                                b[263192] = l, e = b[263189] + e | 0, b[263189] = e, b[l + 4 >> 2] = 1 | e;
                                                                break o
                                                            }
                                                            if (b[263191] == (0 | n)) {
                                                                b[263191] = l, e = b[263188] + e | 0, b[263188] = e, b[l + 4 >> 2] = 1 | e, b[e + l >> 2] = e;
                                                                break o
                                                            }
                                                            if (1 == (3 & (r = b[n + 4 >> 2]))) {
                                                                d = -8 & r;
                                                                c: if (r >>> 0 <= 255) {
                                                                    if (a = r >>> 3 | 0, r = b[n + 8 >> 2], (0 | (i = b[n + 12 >> 2])) == (0 | r)) {
                                                                        b[263186] = b[263186] & v(a);
                                                                        break c
                                                                    }
                                                                    b[r + 12 >> 2] = i, b[i + 8 >> 2] = r
                                                                } else {
                                                                    if (c = b[n + 24 >> 2], (0 | (o = b[n + 12 >> 2])) == (0 | n))
                                                                        if ((s = b[(i = n + 20 | 0) >> 2]) || (s = b[(i = n + 16 | 0) >> 2])) {
                                                                            for (; r = i, (s = b[(i = (o = s) + 20 | 0) >> 2]) || (i = o + 16 | 0, s = b[o + 16 >> 2]););
                                                                            b[r >> 2] = 0
                                                                        } else o = 0;
                                                                    else r = b[n + 8 >> 2], b[r + 12 >> 2] = o, b[o + 8 >> 2] = r;
                                                                    if (c) {
                                                                        r = b[n + 28 >> 2];
                                                                        u: {
                                                                            if (b[(i = 1053048 + (r << 2) | 0) >> 2] == (0 | n)) {
                                                                                if (b[i >> 2] = o) break u;
                                                                                b[263187] = b[263187] & v(r);
                                                                                break c
                                                                            }
                                                                            if (!(b[c + (b[c + 16 >> 2] == (0 | n) ? 16 : 20) >> 2] = o)) break c
                                                                        }
                                                                        b[o + 24 >> 2] = c, (r = b[n + 16 >> 2]) && (b[o + 16 >> 2] = r, b[r + 24 >> 2] = o), (r = b[n + 20 >> 2]) && (b[o + 20 >> 2] = r, b[r + 24 >> 2] = o)
                                                                    }
                                                                } n = n + d | 0, e = e + d | 0
                                                            }
                                                            if (b[n + 4 >> 2] = -2 & b[n + 4 >> 2], b[l + 4 >> 2] = 1 | e, (b[e + l >> 2] = e) >>> 0 <= 255) {
                                                                e = 1052784 + ((n = e >>> 3 | 0) << 3) | 0, n = (r = b[263186]) & (n = 1 << n) ? b[e + 8 >> 2] : (b[263186] = n | r, e), b[e + 8 >> 2] = l, b[n + 12 >> 2] = l, b[l + 12 >> 2] = e, b[l + 8 >> 2] = n;
                                                                break o
                                                            }
                                                            if ((i = e >>> 8 | (n = 0)) && (n = 31, 16777215 < e >>> 0 || (n = 28 + ((n = ((s = (i <<= a = i + 1048320 >>> 16 & 8) << (n = i + 520192 >>> 16 & 4)) << (i = s + 245760 >>> 16 & 2) >>> 15 | 0) - (i | n | a) | 0) << 1 | e >>> n + 21 & 1) | 0)), b[(r = l) + 28 >> 2] = n, b[l + 16 >> 2] = 0, r = 1053048 + (n << 2) | (b[l + 20 >> 2] = 0), (i = b[263187]) & (a = 1 << n)) {
                                                                for (i = e << (31 == (0 | n) ? 0 : 25 - (n >>> 1 | 0) | 0), n = b[r >> 2];;) {
                                                                    if ((-8 & b[(r = n) + 4 >> 2]) == (0 | e)) break s;
                                                                    if (n = i >>> 29 | 0, i <<= 1, !(n = b[16 + (a = (4 & n) + r | 0) >> 2])) break
                                                                }
                                                                b[a + 16 >> 2] = l
                                                            } else b[263187] = i | a,
                                                            b[r >> 2] = l;b[l + 24 >> 2] = r,
                                                            b[l + 12 >> 2] = l,
                                                            b[l + 8 >> 2] = l;
                                                            break o
                                                        }
                                                        for (l = (e = o + -40 | 0) - (i = n + 8 & 7 ? -8 - n & 7 : 0) | 0, b[263189] = l, i = n + i | 0, b[263192] = i, b[i + 4 >> 2] = 1 | l, b[4 + (e + n | 0) >> 2] = 40, b[263193] = b[263308], b[(i = (e = (a + (a + -39 & 7 ? 39 - a & 7 : 0) | 0) - 47 | 0) >>> 0 < r + 16 >>> 0 ? r : e) + 4 >> 2] = 27, e = b[263301], b[i + 16 >> 2] = b[263300], b[i + 20 >> 2] = e, e = b[263299], b[i + 8 >> 2] = b[263298], b[i + 12 >> 2] = e, b[263300] = i + 8, b[263299] = o, b[263298] = n, e = i + 24 | (b[263301] = 0); b[e + 4 >> 2] = 7, n = e + 8 | 0, e = e + 4 | 0, n >>> 0 < a >>> 0;);
                                                        if ((0 | r) == (0 | i)) break i;
                                                        if (b[i + 4 >> 2] = -2 & b[i + 4 >> 2], a = i - r | 0, b[r + 4 >> 2] = 1 | a, (b[i >> 2] = a) >>> 0 <= 255) {
                                                            e = 1052784 + ((n = a >>> 3 | 0) << 3) | 0, n = (i = b[263186]) & (n = 1 << n) ? b[e + 8 >> 2] : (b[263186] = n | i, e), b[e + 8 >> 2] = r, b[n + 12 >> 2] = r, b[r + 12 >> 2] = e, b[r + 8 >> 2] = n;
                                                            break i
                                                        }
                                                        if (b[r + 16 >> 2] = 0, e = b[r + 20 >> 2] = 0, (i = a >>> 8 | 0) && (e = 31, 16777215 < a >>> 0 || (e = 28 + ((e = ((l = (i <<= o = i + 1048320 >>> 16 & 8) << (e = i + 520192 >>> 16 & 4)) << (i = l + 245760 >>> 16 & 2) >>> 15 | 0) - (i | e | o) | 0) << 1 | a >>> e + 21 & 1) | 0)), n = 1053048 + ((b[(n = r) + 28 >> 2] = e) << 2) | 0, (i = b[263187]) & (o = 1 << e)) {
                                                            for (e = a << (31 == (0 | e) ? 0 : 25 - (e >>> 1 | 0) | 0), n = b[n >> 2];;) {
                                                                if ((0 | a) == (-8 & b[(i = n) + 4 >> 2])) break a;
                                                                if (n = e >>> 29 | 0, e <<= 1, !(n = b[16 + (o = i + (4 & n) | 0) >> 2])) break
                                                            }
                                                            b[o + 16 >> 2] = r, b[r + 24 >> 2] = i
                                                        } else b[263187] = i | o,
                                                        b[n >> 2] = r,
                                                        b[r + 24 >> 2] = n;b[r + 12 >> 2] = r,
                                                        b[r + 8 >> 2] = r;
                                                        break i
                                                    }
                                                    e = b[r + 8 >> 2],
                                                    b[e + 12 >> 2] = l,
                                                    b[r + 8 >> 2] = l,
                                                    b[l + 24 >> 2] = 0,
                                                    b[l + 12 >> 2] = r,
                                                    b[l + 8 >> 2] = e
                                                }
                                                e = u + 8 | 0;
                                                break e
                                            }
                                            e = b[i + 8 >> 2],
                                            b[e + 12 >> 2] = r,
                                            b[i + 8 >> 2] = r,
                                            b[r + 24 >> 2] = 0,
                                            b[r + 12 >> 2] = i,
                                            b[r + 8 >> 2] = e
                                        }
                                        if (!((e = b[263189]) >>> 0 <= s >>> 0)) {
                                            n = e - s | 0, b[263189] = n, r = (e = b[263192]) + s | 0, b[263192] = r, b[r + 4 >> 2] = 1 | n, b[e + 4 >> 2] = 3 | s, e = e + 8 | 0;
                                            break e
                                        }
                                    }
                                    b[263185] = 48,
                                    e = 0;
                                    break e
                                }
                                n: if (l) {
                                    e = b[a + 28 >> 2];
                                    r: {
                                        if (b[(i = 1053048 + (e << 2) | 0) >> 2] == (0 | a)) {
                                            if (b[i >> 2] = n) break r;
                                            c = v(e) & c, b[263187] = c;
                                            break n
                                        }
                                        if (!(b[l + (b[l + 16 >> 2] == (0 | a) ? 16 : 20) >> 2] = n)) break n
                                    }
                                    b[n + 24 >> 2] = l, (e = b[a + 16 >> 2]) && (b[n + 16 >> 2] = e, b[e + 24 >> 2] = n), (e = b[a + 20 >> 2]) && (b[n + 20 >> 2] = e, b[e + 24 >> 2] = n)
                                }n: if (r >>> 0 <= 15) e = r + s | 0, b[a + 4 >> 2] = 3 | e, b[4 + (e = e + a | 0) >> 2] = 1 | b[e + 4 >> 2];
                                    else if (b[a + 4 >> 2] = 3 | s, b[4 + (i = a + s | 0) >> 2] = 1 | r, (b[r + i >> 2] = r) >>> 0 <= 255) e = 1052784 + ((n = r >>> 3 | 0) << 3) | 0,
                                n = (r = b[263186]) & (n = 1 << n) ? b[e + 8 >> 2] : (b[263186] = n | r, e),
                                b[e + 8 >> 2] = i,
                                b[n + 12 >> 2] = i,
                                b[i + 12 >> 2] = e,
                                b[i + 8 >> 2] = n;
                                else {
                                    (s = r >>> 8 | (e = 0)) && (e = 31, 16777215 < r >>> 0 || (e = 28 + ((e = ((l = (s <<= o = s + 1048320 >>> 16 & 8) << (e = s + 520192 >>> 16 & 4)) << (s = l + 245760 >>> 16 & 2) >>> 15 | 0) - (s | e | o) | 0) << 1 | r >>> e + 21 & 1) | 0)), b[(n = i) + 28 >> 2] = e, b[i + 16 >> 2] = 0, n = 1053048 + (e << 2) | (b[i + 20 >> 2] = 0);
                                    r: {
                                        if ((s = 1 << e) & c) {
                                            for (e = r << (31 == (0 | e) ? 0 : 25 - (e >>> 1 | 0) | 0), s = b[n >> 2];;) {
                                                if ((-8 & b[(n = s) + 4 >> 2]) == (0 | r)) break r;
                                                if (s = e >>> 29 | 0, e <<= 1, !(s = b[16 + (o = (4 & s) + n | 0) >> 2])) break
                                            }
                                            b[o + 16 >> 2] = i
                                        } else b[263187] = s | c,
                                        b[n >> 2] = i;b[i + 24 >> 2] = n,
                                        b[i + 12 >> 2] = i,
                                        b[i + 8 >> 2] = i;
                                        break n
                                    }
                                    e = b[n + 8 >> 2], b[e + 12 >> 2] = i, b[n + 8 >> 2] = i, b[i + 24 >> 2] = 0, b[i + 12 >> 2] = n, b[i + 8 >> 2] = e
                                }
                                e = a + 8 | 0;
                                break e
                            }
                            t: if (u) {
                                e = b[n + 28 >> 2];
                                n: {
                                    if (b[(r = 1053048 + (e << 2) | 0) >> 2] == (0 | n)) {
                                        if (b[r >> 2] = a) break n;
                                        b[263187] = v(e) & d;
                                        break t
                                    }
                                    if (!(b[u + (b[u + 16 >> 2] == (0 | n) ? 16 : 20) >> 2] = a)) break t
                                }
                                b[a + 24 >> 2] = u, (e = b[n + 16 >> 2]) && (b[a + 16 >> 2] = e, b[e + 24 >> 2] = a), (e = b[n + 20 >> 2]) && (b[a + 20 >> 2] = e, b[e + 24 >> 2] = a)
                            }i >>> 0 <= 15 ? (e = i + s | 0, b[n + 4 >> 2] = 3 | e, b[4 + (e = e + n | 0) >> 2] = 1 | b[e + 4 >> 2]) : (b[n + 4 >> 2] = 3 | s, b[4 + (s = n + s | 0) >> 2] = 1 | i, b[i + s >> 2] = i, c && (e = 1052784 + ((r = c >>> 3 | 0) << 3) | 0, a = b[263191], r = (r = 1 << r) & o ? b[e + 8 >> 2] : (b[263186] = r | o, e), b[e + 8 >> 2] = a, b[r + 12 >> 2] = a, b[a + 12 >> 2] = e, b[a + 8 >> 2] = r), b[263191] = s, b[263188] = i),
                            e = n + 8 | 0
                        }
                        return h = 16 + t | 0, e
                    }

                    function f(e) {
                        var t = 0,
                            n = 0,
                            r = 0,
                            i = 0,
                            a = 0,
                            o = 0,
                            s = 0,
                            l = 0,
                            c = 0,
                            u = 0,
                            d = 0,
                            h = 0,
                            p = 0,
                            f = 0,
                            m = 0,
                            v = 0;
                        if (!((n = b[e + 40 >> 2]) >>> 0 <= (c = b[e + 32 >> 2]) >>> 0) && (t = b[e + 104 >> 2]) && (a = b[e + 84 >> 2], !(M[e + 36 >> 2] <= a >>> 0 | M[e + 48 >> 2] <= a >>> 0))) {
                            if (o = (n = n - c | 0) >>> 0 < t >>> 0 ? n : t, b[e + 104 >> 2] = t - o, t = (-1 ^ a) + c | 0, t = c >>> 0 <= a >>> 0 ? b[e + 44 >> 2] + t | 0 : t, a = b[e + 24 >> 2], n = w[t + a | 0], b[e + 32 >> 2] = c + 1, x[a + c | 0] = n, r = o + -1 | 0)
                                for (; t = (0 | (n = t + 1 | 0)) == b[e + 44 >> 2] ? 0 : n, o = b[e + 24 >> 2], a = w[t + o | 0], n = b[e + 32 >> 2], b[e + 32 >> 2] = n + 1, x[n + o | 0] = a, r = r + -1 | 0;);
                            c = b[e + 32 >> 2], M[e + 36 >> 2] >= c >>> 0 || (b[e + 36 >> 2] = c)
                        }
                        e: {
                            t: if (!(c >>> 0 >= M[e + 40 >> 2]))
                                for (p = e + 1756 | 0, f = e + 2784 | 0, m = e + 84 | 0;;) {
                                    if ((a = b[e + 16 >> 2]) >>> 0 > M[e + 20 >> 2]) break t;
                                    o = u = (((d = b[e + 100 >> 2]) << 5) + e | 0) + ((s = b[e + 116 >> 2] & c) << 1) | 0, 16777216 <= (i = b[e >> 2]) >>> 0 ? r = b[e + 4 >> 2] : (i <<= 8, b[e >> 2] = i, n = a + 1 | 0, b[e + 16 >> 2] = n, r = w[b[e + 12 >> 2] + a | 0] | b[e + 4 >> 2] << 8, b[e + 4 >> 2] = r, a = n), n = _[o + 120 >> 1];
                                    n: if (r >>> 0 < (t = y(n, i >>> 11 | 0)) >>> 0) {
                                        b[e >> 2] = t, g[o + 120 >> 1] = n + (2048 - n >>> 5 | 0), i = c + -1 | 0, i = c ? i : b[e + 44 >> 2] + i | 0, s = b[e + 108 >> 2], n = (b[e + 112 >> 2] & c) << s, u = 0, (o = b[e + 36 >> 2]) && (u = w[b[e + 24 >> 2] + i | 0]), h = n + (u >>> 8 - s | 0) | 0, i = 1;
                                        r: {
                                            if (d >>> 0 <= 6)
                                                for (;;)
                                                    if (o = 3812 + ((i <<= 1) + (y(h, 1536) + e | 0) | 0) | 0, 16777215 < t >>> 0 ? n = t : (n = t << 8, b[e >> 2] = n, t = a + 1 | 0, b[e + 16 >> 2] = t, r = w[b[e + 12 >> 2] + a | 0] | r << 8, b[e + 4 >> 2] = r, a = t), s = _[o >> 1], (t = y(s, n >>> 11 | 0)) >>> 0 <= r >>> 0 ? (r = r - t | 0, b[e + 4 >> 2] = r, t = n - t | 0, b[e >> 2] = t, g[o >> 1] = s - (s >>> 5 | 0), i |= 1) : (b[e >> 2] = t, g[o >> 1] = s + (2048 - s >>> 5 | 0)), !(i >>> 0 < 256)) break r;
                                            for (i = (-1 ^ (n = b[e + 84 >> 2])) + c | 0, i = c >>> 0 <= n >>> 0 ? b[e + 44 >> 2] + i | 0 : i, o = o ? w[b[e + 24 >> 2] + i | 0] : 0, i = 1, l = 256; d = l & (o <<= 1), s = 3812 + ((y(h, 1536) + e | 0) + ((d + l | 0) + i << 1) | 0) | 0, 16777215 < t >>> 0 ? u = t : (u = t << 8, b[e >> 2] = u, n = a + 1 | 0, b[e + 16 >> 2] = n, r = w[b[e + 12 >> 2] + a | 0] | r << 8, b[e + 4 >> 2] = r, a = n), s = _[(v = n = s) >> 1], n = (t = y(s, u >>> 11 | 0)) >>> 0 <= r >>> 0 ? (r = r - t | 0, b[e + 4 >> 2] = r, t = u - t | 0, b[e >> 2] = t, u = 1, s - (s >>> 5 | (l = 0)) | 0) : (b[e >> 2] = t, s + (2048 - s >>> 5 | (u = 0)) | 0), g[v >> 1] = n, l ^= d, (i = i << 1 | u) >>> 0 < 256;);
                                        }
                                        if (b[e + 32 >> 2] = c + 1, x[b[e + 24 >> 2] + c | 0] = i, c = b[e + 32 >> 2], M[e + 36 >> 2] < c >>> 0 && (b[e + 36 >> 2] = c), (n = b[e + 100 >> 2]) >>> 0 <= 3) {
                                            b[e + 100 >> 2] = 0;
                                            break n
                                        }
                                        if (n >>> 0 <= 9) {
                                            b[e + 100 >> 2] = n + -3;
                                            break n
                                        }
                                        b[e + 100 >> 2] = n + -6
                                    } else {
                                        r = r - t | 0, b[e + 4 >> 2] = r, t = i - t | 0, b[e >> 2] = t, g[o + 120 >> 1] = n - (n >>> 5 | 0), o = h = (d << 1) + e | 0, 16777215 < t >>> 0 ? n = a : (t <<= 8, b[e >> 2] = t, n = a + 1 | 0, b[e + 16 >> 2] = n, r = w[b[e + 12 >> 2] + a | 0] | r << 8, b[e + 4 >> 2] = r), d = _[o + 504 >> 1];
                                        r: if ((a = y(d, t >>> 11 | 0)) >>> 0 <= r >>> 0) {
                                            r = r - a | 0, b[e + 4 >> 2] = r, t = t - a | 0, b[e >> 2] = t, g[o + 504 >> 1] = d - (d >>> 5 | 0), 16777215 < t >>> 0 ? o = n : (t <<= 8, b[e >> 2] = t, o = n + 1 | 0, b[e + 16 >> 2] = o, r = w[b[e + 12 >> 2] + n | 0] | r << 8, b[e + 4 >> 2] = r), n = _[h + 528 >> 1];
                                            i: {
                                                if (r >>> 0 < (i = y(n, t >>> 11 | 0)) >>> 0) {
                                                    if (b[e >> 2] = i, g[h + 528 >> 1] = n + (2048 - n >>> 5 | 0), i >>> 0 <= 16777215 && (i <<= 8, b[e >> 2] = i, b[e + 16 >> 2] = o + 1, r = w[b[e + 12 >> 2] + o | 0] | r << 8, b[e + 4 >> 2] = r), t = _[u + 600 >> 1], (n = y(t, i >>> 11 | 0)) >>> 0 <= r >>> 0) {
                                                        b[e + 4 >> 2] = r - n, b[e >> 2] = i - n, g[u + 600 >> 1] = t - (t >>> 5 | 0);
                                                        break i
                                                    }
                                                    b[e >> 2] = n, g[u + 600 >> 1] = t + (2048 - t >>> 5 | 0), b[e + 104 >> 2] = 1, b[e + 100 >> 2] = M[e + 100 >> 2] < 7 ? 9 : 11;
                                                    break r
                                                }
                                                r = r - i | 0,
                                                b[e + 4 >> 2] = r,
                                                t = t - i | 0,
                                                b[e >> 2] = t,
                                                g[h + 528 >> 1] = n - (n >>> 5 | 0),
                                                16777215 < t >>> 0 ? n = o : (t <<= 8, b[e >> 2] = t, n = o + 1 | 0, b[e + 16 >> 2] = n, r = w[b[e + 12 >> 2] + o | 0] | r << 8, b[e + 4 >> 2] = r),
                                                o = _[h + 552 >> 1],
                                                r >>> 0 < (a = y(o, t >>> 11 | 0)) >>> 0 ? (b[e >> 2] = a, g[h + 552 >> 1] = o + (2048 - o >>> 5 | 0), t = b[e + 88 >> 2]) : (r = r - a | 0, b[e + 4 >> 2] = r, t = t - a | 0, b[e >> 2] = t, g[h + 552 >> 1] = o - (o >>> 5 | 0), t >>> 0 <= 16777215 && (t <<= 8, b[e >> 2] = t, b[e + 16 >> 2] = n + 1, r = w[b[e + 12 >> 2] + n | 0] | r << 8, b[e + 4 >> 2] = r), a = _[h + 576 >> 1], r >>> 0 < (n = y(a, t >>> 11 | 0)) >>> 0 ? (b[e >> 2] = n, g[h + 576 >> 1] = a + (2048 - a >>> 5 | 0), t = b[e + 92 >> 2]) : (b[e + 4 >> 2] = r - n, b[e >> 2] = t - n, g[h + 576 >> 1] = a - (a >>> 5 | 0), t = b[e + 96 >> 2], b[e + 96 >> 2] = b[e + 92 >> 2]), b[e + 92 >> 2] = b[e + 88 >> 2]),
                                                b[e + 88 >> 2] = b[e + 84 >> 2],
                                                b[e + 84 >> 2] = t
                                            }
                                            b[e + 100 >> 2] = M[e + 100 >> 2] < 7 ? 8 : 11, P(e, f, s)
                                        } else {
                                            for (b[e >> 2] = a, g[o + 504 >> 1] = d + (2048 - d >>> 5 | 0), b[e + 96 >> 2] = b[e + 92 >> 2], n = b[e + 88 >> 2], b[e + 88 >> 2] = b[e + 84 >> 2], b[e + 92 >> 2] = n, b[e + 100 >> 2] = M[e + 100 >> 2] < 7 ? 7 : 10, P(e, p, s), a = (n = b[e + 104 >> 2]) >>> 0 < 6 ? n + -2 | 0 : 3, t = b[e >> 2], r = 1; o = (r <<= 1) + ((a << 7) + e | 0) | 0, 16777216 <= t >>> 0 ? i = b[e + 4 >> 2] : (t <<= 8, b[e >> 2] = t, n = b[e + 16 >> 2], b[e + 16 >> 2] = n + 1, i = w[n + b[e + 12 >> 2] | 0] | b[e + 4 >> 2] << 8, b[e + 4 >> 2] = i), s = _[o + 984 >> 1], (n = y(s, t >>> 11 | 0)) >>> 0 <= i >>> 0 ? (i = i - n | 0, b[e + 4 >> 2] = i, t = t - n | 0, b[e >> 2] = t, g[o + 984 >> 1] = s - (s >>> 5 | 0), r |= 1) : (b[e >> 2] = n, g[o + 984 >> 1] = s + (2048 - s >>> 5 | 0), t = n), r >>> 0 < 64;);
                                            if ((a = r + -64 | 0) >>> 0 <= 3) b[e + 84 >> 2] = a;
                                            else if (l = 1 & a | 2, b[e + 84 >> 2] = l, n = a >>> 1 | 0, a >>> 0 <= 13)
                                                for (u = l << (o = n + -1 | 0), a = 1538 + ((((b[e + 84 >> 2] = u) << (l = 1)) + m | 0) + (0 - r << 1) | 0) | 0, r = 0; s = a + (l <<= 1) | 0, 16777215 < t >>> 0 ? n = t : (n = t << 8, b[e >> 2] = n, t = b[e + 16 >> 2], b[e + 16 >> 2] = t + 1, i = w[t + b[e + 12 >> 2] | 0] | i << 8, b[e + 4 >> 2] = i), d = _[s >> 1], i >>> 0 < (t = y(d, n >>> 11 | 0)) >>> 0 ? (b[e >> 2] = t, g[s >> 1] = d + (2048 - d >>> 5 | 0)) : (i = i - t | 0, b[e + 4 >> 2] = i, t = n - t | 0, b[e >> 2] = t, g[s >> 1] = d - (d >>> 5 | 0), u = (1 << r) + u | 0, b[e + 84 >> 2] = u, l |= 1), (r = r + 1 | 0) >>> 0 < o >>> 0;);
                                            else {
                                                for (a = n + -5 | 0; 16777215 < t >>> 0 ? r = t : (r = t << 8, b[e >> 2] = r, n = b[e + 16 >> 2], b[e + 16 >> 2] = n + 1, i = w[n + b[e + 12 >> 2] | 0] | i << 8, b[e + 4 >> 2] = i), t = r >>> 1 | 0, l = (n = (o = i - (b[e >> 2] = t) | 0) >> 31) + (l << 1 | 1) | 0, b[e + 84 >> 2] = l, i = o + (t & n) | 0, b[e + 4 >> 2] = i, a = a + -1 | 0;);
                                                l <<= 4, b[e + 84 >> 2] = l, r >>> 0 <= 33554431 && (t <<= 8, b[e >> 2] = t, n = b[e + 16 >> 2], b[e + 16 >> 2] = n + 1, i = w[n + b[e + 12 >> 2] | 0] | i << 8, b[e + 4 >> 2] = i), a = _[(n = e) + 1726 >> 1], o = 1724 + (n + (a = (t = i >>> 0 < (r = y(a, t >>> 11 | 0)) >>> 0 ? (b[e >> 2] = r, g[e + 1726 >> 1] = a + (2048 - a >>> 5 | 0), 2) : (i = i - r | 0, b[e + 4 >> 2] = i, r = t - r | 0, b[e >> 2] = r, l |= 1, b[e + 84 >> 2] = l, g[e + 1726 >> 1] = a - (a >>> 5 | 0), 3)) << 1) | 0) | 0, r >>> 0 <= 16777215 && (r <<= 8, b[e >> 2] = r, n = b[e + 16 >> 2], b[e + 16 >> 2] = n + 1, i = w[n + b[e + 12 >> 2] | 0] | i << 8, b[e + 4 >> 2] = i), n = _[o >> 1], (t = y(n, r >>> 11 | 0)) >>> 0 <= i >>> 0 ? (i = i - t | 0, b[e + 4 >> 2] = i, t = r - t | 0, b[e >> 2] = t, g[o >> 1] = n - (n >>> 5 | 0), l = l + 2 | 0, b[e + 84 >> 2] = l, a |= 1) : (b[e >> 2] = t, g[o >> 1] = n + (2048 - n >>> 5 | 0)), o = 1724 + ((a <<= 1) + e | 0) | 0, t >>> 0 <= 16777215 && (t <<= 8, b[e >> 2] = t, n = b[e + 16 >> 2], b[e + 16 >> 2] = n + 1, i = w[n + b[e + 12 >> 2] | 0] | i << 8, b[e + 4 >> 2] = i), n = _[o >> 1], (r = y(n, t >>> 11 | 0)) >>> 0 <= i >>> 0 ? (i = i - r | 0, b[e + 4 >> 2] = i, r = t - r | 0, b[e >> 2] = r, g[o >> 1] = n - (n >>> 5 | 0), l = l + 4 | 0, b[e + 84 >> 2] = l, a |= 1) : (b[e >> 2] = r, g[o >> 1] = n + (2048 - n >>> 5 | 0)), r >>> 0 <= 16777215 && (r <<= 8, b[e >> 2] = r, n = b[e + 16 >> 2], b[e + 16 >> 2] = n + 1, i = w[n + b[e + 12 >> 2] | 0] | i << 8, b[e + 4 >> 2] = i), a = _[(n = 1724 + ((a << 1) + e | 0) | 0) >> 1], (t = y(a, r >>> 11 | 0)) >>> 0 <= i >>> 0 ? (b[e + 4 >> 2] = i - t, b[e >> 2] = r - t, g[n >> 1] = a - (a >>> 5 | 0), b[e + 84 >> 2] = l + 8) : (b[e >> 2] = t, g[n >> 1] = a + (2048 - a >>> 5 | 0))
                                            }
                                        }
                                        if (t = 0, a = b[e + 84 >> 2], M[e + 36 >> 2] <= a >>> 0 | M[e + 48 >> 2] <= a >>> 0) break e;
                                        if (s = b[e + 32 >> 2], o = (n = b[e + 40 >> 2] - s | 0) >>> 0 < (t = b[e + 104 >> 2]) >>> 0 ? n : t, b[e + 104 >> 2] = t - o, t = s + (-1 ^ a) | 0, t = s >>> 0 <= a >>> 0 ? b[e + 44 >> 2] + t | 0 : t, a = b[e + 24 >> 2], n = w[t + a | 0], b[e + 32 >> 2] = s + 1, x[a + s | 0] = n, i = o + -1 | 0)
                                            for (; t = (0 | (n = t + 1 | 0)) == b[e + 44 >> 2] ? 0 : n, o = b[e + 24 >> 2], a = w[t + o | 0], n = b[e + 32 >> 2], b[e + 32 >> 2] = n + 1, x[n + o | 0] = a, i = i + -1 | 0;);
                                        c = b[e + 32 >> 2], M[e + 36 >> 2] >= c >>> 0 || (b[e + 36 >> 2] = c)
                                    }
                                    if (!(c >>> 0 < M[e + 40 >> 2])) break
                                }
                            t = 1,
                            16777215 < (n = b[e >> 2]) >>> 0 || (b[e >> 2] = n << 8, n = b[e + 16 >> 2], b[e + 16 >> 2] = n + 1, b[e + 4 >> 2] = w[n + b[e + 12 >> 2] | 0] | b[e + 4 >> 2] << 8)
                        }
                        return t
                    }

                    function C(e, t, n) {
                        var r = 0,
                            i = 0,
                            a = 0;
                        e: if (n) {
                            for (;
                                (0 | (r = w[0 | e])) == (0 | (i = w[0 | t]));)
                                if (t = t + 1 | 0, e = e + 1 | 0, !(n = n + -1 | 0)) break e;
                            a = r - i | 0
                        }
                        return a
                    }

                    function P(e, t, n) {
                        var r = 0,
                            i = 0,
                            a = 0,
                            o = 0,
                            s = 0,
                            l = 0,
                            c = 0;
                        for (16777216 <= (o = b[e >> 2]) >>> 0 ? a = b[e + 4 >> 2] : (o <<= 8, b[e >> 2] = o, i = b[e + 16 >> 2], b[e + 16 >> 2] = i + 1, a = w[i + b[e + 12 >> 2] | 0] | b[e + 4 >> 2] << 8, b[e + 4 >> 2] = a), i = _[t >> 1], i = a >>> 0 < (r = y(i, o >>> 11 | 0)) >>> 0 ? (b[e >> 2] = r, g[t >> 1] = i + (2048 - i >>> 5 | 0), c = 4 + ((n << 4) + t | 0) | 0, l = 2, 8) : (a = a - r | 0, b[e + 4 >> 2] = a, o = o - r | 0, b[e >> 2] = o, g[t >> 1] = i - (i >>> 5 | 0), o >>> 0 <= 16777215 && (o <<= 8, b[e >> 2] = o, i = b[e + 16 >> 2], b[e + 16 >> 2] = i + 1, a = w[i + b[e + 12 >> 2] | 0] | a << 8, b[e + 4 >> 2] = a), i = _[t + 2 >> 1], a >>> 0 < (r = y(i, o >>> 11 | 0)) >>> 0 ? (b[e >> 2] = r, g[t + 2 >> 1] = i + (2048 - i >>> 5 | 0), c = 260 + ((n << 4) + t | 0) | 0, l = 10, 8) : (a = a - r | 0, b[e + 4 >> 2] = a, r = o - r | 0, b[e >> 2] = r, g[t + 2 >> 1] = i - (i >>> 5 | 0), c = t + 516 | 0, l = 18, 256)), b[e + 104 >> 2] = l, t = 1; o = c + (t <<= 1) | 0, 16777215 < r >>> 0 ? n = r : (n = r << 8, b[e >> 2] = n, r = b[e + 16 >> 2], b[e + 16 >> 2] = r + 1, a = w[r + b[e + 12 >> 2] | 0] | a << 8, b[e + 4 >> 2] = a), s = _[o >> 1], (r = y(s, n >>> 11 | 0)) >>> 0 <= a >>> 0 ? (a = a - r | 0, b[e + 4 >> 2] = a, r = n - r | 0, b[e >> 2] = r, g[o >> 1] = s - (s >>> 5 | 0), t |= 1) : (b[e >> 2] = r, g[o >> 1] = (2048 - s >>> 5 | 0) + s), t >>> 0 < i >>> 0;);
                        b[e + 104 >> 2] = (t - i | 0) + l
                    }

                    function L(e) {
                        var t, n, r = 0,
                            i = 0,
                            a = 0,
                            o = 0,
                            s = 0,
                            l = 0,
                            c = 0,
                            u = 0,
                            d = 0;
                        for (t = e + 28392 | 0, n = e + 28388 | 0;;) {
                            r = b[e + 64 >> 2];
                            e: {
                                t: {
                                    n: {
                                        r: {
                                            i: {
                                                a: {
                                                    o: {
                                                        s: {
                                                            l: {
                                                                c: {
                                                                    u: {
                                                                        d: {
                                                                            h: {
                                                                                p: {
                                                                                    f: {
                                                                                        if (i = b[132105], (a = b[132106]) >>> 0 <= i >>> 0) {
                                                                                            if (7 == (0 | r)) break f;
                                                                                            return 0
                                                                                        }
                                                                                        if (8 < r >>> 0) continue;
                                                                                        switch (r - 1 | 0) {
                                                                                            case 4:
                                                                                                break l;
                                                                                            case 3:
                                                                                                break c;
                                                                                            case 2:
                                                                                                break u;
                                                                                            case 1:
                                                                                                break d;
                                                                                            case 0:
                                                                                                break h;
                                                                                            case 6:
                                                                                                break f;
                                                                                            case 7:
                                                                                                break a;
                                                                                            case 5:
                                                                                                break s;
                                                                                            default:
                                                                                                break p
                                                                                        }
                                                                                    }
                                                                                    r = b[e + 76 >> 2];
                                                                                    break o
                                                                                }
                                                                                if (s = 1, b[132105] = i + 1, !(r = w[b[132104] + i | 0])) break i;
                                                                                if (!(1 != (0 | r) && r >>> 0 <= 223)) {
                                                                                    g[e + 80 >> 1] = 256, b[e + 60 >> 2] || (a = b[132108], b[e + 24 >> 2] = a + b[132107], b[e + 44 >> 2] = b[132109] - a), b[e + 28 >> 2] = 0, b[e + 32 >> 2] = 0, b[e + 36 >> 2] = 0, b[e + 40 >> 2] = 0;
                                                                                    break n
                                                                                }
                                                                                if (!w[e + 80 | 0]) break n;
                                                                                return 7
                                                                            }
                                                                            b[132105] = i + 1,
                                                                            r = w[b[132104] + i | 0],
                                                                            b[e + 64 >> 2] = 2,
                                                                            b[e + 72 >> 2] = b[e + 72 >> 2] + (r << 8);
                                                                            continue
                                                                        }
                                                                        b[132105] = i + 1,
                                                                        r = w[b[132104] + i | 0],
                                                                        b[e + 64 >> 2] = 3,
                                                                        b[e + 72 >> 2] = 1 + (r + b[e + 72 >> 2] | 0);
                                                                        continue
                                                                    }
                                                                    b[132105] = i + 1,
                                                                    r = w[b[132104] + i | 0],
                                                                    b[e + 64 >> 2] = 4,
                                                                    b[e + 76 >> 2] = r << 8;
                                                                    continue
                                                                }
                                                                b[132105] = i + 1,
                                                                r = w[b[132104] + i | 0],
                                                                b[e + 64 >> 2] = b[e + 68 >> 2],
                                                                b[e + 76 >> 2] = 1 + (r + b[e + 76 >> 2] | 0);
                                                                continue
                                                            }
                                                            if (b[132105] = i + 1, s = 7, 224 < (r = w[b[132104] + i | 0]) >>> 0) break i;
                                                            if (a = e, o = r >>> (i = 0) < 45 ? 0 : (r = (r = r + -45 | 0) - y(o = ((255 & r) >>> 0) / 45 | 0, 45) | 0, o + 1 | 0), b[a + 116 >> 2] = -1 << o ^ -1, 9 <= (255 & r) >>> 0 && (i = 1 + (a = ((255 & (r = r + -9 | 0)) >>> 0) / 9 | 0) | 0, r = r - y(a, 9) | 0), b[e + 112 >> 2] = i, r &= 255, 4 < (b[e + 108 >> 2] = r) + i >>> 0) break i;
                                                            for (b[e + 112 >> 2] = -1 << i ^ -1, r = 0, b[e + 100 >> 2] = 0, b[e + 92 >> 2] = 0, b[e + 96 >> 2] = 0, b[e + 84 >> 2] = 0, b[e + 88 >> 2] = 0; g[120 + ((r << 1) + e | 0) >> 1] = 1024, 14134 != (0 | (r = r + 1 | 0)););b[e + 64 >> 2] = 6,
                                                            b[e + 8 >> 2] = 5,
                                                            b[e >> 2] = -1,
                                                            b[e + 4 >> 2] = 0
                                                        }
                                                        if ((s = b[e + 76 >> 2]) >>> 0 < 5) return 7;
                                                        if (i = b[e + 8 >> 2])
                                                            for (r = b[132105], o = b[132106];;) {
                                                                if ((0 | r) == (0 | o)) return 0;
                                                                if (l = b[e + 4 >> 2], a = r + 1 | 0, b[132105] = a, r = w[b[132104] + r | 0], i = i + -1 | 0, b[e + 8 >> 2] = i, b[e + 4 >> 2] = r | l << 8, r = a, !i) break
                                                            }
                                                        b[e + 64 >> 2] = 7,
                                                        r = s + -5 | 0,
                                                        b[e + 76 >> 2] = r
                                                    }
                                                    a = b[e + 32 >> 2],
                                                    i = (i = b[132109] - b[132108] | 0) >>> 0 < (s = b[e + 72 >> 2]) >>> 0 ? i : s,
                                                    s = b[e + 44 >> 2],
                                                    b[e + 40 >> 2] = i >>> 0 < s - a >>> 0 ? a + i | 0 : s,
                                                    i = (o = b[132106]) - (a = b[132105]) | 0,
                                                    s = b[e + 28388 >> 2];o: {
                                                        if (!r || s) {
                                                            if (S(4 + (s + n | 0) | 0, o = b[132104] + a | 0, r = i >>> 0 < (r = (r = r - s | 0) >>> 0 < (a = 42 - s | 0) >>> 0 ? r : a) >>> 0 ? i : r), (0 | (a = (i = b[e + 28388 >> 2]) + r | 0)) != b[e + 76 >> 2]) {
                                                                if (a >>> 0 <= 20) {
                                                                    b[e + 28388 >> 2] = a, b[132105] = r + b[132105];
                                                                    break o
                                                                }
                                                                a = a + -21 | 0
                                                            } else E(4 + (r + (i + n | 0) | 0) | 0, 63 - a | 0), a = r + b[e + 28388 >> 2] | 0;
                                                            if (b[e + 16 >> 2] = 0, b[e + 12 >> 2] = t, b[e + 20 >> 2] = a, s = 7, !f(e)) break i;
                                                            if (a = b[e + 16 >> 2], (i = b[e + 28388 >> 2]) + r >>> 0 < a >>> 0) break i;
                                                            if (r = b[e + 76 >> 2] - a | 0, b[e + 76 >> 2] = r, a >>> 0 < i >>> 0) {
                                                                r = i - a | 0, m(t, 4 + (a + n | 0) | 0, b[e + 28388 >> 2] = r);
                                                                break o
                                                            }
                                                            a = b[132105] + (a - i | 0) | 0, b[132105] = a, b[e + 28388 >> 2] = 0, i = (o = b[132106]) - a | 0
                                                        }
                                                        if (21 <= i >>> 0) {
                                                            if (s = b[132104], b[e + 16 >> 2] = a, b[e + 12 >> 2] = s, b[e + 20 >> 2] = i >>> 0 < r + 21 >>> 0 ? o + -21 | 0 : r + a | 0, s = 7, !f(e)) break i;
                                                            if ((r = b[e + 76 >> 2]) >>> 0 < (i = (a = b[e + 16 >> 2]) - b[132105] | 0) >>> 0) break i;
                                                            if (r = r - i | 0, b[e + 76 >> 2] = r, b[132105] = a, 20 < (i = b[132106] - a | 0) >>> 0) break o
                                                        }
                                                        r = r >>> 0 < i >>> 0 ? r : i,
                                                        S(t, b[132104] + a | 0, r),
                                                        b[e + 28388 >> 2] = r,
                                                        b[132105] = r + b[132105]
                                                    }
                                                    if (i = (r = b[e + 32 >> 2]) - (s = b[e + 28 >> 2]) | 0, b[(a = e) + 60 >> 2] && ((0 | r) == b[e + 44 >> 2] && (b[e + 32 >> 2] = 0), S(b[132107] + b[132108] | 0, s + b[e + 24 >> 2] | 0, i), r = b[e + 32 >> 2]), b[a + 28 >> 2] = r, r = i + b[132108] | 0, b[132108] = r, a = b[e + 72 >> 2] - i | 0, !(b[e + 72 >> 2] = a)) {
                                                        if (s = 7, b[e + 4 >> 2] | (b[e + 76 >> 2] | b[e + 104 >> 2])) break i;
                                                        b[e + 64 >> 2] = 0;
                                                        break t
                                                    }
                                                    if (((s = 0) | r) == b[132109]) break i;
                                                    if (b[132105] != b[132106] | M[e + 28388 >> 2] >= M[e + 76 >> 2]) continue;
                                                    break i
                                                }
                                                if (!(o = b[e + 76 >> 2])) break r;
                                                if (!(a >>> (s = 0) <= i >>> 0))
                                                    for (;;) {
                                                        if ((r = b[132109]) >>> 0 <= (l = b[132108]) >>> 0) break i;
                                                        if (d = o, c = b[e + 32 >> 2], o = o >>> 0 < (r = (u = b[e + 44 >> 2] - c | 0) >>> 0 < (r = (a = a - i | 0) >>> 0 < (r = r - l | 0) >>> 0 ? a : r) >>> 0 ? u : r) >>> 0 ? o : r, b[e + 76 >> 2] = d - o, S(b[e + 24 >> 2] + c | 0, b[132104] + i | 0, o), r = o + b[e + 32 >> 2] | 0, b[e + 32 >> 2] = r, M[e + 36 >> 2] < r >>> 0 && (b[e + 36 >> 2] = r), b[(a = e) + 60 >> 2] && ((0 | r) == b[e + 44 >> 2] && (b[e + 32 >> 2] = 0), S(b[132107] + b[132108] | 0, b[132104] + b[132105] | 0, o), r = b[e + 32 >> 2]), b[a + 28 >> 2] = r, b[132108] = o + b[132108], i = o + b[132105] | 0, b[132105] = i, !(o = b[e + 76 >> 2])) break r;
                                                        if (!(i >>> 0 < (a = b[132106]) >>> 0)) break
                                                    }
                                            }
                                            return s
                                        }
                                        b[e + 64 >> 2] = 0;
                                        continue
                                    }
                                    if (-1 < r << 24 >> 24) break e;
                                    if (b[e + 64 >> 2] = 1, b[e + 72 >> 2] = r << 16 & 2031616, 192 <= r >>> 0) {
                                        b[e + 68 >> 2] = 5, x[e + 81 | 0] = 0;
                                        continue
                                    }
                                    if (w[e + 81 | 0]) return 7;
                                    if (b[e + 68 >> 2] = 6, r >>> 0 < 160) continue;
                                    for (b[e + 84 >> 2] = 0, r = b[e + 88 >> 2] = 0, b[e + 100 >> 2] = 0, b[e + 92 >> 2] = 0, b[e + 96 >> 2] = 0; g[120 + ((r << 1) + e | 0) >> 1] = 1024, 14134 != (0 | (r = r + 1 | 0)););
                                }
                                b[e + 8 >> 2] = 5,
                                b[e >> 2] = -1,
                                b[e + 4 >> 2] = 0;
                                continue
                            }
                            if (!(r >>> 0 <= 2)) break;
                            b[e + 64 >> 2] = 3, b[e + 68 >> 2] = 8
                        }
                        return 7
                    }

                    function c() {
                        var e, t, n = 0;
                        if (e = l(1208)) {
                            if (b[e + 36 >> 2] = 2, n = (t = l(28456)) ? (b[t + 52 >> 2] = 8388608, b[t + 60 >> 2] = 2, b[t + 56 >> 2] = 0, b[t + 24 >> 2] = 0, t) : 0, b[e + 1200 >> 2] = n) return x[e + 40 | 0] = 0, b[e >> 2] = 0, b[e + 4 >> 2] = 0, b[e + 24 >> 2] = 0, E(e + 72 | (b[e + 28 >> 2] = 0), 100), b[e + 172 >> 2] = 12, e;
                            s(e)
                        }
                        return 0
                    }

                    function R(e, t, n, r) {
                        var i = 0;
                        if (n ^= -1, r ^= -1, t)
                            for (; i = 2080 + ((w[0 | e] ^ 255 & n) << 3) | 0, n = b[i >> 2] ^ ((255 & r) << 24 | n >>> 8), r = b[i + 4 >> 2] ^ r >>> 8, e = e + 1 | 0, t = t + -1 | 0;);
                        return A = -1 ^ r, -1 ^ n
                    }

                    function m(e, t, n) {
                        var r = 0,
                            i = 0;
                        e: if ((0 | e) != (0 | t)) {
                            if (!(e >>> 0 < t + n >>> 0 && t >>> 0 < (i = e + n | 0) >>> 0)) return void S(e, t, n);
                            if (r = 3 & (e ^ t), e >>> 0 < t >>> 0) {
                                if (!r) {
                                    if (3 & e)
                                        for (;;) {
                                            if (!n) break e;
                                            if (x[0 | e] = w[0 | t], t = t + 1 | 0, n = n + -1 | 0, !(3 & (e = e + 1 | 0))) break
                                        }
                                    if (!(n >>> 0 <= 3)) {
                                        for (r = n; b[e >> 2] = b[t >> 2], t = t + 4 | 0, e = e + 4 | 0, 3 < (r = r + -4 | 0) >>> 0;);
                                        n &= 3
                                    }
                                }
                                if (n)
                                    for (; x[0 | e] = w[0 | t], e = e + 1 | 0, t = t + 1 | 0, n = n + -1 | 0;);
                            } else {
                                if (!r) {
                                    if (3 & i)
                                        for (;;) {
                                            if (!n) break e;
                                            if (x[0 | (r = (n = n + -1 | 0) + e | 0)] = w[t + n | 0], !(3 & r)) break
                                        }
                                    if (!(n >>> 0 <= 3))
                                        for (; b[(n = n + -4 | 0) + e >> 2] = b[t + n >> 2], 3 < n >>> 0;);
                                }
                                if (!n) break e;
                                for (; x[(n = n + -1 | 0) + e | 0] = w[t + n | 0], n;);
                            }
                        }
                    }

                    function D(e, t) {
                        var n = 0,
                            r = 0;
                        n = 6;
                        e: if (!(39 < t >>> 0)) {
                            if (t = (1 & t | 2) << 11 + (t >>> 1 | 0), b[e + 48 >> 2] = t, r = b[e + 60 >> 2]) {
                                if (n = 4, t >>> 0 > M[e + 52 >> 2]) break e;
                                if (b[e + 44 >> 2] = t, !(2 != (0 | r) | M[e + 56 >> 2] >= t >>> 0 || (s(b[e + 24 >> 2]), t = l(b[e + 48 >> 2]), b[e + 24 >> 2] = t))) return b[e + 56 >> 2] = 0, 3
                            }
                            b[e + 28388 >> 2] = 0, b[e + 64 >> 2] = 0, x[e + 80 | 0] = 1, n = b[e + 104 >> 2] = 0
                        }
                        return n
                    }

                    function v(e) {
                        var t;
                        return (-1 >>> (t = 31 & e) & -2) << t | (-1 << (e = 0 - e & 31) & -2) >>> e
                    }
                    return {
                        __wasm_call_ctors: function () {},
                        init_decompressor: function () {
                            var e = 0;
                            return b[132108] = 0, b[132109] = 524288, b[132107] = 528448, b[132105] = 0, b[132106] = 0, b[132104] = 4128,
                                function () {
                                    for (var e = 0, t = 0, n = 0; e = ((t = (0 - (1 & (e = (0 - (1 & (e = ((t = n >>> 1 | 0) ^ 0 - (1 & n) & -306674912) >>> 1 | 0)) & -306674912 ^ (t = (e ^ 0 - (1 & t) & -306674912) >>> 1 | 0)) >>> 1 | 0)) & -306674912 ^ (e = (e ^ 0 - (1 & t) & -306674912) >>> 1 | 0)) >>> 1 | 0) ^ 0 - (1 & e) & -306674912) >>> 1 | 0, b[1056 + (n << 2) >> 2] = 0 - (1 & e) & -306674912 ^ (e ^ 0 - (1 & t) & -306674912) >>> 1, 256 != (0 | (n = n + 1 | 0)););
                                }(),
                                function () {
                                    for (var e = 0, t = 0, n = 0, r = 0, i = 0, a = 0, o = 0, s = 0, l = 0; t = (e = o) >>> 1 | 0, n = 1 & (e = (1 & e) << 31 | s >>> 1), t ^= 0 - (0 < (a = 1 & s) >>> 0) & -915646571, a = e ^ (i = 0 - a & -679014590), e = t >>> 1 | 0, e ^= 0 - (0 < n >>> 0) & -915646571, n = (t = (1 & t) << 31 | a >>> 1) ^ (r = 0 - n & -679014590), r = e >>> 1 | 0, n = 1 & (e = (1 & e) << 31 | n >>> 1), i = 0 - (t &= 1) & -679014590, t = r ^ 0 - (0 < t >>> 0) & -915646571, r = e ^ i, e = t >>> 1 | 0, r = 0 - n & -679014590 ^ (t = (1 & t) << 31 | r >>> 1), e = (n = e ^ 0 - (0 < n >>> 0) & -915646571) >>> 1 | 0, t = (1 & (e ^= 0 - (0 < (t &= 1) >>> 0) & -915646571)) << 31 | (t = (n = (1 & n) << 31 | r >>> 1) ^ (i = 0 - t & -679014590)) >>> 1, e = (n = 0 - (0 < (r = 1 & n) >>> 0) & -915646571 ^ e >>> 1) >>> 1 | 0, r = 1 & (n = (1 & n) << 31 | (r = t ^ (a = 0 - r & -679014590)) >>> 1), n ^= 0 - (t &= 1) & -679014590, t = (e ^= 0 - (0 < t >>> 0) & -915646571) >>> 1 | 0, b[(i = 2080 + (l << 3) | 0) >> 2] = 0 - r & -679014590 ^ ((1 & e) << 31 | n >>> 1), b[i + 4 >> 2] = t ^ 0 - (0 < r >>> 0) & -915646571, l = l + 1 | 0, e = o, (o = s + 1 | 0) >>> 0 < 1 && (e = e + 1 | 0), 256 != (0 | (s = o)) | (o = e););
                                }(), e = c(), 0 | (e = (b[263184] = e) ? 0 : (o(0), 1))
                        },
                        decompress: function () {
                            var e, t = 0;
                            e: {
                                if ((e = function (e) {
                                        var t, n, r, i, a = 0,
                                            o = 0,
                                            s = 0,
                                            l = 0,
                                            c = 0,
                                            u = 0,
                                            d = 0,
                                            h = 0,
                                            p = 0,
                                            f = 0,
                                            m = 0,
                                            v = 0,
                                            g = 0,
                                            _ = 0,
                                            y = 0;
                                        o = b[e + 36 >> 2] ? b[e >> 2] : (x[e + 40 | 0] = 0, b[e >> 2] = 0, b[e + 4 >> 2] = 0, b[e + 24 >> 2] = 0, E(e + 72 | (b[e + 28 >> 2] = 0), 100), b[e + 172 >> 2] = 12, 0), n = b[132108], t = b[132105], b[e + 16 >> 2] = t, r = e + 96 | 0, v = (a = e) + 182 | 0, i = a + 176 | 0, d = a + 168 | 0;
                                        t: {
                                            n: {
                                                r: {
                                                    i: {
                                                        a: {
                                                            for (;;)
                                                                if (!(9 < o >>> 0)) {
                                                                    e = d;
                                                                    o: {
                                                                        s: {
                                                                            l: {
                                                                                c: {
                                                                                    u: {
                                                                                        d: switch (o - 1 | 0) {
                                                                                            case 1:
                                                                                                u = b[132106], o = b[132104], l = b[a + 172 >> 2], s = b[a + 168 >> 2];
                                                                                                break u;
                                                                                            default:
                                                                                                if (s = b[132105], o = b[132106] - s | 0, c = b[a + 168 >> 2], o = o >>> 0 < (u = b[a + 172 >> 2] - c | 0) >>> 0 ? o : u, S(8 + (c + d | 0) | 0, s + b[132104] | 0, o), b[132105] = o + b[132105], l = 0, o = o + b[a + 168 >> 2] | 0, s = b[a + 172 >> 2], b[a + 168 >> 2] = (0 | s) == (0 | o) ? 0 : o, (0 | o) != (0 | s)) break t;
                                                                                                if (b[a >> 2] = 1, C(i, 1024, 6)) {
                                                                                                    l = 5;
                                                                                                    break t
                                                                                                }
                                                                                                if ((0 | T(v, 2, 0)) != (w[a + 184 | 0] | w[a + 185 | 0] << 8 | (w[a + 186 | 0] << 16 | w[a + 187 | 0] << 24))) {
                                                                                                    l = 7;
                                                                                                    break t
                                                                                                }
                                                                                                if (l = 6, w[0 | v]) break t;
                                                                                                if (o = w[a + 183 | 0], 15 < (b[a + 32 >> 2] = o) >>> 0) break t;
                                                                                                if (l = 2, !(1 << o & 19) | 4 < o >>> 0) break t;
                                                                                                break;
                                                                                            case 4:
                                                                                                break s;
                                                                                            case 3:
                                                                                                break l;
                                                                                            case 2:
                                                                                                break c;
                                                                                            case 0:
                                                                                                break d;
                                                                                            case 8:
                                                                                                break r;
                                                                                            case 7:
                                                                                                break i;
                                                                                            case 6:
                                                                                                break a;
                                                                                            case 5:
                                                                                                break o
                                                                                        }
                                                                                        if ((0 | (u = b[132106])) == (0 | (s = b[132105]))) {
                                                                                            l = 0;
                                                                                            break t
                                                                                        }
                                                                                        if (o = b[132104], !(c = w[s + o | 0])) {
                                                                                            b[132105] = s + 1, b[a + 16 >> 2] = s, o = 6, b[a >> 2] = 6;
                                                                                            continue
                                                                                        }
                                                                                        b[a + 168 >> 2] = 0,
                                                                                        l = 4 + (c << (b[a >> 2] = 2)) | 0,
                                                                                        b[a + 172 >> 2] = l,
                                                                                        b[a + 64 >> 2] = l,
                                                                                        s = 0
                                                                                    }
                                                                                    if (c = u, S(8 + (e + s | 0) | 0, o + (u = b[132105]) | 0, c = (c = c - u | 0) >>> 0 < (l = l - s | 0) >>> 0 ? c : l), b[132105] = c + b[132105], l = 0, e = c + b[a + 168 >> 2] | 0, o = b[a + 172 >> 2], b[a + 168 >> 2] = (0 | o) == (0 | e) ? 0 : e, (0 | e) != (0 | o)) break t;
                                                                                    if (e = e + -4 | 0, o = T(i, b[a + 172 >> 2] = e, 0), p = b[a + 172 >> 2], (0 | o) != (w[176 + (e = p + a | 0) | 0] | w[e + 177 | 0] << 8 | (w[e + 178 | 0] << 16 | w[e + 179 | 0] << 24))) {
                                                                                        l = 7;
                                                                                        break t
                                                                                    }
                                                                                    if (b[a + 168 >> 2] = 2, 63 & (g = x[a + 177 | 0])) {
                                                                                        l = 6;
                                                                                        break t
                                                                                    }
                                                                                    if (o = 2, c = s = _ = h = -1, 64 & g) {
                                                                                        for ((u = b[a + 4 >> 2]) || (b[a + 8 >> 2] = 0, b[a + 12 >> 2] = 0);;) {
                                                                                            if (p >>> 0 <= o >>> 0) {
                                                                                                l = 7;
                                                                                                break t
                                                                                            }
                                                                                            f = w[8 + (o + d | 0) | 0], o = o + 1 | 0, b[a + 168 >> 2] = o, y = b[(e = a) + 12 >> 2], m = 127 & f, l = 31 & (s = u), s = 32 <= (63 & s) >>> 0 ? (c = m << l, 0) : (c = (1 << l) - 1 & m >>> 32 - l, m << l), s |= b[a + 8 >> 2], c = l = c | y, b[e + 8 >> 2] = s, b[e + 12 >> 2] = c;
                                                                                            u: {
                                                                                                if (!(128 & f)) {
                                                                                                    if (f | !u) break u;
                                                                                                    l = 7;
                                                                                                    break t
                                                                                                }
                                                                                                if (u = u + (l = 7) | 0, 63 != (0 | (b[a + 4 >> 2] = u))) continue;
                                                                                                break t
                                                                                            }
                                                                                            break
                                                                                        }
                                                                                        b[a + 4 >> 2] = 0
                                                                                    }
                                                                                    if (b[a + 48 >> 2] = s, b[a + 52 >> 2] = c, (0 | g) <= -1) {
                                                                                        for ((u = b[a + 4 >> 2]) || (b[a + 8 >> 2] = 0, b[a + 12 >> 2] = 0);;) {
                                                                                            if (p >>> 0 <= o >>> 0) {
                                                                                                l = 7;
                                                                                                break t
                                                                                            }
                                                                                            f = w[8 + (o + d | 0) | 0], o = o + 1 | 0, b[a + 168 >> 2] = o, m = b[(e = a) + 12 >> 2], h = 127 & f, l = 31 & (s = u), h = (s = 32 <= (63 & s) >>> 0 ? (c = h << l, 0) : (c = (1 << l) - 1 & h >>> 32 - l, h << l)) | b[a + 8 >> 2], _ = s = c | m, b[e + 8 >> 2] = h, b[e + 12 >> 2] = s;
                                                                                            u: {
                                                                                                if (!(128 & f)) {
                                                                                                    if (f | !u) break u;
                                                                                                    l = 7;
                                                                                                    break t
                                                                                                }
                                                                                                if (u = u + (l = 7) | 0, 63 != (0 | (b[a + 4 >> 2] = u))) continue;
                                                                                                break t
                                                                                            }
                                                                                            break
                                                                                        }
                                                                                        b[a + 4 >> 2] = 0
                                                                                    }
                                                                                    if (b[a + 56 >> 2] = h, b[a + 60 >> 2] = _, p - o >>> 0 < 2) {
                                                                                        l = 7;
                                                                                        break t
                                                                                    }
                                                                                    if (s = o + 1 | 0, b[a + 168 >> 2] = s, 33 != w[8 + (o + d | 0) | 0]) {
                                                                                        l = 6;
                                                                                        break t
                                                                                    }
                                                                                    if (e = o + 2 | 0, b[a + 168 >> 2] = e, 1 != w[8 + (s + d | 0) | 0]) {
                                                                                        l = 6;
                                                                                        break t
                                                                                    }
                                                                                    if (l = 7, (0 | e) == (0 | p)) break t;
                                                                                    if (b[a + 168 >> 2] = o + 3, l = D(b[a + 1200 >> 2], w[8 + (e + d | 0) | 0])) break t;o = b[a + 168 >> 2],
                                                                                    s = b[a + 172 >> 2];u: {
                                                                                        for (;;) {
                                                                                            if (s >>> 0 <= o >>> 0) break u;
                                                                                            if (e = o + 1 | 0, c = o + d | 0, o = b[a + 168 >> 2] = e, w[c + 8 | 0]) break
                                                                                        }
                                                                                        l = 6;
                                                                                        break t
                                                                                    }
                                                                                    b[a + 168 >> 2] = 0,
                                                                                    b[a + 80 >> 2] = 0,
                                                                                    b[a + 84 >> 2] = 0,
                                                                                    b[a + 72 >> 2] = 0,
                                                                                    b[a + 76 >> 2] = 0,
                                                                                    b[a >> 2] = 3
                                                                                }
                                                                                if (b[a + 16 >> 2] = b[132105], b[a + 20 >> 2] = b[132108], l = L(b[a + 1200 >> 2]), e = b[(o = a) + 76 >> 2], (c = (s = b[132105] - b[a + 16 >> 2] | 0) + b[a + 72 >> 2] | 0) >>> 0 < s >>> 0 && (e = e + 1 | 0), u = c, s = e, b[o + 72 >> 2] = c, b[o + 76 >> 2] = e, e = b[a + 84 >> 2], p = b[a + 20 >> 2], (f = (c = h = b[132108] - p | 0) + b[a + 80 >> 2] | 0) >>> 0 < c >>> 0 && (e = e + 1 | 0), c = e, b[o + 80 >> 2] = f, b[o + 84 >> 2] = e, (0 | (e = b[a + 52 >> 2])) == (0 | s) & u >>> 0 > M[a + 48 >> 2] | e >>> 0 < s >>> 0) {
                                                                                    l = 7;
                                                                                    break t
                                                                                }
                                                                                if ((0 | (e = b[a + 60 >> 2])) == (0 | c) & f >>> 0 > M[a + 56 >> 2] | e >>> 0 < c >>> 0) {
                                                                                    l = 7;
                                                                                    break t
                                                                                }
                                                                                c: if (!(3 < (o = b[a + 32 >> 2] + -1 | 0) >>> 0)) {
                                                                                    e = a;
                                                                                    u: {
                                                                                        d: switch (o - 1 | 0) {
                                                                                            default:
                                                                                                o = T(p + b[132107] | 0, h, b[a + 24 >> 2]), s = 0;
                                                                                                break u;
                                                                                            case 0:
                                                                                            case 1:
                                                                                                break c;
                                                                                            case 2:
                                                                                        }
                                                                                        o = R(p + b[132107] | 0, h, b[a + 24 >> 2], b[a + 28 >> 2]),
                                                                                        s = A
                                                                                    }
                                                                                    b[e + 24 >> 2] = o, b[e + 28 >> 2] = s
                                                                                }if (1 != (0 | l)) break t;
                                                                                if (o = e = b[a + 52 >> 2], !(-1 == (0 | (s = b[a + 48 >> 2])) & -1 == (0 | o) | b[a + 72 >> 2] == (0 | s) & b[a + 76 >> 2] == (0 | o))) {
                                                                                    l = 7;
                                                                                    break t
                                                                                }
                                                                                if (e = b[a + 80 >> 2], o = b[a + 84 >> 2], c = u = b[a + 60 >> 2], -1 == (0 | (s = b[a + 56 >> 2])) & -1 == (0 | c)) s = e,
                                                                                c = o;
                                                                                else if (l = 7, (0 | e) != (0 | s) | (0 | o) != (0 | c)) break t;c = c + b[a + 108 >> 2] | 0,
                                                                                (o = s + b[a + 104 >> 2] | 0) >>> 0 < s >>> 0 && (c = c + 1 | 0),
                                                                                b[a + 104 >> 2] = o,
                                                                                b[a + 108 >> 2] = c,
                                                                                c = b[a + 100 >> 2],
                                                                                e = b[a + 76 >> 2],
                                                                                (u = (s = b[a + 64 >> 2]) + b[a + 72 >> 2] | 0) >>> 0 < s >>> 0 && (e = e + 1 | 0),
                                                                                e = e + c | 0,
                                                                                e = (s = u + b[a + 96 >> 2] | 0) >>> 0 < u >>> 0 ? e + 1 | 0 : e,
                                                                                (s = (c = s) + w[b[a + 32 >> 2] + 1040 | 0] | 0) >>> 0 < c >>> 0 && (e = e + 1 | 0),
                                                                                b[a + 96 >> 2] = s,
                                                                                b[a + 100 >> 2] = e,
                                                                                b[a + 112 >> 2] = T(r, 24, b[a + 112 >> 2]),
                                                                                b[a >> 2] = 4,
                                                                                o = b[a + 92 >> 2],
                                                                                (s = b[a + 88 >> 2] + 1 | 0) >>> 0 < 1 && (o = o + 1 | 0),
                                                                                b[a + 88 >> 2] = s,
                                                                                b[a + 92 >> 2] = o
                                                                            }
                                                                            if (c = b[a + 76 >> 2], 3 & (s = b[a + 72 >> 2]))
                                                                                for (o = b[132105], u = b[132106];;) {
                                                                                    if ((0 | o) == (0 | u)) {
                                                                                        l = 0;
                                                                                        break t
                                                                                    }
                                                                                    if (e = o + 1 | 0, b[132105] = e, w[b[132104] + o | 0]) {
                                                                                        l = 7;
                                                                                        break t
                                                                                    }
                                                                                    if ((s = s + 1 | 0) >>> 0 < 1 && (c = c + 1 | 0), b[a + 72 >> 2] = s, b[a + 76 >> 2] = c, o = e, !(3 & s)) break
                                                                                }
                                                                            b[a >> 2] = 5
                                                                        }
                                                                        s: {
                                                                            l: if (!(3 < (o = (e = b[a + 32 >> 2]) + -1 | 0) >>> 0)) {
                                                                                c: switch (o - 1 | 0) {
                                                                                    default:
                                                                                        for (o = b[132105], l = b[132106];;) {
                                                                                            if ((0 | o) == (0 | l)) {
                                                                                                l = 0;
                                                                                                break t
                                                                                            }
                                                                                            if (u = b[a + 24 >> 2], s = b[a + 28 >> 2], e = b[a + 4 >> 2], c = o + 1 | 0, b[132105] = c, h = w[b[132104] + o | 0], p = u, o = s, u = 31 & e, (0 | h) != (255 & (32 <= (63 & e) >>> 0 ? o >>> u | 0 : ((1 << u) - 1 & o) << 32 - u | p >>> u))) {
                                                                                                l = 7;
                                                                                                break t
                                                                                            }
                                                                                            if (e = e + 8 | 0, o = c, !((b[a + 4 >> 2] = e) >>> 0 < 32)) break
                                                                                        }
                                                                                        b[a + 24 >> 2] = 0, b[a + 28 >> 2] = 0;
                                                                                        break s;
                                                                                    case 0:
                                                                                    case 1:
                                                                                        break l;
                                                                                    case 2:
                                                                                }
                                                                                for (o = b[132105], l = b[132106];;) {
                                                                                    if ((0 | o) == (0 | l)) {
                                                                                        l = 0;
                                                                                        break t
                                                                                    }
                                                                                    if (u = b[a + 24 >> 2], s = b[a + 28 >> 2], e = b[a + 4 >> 2], c = o + 1 | 0, b[132105] = c, h = w[b[132104] + o | 0], p = u, o = s, u = 31 & e, (0 | h) != (255 & (32 <= (63 & e) >>> 0 ? o >>> u | 0 : ((1 << u) - 1 & o) << 32 - u | p >>> u))) {
                                                                                        l = 7;
                                                                                        break t
                                                                                    }
                                                                                    if (e = e + 8 | 0, o = c, !((b[a + 4 >> 2] = e) >>> 0 < 64)) break
                                                                                }
                                                                                b[a + 24 >> 2] = 0,
                                                                                b[a + 28 >> 2] = 0;
                                                                                break s
                                                                            }if (o = b[a + 4 >> 2], !((e = w[e + 1040 | 0]) >>> 0 <= o >>> 0))
                                                                                for (l = b[132105], s = b[132106];;) {
                                                                                    if ((0 | l) == (0 | s)) {
                                                                                        l = 0;
                                                                                        break t
                                                                                    }
                                                                                    if (l = l + 1 | 0, b[132105] = l, o = o + 1 | 0, (0 | e) == (0 | (b[a + 4 >> 2] = o))) break
                                                                                }
                                                                        }
                                                                        b[a + 4 >> 2] = 0,
                                                                        o = 1,
                                                                        b[a >> 2] = 1;
                                                                        continue
                                                                    }
                                                                    break
                                                                } for (f = a + 144 | 0;;) {
                                                                m = b[132106], h = b[132104], (e = b[a + 4 >> 2]) || (b[a + 8 >> 2] = 0, b[a + 12 >> 2] = 0), o = b[132105];
                                                                o: {
                                                                    for (;;) {
                                                                        if (m >>> 0 <= o >>> 0) l = 0;
                                                                        else if (d = w[o + h | 0], o = o + 1 | 0, b[132105] = o, v = b[(u = a) + 12 >> 2], p = 127 & d, l = 31 & e, s = 32 <= (63 & e) >>> 0 ? (c = p << l, 0) : (c = (1 << l) - 1 & p >>> 32 - l, p << l), s |= b[a + 8 >> 2], c = l = c | v, b[u + 8 >> 2] = s, b[u + 12 >> 2] = c, 128 & d) {
                                                                            if (e = e + (l = 7) | 0, 63 != (0 | (b[a + 4 >> 2] = e))) continue
                                                                        } else {
                                                                            if (d | !e) break o;
                                                                            l = 7
                                                                        }
                                                                        break
                                                                    }
                                                                    e = b[a + 132 >> 2],
                                                                    (d = (c = (s = o) - (o = b[a + 16 >> 2]) | 0) + b[a + 128 >> 2] | 0) >>> 0 < c >>> 0 && (e = e + 1 | 0),
                                                                    b[a + 128 >> 2] = d,
                                                                    b[a + 132 >> 2] = e,
                                                                    b[a + 24 >> 2] = T(o + h | 0, c, b[a + 24 >> 2]),
                                                                    b[a + 28 >> 2] = 0;
                                                                    break t
                                                                }
                                                                b[a + 4 >> 2] = 0;
                                                                o: {
                                                                    if ((e = b[a + 120 >> 2]) >>> 0 <= 2) {
                                                                        s: switch (e - 1 | 0) {
                                                                            default:
                                                                                if (b[a + 136 >> 2] = s, b[a + 140 >> 2] = c, (0 | s) != b[a + 88 >> 2] | (0 | c) != b[a + 92 >> 2]) {
                                                                                    l = 7;
                                                                                    break t
                                                                                }
                                                                                b[a + 120 >> 2] = 1;
                                                                                break o;
                                                                            case 1:
                                                                                e = c + b[a + 156 >> 2] | 0, (c = s + b[a + 152 >> 2] | 0) >>> 0 < s >>> 0 && (e = e + 1 | 0), b[a + 152 >> 2] = c, b[a + 156 >> 2] = e, b[a + 160 >> 2] = T(f, 24, b[a + 160 >> 2]), b[a + 120 >> 2] = 1, c = b[a + 140 >> 2] + -1 | 0, (o = b[a + 136 >> 2] + -1 | 0) >>> 0 < 4294967295 && (c = c + 1 | 0), s = o, b[a + 136 >> 2] = o, b[a + 140 >> 2] = c;
                                                                                break o;
                                                                            case 0:
                                                                        }
                                                                        b[a + 120 >> 2] = 2,
                                                                        e = c + b[a + 148 >> 2] | 0,
                                                                        (c = s + b[a + 144 >> 2] | 0) >>> 0 < s >>> 0 && (e = e + 1 | 0),
                                                                        b[a + 144 >> 2] = c,
                                                                        b[a + 148 >> 2] = e
                                                                    }
                                                                    s = b[a + 136 >> 2],
                                                                    c = b[a + 140 >> 2]
                                                                }
                                                                if (!(s | c)) break
                                                            }
                                                            b[a >> 2] = 7
                                                        }
                                                        s = b[a + 132 >> 2],
                                                        p = ((o = b[132105]) + (((c = b[a + 16 >> 2]) - o | 0) - (d = b[a + 128 >> 2]) & 3) | 0) - c | 0;a: {
                                                            for (;;) {
                                                                if (e = s, (l = (u = h = o - c | 0) + d | 0) >>> 0 < u >>> 0 && (e = e + 1 | 0), !(3 & (u = l))) break a;
                                                                if (l = b[132104], b[132106] == (0 | o)) {
                                                                    b[a + 128 >> 2] = u, b[a + 132 >> 2] = e, b[a + 24 >> 2] = T(l + c | 0, h, b[a + 24 >> 2]), l = b[a + 28 >> 2] = 0;
                                                                    break t
                                                                }
                                                                if (e = o + 1 | 0, u = o + l | 0, o = b[132105] = e, w[0 | u]) break
                                                            }
                                                            l = 7;
                                                            break t
                                                        }
                                                        if (o = b[132104], b[a + 128 >> 2] = u, b[a + 132 >> 2] = e, b[a + 24 >> 2] = T(o + c | 0, p, b[a + 24 >> 2]), l = 7, C(r, a + 144 | (b[a + 28 >> 2] = 0), 24)) break t;b[a >> 2] = 8
                                                    }
                                                    for (o = b[132105], l = b[132106];;) {
                                                        if ((0 | o) == (0 | l)) {
                                                            l = 0;
                                                            break t
                                                        }
                                                        if (d = b[a + 24 >> 2], c = b[a + 28 >> 2], s = b[a + 4 >> 2], e = o + 1 | 0, b[132105] = e, u = b[132104], h = w[u + o | 0], p = d, o = c, d = 31 & s, (0 | h) != (255 & (32 <= (63 & s) >>> 0 ? o >>> d | 0 : ((1 << d) - 1 & o) << 32 - d | p >>> d))) {
                                                            l = 7;
                                                            break t
                                                        }
                                                        if (s = s + 8 | 0, o = e, !((b[a + 4 >> 2] = s) >>> 0 < 32)) break
                                                    }
                                                    b[a + 172 >> 2] = 12,
                                                    b[a + 24 >> 2] = 0,
                                                    b[a + 28 >> 2] = 0,
                                                    b[a >> 2] = 9,
                                                    b[a + 4 >> 2] = 0,
                                                    o = 12;
                                                    break n
                                                }
                                                e = b[132105],
                                                u = b[132104],
                                                l = b[132106],
                                                o = b[a + 172 >> 2]
                                            }
                                            s = l - e | 0,
                                            S(176 + (a + (c = b[a + 168 >> 2]) | 0) | 0, e + u | 0, o = s >>> 0 < (o = o - c | 0) >>> 0 ? s : o),
                                            b[132105] = o + b[132105],
                                            l = 0,
                                            e = o + b[a + 168 >> 2] | 0,
                                            o = b[a + 172 >> 2],
                                            b[a + 168 >> 2] = (0 | o) == (0 | e) ? 0 : e,
                                            (0 | e) == (0 | o) && (l = 7, 23129 == (w[a + 186 | 0] | w[a + 187 | 0] << 8) && (0 | T(a + 180 | 0, 6, 0)) == (w[a + 176 | 0] | w[a + 177 | 0] << 8 | (w[a + 178 | 0] << 16 | w[a + 179 | 0] << 24)) && (e = (o = b[a + 132 >> 2]) >>> 2 | 0, w[a + 184 | 0] | (w[a + 180 | 0] | w[a + 181 | 0] << 8 | (w[a + 182 | 0] << 16 | w[a + 183 | 0] << 24)) != ((3 & o) << 30 | b[a + 128 >> 2] >>> 2) | e || (l = b[a + 32 >> 2] == w[a + 185 | 0] ? 1 : 7)))
                                        }
                                        t: {
                                            if (!b[a + 36 >> 2]) {
                                                if (l) {
                                                    if (a = 1 == (0 | l), e = l, l = 1, a) break t
                                                } else e = b[132105] == b[132106] ? 7 : 8;
                                                return b[132108] = n, b[132105] = t, e
                                            }
                                            if (!(b[132105] != (0 | t) | l | b[132108] != (0 | n))) return e = w[a + 40 | 0],
                                            x[a + 40 | 0] = 1,
                                            e << 3;x[a + 40 | 0] = 0
                                        }
                                        return l
                                    }(b[263184])) >>> 0 <= 8) {
                                    t: switch (e - 1 | 0) {
                                        case 0:
                                            return o(b[263184]), 0;
                                        case 2:
                                            return o(b[263184]), 1;
                                        case 3:
                                            return o(b[263184]), 2;
                                        case 4:
                                            return o(b[263184]), 4;
                                        case 5:
                                            return o(b[263184]), 5;
                                        case 6:
                                        case 7:
                                            break t;
                                        default:
                                            break e
                                    }
                                    return o(b[263184]),
                                    6
                                }
                                o(b[263184]),
                                t = 7
                            }
                            return 0 | t
                        },
                        get_in_buffer_ptr: function () {
                            return b[132104]
                        },
                        get_out_buffer_ptr: function () {
                            return b[132107]
                        },
                        in_buffer_set_pos: function (e) {
                            e |= 0, b[132105] = e
                        },
                        in_buffer_set_size: function (e) {
                            e |= 0, b[132106] = e >>> 0 < 524288 ? e : 524288
                        },
                        out_buffer_set_pos: function (e) {
                            e |= 0, b[132108] = e
                        },
                        out_buffer_set_size: function (e) {
                            e |= 0, b[132109] = e >>> 0 < 524288 ? e : 524288
                        },
                        get_curr_output_length: function () {
                            return b[132108]
                        },
                        is_input_end_reached: function () {
                            return b[132105] == b[132106] | 0
                        },
                        stackSave: function () {
                            return 0 | h
                        },
                        stackAlloc: function (e) {
                            return 0 | (h = e = h - (e |= 0) & -16)
                        },
                        stackRestore: function (e) {
                            h = e |= 0
                        },
                        __growWasmMemory: function (e) {
                            return 0 | r()
                        }
                    }
                }({
                    Int8Array: Int8Array,
                    Int16Array: Int16Array,
                    Int32Array: Int32Array,
                    Uint8Array: Uint8Array,
                    Uint16Array: Uint16Array,
                    Uint32Array: Uint32Array,
                    Float32Array: Float32Array,
                    Float64Array: Float64Array,
                    NaN: NaN,
                    Infinity: 1 / 0,
                    Math: Math
                }, n, r.buffer))
            }
        },
        instantiate: function (t, n) {
            return {
                then: function (e) {
                    e({
                        instance: new Sv.Instance(new Sv.Module(t, n))
                    })
                }
            }
        },
        RuntimeError: Error
    };
    bv = [], "object" != typeof Sv && Mv("no native wasm support detected");
    var Tv = new Sv.Table({
            initial: 1,
            maximum: 1,
            element: "anyfunc"
        }),
        Ev = !1;

    function Cv(e, t) {
        e || Xv("Assertion failed: " + t)
    }

    function Pv(e) {
        var t = cv["_" + e];
        return Cv(t, "Cannot call unknown function " + e + ", make sure it is exported"), t
    }

    function Lv(e, t, n, r) {
        var i = {
            string: function (e) {
                var t = 0;
                if (null != e && 0 !== e) {
                    var n = 1 + (e.length << 2);
                    t = ag(n),
                        function (e, t, n, r) {
                            if (0 < r) {
                                for (var i = n, a = n + r - 1, o = 0; o < e.length; ++o) {
                                    var s = e.charCodeAt(o);
                                    if (55296 <= s && s <= 57343) {
                                        var l = e.charCodeAt(++o);
                                        s = 65536 + ((1023 & s) << 10) | 1023 & l
                                    }
                                    if (s <= 127) {
                                        if (a <= n) break;
                                        t[n++] = s
                                    } else if (s <= 2047) {
                                        if (a <= n + 1) break;
                                        t[n++] = 192 | s >> 6, t[n++] = 128 | 63 & s
                                    } else if (s <= 65535) {
                                        if (a <= n + 2) break;
                                        t[n++] = 224 | s >> 12, t[n++] = 128 | s >> 6 & 63, t[n++] = 128 | 63 & s
                                    } else {
                                        if (a <= n + 3) break;
                                        t[n++] = 240 | s >> 18, t[n++] = 128 | s >> 12 & 63, t[n++] = 128 | s >> 6 & 63, t[n++] = 128 | 63 & s
                                    }
                                }
                                t[n] = 0
                            }
                        }(e, Nv, t, n)
                }
                return t
            },
            array: function (e) {
                var t, n, r = ag(e.length);
                return t = e, n = r, Iv.set(t, n), r
            }
        };
        var a = Pv(e),
            o = [],
            s = 0;
        if (r)
            for (var l = 0; l < r.length; l++) {
                var c = i[n[l]];
                c ? (0 === s && (s = ig()), o[l] = c(r[l])) : o[l] = r[l]
            }
        var u, d, h, p = a.apply(null, o);
        return u = p, p = "string" === t ? (d = u) ? function (e, t, n) {
            for (var r = t + n, i = t; e[i] && !(r <= i);) ++i;
            if (16 < i - t && e.subarray && Rv) return Rv.decode(e.subarray(t, i));
            for (var a = ""; t < i;) {
                var o = e[t++];
                if (128 & o) {
                    var s = 63 & e[t++];
                    if (192 != (224 & o)) {
                        var l = 63 & e[t++];
                        if ((o = 224 == (240 & o) ? (15 & o) << 12 | s << 6 | l : (7 & o) << 18 | s << 12 | l << 6 | 63 & e[t++]) < 65536) a += String.fromCharCode(o);
                        else {
                            var c = o - 65536;
                            a += String.fromCharCode(55296 | c >> 10, 56320 | 1023 & c)
                        }
                    } else a += String.fromCharCode((31 & o) << 6 | s)
                } else a += String.fromCharCode(o)
            }
            return a
        }(Nv, d, h) : "" : "boolean" === t ? Boolean(u) : u, 0 !== s && og(s), p
    }
    var Rv = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
    "undefined" != typeof TextDecoder && new TextDecoder("utf-16le");
    var Dv, Iv, Nv, Ov;
    var Fv, Bv = cv.TOTAL_MEMORY || 16777216;

    function zv(e) {
        for (; 0 < e.length;) {
            var t = e.shift();
            if ("function" != typeof t) {
                var n = t.func;
                "number" == typeof n ? void 0 === t.arg ? cv.dynCall_v(n) : cv.dynCall_vi(n, t.arg) : n(void 0 === t.arg ? null : t.arg)
            } else t()
        }
    }(Av = cv.wasmMemory ? cv.wasmMemory : new Sv.Memory({
        initial: Bv / 65536,
        maximum: Bv / 65536
    })) && (Dv = Av.buffer), Bv = Dv.byteLength, Dv = Fv = Dv, cv.HEAP8 = Iv = new Int8Array(Fv), cv.HEAP16 = new Int16Array(Fv), cv.HEAP32 = Ov = new Int32Array(Fv), cv.HEAPU8 = Nv = new Uint8Array(Fv), cv.HEAPU16 = new Uint16Array(Fv), cv.HEAPU32 = new Uint32Array(Fv), cv.HEAPF32 = new Float32Array(Fv), cv.HEAPF64 = new Float64Array(Fv), Ov[263312] = 6296288;
    var Uv = [],
        Vv = [],
        Gv = [],
        kv = [];
    var jv = 0,
        Wv = null;

    function Xv(e) {
        throw cv.onAbort && cv.onAbort(e), wv(e += ""), Mv(e), Ev = !0, e = "abort(" + e + "). Build with -s ASSERTIONS=1 for more info.", new Sv.RuntimeError(e)
    }
    cv.preloadedImages = {}, cv.preloadedAudios = {};
    var Hv = "data:application/octet-stream;base64,";

    function Yv(e) {
        return String.prototype.startsWith ? e.startsWith(Hv) : 0 === e.indexOf(Hv)
    }
    var qv, Zv = "xz.wasm";

    function Qv() {
        try {
            if (bv) return new Uint8Array(bv);
            var e = $v(Zv);
            if (e) return e;
            if (gv) return gv(Zv);
            throw "both async and sync fetching of the wasm failed"
        } catch (e) {
            Xv(e)
        }
    }

    function Kv(e) {
        for (var t = [], n = 0; n < e.length; n++) {
            var r = e[n];
            255 < r && (r &= 255), t.push(String.fromCharCode(r))
        }
        return t.join("")
    }
    Yv(Zv) || (qv = Zv, Zv = cv.locateFile ? cv.locateFile(qv, xv) : xv + qv), Vv.push({
        func: function () {
            rg()
        }
    });
    var Jv = "function" == typeof atob ? atob : function (e) {
        var t, n, r, i, a, o, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            l = "",
            c = 0;
        for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); t = s.indexOf(e.charAt(c++)) << 2 | (i = s.indexOf(e.charAt(c++))) >> 4, n = (15 & i) << 4 | (a = s.indexOf(e.charAt(c++))) >> 2, r = (3 & a) << 6 | (o = s.indexOf(e.charAt(c++))), l += String.fromCharCode(t), 64 !== a && (l += String.fromCharCode(n)), 64 !== o && (l += String.fromCharCode(r)), c < e.length;);
        return l
    };

    function $v(e) {
        if (Yv(e)) return function (t) {
            if ("boolean" == typeof mv && mv) {
                var n;
                try {
                    n = Buffer.from(t, "base64")
                } catch (e) {
                    n = new Buffer(t, "base64")
                }
                return new Uint8Array(n.buffer, n.byteOffset, n.byteLength)
            }
            try {
                for (var e = Jv(t), r = new Uint8Array(e.length), i = 0; i < e.length; ++i) r[i] = e.charCodeAt(i);
                return r
            } catch (e) {
                throw new Error("Converting base64 string to bytes failed.")
            }
        }(e.slice(Hv.length))
    }
    var eg = {
            emscripten_memcpy_big: function (e, t, n) {
                Nv.set(Nv.subarray(t, t + n), e)
            },
            emscripten_resize_heap: function (e) {
                Xv("OOM")
            },
            memory: Av,
            table: Tv
        },
        tg = function () {
            var t = {
                env: eg,
                wasi_snapshot_preview1: eg
            };

            function n(e, t) {
                var n = e.exports;
                cv.asm = n,
                    function () {
                        if (jv--, cv.monitorRunDependencies && cv.monitorRunDependencies(jv), 0 == jv && Wv) {
                            var e = Wv;
                            Wv = null, e()
                        }
                    }()
            }

            function r(e) {
                n(e.instance)
            }

            function i(e) {
                return (bv || !pv && !fv || "function" != typeof fetch ? new Promise(function (e, t) {
                    e(Qv())
                }) : fetch(Zv, {
                    credentials: "same-origin"
                }).then(function (e) {
                    if (!e.ok) throw "failed to load wasm binary file at '" + Zv + "'";
                    return e.arrayBuffer()
                }).catch(function () {
                    return Qv()
                })).then(function (e) {
                    return Sv.instantiate(e, t)
                }).then(e, function (e) {
                    Mv("failed to asynchronously prepare wasm: " + e), Xv(e)
                })
            }
            if (jv++, cv.monitorRunDependencies && cv.monitorRunDependencies(jv), cv.instantiateWasm) try {
                return cv.instantiateWasm(t, n)
            } catch (e) {
                return Mv("Module.instantiateWasm callback failed with error: " + e), !1
            }
            return function () {
                if (bv || "function" != typeof Sv.instantiateStreaming || Yv(Zv) || "function" != typeof fetch) return i(r);
                fetch(Zv, {
                    credentials: "same-origin"
                }).then(function (e) {
                    return Sv.instantiateStreaming(e, t).then(r, function (e) {
                        Mv("wasm streaming compile failed: " + e), Mv("falling back to ArrayBuffer instantiation"), i(r)
                    })
                })
            }(), {}
        }();
    cv.asm = tg;
    var ng, rg = cv.___wasm_call_ctors = function () {
            return (rg = cv.___wasm_call_ctors = cv.asm.__wasm_call_ctors).apply(null, arguments)
        },
        ig = (cv._init_decompressor = function () {
            return (cv._init_decompressor = cv.asm.init_decompressor).apply(null, arguments)
        }, cv._decompress = function () {
            return (cv._decompress = cv.asm.decompress).apply(null, arguments)
        }, cv._get_in_buffer_ptr = function () {
            return (cv._get_in_buffer_ptr = cv.asm.get_in_buffer_ptr).apply(null, arguments)
        }, cv._get_out_buffer_ptr = function () {
            return (cv._get_out_buffer_ptr = cv.asm.get_out_buffer_ptr).apply(null, arguments)
        }, cv._in_buffer_set_pos = function () {
            return (cv._in_buffer_set_pos = cv.asm.in_buffer_set_pos).apply(null, arguments)
        }, cv._in_buffer_set_size = function () {
            return (cv._in_buffer_set_size = cv.asm.in_buffer_set_size).apply(null, arguments)
        }, cv._out_buffer_set_pos = function () {
            return (cv._out_buffer_set_pos = cv.asm.out_buffer_set_pos).apply(null, arguments)
        }, cv._out_buffer_set_size = function () {
            return (cv._out_buffer_set_size = cv.asm.out_buffer_set_size).apply(null, arguments)
        }, cv._get_curr_output_length = function () {
            return (cv._get_curr_output_length = cv.asm.get_curr_output_length).apply(null, arguments)
        }, cv._is_input_end_reached = function () {
            return (cv._is_input_end_reached = cv.asm.is_input_end_reached).apply(null, arguments)
        }, cv.stackSave = function () {
            return (ig = cv.stackSave = cv.asm.stackSave).apply(null, arguments)
        }),
        ag = cv.stackAlloc = function () {
            return (ag = cv.stackAlloc = cv.asm.stackAlloc).apply(null, arguments)
        },
        og = cv.stackRestore = function () {
            return (og = cv.stackRestore = cv.asm.stackRestore).apply(null, arguments)
        },
        sg = cv.__growWasmMemory = function () {
            return (sg = cv.__growWasmMemory = cv.asm.__growWasmMemory).apply(null, arguments)
        };

    function lg(e) {
        function t() {
            ng || (ng = !0, Ev || (zv(Vv), zv(Gv), cv.onRuntimeInitialized && cv.onRuntimeInitialized(), function () {
                if (cv.postRun)
                    for ("function" == typeof cv.postRun && (cv.postRun = [cv.postRun]); cv.postRun.length;) e = cv.postRun.shift(), kv.unshift(e);
                var e;
                zv(kv)
            }()))
        }
        0 < jv || (function () {
            if (cv.preRun)
                for ("function" == typeof cv.preRun && (cv.preRun = [cv.preRun]); cv.preRun.length;) e = cv.preRun.shift(), Uv.unshift(e);
            var e;
            zv(Uv)
        }(), 0 < jv || (cv.setStatus ? (cv.setStatus("Running..."), setTimeout(function () {
            setTimeout(function () {
                cv.setStatus("")
            }, 1), t()
        }, 1)) : t()))
    }
    if (cv.asm = tg, cv.cwrap = function (e, t, n, r) {
            var i = (n = n || []).every(function (e) {
                return "number" === e
            });
            return "string" !== t && i && !r ? Pv(e) : function () {
                return Lv(e, t, n, arguments)
            }
        }, Wv = function e() {
            ng || lg(), ng || (Wv = e)
        }, cv.run = lg, cv.preInit)
        for ("function" == typeof cv.preInit && (cv.preInit = [cv.preInit]); 0 < cv.preInit.length;) cv.preInit.pop()();
    lg(), cv._lock = !1;
    var cg = ["", "Memory allocation failed", "Memory usage limit reached", "Unsupported check; not verifying file integrity", "Not an .xz file", "Unsupported options in the .xz headers", "File is corrupt", "Unknown decompression bug"];

    function ug(e) {
        this.manager = void 0 !== e ? e : Lu
    }
    Object.assign(ug.prototype, {
        crossOrigin: "Anonymous",
        load: function (r, i, a, o) {
            void 0 === r && (r = ""), void 0 !== this.path && (r = this.path + r);
            var s = this,
                e = Cu.get(r);
            if (void 0 !== e) return s.manager.itemStart(r), setTimeout(function () {
                i && i(e), s.manager.itemEnd(r)
            }, 0), e;
            var t = new XMLHttpRequest;
            return t.open("GET", r, !0), t.addEventListener("load", function (e) {
                var t = e.target.response;
                if (200 === this.status || 0 === this.status) {
                    0 === this.status && console.warn("v3d.XZLoader: HTTP Status 0 received.");
                    var n = function () {
                        cv._lock ? setTimeout(n, 1) : s.decompressArrayBuffer(t, function (e) {
                            setTimeout(function () {
                                i && i(e), s.manager.itemEnd(r), Cu.add(r, e)
                            }, 1)
                        }, function (e) {
                            a && a((+e + 2) / 3)
                        }, function (e) {
                            o && o(e), s.manager.itemEnd(r), s.manager.itemError(r)
                        })
                    };
                    setTimeout(n, 1)
                } else o && o(e), s.manager.itemEnd(r), s.manager.itemError(r)
            }, !1), a && t.addEventListener("progress", function (e) {
                if (e.lengthComputable) var t = e.loaded / e.total;
                else t = 1;
                a(2 * t / 3)
            }, !1), t.addEventListener("error", function (e) {
                o && o(e), s.manager.itemEnd(r), s.manager.itemError(r)
            }, !1), t.responseType = "arraybuffer", t.send(null), s.manager.itemStart(r), t
        },
        setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        },
        setPath: function (e) {
            return this.path = e, this
        },
        decompressArrayBuffer: function (e, l, c, u) {
            var d = this;

            function h(e) {
                var t = d._emGetInBufferPtr();
                cv.HEAPU8.set(e, t), d._emInBufferSetPos(0), d._emInBufferSetSize(e.length), p()
            }

            function p() {
                d._emOutBufferSetPos(0)
            }
            cv._lock = !0;
            var t = d._emInitDecompressor();
            if (0 != t) return console.error("XZLoader._emInitDecompressor: error code " + t + " (" + cg[t] + ")"), void(u && u(t));
            var f = new Uint8Array(e),
                m = f.length,
                v = [],
                g = 0,
                _ = Math.min(524288, m),
                y = 0;
            h(f.subarray(g, _)),
                function e() {
                    var t, n, r = d._emDecompress();
                    if (r) console.error("XZLoader._emDecompress: error code " + r + " (" + cg[r] + ")"), cv._lock = !1, u && u(r);
                    else {
                        var i = d._emGetCurrOutputLength();
                        if (v.push((t = i, n = d._emGetOutBufferPtr(), new Uint8Array(cv.HEAPU8.subarray(n, n + t)))), p(), d._emIsInputEndReached() && (g = _, _ = Math.min(_ + 524288, m), h(f.subarray(g, _))), c && c(g / m), g == _) {
                            var a = v.reduce(function (e, t, n, r) {
                                    return e + t.length
                                }, 0),
                                o = new Uint8Array(a),
                                s = 0;
                            v.forEach(function (e) {
                                o.set(e, s), s += e.length
                            }), cv._lock = !1, l && l(o.buffer)
                        } else ++y % 2 == 0 ? setTimeout(e, 1) : e()
                    }
                }()
        },
        _emInitDecompressor: cv.cwrap("init_decompressor", "number"),
        _emDecompress: cv.cwrap("decompress", "number"),
        _emGetInBufferPtr: cv.cwrap("get_in_buffer_ptr", "number"),
        _emGetOutBufferPtr: cv.cwrap("get_out_buffer_ptr", "number"),
        _emInBufferSetPos: cv.cwrap("in_buffer_set_pos", null, ["number"]),
        _emInBufferSetSize: cv.cwrap("in_buffer_set_size", null, ["number"]),
        _emOutBufferSetPos: cv.cwrap("out_buffer_set_pos", null, ["number"]),
        _emOutBufferSetSize: cv.cwrap("out_buffer_set_size", null, ["number"]),
        _emGetCurrOutputLength: cv.cwrap("get_curr_output_length", "number"),
        _emIsInputEndReached: cv.cwrap("is_input_end_reached", "number")
    });

    function dg(e) {
        Fu.call(this, e), this.type = tt
    }

    function hg(e, t) {
        ec.call(this, e, t), this.type = "BlenderTextGeometry", this.computeBoundingBox();
        var n, r, i = this.boundingBox.max.x - this.boundingBox.min.x,
            a = this.boundingBox.max.y - this.boundingBox.min.y;
        switch (t.alignX) {
            case "left":
                n = 0;
                break;
            case "center":
                n = -.5 * i;
                break;
            case "right":
                n = -i
        }
        switch (t.alignY) {
            case "bottom":
                r = 0;
                break;
            case "center":
                r = -.5 * a;
                break;
            case "top":
                r = -a
        }(0 < Math.abs(n) || 0 < Math.abs(r)) && this.translate(n, r, 0)
    }

    function pg() {
        this.positions = [], this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], this.counters = [], this.geometry = new ni, this.widthCallback = null
    }

    function fg(e, t, n, r, i) {
        var a;
        if (e = e.subarray || e.slice ? e : e.buffer, n = n.subarray || n.slice ? n : n.buffer, e = t ? e.subarray ? e.subarray(t, i && t + i) : e.slice(t, i && t + i) : e, n.set) n.set(e, r);
        else
            for (a = 0; a < e.length; a++) n[a + r] = e[a];
        return n
    }

    function mg(e) {
        this.headEdge = this.tailEdge = e, this.headIndex = e.index0, this.tailIndex = e.index1, this.indexCount = 2
    }

    function vg(e, t) {
        this.index0 = e, this.index1 = t, this.edge0 = null, this.edge1 = null
    }

    function gg() {
        this.geometry = new ni
    }

    function _g(e, t, n) {
        var r = e.headIndex,
            i = e.tailIndex;
        return t[r][0] || t[i][0] || n[r][0] || n[i][0] || null
    }

    function yg(e) {
        xc.call(this), this.type = "MeshLineMaterial", this.lineWidth = 1, this.sizeAttenuation = 1, this.color = new Pr(16777215), this.opacity = 1, this.useMap = 0, this.map = null, this.useAlphaMap = 0, this.alphaMap = null, this.resolution = new qt(1, 1), this.visibility = 1, this.alphaTest = 0, this.repeat = new qt(1, 1), this.uniforms = {
            lineWidth: {
                value: 1
            },
            sizeAttenuation: {
                value: 1
            },
            color: {
                value: new Pr(16777215)
            },
            opacity: {
                value: 1
            },
            useMap: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            useAlphaMap: {
                value: 0
            },
            resolution: {
                value: new qt(1, 1)
            },
            visibility: {
                value: 1
            },
            alphaTest: {
                value: 0
            },
            repeat: {
                value: new qt(1, 1)
            }
        }, this.vertexShader = Ki.raw_meshline_vert, this.fragmentShader = Ki.raw_meshline_frag, this.setValues(e)
    }
    dg.prototype = Object.assign(Object.create(Fu.prototype), {
        constructor: dg,
        parse: function (e) {
            function _(e, t) {
                switch (e) {
                    case 1:
                        console.error("RGBELoader Read Error: " + (t || ""));
                        break;
                    case 2:
                        console.error("RGBELoader Write Error: " + (t || ""));
                        break;
                    case 3:
                        console.error("RGBELoader Bad File Format: " + (t || ""));
                        break;
                    default:
                        console.error("RGBELoader: Error: " + (t || ""))
                }
                return -1
            }

            function l(e, t, n) {
                t = t || 1024;
                for (var r = e.pos, i = -1, a = 0, o = "", s = String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                    (i = s.indexOf("\n")) < 0 && a < t && r < e.byteLength;) o += s, a += s.length, r += 128, s += String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                return -1 < i && (!1 !== n && (e.pos += a + i + 1), o + s.slice(0, i))
            }
            var a, o, t = (a = new Float32Array(1), o = new Int32Array(a.buffer), function (e, t, n, r) {
                var i = e[t + 3],
                    a = Math.pow(2, i - 128) / 255;
                n[r + 0] = s(e[t + 0] * a), n[r + 1] = s(e[t + 1] * a), n[r + 2] = s(e[t + 2] * a)
            });

            function s(e) {
                a[0] = e;
                var t = o[0],
                    n = t >> 16 & 32768,
                    r = t >> 12 & 2047,
                    i = t >> 23 & 255;
                return i < 103 ? n : 142 < i ? (n |= 31744, n |= (255 == i ? 0 : 1) && 8388607 & t) : i < 113 ? n |= ((r |= 2048) >> 114 - i) + (r >> 113 - i & 1) : (n |= i - 112 << 10 | r >> 1, n += 1 & r)
            }
            var n = new Uint8Array(e);
            n.pos = 0;
            var r, i, c, u, d, h, p = function (e) {
                var t, n, r = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                    i = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                    a = /^\s*FORMAT=(\S+)\s*$/,
                    o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                    s = {
                        valid: 0,
                        string: "",
                        comments: "",
                        programtype: "RGBE",
                        format: "",
                        gamma: 1,
                        exposure: 1,
                        width: 0,
                        height: 0
                    };
                if (e.pos >= e.byteLength || !(t = l(e))) return _(1, "no header found");
                if (!(n = t.match(/^#\?(\S+)$/))) return _(3, "bad initial token");
                for (s.valid |= 1, s.programtype = n[1], s.string += t + "\n"; !1 !== (t = l(e));)
                    if (s.string += t + "\n", "#" !== t.charAt(0)) {
                        if ((n = t.match(r)) && (s.gamma = parseFloat(n[1], 10)), (n = t.match(i)) && (s.exposure = parseFloat(n[1], 10)), (n = t.match(a)) && (s.valid |= 2, s.format = n[1]), (n = t.match(o)) && (s.valid |= 4, s.height = parseInt(n[1], 10), s.width = parseInt(n[2], 10)), 2 & s.valid && 4 & s.valid) break
                    } else s.comments += t + "\n";
                return 2 & s.valid ? 4 & s.valid ? s : _(3, "missing image size specifier") : _(3, "missing format specifier")
            }(n);
            if (-1 !== p) {
                var f = p.width,
                    m = p.height,
                    v = function (e, t, n) {
                        var r, i, a, o, s, l, c, u, d, h, p, f, m, v = t,
                            g = n;
                        if (v < 8 || 32767 < v || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
                        if (v !== (e[2] << 8 | e[3])) return _(3, "wrong scanline width");
                        if (!(r = new Uint8Array(4 * t * n)) || !r.length) return _(4, "unable to allocate buffer space");
                        for (a = i = 0, u = 4 * v, m = new Uint8Array(4), l = new Uint8Array(u); 0 < g && a < e.byteLength;) {
                            if (a + 4 > e.byteLength) return _(1);
                            if (m[0] = e[a++], m[1] = e[a++], m[2] = e[a++], m[3] = e[a++], 2 != m[0] || 2 != m[1] || (m[2] << 8 | m[3]) != v) return _(3, "bad rgbe scanline format");
                            for (c = 0; c < u && a < e.byteLength;) {
                                if ((f = 128 < (o = e[a++])) && (o -= 128), 0 === o || u < c + o) return _(3, "bad scanline data");
                                if (f)
                                    for (s = e[a++], d = 0; d < o; d++) l[c++] = s;
                                else l.set(e.subarray(a, a + o), c), c += o, a += o
                            }
                            for (h = v, d = 0; d < h; d++) p = 0, r[i] = l[d + p], p += v, r[i + 1] = l[d + p], p += v, r[i + 2] = l[d + p], p += v, r[i + 3] = l[d + p], i += 4;
                            g--
                        }
                        return r
                    }(n.subarray(n.pos), f, m);
                if (-1 !== v) {
                    switch (this.type) {
                        case tt:
                            var g = v,
                                y = S,
                                x = tt;
                            break;
                        case it:
                            for (var b = v.length / 4 * 3, w = new Float32Array(b), M = 0; M < b; M++) c = w, u = 3 * M, 0, d = (r = v)[(i = 4 * M) + 3], h = Math.pow(2, d - 128) / 255, c[u + 0] = r[i + 0] * h, c[u + 1] = r[i + 1] * h, c[u + 2] = r[i + 2] * h;
                            g = w, y = st, x = it;
                            break;
                        case at:
                            b = v.length / 4 * 3;
                            var A = new Uint16Array(b);
                            for (M = 0; M < b; M++) t(v, 4 * M, A, 3 * M);
                            g = A, y = st, x = at;
                            break;
                        default:
                            console.error("v3d.RGBELoader: unsupported type: ", this.type)
                    }
                    return {
                        width: f,
                        height: m,
                        data: g,
                        header: p.string,
                        gamma: p.gamma,
                        exposure: p.exposure,
                        format: y,
                        type: x
                    }
                }
            }
            return null
        },
        setDataType: function (e) {
            return this.type = e, this
        },
        load: function (e, n, t, r) {
            return Fu.prototype.load.call(this, e, function (e, t) {
                switch (e.type) {
                    case tt:
                        e.encoding = Et, e.minFilter = Ze, e.magFilter = Ze, e.generateMipmaps = !1, e.flipY = !0;
                        break;
                    case it:
                    case at:
                        e.encoding = At, e.minFilter = Je, e.magFilter = Je, e.generateMipmaps = !1, e.flipY = !0
                }
                n && n(e, t)
            }, t, r)
        }
    }), ((hg.prototype = Object.create(ec.prototype)).constructor = hg).prototype.cloneWithText = function (e) {
        var t = this.parameters.parameters;
        return new hg(e, {
            font: t.font,
            size: t.size,
            height: t.height,
            curveSegments: t.curveSegments,
            bevelEnabled: t.bevelEnabled,
            bevelThickness: t.bevelThickness,
            bevelSize: t.bevelSize,
            alignX: t.alignX,
            alignY: t.alignY
        })
    }, pg.prototype.setGeometry = function (e, t) {
        if (this.widthCallback = t, this.positions = [], this.counters = [], e instanceof Ei)
            for (var n = 0; n < e.vertices.length; n++) {
                var r = e.vertices[n];
                t = n / e.vertices.length;
                this.positions.push(r.x, r.y, r.z), this.positions.push(r.x, r.y, r.z), this.counters.push(t), this.counters.push(t)
            }
        if (e instanceof Float32Array || e instanceof Array)
            for (n = 0; n < e.length; n += 3) {
                t = n / e.length;
                this.positions.push(e[n], e[n + 1], e[n + 2]), this.positions.push(e[n], e[n + 1], e[n + 2]), this.counters.push(t), this.counters.push(t)
            }
        this.process()
    }, pg.prototype.compareV3 = function (e, t) {
        var n = 6 * e,
            r = 6 * t;
        return this.positions[n] === this.positions[r] && this.positions[1 + n] === this.positions[1 + r] && this.positions[2 + n] === this.positions[2 + r]
    }, pg.prototype.copyV3 = function (e) {
        var t = 6 * e;
        return [this.positions[t], this.positions[1 + t], this.positions[2 + t]]
    }, pg.prototype.process = function () {
        var e, t, n = this.positions.length / 6;
        this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [];
        for (var r = 0; r < n; r++) this.side.push(1), this.side.push(-1);
        for (r = 0; r < n; r++) e = this.widthCallback ? this.widthCallback(r / (n - 1)) : 1, this.width.push(e), this.width.push(e);
        for (r = 0; r < n; r++) this.uvs.push(r / (n - 1), 0), this.uvs.push(r / (n - 1), 1);
        t = this.compareV3(0, n - 1) ? this.copyV3(n - 2) : this.copyV3(0), this.previous.push(t[0], t[1], t[2]), this.previous.push(t[0], t[1], t[2]);
        for (r = 0; r < n - 1; r++) t = this.copyV3(r), this.previous.push(t[0], t[1], t[2]), this.previous.push(t[0], t[1], t[2]);
        for (r = 1; r < n; r++) t = this.copyV3(r), this.next.push(t[0], t[1], t[2]), this.next.push(t[0], t[1], t[2]);
        t = this.compareV3(n - 1, 0) ? this.copyV3(1) : this.copyV3(n - 1), this.next.push(t[0], t[1], t[2]), this.next.push(t[0], t[1], t[2]);
        for (r = 0; r < n - 1; r++) {
            var i = 2 * r;
            this.indices_array.push(i, 1 + i, 2 + i), this.indices_array.push(2 + i, 1 + i, 3 + i)
        }
        this.attributes ? (this.attributes.position.copyArray(new Float32Array(this.positions)), this.attributes.position.needsUpdate = !0, this.attributes.previous.copyArray(new Float32Array(this.previous)), this.attributes.previous.needsUpdate = !0, this.attributes.next.copyArray(new Float32Array(this.next)), this.attributes.next.needsUpdate = !0, this.attributes.side.copyArray(new Float32Array(this.side)), this.attributes.side.needsUpdate = !0, this.attributes.width.copyArray(new Float32Array(this.width)), this.attributes.width.needsUpdate = !0, this.attributes.uv.copyArray(new Float32Array(this.uvs)), this.attributes.uv.needsUpdate = !0, this.attributes.counters.copyArray(new Float32Array(this.counters)), this.attributes.counters.needsUpdate = !0, this.attributes.index.copyArray(new Uint16Array(this.indices_array)), this.attributes.index.needsUpdate = !0) : this.attributes = {
            position: new zr(new Float32Array(this.positions), 3),
            previous: new zr(new Float32Array(this.previous), 3),
            next: new zr(new Float32Array(this.next), 3),
            side: new zr(new Float32Array(this.side), 1),
            width: new zr(new Float32Array(this.width), 1),
            uv: new zr(new Float32Array(this.uvs), 2),
            counters: new zr(new Float32Array(this.counters), 1),
            index: new zr(new Uint16Array(this.indices_array), 1)
        }, this.geometry.setAttribute("position", this.attributes.position), this.geometry.setAttribute("previous", this.attributes.previous), this.geometry.setAttribute("next", this.attributes.next), this.geometry.setAttribute("side", this.attributes.side), this.geometry.setAttribute("width", this.attributes.width), this.geometry.setAttribute("uv", this.attributes.uv), this.geometry.setAttribute("counters", this.attributes.counters), this.geometry.setIndex(this.attributes.index)
    }, pg.prototype.advance = function (e) {
        var t = this.attributes.position.array,
            n = this.attributes.previous.array,
            r = this.attributes.next.array,
            i = t.length;
        fg(t, 0, n, 0, i), fg(t, 6, t, 0, i - 6), t[i - 6] = e.x, t[i - 5] = e.y, t[i - 4] = e.z, t[i - 3] = e.x, t[i - 2] = e.y, t[i - 1] = e.z, fg(t, 6, r, 0, i - 6), r[i - 6] = e.x, r[i - 5] = e.y, r[i - 4] = e.z, r[i - 3] = e.x, r[i - 2] = e.y, r[i - 1] = e.z, this.attributes.position.needsUpdate = !0, this.attributes.previous.needsUpdate = !0, this.attributes.next.needsUpdate = !0
    }, Object.assign(mg.prototype, {
        mergeStrip: function (e) {
            var t = this.headIndex,
                n = e.headIndex,
                r = this.tailIndex,
                i = e.tailIndex;
            t == n ? (this.headEdge.linkToEdge(e.headEdge), e.headEdge.linkToEdge(this.headEdge), this.headEdge = e.tailEdge, this.headIndex = e.tailIndex, this.indexCount += e.indexCount - 1) : t == i ? (this.headEdge.linkToEdge(e.tailEdge), e.tailEdge.linkToEdge(this.headEdge), this.headEdge = e.headEdge, this.headIndex = e.headIndex, this.indexCount += e.indexCount - 1) : r == n ? (this.tailEdge.linkToEdge(e.headEdge), e.headEdge.linkToEdge(this.tailEdge), this.tailEdge = e.tailEdge, this.tailIndex = e.tailIndex, this.indexCount += e.indexCount - 1) : r == i && (this.tailEdge.linkToEdge(e.tailEdge), e.tailEdge.linkToEdge(this.tailEdge), this.tailEdge = e.headEdge, this.tailIndex = e.headIndex, this.indexCount += e.indexCount - 1)
        },
        getIndicesFlat: function () {
            for (var e = new Float32Array(this.indexCount), t = 0, n = null, r = this.headEdge, i = e[t++] = this.headIndex; null !== r;) {
                i = r.index0 == i ? r.index1 : r.index0;
                e[t++] = i;
                var a = r.edge0;
                a != n && null !== a || (a = r.edge1), a == n && (a = null), n = r, r = a
            }
            return e
        }
    }), Object.assign(vg.prototype, {
        linkToEdge: function (e) {
            null === this.edge0 ? this.edge0 = e : null === this.edge1 && (this.edge1 = e)
        }
    }), Object.assign(gg.prototype, {
        fromBufferGeometry: function (e) {
            var r = e.getAttribute("position"),
                t = e.getIndex();
            if (void 0 !== r) {
                var i = [];
                if (null !== t)(function (e) {
                    for (var t = e.length % 2 ? e.length - 1 : e.length, n = {}, r = {}, i = 0; i < t; i += 2) {
                        var a = (u = new mg(new vg(e[i], e[i + 1]))).headIndex,
                            o = u.tailIndex;
                        n[a] = n[a] || [], n[o] = n[o] || [], r[a] = r[a] || [], r[o] = r[o] || [], n[a].push(u), r[o].push(u)
                    }
                    var s = new Dc.LinkMap;
                    for (var l in n) n[l].length && s.push(new Dc.LinkMapNode(n[l]), l);
                    for (var c = [], u = s.first && s.first.value[0]; u;) {
                        n[a = u.headIndex].splice(n[a].indexOf(u), 1), r[o = u.tailIndex].splice(r[o].indexOf(u), 1), 0 == n[a].length && s.removeNodeByKey(a);
                        for (var d = _g(u, n, r); null !== d;) n[a = d.headIndex].splice(n[a].indexOf(d), 1), r[o = d.tailIndex].splice(r[o].indexOf(d), 1), 0 == n[a].length && s.removeNodeByKey(a), u.mergeStrip(d), d = _g(u, n, r);
                        c.push(u), u = s.first && s.first.value[0]
                    }
                    return c
                })(t.array).forEach(function (e) {
                    var t = new pg,
                        n = new Float32Array(3 * e.indexCount);
                    e.getIndicesFlat().forEach(function (e, t) {
                        n.set(r.array.subarray(3 * e, 3 * e + 3), 3 * t)
                    }), t.setGeometry(n), i.push(t)
                });
                else {
                    var n = new pg;
                    n.setGeometry(r.array), i.push(n)
                }
                var a = [],
                    o = [],
                    s = [],
                    l = [],
                    c = [],
                    u = [],
                    d = [],
                    h = [],
                    p = 0;
                i.forEach(function (e) {
                    a = a.concat(e.positions), o = o.concat(e.previous), s = s.concat(e.next), l = l.concat(e.side), c = c.concat(e.width), u = u.concat(e.uvs), d = d.concat(e.counters);
                    var t = e.indices_array.map(function (e) {
                        return e + p
                    });
                    h = h.concat(t), p += e.positions.length / 3
                }), this.geometry.setAttribute("position", new zr(new Float32Array(a), 3)), this.geometry.setAttribute("previous", new zr(new Float32Array(o), 3)), this.geometry.setAttribute("next", new zr(new Float32Array(s), 3)), this.geometry.setAttribute("side", new zr(new Float32Array(l), 1)), this.geometry.setAttribute("width", new zr(new Float32Array(c), 1)), this.geometry.setAttribute("uv", new zr(new Float32Array(u), 2)), this.geometry.setAttribute("counters", new zr(new Float32Array(d), 1));
                var f = 65535 < yn(h) ? Uint32Array : Uint16Array;
                this.geometry.setIndex(new zr(new f(h), 1))
            }
        }
    }), yg.prototype = Object.assign(Object.create(xc.prototype), {
        constructor: yg,
        isMeshLineMaterial: !0,
        copy: function (e) {
            return xc.prototype.copy.call(this, e), this.lineWidth = e.lineWidth, this.sizeAttenuation = e.sizeAttenuation, this.color.copy(e.color), this.opacity = e.opacity, this.useMap = e.useMap, this.map = e.map, this.useAlphaMap = e.useAlphaMap, this.alphaMap = e.alphaMap, this.resolution.copy(e.resolution), this.visibility = e.visibility, this.alphaTest = e.alphaTest, this.repeat.copy(e.repeat), this
        }
    });
    var xg = ["TEXTURE_BL", "TEX_IMAGE_BL", "TEX_ENVIRONMENT_BL", "TEXTURE_GF", "TEX_ENVIRONMENT_MX", "BITMAP_MX", "BITMAP_ENV_MX", "REFLECT_REFRACT_MX", "AI_SKYDOME_LIGHT_MY", "TEXTURE", "TEX_IMAGE", "TEX_ENVIRONMENT", "TEX_ENVIRONMENT_MAX", "BITMAP_MAX", "BITMAP_ENV_MAX", "REFLECT_REFRACT_MAX"];

    function bg(e) {
        this.manager = void 0 !== e ? e : Lu, this.crossOrigin = "Anonymous", this.onProgress = null
    }

    function wg() {
        var n = {};
        return {
            get: function (e) {
                return n[e]
            },
            add: function (e, t) {
                n[e] = t
            },
            remove: function (e) {
                delete n[e]
            },
            removeAll: function () {
                n = {}
            }
        }
    }
    Object.assign(bg.prototype, {
        load: function (e, t, n, r) {
            var i = this;
            i.onProgress = n || function () {};
            var a = this.path && "string" == typeof this.path ? this.path : Md.extractUrlBase(e),
                o = -1 != e.indexOf(".xz", e.length - 3);
            if (o) var s = new ug(i.manager);
            else(s = new Iu(i.manager)).setResponseType("arraybuffer");

            function l(e) {
                i.onProgress && i.onProgress(.3 * e * 100)
            }
            var c = l;
            s instanceof Iu && (c = function (e) {
                var t = e.lengthComputable ? e.loaded / e.total : 1;
                l(t)
            }), s.load(e, function (e) {
                i.parse(e, a, t, r, o)
            }, c, r)
        },
        setCrossOrigin: function (e) {
            this.crossOrigin = e
        },
        setPath: function (e) {
            this.path = e
        },
        parse: function (e, t, s, n, r) {
            var i, l = this,
                a = {};
            i = Kg(new Uint8Array(e, 0, 4)) === Tg ? (a[Mg.KHR_BINARY_GLTF] = new Pg(e), a[Mg.KHR_BINARY_GLTF].content) : Kg(new Uint8Array(e));
            var o = JSON.parse(i);
            void 0 === o.asset || o.asset.version[0] < 2 ? n(new Error("v3d.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")) : (o.extensionsUsed && (0 <= o.extensionsUsed.indexOf(Mg.S8S_V3D_DATA) && (a[Mg.S8S_V3D_DATA] = new Ag(o)), 0 <= o.extensionsUsed.indexOf(Mg.S8S_V3D_MATERIAL_DATA) && (a[Mg.S8S_V3D_MATERIAL_DATA] = new Sg(o))), new e_(o, a, {
                path: t || this.path,
                crossOrigin: this.crossOrigin,
                loadBinXZ: r,
                manager: this.manager,
                onProgress: function (e) {
                    l.onProgress && l.onProgress(e)
                }
            }).parse(function (e, t, n, r, i, a) {
                var o = {
                    scene: e,
                    scenes: t,
                    world: n,
                    cameras: r,
                    animations: i,
                    renderer: a
                };
                l.onProgress && l.onProgress(100), s(o)
            }, n))
        }
    });
    var Mg = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        S8S_V3D_ANIMATION_DATA: "S8S_v3d_animation_data",
        S8S_V3D_DATA: "S8S_v3d_data",
        S8S_V3D_CAMERA_DATA: "S8S_v3d_camera_data",
        S8S_V3D_MATERIAL_DATA: "S8S_v3d_material_data",
        S8S_V3D_MESH_DATA: "S8S_v3d_mesh_data",
        S8S_V3D_NODE_DATA: "S8S_v3d_node_data",
        S8S_V3D_SCENE_DATA: "S8S_v3d_scene_data",
        S8S_V3D_TEXTURE_DATA: "S8S_v3d_texture_data"
    };

    function Ag(e) {
        this.name = Mg.S8S_V3D_DATA;
        var t = e.extensions && e.extensions[Mg.S8S_V3D_DATA] || {};
        this.lights = {};
        var n = t.lights || {};
        for (var r in n) {
            var i, a = n[r],
                o = (new Pr).fromArray(a.color),
                s = a.intensity;
            switch (a.type) {
                case "point":
                    i = new vd(o, s);
                    break;
                case "directional":
                    i = new yd(o, s), xn(a.shadow) && xn(a.shadow.csm) && (i.shadow = new _d);
                    break;
                case "spot":
                    i = new fd(o, s);
                    break;
                case "hemisphere":
                    i = new pd(o, new Pr(0, 0, 0), s);
                    break;
                case "ambient":
                    i = new xd(o, s)
            }
            i && (xn(a.distance) && (i.distance = a.distance), xn(a.decay) && (i.decay = a.decay, "blender" == a.profile && 2 <= a.decay && (i.intensity /= 4 * Math.PI)), xn(a.angle) && (i.angle = a.angle), xn(a.penumbra) && (i.penumbra = a.penumbra), xn(a.shadow) ? (i.castShadow = !0, i.shadow.bias = a.shadow.bias, xn(a.shadow.expBias) && (i.shadow.expBias = a.shadow.expBias), xn(a.shadow.slopeScaledBias) && (i.shadow.slopeScaledBias = a.shadow.slopeScaledBias), i.shadow.radius = a.shadow.radius, i.shadow.mapSize.width = a.shadow.mapSize, i.shadow.mapSize.height = a.shadow.mapSize, i.shadow.camera.near = a.shadow.cameraNear, i.shadow.camera.far = a.shadow.cameraFar, i.isSpotLight ? (i.shadow.camera.fov = Yt.radToDeg(a.shadow.cameraFov), i.shadow.useMinFov90 = "blender" === a.profile) : i.isDirectionalLight && (xn(a.shadow.cameraOrthoLeft) && xn(a.shadow.cameraOrthoRight) && xn(a.shadow.cameraOrthoBottom) && xn(a.shadow.cameraOrthoTop) && (i.shadow.camera.left = a.shadow.cameraOrthoLeft, i.shadow.camera.right = a.shadow.cameraOrthoRight, i.shadow.camera.bottom = a.shadow.cameraOrthoBottom, i.shadow.camera.top = a.shadow.cameraOrthoTop), i.shadow.isDirectionalLightShadowCSM && (i.shadow.maxDistance = a.shadow.csm.maxDistance)), i.shadow.camera.updateProjectionMatrix()) : i.castShadow = !1, i.name = a.name || "light_" + r, this.lights[r] = i)
        }
        this.nodeGraphs = {};
        var l = t.nodeGraphs || [];
        for (var c in l) {
            var u = l[c];
            this.nodeGraphs[c] = u
        }
    }

    function Sg(e) {
        this.name = Mg.S8S_V3D_MATERIAL_DATA
    }
    Ag.prototype.loadCurves = function (e, t) {
        var n = e.extensions && e.extensions[Mg.S8S_V3D_DATA] || {};
        this.curves = {};
        var r = n.curves || {};
        for (var i in r) {
            var a, o = r[i];
            switch (o.type) {
                case "font":
                    var s = new Od(o.font),
                        l = 0 < o.bevelSize || 0 < o.bevelThickness,
                        c = new hg(o.text, {
                            font: s,
                            size: o.size,
                            height: o.height,
                            curveSegments: o.curveSegments,
                            bevelEnabled: l,
                            bevelThickness: o.bevelThickness,
                            bevelSize: o.bevelSize,
                            bevelSegments: o.bevelSegments,
                            alignX: o.alignX,
                            alignY: o.alignY
                        });
                    if (t && t[o.material]) var u = t[o.material];
                    else u = new Mc({
                        color: new Pr(.8, .8, .8)
                    });
                    a = new xi(c, u)
            }
            a && (a.name = o.name || "curve_" + i, this.curves[i] = a)
        }
    }, Sg.prototype.extendParams = function (e, t, n) {
        var r = t.extensions[this.name],
            i = [];
        if (xn(r.nodeGraph)) {
            var a = r.nodeGraph;
            e.nodeGraph = hu.nodeGraphFromExtGraph(a);
            for (var o = 0; o < a.nodes.length; o++) {
                var s = a.nodes[o];
                if (-1 < xg.indexOf(s.type)) {
                    var l = hu.nodeTexUniName(s.type, s.texture);
                    i.push(n.assignTextureNode(e, l, s.texture))
                }
            }
            var c = n.extensions[Mg.S8S_V3D_DATA];
            if (c)
                for (var u in e.additionalNodeGraphs = {}, c.nodeGraphs) {
                    a = c.nodeGraphs[u];
                    e.additionalNodeGraphs[u] = hu.nodeGraphFromExtGraph(a);
                    for (o = 0; o < a.nodes.length; o++) {
                        s = a.nodes[o];
                        if (-1 < xg.indexOf(s.type)) {
                            l = hu.nodeTexUniName(s.type, s.texture);
                            i.push(n.assignTextureNode(e, l, s.texture))
                        }
                    }
                }
        }
        return xn(r.profile) && (e.profile = r.profile), xn(r.renderSide) && (e.side = qg[r.renderSide]), xn(r.useShadows) && (e.receiveShadow = r.useShadows), xn(r.useCastShadows) && (e.castShadow = r.useCastShadows), xn(r.depthWrite) && (e.depthWrite = r.depthWrite), xn(r.depthTest) && (e.depthTest = r.depthTest), xn(r.dithering) && (e.dithering = r.dithering), Promise.all(i)
    };
    var Tg = "glTF",
        Eg = 12,
        Cg = {
            JSON: 1313821514,
            BIN: 5130562
        };

    function Pg(e) {
        this.name = Mg.KHR_BINARY_GLTF, this.content = null, this.body = null;
        var t = new DataView(e, 0, Eg);
        if (this.header = {
                magic: Kg(new Uint8Array(e.slice(0, 4))),
                version: t.getUint32(4, !0),
                length: t.getUint32(8, !0)
            }, this.header.magic !== Tg) throw new Error("v3d.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("v3d.GLTFLoader: Legacy binary file detected. Use GLTFLoader instead.");
        for (var n = new DataView(e, Eg), r = 0; r < n.byteLength;) {
            var i = n.getUint32(r, !0);
            r += 4;
            var a = n.getUint32(r, !0);
            if (r += 4, a === Cg.JSON) {
                var o = new Uint8Array(e, Eg + r, i);
                this.content = Kg(o)
            } else if (a === Cg.BIN) {
                var s = Eg + r;
                this.body = e.slice(s, s + i)
            }
            r += i
        }
        if (null === this.content) throw new Error("v3d.GLTFLoader: JSON content not found.")
    }
    var Lg = 0,
        Rg = 1,
        Dg = 2,
        Ig = 3,
        Ng = 4,
        Og = 5,
        Fg = 6,
        Bg = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        zg = {
            9728: Ze,
            9729: Je,
            9984: 1004,
            9985: 1007,
            9986: 1005,
            9987: 1008
        },
        Ug = {
            33071: Ye,
            33648: qe,
            10497: He
        },
        Vg = {
            6406: h,
            6407: st,
            6408: lt,
            6409: p,
            6410: f
        },
        Gg = {
            5121: tt,
            32819: c,
            32820: u,
            33635: d
        },
        kg = {
            32774: de,
            32778: he,
            32779: pe
        },
        jg = {
            0: ve,
            1: ge,
            768: _e,
            769: ye,
            770: xe,
            771: be,
            772: we,
            773: Me,
            774: Ae,
            775: Se,
            776: Te
        },
        Wg = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        },
        Xg = {
            CATMULLROMSPLINE: xt,
            CUBICSPLINE: xt,
            LINEAR: yt,
            STEP: _t
        },
        Hg = "OPAQUE",
        Yg = "MASK",
        qg = {
            FRONT: re,
            BACK: Pe,
            DOUBLE: ie
        };

    function Zg(e, t, n) {
        if (!e) return Promise.resolve();
        var r, i = [];
        if ("[object Array]" === Object.prototype.toString.call(e)) {
            r = [];
            for (var a = e.length, o = 0; o < a; o++) {
                (l = t.call(n || this, e[o], o)) && (i.push(l), l instanceof Promise ? l.then(function (e, t) {
                    r[e] = t
                }.bind(this, o)) : r[o] = l)
            }
        } else
            for (var s in r = {}, e) {
                var l;
                if (e.hasOwnProperty(s))(l = t.call(n || this, e[s], s)) && (i.push(l), l instanceof Promise ? l.then(function (e, t) {
                    r[e] = t
                }.bind(this, s)) : r[s] = l)
            }
        return Promise.all(i).then(function () {
            return r
        })
    }

    function Qg(e, t) {
        return "string" != typeof e || "" === e ? "" : /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : (t || "") + e
    }

    function Kg(e) {
        if (void 0 !== window.TextDecoder) return (new TextDecoder).decode(e);
        for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
        return t
    }

    function Jg(e, t, n, r) {
        var i = e.geometry,
            a = e.material,
            o = n.targets,
            s = i.morphAttributes;
        s.position = [], s.normal = [], a.morphTargets = !0;
        for (var l = 0, c = o.length; l < c; l++) {
            var u, d, h = o[l],
                p = xn(t.extras) && xn(t.extras.targetNames) ? t.extras.targetNames[l] : "morphTarget" + l;
            if (void 0 !== h.POSITION) {
                u = r.accessors[h.POSITION].clone();
                for (var f = i.attributes.position, m = 0, v = u.count; m < v; m++) u.setXYZ(m, u.getX(m) + f.getX(m), u.getY(m) + f.getY(m), u.getZ(m) + f.getZ(m))
            } else u = i.attributes.position.clone();
            if (void 0 !== h.NORMAL) {
                a.morphNormals = !0, d = r.accessors[h.NORMAL].clone();
                var g = i.attributes.normal;
                for (m = 0, v = d.count; m < v; m++) d.setXYZ(m, d.getX(m) + g.getX(m), d.getY(m) + g.getY(m), d.getZ(m) + g.getZ(m))
            } else d = i.attributes.normal.clone();
            h.TANGENT, u.name = p, d.name = p, s.position.push(u), s.normal.push(d)
        }
        if (e.updateMorphTargets(), void 0 !== t.weights)
            for (l = 0, c = t.weights.length; l < c; l++) e.morphTargetInfluences[l] = t.weights[l]
    }

    function $g(e, t) {
        var n = xn(e.attributes.color) && !t.isMeshNodeMaterial,
            r = void 0 === e.attributes.normal,
            i = t.isMeshNodeMaterial && (t.nodeValue.length || t.nodeRGB.length),
            a = t.morphTargets,
            o = t.hasNode("TEX_COORD_BL");
        return n || r || i || a || o
    }

    function e_(e, t, n) {
        this.json = e || {}, this.extensions = t || {}, this.options = n || {}, this.onProgress = n.onProgress || function () {}, this.cache = new wg, this.clonedResources = {
            materials: []
        }
    }

    function t_() {
        Jm.call(this, Ji.grayscale), this.material.type = "Grayscale"
    }

    function n_(e, t, n, r) {
        this.renderScene = t, this.renderCamera = n, this.selectedObjects = void 0 !== r ? r : [], this.visibleEdgeColor = new $t(1, 1, 1, 1), this.hiddenEdgeColor = new $t(.1, .04, .02, 1), this.edgeGlow = 0, this.usePatternTexture = !1, this.edgeThickness = 1, this.edgeStrength = 3, this.downSampleRatio = 2, this.pulsePeriod = 0, this.renderToScreen = !1, Zm.call(this), this.resolution = void 0 !== e ? new qt(e.x, e.y) : new qt(256, 256);
        var i = {
                minFilter: Je,
                magFilter: Je,
                format: lt
            },
            a = Math.round(this.resolution.x / this.downSampleRatio),
            o = Math.round(this.resolution.y / this.downSampleRatio);
        this.renderTargetMaskBuffer = new en(this.resolution.x, this.resolution.y, i), this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask", this.renderTargetMaskBuffer.texture.generateMipmaps = !1, this.renderTargetDepthBuffer = new en(this.resolution.x, this.resolution.y, i), this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth", this.renderTargetDepthBuffer.texture.generateMipmaps = !1, this.renderTargetMaskDownSampleBuffer = new en(a, o, i), this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1, this.renderTargetBlurBuffer1 = new en(a, o, i), this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", this.renderTargetBlurBuffer1.texture.generateMipmaps = !1, this.renderTargetBlurBuffer2 = new en(Math.round(a / 2), Math.round(o / 2), i), this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", this.renderTargetBlurBuffer2.texture.generateMipmaps = !1, this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(), this.renderTargetEdgeBuffer1 = new en(a, o, i), this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1, this.renderTargetEdgeBuffer2 = new en(Math.round(a / 2), Math.round(o / 2), i), this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1;
        this.separableBlurMaterial1 = this.getSeparableBlurMaterial(4), this.separableBlurMaterial1.uniforms.texSize.value = new qt(a, o), this.separableBlurMaterial1.uniforms.kernelRadius.value = 1, this.separableBlurMaterial2 = this.getSeparableBlurMaterial(4), this.separableBlurMaterial2.uniforms.texSize.value = new qt(Math.round(a / 2), Math.round(o / 2)), this.separableBlurMaterial2.uniforms.kernelRadius.value = 4, this.overlayMaterial = this.getOverlayMaterial();
        var s = Ji.copy;
        this.copyUniforms = Di.clone(s.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new Oi({
            defines: s.defines,
            uniforms: this.copyUniforms,
            vertexShader: s.vertexShader,
            fragmentShader: s.fragmentShader,
            blending: ae,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), this.enabled = !0, this.needsSwap = !1, this.oldClearColor = new Pr, this.oldClearAlpha = 1, this.basic = new Fr, this.fsQuad = new Zm.FullScreenQuad(null), this.camera = new qi(-1, 1, 1, -1, 0, 1), this.scene = new Bn, this.tempPulseColor1 = new $t, this.tempPulseColor2 = new $t, this.textureMatrix = new fn, this._MorphingFlag = 1, this._SkinningFlag = 2, this._NumberOfMaterialVariants = 1 + (this._MorphingFlag | this._SkinningFlag), this._depthMaterials = new Array(this._NumberOfMaterialVariants), this._maskMaterials = new Array(this._NumberOfMaterialVariants);
        for (var l = 0; l !== this._NumberOfMaterialVariants; ++l) {
            var c = 0 != (l & this._MorphingFlag),
                u = 0 != (l & this._SkinningFlag),
                d = new Uo({
                    blending: ae,
                    depthPacking: It,
                    side: ie,
                    morphTargets: c,
                    skinning: u
                });
            this._depthMaterials[l] = d;
            var h = new Pc({
                side: ie,
                morphTargets: c,
                skinning: u
            });
            this._maskMaterials[l] = h
        }
    }
    e_.prototype._withDependencies = function (e) {
        for (var t = this, n = {}, r = 0; r < e.length; r++) {
            var i = e[r],
                a = "load" + i.charAt(0).toUpperCase() + i.slice(1),
                o = t.cache.get(i);
            if (void 0 !== o) n[i] = o;
            else if (t[a]) {
                var s = new Promise(function (e) {
                    e(a)
                }).then(function (e) {
                    return t[e]()
                });
                t.cache.add(i, s), n[i] = s
            }
        }
        return Zg(n, function (e) {
            return e
        })
    }, e_.prototype.parse = function (f, e) {
        var m = this,
            v = this.json;
        this.cache.removeAll(), this._withDependencies(["scenes", "nodes", "materials", "cameras", "animations", "clonedMaterials"]).then(function (i) {
            var e = [];
            i.scenes = i.scenes || [];
            for (var t = 0; t < i.scenes.length; t++) e.push(i.scenes[t]);
            var n = xn(v.scene) ? v.scenes[v.scene] : v.scenes[0],
                r = xn(v.scene) ? i.scenes[v.scene] : e[0],
                a = {};
            n && (d = m.getExt(n, Mg.S8S_V3D_SCENE_DATA)) && xn(d.worldMaterial) && (a.material = i.materials[d.worldMaterial]);
            i.materials = i.materials || [], [].concat(i.materials, i.clonedMaterials).forEach(function (r) {
                r.isMeshNodeMaterial && r.traverseNodes(function (e) {
                    if ("TEX_COORD_BL" === e.originData.type) {
                        var t = i.nodes[e.originData.object];
                        if (t) {
                            var n = r.nodeTexCoordObjectMap[e.originData.name];
                            r.nodeTexCoordObject[n] = t
                        }
                    }
                })
            });
            var o = [];
            i.cameras = i.cameras || [];
            for (t = 0; t < i.cameras.length; t++) {
                var s = i.cameras[t],
                    l = !1;
                s.traverseAncestors(function (e) {
                    e == r && (l = !0)
                }), l && o.push(s)
            }
            var c = [];
            i.animations = i.animations || [];
            for (t = 0; t < i.animations.length; t++) {
                var u = i.animations[t];
                u.clip && void 0 !== u.clip.name && (u.clip.name = u.clip.name), c.push(u)
            }
            var d, h = {};
            if (n && (d = m.getExt(n, Mg.S8S_V3D_SCENE_DATA))) {
                if (xn(d.shadowMap)) {
                    switch (h.shadowMap = {
                        enabled: !0
                    }, d.shadowMap.type) {
                        case "BASIC":
                            h.shadowMap.type = q;
                            break;
                        case "PCF":
                            h.shadowMap.type = Z;
                            break;
                        case "PCFSOFT":
                            h.shadowMap.type = $;
                            break;
                        case "PCFPOISSON":
                            h.shadowMap.type = ne;
                            break;
                        case "ESM":
                            h.shadowMap.type = te
                    }
                    if (d.shadowMap.renderSingleSided)
                        if (d.shadowMap.renderReverseSided) p = Pe;
                        else p = re;
                    else var p = ie;
                    r.traverse(function (e) {
                        var t = e.material;
                        t && (t.shadowSide = p)
                    })
                }
                if (xn(d.physicallyCorrectLights) && (h.physicallyCorrectLights = d.physicallyCorrectLights), xn(d.aaMethod) && (h.aaMethod = d.aaMethod), xn(d.useHDR) && (h.useHDR = d.useHDR), xn(d.unitsScaleFactor) ? h.unitsScaleFactor = d.unitsScaleFactor : h.unitsScaleFactor = 1, xn(d.toneMapping)) switch (d.toneMapping.type) {
                    case "logarithmicMax":
                        h.toneMapping = Be, h.toneMappingBrightness = d.toneMapping.brightness, h.toneMappingContrast = d.toneMapping.contrast, h.toneMappingMidTones = d.toneMapping.midTones, h.toneMappingPhysicalScale = d.toneMapping.physicalScale, h.toneMappingChromaticAdaptation = d.toneMapping.chromaticAdaptation, h.toneMappingWhiteColor = (new Pr).fromArray(d.toneMapping.whiteColor), h.toneMappingColorDifferentiation = d.toneMapping.colorDifferentiation, h.toneMappingExteriorDaylight = d.toneMapping.exteriorDaylight;
                        break;
                    case "physicalMax":
                        h.toneMapping = ze, h.toneMappingWhiteBalance = (new Pr).fromArray(d.toneMapping.whiteBalance), h.toneMappingHighlights = d.toneMapping.highlights, h.toneMappingMidTones = d.toneMapping.midTones, h.toneMappingShadows = d.toneMapping.shadows, h.toneMappingSaturation = d.toneMapping.saturation, h.toneMappingPhysicalScale = d.toneMapping.physicalScale, h.toneMappingAperture = d.toneMapping.aperture, h.toneMappingShutter = d.toneMapping.shutter, h.toneMappingISO = d.toneMapping.iso, h.toneMappingVignetting = d.toneMapping.vignetting;
                        break;
                    case "filmicBlender":
                        h.toneMapping = Y
                }
            }
            f(r, e, a, o, c, h)
        }).catch(e)
    }, e_.prototype.getDependency = function (e, t) {
        var n = this,
            r = e + ":" + t,
            i = n.cache.get(r);
        if (!i) {
            var a = "load" + e.charAt(0).toUpperCase() + e.slice(1);
            i = new Promise(function (e) {
                e()
            }).then(function () {
                return n[a](t)
            }), n.cache.add(r, i)
        }
        return i
    }, e_.prototype.loadBuffer = function (e) {
        var a = this,
            o = this.json.buffers[e];
        if (o.type && "arraybuffer" !== o.type) throw new Error("v3d.GLTFLoader: %s buffer type is not supported.", o.type);
        if (void 0 === o.uri && 0 === e) return Promise.resolve(this.extensions[Mg.KHR_BINARY_GLTF].body);
        var s = this.options;
        return new Promise(function (e) {
            if (s.loadBinXZ) var t = Qg(o.uri, s.path) + ".xz",
                n = new ug;
            else {
                t = Qg(o.uri, s.path);
                (n = new Iu).setResponseType("arraybuffer")
            }

            function r(e) {
                if (a.onProgress) {
                    var t = 100 * (.3 + .7 * e);
                    a.onProgress(t)
                }
            }
            var i = r;
            n instanceof Iu && (i = function (e) {
                var t = e.lengthComputable ? e.loaded / e.total : 1;
                r(t)
            }), n.load(t, e, i)
        })
    }, e_.prototype.loadBufferView = function (e) {
        var r = this.json.bufferViews[e];
        return this.getDependency("buffer", r.buffer).then(function (e) {
            var t = r.byteLength || 0,
                n = r.byteOffset || 0;
            return e.slice(n, n + t)
        })
    }, e_.prototype.loadAccessors = function () {
        var e = this,
            s = this.json;
        return Zg(s.accessors, function (o) {
            return e.getDependency("bufferView", o.bufferView).then(function (e) {
                var t = Wg[o.type],
                    n = Bg[o.componentType],
                    r = n.BYTES_PER_ELEMENT,
                    i = r * t,
                    a = s.bufferViews[o.bufferView].byteStride;
                return a && a !== i ? new us(new ss(new n(e), a / r), t, o.byteOffset / r) : new zr(new n(e, o.byteOffset, o.count * t), t)
            })
        })
    }, e_.prototype.loadTexture = function (e) {
        var t = this,
            n = this.json,
            a = this.options,
            r = (this.extensions, window.URL || window.webkitURL),
            i = n.textures[e],
            o = n.images[i.source],
            s = o.uri,
            l = !1,
            c = t.getExt(i, Mg.S8S_V3D_TEXTURE_DATA);
        if (c) var u = !!c.isCubeTexture,
            d = "linear" == c.colorSpace || "non-color" == c.colorSpace ? At : St;
        else u = !1, d = St;
        return void 0 !== o.bufferView && (s = this.getDependency("bufferView", o.bufferView).then(function (e) {
            l = !0;
            var t = new Blob([e], {
                type: o.mimeType
            });
            return s = r.createObjectURL(t)
        })), Promise.resolve(s).then(function (r) {
            "hdr" != r.split(".").pop() && "image/vnd.radiance" != o.mimeType || (d = Et);
            var i = t.options.manager.getHandler(r);
            return (i = i || new(d == Et ? dg : u ? sv : Uu)).setCrossOrigin(a.crossOrigin), new Promise(function (e, t) {
                var n = i.load(Qg(r, a.path), e, void 0, function (e) {
                    t(n)
                })
            }).then(function (e) {
                return e
            }, function (e) {
                return e.isCubeTexture && (e.images = new Array(6).fill(document.createElement("img"))), e
            })
        }).then(function (e) {
            !0 === l && r.revokeObjectURL(s), e.flipY = !1, void 0 !== i.name && (e.name = i.name), e.format = void 0 !== i.format ? Vg[i.format] : lt, void 0 !== i.internalFormat && e.format !== Vg[i.internalFormat] && console.warn("v3d.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. internalFormat will be forced to be the same value as format."), e.type = void 0 !== i.type ? Gg[i.type] : tt;
            var t = (n.samplers || {})[i.sampler] || {};
            return e.magFilter = zg[t.magFilter] || Je, e.minFilter = zg[t.minFilter] || 1008, e.wrapS = Ug[t.wrapS] || He, e.wrapT = Ug[t.wrapT] || He, (e.encoding = d) == Et && (e.minFilter = Je, e.magFilter = Je), c && (xn(c.anisotropy) && (e.anisotropy = c.anisotropy), xn(c.uvTransform) && (e.matrix = (new Zt).fromArray(c.uvTransform), e.matrixAutoUpdate = !1)), e
        })
    }, e_.prototype.assignTexture = function (t, n, e) {
        return this.getDependency("texture", e).then(function (e) {
            t[n] = e
        })
    }, e_.prototype.assignTextureNode = function (t, n, e) {
        return this.getDependency("texture", e).then(function (e) {
            t.nodeTextures = t.nodeTextures || {}, t.nodeTextures[n] = e
        })
    }, e_.prototype.loadMaterials = function () {
        var p = this,
            e = this.json,
            f = this.extensions;
        return Zg(e.materials, function (t) {
            var n, r = {},
                e = [],
                i = p.getExt(t, Mg.S8S_V3D_MATERIAL_DATA);
            if (xn(t.pbrMetallicRoughness)) {
                var a = (n = hu).nodeGraphFromGLTFMat(t, i);
                r.nodeGraph = a;
                for (var o = 0; o < a.len(); o++) {
                    var s = a.node(o).originData; - 1 < xg.indexOf(s.type) && e.push(p.assignTextureNode(r, s.name, s.texture))
                }
            } else n = i ? hu : Mc;
            if (i) {
                var l = f[Mg.S8S_V3D_MATERIAL_DATA];
                e.push(l.extendParams(r, t, p))
            }!0 === t.doubleSided && (r.side = ie);
            var c = t.alphaMode || Hg,
                u = c !== Hg,
                d = c === Yg;
            if (r.premultipliedAlpha = u, r.transparent = u, r.alphaTest = d ? xn(t.alphaCutoff) ? t.alphaCutoff : .5 : 0, u)
                if (i && xn(i.blendMode)) {
                    var h = i.blendMode;
                    r.blending = ue, xn(h.blendEquation) && (r.blendEquation = kg[h.blendEquation]), xn(h.blendEquationAlpha) && (r.blendEquationAlpha = kg[h.blendEquationAlpha]), xn(h.srcRGB) && (r.blendSrc = jg[h.srcRGB]), xn(h.dstRGB) && (r.blendDst = jg[h.dstRGB]), xn(h.srcAlpha) && (r.blendSrcAlpha = jg[h.srcAlpha]), xn(h.dstAlpha) && (r.blendDstAlpha = jg[h.dstAlpha])
                } else r.blending = ue, r.blendEquation = de, r.blendSrc = ge, r.blendDst = be;
            return Promise.all(e).then(function () {
                var e = new n(r);
                return void 0 !== t.name && (e.name = t.name), t.extras && (e.userData.v3d = t.extras), (t.pbrMetallicRoughness || e.isMeshNodeMaterial) && e.envMap && (e.envMap.mapping = Ge, e.envMap.flipY = !0), e
            })
        })
    }, e_.prototype.loadClonedMaterials = function () {
        var e = this;
        return this._withDependencies(["meshes", "nodes"]).then(function () {
            return Promise.resolve(e.clonedResources.materials)
        })
    }, e_.prototype.loadGeometries = function (e) {
        var s = this;
        return this._withDependencies(["accessors"]).then(function (o) {
            return Zg(e, function (e) {
                var t = new ni,
                    n = e.attributes;
                for (var r in n) {
                    var i = n[r];
                    if (void 0 === i) return;
                    var a = o.accessors[i];
                    switch (r) {
                        case "POSITION":
                            t.setAttribute("position", a);
                            break;
                        case "NORMAL":
                            t.setAttribute("normal", a);
                            break;
                        case "TEXCOORD_0":
                        case "TEXCOORD0":
                        case "TEXCOORD":
                            t.setAttribute("uv", a);
                            break;
                        case "COLOR_0":
                        case "COLOR0":
                        case "COLOR":
                            t.setAttribute("color", a);
                            break;
                        case "WEIGHTS_0":
                        case "WEIGHT":
                            t.setAttribute("skinWeight", a);
                            break;
                        case "JOINTS_0":
                        case "JOINT":
                            t.setAttribute("skinIndex", a);
                            break;
                        case "TANGENT":
                            t.setAttribute("tangent", a);
                            break;
                        default:
                            -1 < r.indexOf("TEXCOORD_") && t.setAttribute(s.texcoordToAttrName(r), a), -1 < r.indexOf("COLOR_") && t.setAttribute(s.colorToAttrName(r), a)
                    }
                }
                return void 0 !== e.indices && t.setIndex(o.accessors[e.indices]), t
            })
        })
    }, e_.prototype.loadMeshes = function () {
        var g = this,
            e = this.json;
        return this._withDependencies(["accessors", "materials"]).then(function (v) {
            return Zg(e.meshes, function (d, h) {
                var p = new Jo,
                    f = d.primitives || [],
                    m = g.getExt(d, Mg.S8S_V3D_MESH_DATA);
                return g.loadGeometries(f).then(function (e) {
                    for (var t = 0; t < f.length; t++) {
                        var n = f[t],
                            r = e[t],
                            i = void 0 === n.material ? new bc({
                                color: 16777215,
                                emissive: 0,
                                metalness: 1,
                                roughness: 1,
                                transparent: !1,
                                depthTest: !0,
                                side: re,
                                receiveShadow: !0,
                                castShadow: !0
                            }) : v.materials[n.material];
                        if (i.aoMap && void 0 === r.attributes.uv2 && void 0 !== r.attributes.uv && r.setAttribute("uv2", new zr(r.attributes.uv.array, 2)), xn(r.attributes.color) && !i.isMeshNodeMaterial) var a = !0;
                        else a = !1;
                        var o, s = void 0 === r.attributes.normal;
                        if (i.isMeshNodeMaterial && m) {
                            if (m.uvLayers)
                                for (var l in m.uvLayers) i.nodeUVAliases[l] = g.texcoordToAttrName(m.uvLayers[l]);
                            if (m.colorLayers)
                                for (var l in m.colorLayers) i.nodeVCAliases[l] = g.colorToAttrName(m.colorLayers[l]);
                            i.updateNodeGraph()
                        }
                        if (a && (i.vertexColors = _, i.needsUpdate = !0), s && (i.flatShading = !0), n.mode === Ng || void 0 === n.mode) o = new xi(r, i);
                        else if (n.mode === Og)(o = new xi(r, i)).drawMode = 1;
                        else if (n.mode === Fg)(o = new xi(r, i)).drawMode = 2;
                        else if (n.mode === Rg)
                            if (m) {
                                var c = new gg;
                                c.fromBufferGeometry(r);
                                var u = new yg({
                                    color: xn(m.lineColor) ? (new Pr).fromArray(m.lineColor) : new Pr(1, 1, 1),
                                    lineWidth: xn(m.lineWidth) ? m.lineWidth : 1,
                                    sizeAttenuation: 0
                                });
                                o = new xi(c.geometry, u)
                            } else o = new qs(r, i);
                        else if (n.mode === Ig) o = new Xs(r, i);
                        else if (n.mode === Dg) o = new Zs(r, i);
                        else {
                            if (n.mode !== Lg) throw new Error("v3d.GLTFLoader: Primitive mode unsupported: ", n.mode);
                            o = new tl(r, i)
                        }
                        if (o.name = d.name || "mesh_" + h, void 0 !== n.targets && Jg(o, d, n, v), $g(o.geometry, o.material) && (o.material = o.material.clone(), g.clonedResources.materials.push(o.material)), !(1 < f.length)) return o;
                        o.name += "_" + t, o.isMaterialGeneratedMesh = !0, p.add(o)
                    }
                    return p
                })
            })
        })
    }, e_.prototype.loadCameras = function () {
        var e = this.json,
            o = this;
        return Zg(e.cameras, function (e) {
            var t, n = e[e.type];
            if (n) {
                if ("perspective" === e.type) {
                    var r = n.aspectRatio || 1,
                        i = n.yfov;
                    t = new Bi(Yt.radToDeg(i), r, n.znear || 1, n.zfar || 2e6)
                } else "orthographic" === e.type && (t = new qi(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar));
                xn(e.name) && (t.name = e.name);
                var a = o.getExt(e, Mg.S8S_V3D_CAMERA_DATA);
                if (a) {
                    if (t.controls = {}, t.controls.type = a.controls, t.viewportFit.type = 3, xn(a.viewportFitType)) switch (a.viewportFitType) {
                        case "VERTICAL":
                            t.viewportFit.type = 1;
                            break;
                        case "HORIZONTAL":
                            t.viewportFit.type = 2;
                            break;
                        case "AUTO":
                            t.viewportFit.type = 3
                    }
                    xn(a.viewportFitInitialAspect) && (t.viewportFit.initialAspect = a.viewportFitInitialAspect), xn(a.enablePan) ? t.controls.enablePan = a.enablePan : t.controls.enablePan = !0, xn(a.rotateSpeed) ? t.controls.rotateSpeed = a.rotateSpeed : t.controls.rotateSpeed = 1, xn(a.moveSpeed) ? t.controls.moveSpeed = a.moveSpeed : t.controls.moveSpeed = 1, xn(a.orbitMinDistance) && (t.controls.orbitMinDistance = a.orbitMinDistance), xn(a.orbitMaxDistance) && (t.controls.orbitMaxDistance = a.orbitMaxDistance), xn(a.orbitMinPolarAngle) && (t.controls.orbitMinPolarAngle = a.orbitMinPolarAngle), xn(a.orbitMaxPolarAngle) && (t.controls.orbitMaxPolarAngle = a.orbitMaxPolarAngle), xn(a.orbitMinAzimuthAngle) ? t.controls.orbitMinAzimuthAngle = a.orbitMinAzimuthAngle : t.controls.orbitMinAzimuthAngle = -1 / 0, xn(a.orbitMaxAzimuthAngle) ? t.controls.orbitMaxAzimuthAngle = a.orbitMaxAzimuthAngle : t.controls.orbitMaxAzimuthAngle = 1 / 0, xn(a.orbitTarget) && (a.orbitTarget instanceof Array ? (t.controls.orbitTarget = new Fn, t.controls.orbitTarget.position.fromArray(a.orbitTarget)) : o._withDependencies(["nodes"]).then(function (e) {
                        t.controls.orbitTarget = e.nodes[a.orbitTarget]
                    })), xn(a.fpsCollisionMaterial) ? t.controls.collisionMaterial = a.fpsCollisionMaterial : t.controls.collisionMaterial = null, xn(a.fpsGazeLevel) ? t.controls.gazeLevel = a.fpsGazeLevel : t.controls.gazeLevel = 1.8, xn(a.fpsStoryHeight) ? t.controls.storyHeight = a.fpsStoryHeight : t.controls.storyHeight = 3
                }
                return e.extras && (t.userData.v3d = e.extras), t
            }
            console.warn("v3d.GLTFLoader: Missing camera parameters.")
        })
    }, e_.prototype.loadSkins = function () {
        var e = this.json;
        return this._withDependencies(["accessors"]).then(function (t) {
            return Zg(e.skins, function (e) {
                return {
                    joints: e.joints,
                    inverseBindMatrices: t.accessors[e.inverseBindMatrices]
                }
            })
        })
    }, e_.prototype.loadAnimations = function () {
        var R = this,
            e = this.json;
        return this._withDependencies(["accessors", "materials", "nodes"]).then(function (L) {
            return Zg(e.animations, function (e, t) {
                for (var n = [], r = -1, i = 0; i < e.channels.length; i++) {
                    var a = e.channels[i],
                        o = e.samplers[a.sampler];
                    if (o && -1 < o.input && -1 < o.output) {
                        var s = a.target,
                            l = void 0 !== s.node ? s.node : s.id,
                            c = void 0 !== e.parameters ? e.parameters[o.input] : o.input,
                            u = void 0 !== e.parameters ? e.parameters[o.output] : o.output,
                            d = L.accessors[c];
                        if (d.count <= 1) continue;
                        var h = L.accessors[u],
                            p = L.nodes[l];
                        if (p) {
                            var f;
                            r = p.id, p.updateMatrix(), p.matrixAutoUpdate = !0;
                            var m = "";
                            switch (s.path) {
                                case "weights":
                                    f = bu, m = "morphTargetInfluences";
                                    break;
                                case "rotation":
                                    f = Mu, m = "quaternion";
                                    break;
                                case "translation":
                                    f = Su, m = "position";
                                    break;
                                case "scale":
                                    f = Su, m = "scale";
                                    break;
                                case "intensity":
                                    f = bu, m = "intensity";
                                    break;
                                default:
                                    if (f = Su, -1 < s.path.indexOf("nodeValue")) m = "material.nodeValue[" + s.path.match(/".*"/g)[0] + "]";
                                    else if (-1 < s.path.indexOf("nodeRGB")) {
                                        m = "material.nodeRGB[" + s.path.match(/".*"/g)[0] + "]"
                                    }
                            }
                            var v = p.name ? p.name : p.uuid;
                            "CATMULLROMSPLINE" == o.interpolation && console.warn("v3d.GLTFLoader: CATMULLROMSPLINE interpolation is not supported. Using CUBICSPLINE instead.");
                            var g = xn(o.interpolation) ? Xg[o.interpolation] : yt,
                                _ = [];
                            "weights" == s.path ? p.traverse(function (e) {
                                e.isMesh && e.material.morphTargets && _.push(e.name ? e.name : e.uuid)
                            }) : -1 < s.path.indexOf("material") ? p.traverse(function (e) {
                                if (e.isMesh && e.material.isMeshNodeMaterial) {
                                    var t = !1;
                                    if (s.extras) {
                                        t = L.materials[s.extras.material].name === e.material.name;
                                        var n = s.path.match(/\["(.*)"\]/);
                                        t = t && null !== n && null !== e.material.findNodeByName(n[1])
                                    } else t = !0;
                                    t && _.push(e.name ? e.name : e.uuid)
                                }
                            }) : _.push(v);
                            for (var y = 0, x = _.length; y < x; y++) {
                                var b = vu.arraySlice(d.array, 0),
                                    w = vu.arraySlice(h.array, 0);
                                if (g == xt) {
                                    for (var M = new w.constructor(w.length / 3), A = M.length / b.length, S = 0; S < M.length / A; S++)
                                        for (var T = 0; T < A; T++) M[A * S + T] = w[3 * A * S + A + T];
                                    g = yt, w = M
                                }
                                n.push(new f(_[y] + "." + m, b, w, g))
                            }
                        }
                    }
                }
                var E = {
                        clip: new Tu(l = xn(e.name) ? e.name : "animation_" + t, void 0, n),
                        nodeId: r,
                        auto: !0,
                        loop: 2201,
                        repetitions: 1 / 0,
                        startAt: 0
                    },
                    C = R.getExt(e, Mg.S8S_V3D_ANIMATION_DATA);
                if (C) {
                    E.auto = C.auto;
                    var P = C.repeatInfinite ? 1 / 0 : C.repeatCount;
                    switch (C.loop) {
                        case "ONCE":
                            E.loop = 2200;
                            break;
                        case "REPEAT":
                            E.loop = 2201, E.repetitions = P;
                            break;
                        case "PING_PONG":
                            E.loop = 2202, E.repetitions = P
                    }
                    E.startAt = C.offset
                }
                return E
            })
        })
    }, e_.prototype.loadNodes = function () {
        var x = this.json,
            b = this,
            t = x.nodes || [],
            e = x.skins || [],
            n = {},
            r = {};
        for (var i in e.forEach(function (e) {
                e.joints.forEach(function (e) {
                    t[e].isBone = !0
                })
            }), t) {
            var a = t[i];
            xn(a.mesh) && (xn(n[a.mesh]) || (n[a.mesh] = r[a.mesh] = 0), n[a.mesh]++)
        }
        return b._withDependencies(["materials", "meshes", "skins", "cameras"]).then(function (y) {
            var e = b.getExt(b, Mg.S8S_V3D_DATA);
            return e && e.loadCurves(x, y.materials), Zg(x.nodes, function (e) {
                var t = b.getExt(e, Mg.S8S_V3D_NODE_DATA);
                if (!0 === e.isBone) return new Is;
                if (void 0 === e.mesh) return void 0 !== e.camera ? y.cameras[e.camera] : t && xn(t.curve) ? b.getExt(b, Mg.S8S_V3D_DATA).curves[t.curve] : t && xn(t.light) ? b.getExt(b, Mg.S8S_V3D_DATA).lights[t.light].clone() : new Fn;
                var n = y.meshes[e.mesh];
                return 0 < r[e.mesh] && ((n = n.clone()).name += "_instance_" + r[e.mesh], void 0 !== n.geometry && void 0 !== n.material && $g(n.geometry, n.material) && (n.material = n.material.clone(), b.clonedResources.materials.push(n.material))), r[e.mesh]++, n
            }).then(function (_) {
                return Zg(_, function (d, e) {
                    var h = x.nodes[e];
                    if (xn(h.skin)) {
                        for (var t = [], n = 0 < d.children.length ? d.children : [d], r = 0; r < n.length; r++) {
                            var i = n[r];
                            if (i.isMesh) {
                                var a = y.skins[h.skin],
                                    o = i.geometry,
                                    s = i.material.clone();
                                b.clonedResources.materials.push(s), s.skinning = !0;
                                var l = new Ps(o, s);
                                l.morphTargetInfluences = i.morphTargetInfluences, l.name = i.name, l.isMaterialGeneratedMesh = i.isMaterialGeneratedMesh;
                                for (var c = [], u = [], p = 0, f = a.joints.length; p < f; p++) {
                                    var m = a.joints[p],
                                        v = _[m];
                                    if (v) {
                                        c.push(v);
                                        var g = new fn;
                                        xn(a.inverseBindMatrices) && g.fromArray(a.inverseBindMatrices.array, 16 * p), u.push(g)
                                    } else console.warn('v3d.GLTFLoader: Joint "%s" could not be found.', m)
                                }
                                l.bind(new Ds(c, u), l.matrixWorld), t.push(l)
                            }
                        }
                        t.length && (0 < d.children.length ? (d.remove.apply(d, d.children), d.add.apply(d, t)) : d = t[0])
                    }
                    return d.traverse(function (e) {
                        var t = d == e,
                            n = b.getExt(h, Mg.S8S_V3D_NODE_DATA);
                        if (t) {
                            if (void 0 !== h.name && (e.name = h.name), void 0 !== h.matrix) {
                                var r = new fn;
                                r.fromArray(h.matrix), e.applyMatrix4(r)
                            } else void 0 !== h.translation && e.position.fromArray(h.translation), void 0 !== h.rotation && e.quaternion.fromArray(h.rotation), void 0 !== h.scale && e.scale.fromArray(h.scale);
                            var i = n && n.target ? _[n.target] : null;
                            if ((e.isDirectionalLight || e.isSpotLight || e.isHemisphereLight) && (i ? (e.target = i, e.isFreeLight = !1) : e.isFreeLight = !0), e.isCamera && e.controls && "FIRST_PERSON" == e.controls.type && (e.controls.collisionMaterial = y.materials[e.controls.collisionMaterial]), n && n.hidden && (e.visible = !1), n && xn(n.constraints))
                                for (var a = 0; a < n.constraints.length; a++) {
                                    var o = n.constraints[a];
                                    if ("lockedTrack" == o.type) o.trackAxis = o.trackAxis.toUpperCase(), o.lockAxis = o.lockAxis || "Y";
                                    else if ("trackTo" == o.type) o.trackAxis = o.trackAxis.toUpperCase(), o.upAxis = o.upAxis || "Y";
                                    else if ("floor" == o.type) o.floorLocation = o.floorLocation.toUpperCase();
                                    else if ("copyTransforms" == o.type) {
                                        var s = new Rm(i = _[o.target]),
                                            l = new Dm(i),
                                            c = new Im(i);
                                        s.name = l.name = c.name = o.name, s.mute = l.mute = c.mute = o.mute, e.constraints.push(s), e.constraints.push(l), e.constraints.push(c)
                                    }
                                    var u = null;
                                    switch (o.type) {
                                        case "copyLocation":
                                            u = new Rm(_[o.target]);
                                            break;
                                        case "copyRotation":
                                            u = new Dm(_[o.target]);
                                            break;
                                        case "copyScale":
                                            u = new Im(_[o.target]);
                                            break;
                                        case "limitLocation":
                                            (u = new Om).min.set(Number(o.minX), Number(o.minY), Number(o.minZ)), u.max.set(Number(o.maxX), Number(o.maxY), Number(o.maxZ));
                                            break;
                                        case "limitRotation":
                                            (u = new Fm).axis = o.axis, u.min = o.min, u.max = o.max;
                                            break;
                                        case "limitScale":
                                            (u = new Bm).min.set(Number(o.minX), Number(o.minY), Number(o.minZ)), u.max.set(Number(o.maxX), Number(o.maxY), Number(o.maxZ));
                                            break;
                                        case "lockedTrack":
                                            (u = new zm(_[o.target])).trackAxis = o.trackAxis, u.lockAxis = o.lockAxis;
                                            break;
                                        case "trackTo":
                                            (u = new Um(_[o.target])).trackAxis = o.trackAxis, u.upAxis = o.upAxis;
                                            break;
                                        case "childOf":
                                            (u = new Lm(_[o.target])).offsetMatrix = (new fn).fromArray(o.offsetMatrix);
                                            break;
                                        case "floor":
                                            (u = new Nm(_[o.target])).floorLocation = o.floorLocation, u.offset = o.offset
                                    }
                                    u && (u.name = o.name, u.mute = o.mute, e.constraints.push(u))
                                }
                        }
                        e.isMesh && (n && xn(n.useCastShadows) ? e.castShadow = n.useCastShadows : xn(e.material.castShadow) && (e.castShadow = e.material.castShadow), n && xn(n.useShadows) ? e.receiveShadow = n.useShadows : xn(e.material.receiveShadow) && (e.receiveShadow = e.material.receiveShadow)), h.extras && (e.userData.v3d = h.extras), n && (e.renderOrder = n.renderOrder, e.frustumCulled = n.frustumCulling, xn(n.groupNames) ? e.groupNames = n.groupNames : e.groupNames = [])
                    }), d
                })
            })
        })
    }, e_.prototype.loadScenes = function () {
        var l = this.json,
            c = this,
            u = this.extensions;

        function d(e, t, n) {
            var r = n[e];
            t.add(r), (r.isDirectionalLight || r.isSpotLight || r.isHemisphereLight) && r.isFreeLight && t.add(r.target);
            var i = l.nodes[e];
            if (i.children)
                for (var a = i.children, o = 0, s = a.length; o < s; o++) {
                    d(a[o], r, n)
                }
        }
        return this._withDependencies(["nodes"]).then(function (s) {
            return Zg(l.scenes, function (e) {
                var t = new Bn;
                xn(e.name) && (t.name = e.name), e.extras && (t.userData.v3d = e.extras);
                for (var n = e.nodes || [], r = 0, i = n.length; r < i; r++) {
                    d(n[r], t, s.nodes)
                }
                var a = c.getExt(e, Mg.S8S_V3D_SCENE_DATA);
                if (a) {
                    if (xn(a.light)) {
                        var o = u[Mg.S8S_V3D_DATA].lights;
                        t.add(o[a.light])
                    }
                    xn(a.postprocessing) && (t.postprocessing = a.postprocessing)
                }
                return t
            })
        })
    }, e_.prototype.getExt = function (e, t) {
        return e.extensions && e.extensions[t] ? e.extensions[t] : null
    }, e_.prototype.texcoordToAttrName = function (e) {
        return "TEXCOORD_0" == e ? "uv" : "uv" + String(Number(e.split("TEXCOORD_")[1]) + 1)
    }, e_.prototype.colorToAttrName = function (e) {
        return "COLOR_0" == e ? "color" : "color" + String(Number(e.split("COLOR_")[1]) + 1)
    }, t_.prototype = Object.assign(Object.create(Jm.prototype), {
        constructor: t_
    }), n_.prototype = Object.assign(Object.create(Zm.prototype), {
        constructor: n_,
        dispose: function () {
            this.renderTargetMaskBuffer.dispose(), this.renderTargetDepthBuffer.dispose(), this.renderTargetMaskDownSampleBuffer.dispose(), this.renderTargetBlurBuffer1.dispose(), this.renderTargetBlurBuffer2.dispose(), this.renderTargetEdgeBuffer1.dispose(), this.renderTargetEdgeBuffer2.dispose()
        },
        setSize: function (e, t) {
            this.renderTargetMaskBuffer.setSize(e, t);
            var n = Math.round(e / this.downSampleRatio),
                r = Math.round(t / this.downSampleRatio);
            this.renderTargetMaskDownSampleBuffer.setSize(n, r), this.renderTargetBlurBuffer1.setSize(n, r), this.renderTargetEdgeBuffer1.setSize(n, r), this.separableBlurMaterial1.uniforms.texSize.value = new qt(n, r), n = Math.round(n / 2), r = Math.round(r / 2), this.renderTargetBlurBuffer2.setSize(n, r), this.renderTargetEdgeBuffer2.setSize(n, r), this.separableBlurMaterial2.uniforms.texSize.value = new qt(n, r)
        },
        changeVisibilityOfSelectedObjects: function (t) {
            function e(e) {
                e instanceof xi && (e.outlineVisible = t)
            }
            for (var n = 0; n < this.selectedObjects.length; n++) {
                var r = this.selectedObjects[n];
                e(r);
                for (var i = r.children, a = 0; a < i.length; a++) {
                    var o = i[a];
                    o.isMesh && o.isMaterialGeneratedMesh && e(o)
                }
            }
        },
        changeVisibilityOfNonSelectedObjects: function (r) {
            var i = [];

            function e(e) {
                e instanceof xi && i.push(e)
            }
            for (var t = 0; t < this.selectedObjects.length; t++) {
                var n = this.selectedObjects[t];
                e(n);
                for (var a = n.children, o = 0; o < a.length; o++) {
                    var s = a[o];
                    s.isMesh && s.isMaterialGeneratedMesh && e(s)
                }
            }
            this.renderScene.traverse(function (e) {
                if (e instanceof xi) {
                    for (var t = !1, n = 0; n < i.length; n++) {
                        if (i[n].id === e.id) {
                            t = !0;
                            break
                        }
                    }
                    t || (e.outlineVisible = r)
                }
            })
        },
        updateTextureMatrix: function () {
            this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.textureMatrix.multiply(this.renderCamera.projectionMatrix), this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)
        },
        getDepthMaterial: function (e, t, n) {
            var r = e.geometry,
                i = null,
                a = this._depthMaterials,
                o = e.customDepthMaterial;
            if (n && (a = this._maskMaterials), o) i = o;
            else {
                var s = !1;
                t.morphTargets && (r && r.isBufferGeometry ? s = r.morphAttributes && r.morphAttributes.position && 0 < r.morphAttributes.position.length : r && r.isGeometry && (s = r.morphTargets && 0 < r.morphTargets.length)), e.isSkinnedMesh && !1 === t.skinning && console.warn("v3d.OutlinePass: v3d.SkinnedMesh with material.skinning set to false:", e);
                var l = e.isSkinnedMesh && t.skinning,
                    c = 0;
                s && (c |= this._MorphingFlag), l && (c |= this._SkinningFlag), i = a[c]
            }
            i.visible = t.visible, i.wireframe = t.wireframe;
            var u = t.side;
            return i.side = u, i.clipShadows = t.clipShadows, i.clippingPlanes = t.clippingPlanes, i.clipIntersection = t.clipIntersection, i.wireframeLinewidth = t.wireframeLinewidth, i.linewidth = t.linewidth, n && (i.cameraNearFar = new qt(this.renderCamera.near, this.renderCamera.far), i.depthTexture = this.renderTargetDepthBuffer.texture, i.textureMatrix = this.textureMatrix), i
        },
        renderObject: function (e, t, n, r) {
            if (t.outlineVisible && t.isVisible() && t.layers.test(n.layers)) {
                var i = e.updateGeometry(t),
                    a = t.material;
                if (a.visible) {
                    var o = this.getDepthMaterial(t, a, r);
                    e.renderObject(t, this.scene, n, i, o, null)
                }
            }
            for (var s = t.children, l = 0, c = s.length; l < c; l++) this.renderObject(e, s[l], n, r)
        },
        render: function (e, t, n, r, i) {
            if (this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), 0 !== this.selectedObjects.length) {
                this.oldClearColor.copy(e.getClearColor()), this.oldClearAlpha = e.getClearAlpha();
                var a = e.autoClear;
                e.autoClear = !1, i && e.context.disable(e.context.STENCIL_TEST), e.setClearColor(16777215, 1);
                var o = this.renderScene.background;
                if (this.renderScene.background = null, e.setRenderTarget(this.renderTargetDepthBuffer), e.clear(), this.changeVisibilityOfSelectedObjects(!1), this.changeVisibilityOfNonSelectedObjects(!0), this.renderObject(e, this.renderScene, this.renderCamera, !1), this.updateTextureMatrix(), e.setRenderTarget(this.renderTargetMaskBuffer), e.clear(), this.changeVisibilityOfSelectedObjects(!0), this.changeVisibilityOfNonSelectedObjects(!1), this.renderObject(e, this.renderScene, this.renderCamera, !0), this.renderScene.background = o, this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture, e.setRenderTarget(this.renderTargetMaskDownSampleBuffer), e.clear(), this.fsQuad.render(e), this.tempPulseColor1.copy(this.visibleEdgeColor), this.tempPulseColor2.copy(this.hiddenEdgeColor), 0 < this.pulsePeriod) {
                    var s = .625 + .75 * Math.cos(.01 * performance.now() / this.pulsePeriod) / 2;
                    this.tempPulseColor1.multiplyScalar(s), this.tempPulseColor2.multiplyScalar(s)
                }
                this.fsQuad.material = this.edgeDetectionMaterial, this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture, this.edgeDetectionMaterial.uniforms.texSize.value = new qt(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height), this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1, this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial1, this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = n_.BlurDirectionX, this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness, e.setRenderTarget(this.renderTargetBlurBuffer1), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = n_.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial2, this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial2.uniforms.direction.value = n_.BlurDirectionX, e.setRenderTarget(this.renderTargetBlurBuffer2), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture, this.separableBlurMaterial2.uniforms.direction.value = n_.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer2), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.overlayMaterial, this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture, this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture, this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture, this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture, this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength, this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow, this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture, i && e.context.enable(e.context.STENCIL_TEST), this.renderToScreen ? e.setRenderTarget(null) : e.setRenderTarget(n), this.fsQuad.render(e), e.setClearColor(this.oldClearColor, this.oldClearAlpha), e.autoClear = a
            }
        },
        getEdgeDetectionMaterial: function () {
            return new Oi({
                type: "OutlineEdgeDetection",
                defines: {
                    HIDDEN_EDGE_ALPHA: 1
                },
                uniforms: {
                    maskTexture: {
                        value: null
                    },
                    texSize: {
                        value: new qt(.5, .5)
                    },
                    visibleEdgeColor: {
                        value: new $t(1, 1, 1, 1)
                    },
                    hiddenEdgeColor: {
                        value: new $t(1, 1, 1, 1)
                    }
                },
                vertexShader: Ki.pp_plane_vert,
                fragmentShader: Ki.pp_outline_edge_frag
            })
        },
        getSeparableBlurMaterial: function (e) {
            return new Oi({
                type: "OutlineSeparableBlur",
                defines: {
                    MAX_RADIUS: e
                },
                uniforms: {
                    colorTexture: {
                        value: null
                    },
                    texSize: {
                        value: new qt(.5, .5)
                    },
                    direction: {
                        value: new qt(.5, .5)
                    },
                    kernelRadius: {
                        value: 1
                    }
                },
                vertexShader: Ki.pp_plane_vert,
                fragmentShader: Ki.pp_outline_blur_frag
            })
        },
        getOverlayMaterial: function () {
            return new Oi({
                type: "OutlineOverlay",
                uniforms: {
                    maskTexture: {
                        value: null
                    },
                    edgeTexture1: {
                        value: null
                    },
                    edgeTexture2: {
                        value: null
                    },
                    patternTexture: {
                        value: null
                    },
                    edgeStrength: {
                        value: 1
                    },
                    edgeGlow: {
                        value: 1
                    },
                    usePatternTexture: {
                        value: 0
                    }
                },
                vertexShader: Ki.pp_plane_vert,
                fragmentShader: Ki.pp_outline_overlay_frag,
                blending: ue,
                blendEquation: de,
                blendEquationAlpha: de,
                blendSrc: xe,
                blendDst: be,
                blendSrcAlpha: ge,
                blendDstAlpha: ge,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            })
        },
        setCamera: function (e) {
            this.renderCamera = e
        }
    }), n_.BlurDirectionX = new qt(1, 0), n_.BlurDirectionY = new qt(0, 1);
    var r_, i_, a_, o_, s_ = 4,
        l_ = 8,
        c_ = Math.pow(2, l_),
        u_ = [.125, .215, .35, .446, .526, .582],
        d_ = l_ - s_ + 1 + u_.length,
        h_ = 20,
        p_ = (_defineProperty(n = {}, At, 0), _defineProperty(n, St, 1), _defineProperty(n, Et, 2), _defineProperty(n, Pt, 3), _defineProperty(n, Lt, 4), _defineProperty(n, Rt, 5), _defineProperty(n, Tt, 6), n),
        f_ = new qi,
        m_ = (r_ = h_, i_ = new Float32Array(r_), a_ = new on(0, 1, 0), (o_ = new xc({
            defines: {
                n: r_
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: i_
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                mipInt: {
                    value: 0
                },
                poleAxis: {
                    value: a_
                },
                inputEncoding: {
                    value: p_[At]
                },
                outputEncoding: {
                    value: p_[At]
                }
            },
            vertexShader: U_(),
            fragmentShader: "\nprecision highp float;\nprecision highp int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n".concat(V_(), "\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n    gl_FragColor = vec4(0.0);\n    for (int i = 0; i < n; i++) {\n        if (i >= samples)\n            break;\n        for (int dir = -1; dir < 2; dir += 2) {\n            if (i == 0 && dir == 1)\n                continue;\n            vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n            if (all(equal(axis, vec3(0.0))))\n                axis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);\n            axis = normalize(axis);\n            float theta = dTheta * float(dir * i);\n            float cosTheta = cos(theta);\n            // Rodrigues' axis-angle rotation\n            vec3 sampleDirection = vOutputDirection * cosTheta\n                    + cross(axis, vOutputDirection) * sin(theta)\n                    + axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n            gl_FragColor.rgb +=\n                    weights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);\n        }\n    }\n    gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n        "),
            blending: ae,
            depthTest: !1,
            depthWrite: !1
        })).type = "SphericalGaussianBlur", o_),
        v_ = null,
        g_ = null,
        __ = function () {
            for (var e = [], t = [], n = [], r = l_, i = 0; i < d_; i++) {
                var a = Math.pow(2, r);
                t.push(a);
                var o = 1 / a;
                l_ - s_ < i ? o = u_[i - l_ + s_ - 1] : 0 == i && (o = 0), n.push(o);
                for (var s = 1 / (a - 1), l = -s / 2, c = 1 + s / 2, u = [l, l, c, l, c, c, l, l, c, c, l, c], d = new Float32Array(108), h = new Float32Array(72), p = new Float32Array(36), f = 0; f < 6; f++) {
                    var m = f % 3 * 2 / 3 - 1,
                        v = 2 < f ? 0 : -1,
                        g = [m, v, 0, m + 2 / 3, v, 0, m + 2 / 3, 1 + v, 0, m, v, 0, m + 2 / 3, 1 + v, 0, m, 1 + v, 0];
                    d.set(g, 18 * f), h.set(u, 12 * f);
                    var _ = [f, f, f, f, f, f];
                    p.set(_, 6 * f)
                }
                var y = new ni;
                y.setAttribute("position", new zr(d, 3)), y.setAttribute("uv", new zr(h, 2)), y.setAttribute("faceIndex", new zr(p, 1)), e.push(y), s_ < r && r--
            }
            return {
                _lodPlanes: e,
                _sizeLods: t,
                _sigmas: n = [0, .025, .07, .18, .24, .3, .36, .42, .48, .54, .6]
            }
        }(),
        y_ = __._lodPlanes,
        x_ = __._sizeLods,
        b_ = __._sigmas,
        w_ = null,
        M_ = null,
        A_ = null,
        S_ = (1 + Math.sqrt(5)) / 2,
        T_ = 1 / S_,
        E_ = [new on(1, 1, 1), new on(-1, 1, 1), new on(1, 1, -1), new on(-1, 1, -1), new on(0, S_, T_), new on(0, S_, -T_), new on(T_, 0, S_), new on(-T_, 0, S_), new on(S_, T_, 0), new on(-S_, T_, 0)];

    function C_(e) {
        this.flipCubemapX = !0, M_ = e, R_(m_)
    }

    function P_(e, t) {
        var n = {
            magFilter: Ze,
            minFilter: Ze,
            generateMipmaps: !1,
            type: e ? e.type : tt,
            format: e ? e.format : S,
            encoding: e ? e.encoding : Et,
            depthBuffer: !1,
            stencilBuffer: !1
        };
        Object.assign(n, t);
        var r = D_(n);
        return r.depthBuffer = !e, w_ = D_(n), r
    }

    function L_(e) {
        w_.dispose(), M_.setRenderTarget(A_), e.scissorTest = !1, e.setSize(e.width, e.height)
    }

    function R_(e) {
        var t = new Bn;
        t.add(new xi(y_[0], e)), M_.compile(t, f_)
    }

    function D_(e) {
        var t = new en(3 * c_, 3 * c_, e);
        return t.texture.mapping = We, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
    }

    function I_(e, t, n, r, i) {
        e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
    }

    function N_(e) {
        var t = M_.autoClear;
        M_.autoClear = !1;
        for (var n = 1; n < d_; n++) {
            O_(e, n - 1, n, Math.sqrt(b_[n] * b_[n] - b_[n - 1] * b_[n - 1]), E_[(n - 1) % E_.length])
        }
        M_.autoClear = t
    }

    function O_(e, t, n, r, i) {
        F_(e, w_, t, n, r, "latitudinal", i), F_(w_, e, n, n, r, "longitudinal", i)
    }

    function F_(e, t, n, r, i, a, o) {
        "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
        var s = new Bn;
        s.add(new xi(y_[r], m_));
        var l = m_.uniforms,
            c = x_[n] - 1,
            u = isFinite(i) ? Math.PI / (2 * c) : 2 * Math.PI / (2 * h_ - 1),
            d = i / u,
            h = isFinite(i) ? 1 + Math.floor(3 * d) : h_;
        h_ < h && console.warn("sigmaRadians, ".concat(i, ", is too large and will clip, as it requested ").concat(h, " samples when the maximum is set to ").concat(h_));
        for (var p = [], f = 0, m = 0; m < h_; ++m) {
            var v = m / d,
                g = Math.exp(-v * v / 2);
            p.push(g), 0 == m ? f += g : m < h && (f += 2 * g)
        }
        for (m = 0; m < p.length; m++) p[m] = p[m] / f;
        l.envMap.value = e.texture, l.samples.value = h, l.weights.value = p, l.latitudinal.value = "latitudinal" === a, o && (l.poleAxis.value = o), l.dTheta.value = u, l.mipInt.value = l_ - n, l.inputEncoding.value = p_[e.texture.encoding], l.outputEncoding.value = p_[e.texture.encoding];
        var _ = x_[r];
        I_(t, v = 3 * Math.max(0, c_ - 2 * _), (0 === r ? 0 : 2 * c_) + 2 * _ * (l_ - s_ < r ? r - l_ + s_ : 0), 3 * _, 2 * _), M_.setRenderTarget(t), M_.render(s, f_)
    }

    function B_() {
        var e = new xc({
            uniforms: {
                envMap: {
                    value: null
                },
                texelSize: {
                    value: new qt(1, 1)
                },
                inputEncoding: {
                    value: p_[At]
                },
                outputEncoding: {
                    value: p_[At]
                }
            },
            vertexShader: U_(),
            fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n".concat(V_(), "\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n    gl_FragColor = vec4(0.0);\n    vec3 outputDirection = normalize(vOutputDirection);\n    vec2 uv;\n    uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n    uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n    vec2 f = fract(uv / texelSize - 0.5);\n    uv -= f * texelSize;\n    vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n    uv.x += texelSize.x;\n    vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n    uv.y += texelSize.y;\n    vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n    uv.x -= texelSize.x;\n    vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n    vec3 tm = mix(tl, tr, f.x);\n    vec3 bm = mix(bl, br, f.x);\n    gl_FragColor.rgb = mix(tm, bm, f.y);\n    gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n        "),
            blending: ae,
            depthTest: !1,
            depthWrite: !1
        });
        return e.type = "EquirectangularToCubeUV", e
    }

    function z_() {
        var e = new xc({
            uniforms: {
                envMap: {
                    value: null
                },
                inputEncoding: {
                    value: p_[At]
                },
                outputEncoding: {
                    value: p_[At]
                },
                flipCubemapX: {
                    value: !0
                }
            },
            vertexShader: U_(),
            fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\nuniform bool flipCubemapX;\n\n".concat(V_(), "\n\nvoid main() {\n    gl_FragColor = vec4(0.0);\n    gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3(vOutputDirection.x * (flipCubemapX ? -1.0 : 1.0), vOutputDirection.yz))).rgb;\n    gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n        "),
            blending: ae,
            depthTest: !1,
            depthWrite: !1
        });
        return e.type = "CubemapToCubeUV", e
    }

    function U_() {
        return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n    uv = 2.0 * uv - 1.0;\n    vec3 direction = vec3(uv, 1.0);\n    if (face == 0.0) {\n        direction = direction.zyx;\n        direction.z *= -1.0;\n    } else if (face == 1.0) {\n        direction = direction.xzy;\n        direction.z *= -1.0;\n    } else if (face == 3.0) {\n        direction = direction.zyx;\n        direction.x *= -1.0;\n    } else if (face == 4.0) {\n        direction = direction.xzy;\n        direction.y *= -1.0;\n    } else if (face == 5.0) {\n        direction.xz *= -1.0;\n    }\n    return direction;\n}\nvoid main() {\n    vOutputDirection = getDirection(uv, faceIndex);\n    gl_Position = vec4(position, 1.0);\n}\n    "
    }

    function V_() {
        return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n    if(inputEncoding == 0){\n        return value;\n    }else if(inputEncoding == 1){\n        return sRGBToLinear(value);\n    }else if(inputEncoding == 2){\n        return RGBEToLinear(value);\n    }else if(inputEncoding == 3){\n        return RGBMToLinear(value, 7.0);\n    }else if(inputEncoding == 4){\n        return RGBMToLinear(value, 16.0);\n    }else if(inputEncoding == 5){\n        return RGBDToLinear(value, 256.0);\n    }else{\n        return GammaToLinear(value, 2.2);\n    }\n}\n\nvec4 linearToOutputTexel(vec4 value){\n    if(outputEncoding == 0){\n        return value;\n    }else if(outputEncoding == 1){\n        return LinearTosRGB(value);\n    }else if(outputEncoding == 2){\n        return LinearToRGBE(value);\n    }else if(outputEncoding == 3){\n        return LinearToRGBM(value, 7.0);\n    }else if(outputEncoding == 4){\n        return LinearToRGBM(value, 16.0);\n    }else if(outputEncoding == 5){\n        return LinearToRGBD(value, 256.0);\n    }else{\n        return LinearToGamma(value, 2.2);\n    }\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n    return inputTexelToLinear(color);\n}\n    "
    }

    function G_(e, t, n, r, i) {
        Zm.call(this), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = void 0 !== i ? i : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1
    }

    function k_(e, t) {
        var n = (this.sourceTexture = e).image.width,
            r = e.image.height,
            i = {
                format: lt,
                magFilter: Je,
                minFilter: 1008,
                type: t,
                generateMipmaps: !0,
                anisotropy: e.anisotropy,
                encoding: At,
                wrapS: e.wrapS,
                wrapT: e.wrapT
            };
        this.renderTarget = new en(n, r, i), this.renderTarget.texture.name = e.name, this.renderTarget.texture.flipY = e.flipY, this.camera = new qi(-1, 1, 1, -1, 0, 1), this.shader = new Oi({
            type: "RGBEToFloat",
            uniforms: Di.clone(Ji.copy.uniforms),
            vertexShader: Ji.copy.vertexShader,
            fragmentShader: Ji.copy.fragmentShader,
            defines: {
                MAP_TEXELS: 1
            }
        }), this.planeMesh = new xi(new Qi(2, 2, 0), this.shader), this.planeMesh.material.map = e, this.scene = new Bn, this.scene.add(this.planeMesh), this.scene.add(this.camera), this.shader.uniforms.tDiffuse.value = e, this.shader.uniforms.opacity.value = 1
    }
    C_.prototype = {
        constructor: C_,
        fromScene: function (e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : .1,
                r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 100;
            A_ = M_.getRenderTarget();
            var i = P_();
            return function (e, t, n, r) {
                var i = new Bi(90, 1, t, n),
                    a = [1, 1, 1, 1, -1, 1],
                    o = [1, 1, -1, -1, -1, 1],
                    s = M_.outputEncoding,
                    l = M_.toneMapping,
                    c = M_.toneMappingExposure,
                    u = M_.getClearColor(),
                    d = M_.getClearAlpha();
                M_.toneMapping = Fe, M_.toneMappingExposure = 1, M_.outputEncoding = At, e.scale.z *= -1;
                var h = e.background;
                if (h && h.isColor) {
                    h.convertSRGBToLinear();
                    var p = Math.max(h.r, h.g, h.b),
                        f = Math.min(Math.max(Math.ceil(Math.log2(p)), -128), 127);
                    h = h.multiplyScalar(Math.pow(2, -f));
                    var m = (f + 128) / 255;
                    M_.setClearColor(h, m), e.background = null
                }
                for (var v = 0; v < 6; v++) {
                    var g = v % 3;
                    0 == g ? (i.up.set(0, a[v], 0), i.lookAt(o[v], 0, 0)) : 1 == g ? (i.up.set(0, 0, a[v]), i.lookAt(0, o[v], 0)) : (i.up.set(0, a[v], 0), i.lookAt(0, 0, o[v])), I_(r, g * c_, 2 < v ? c_ : 0, c_, c_), M_.setRenderTarget(r), M_.render(e, i)
                }
                M_.toneMapping = l, M_.toneMappingExposure = c, M_.outputEncoding = s, M_.setClearColor(u, d), e.scale.z *= -1
            }(e, n, r, i), 0 < t && O_(i, 0, 0, t), N_(i), L_(i), i
        },
        fromEquirectangular: function (e) {
            return e.magFilter = Ze, e.minFilter = Ze, e.generateMipmaps = !1, this.fromCubemap(e)
        },
        fromCubemap: function (e) {
            A_ = M_.getRenderTarget();
            var t = P_(e);
            return function (e, t, n) {
                var r = new Bn;
                e.isCubeTexture ? null == g_ && (g_ = z_()) : null == v_ && (v_ = B_());
                var i = e.isCubeTexture ? g_ : v_;
                r.add(new xi(y_[0], i));
                var a = i.uniforms;
                (a.envMap.value = e).isCubeTexture ? a.flipCubemapX.value = n || !1 : a.texelSize.value.set(1 / e.image.width, 1 / e.image.height);
                a.inputEncoding.value = p_[e.encoding], a.outputEncoding.value = p_[e.encoding], I_(t, 0, 0, 3 * c_, 2 * c_), M_.setRenderTarget(t), M_.render(r, f_)
            }(e, t, this.flipCubemapX), N_(t), L_(t), t
        },
        fromCubeRenderTarget: function (e, t) {
            var n = P_(e.texture, t);
            return function (e, t, n) {
                var r = new Bn;
                null == g_ && (g_ = z_());
                var i = g_;
                r.add(new xi(y_[0], i));
                var a = i.uniforms;
                a.envMap.value = e.texture, a.flipCubemapX.value = n || !1, a.inputEncoding.value = p_[e.texture.encoding], a.outputEncoding.value = p_[t.texture.encoding], I_(t, 0, 0, 3 * c_, 2 * c_), M_.setRenderTarget(t), M_.render(r, f_)
            }(e, n, this.flipCubemapX), N_(n), L_(n), n
        },
        compileCubemapShader: function () {
            null == g_ && R_(g_ = z_())
        },
        compileEquirectangularShader: function () {
            null == v_ && R_(v_ = B_())
        },
        dispose: function () {
            m_.dispose(), null != g_ && g_.dispose(), null != v_ && v_.dispose();
            for (var e = 0; e < y_.length; e++) y_[e].dispose()
        }
    }, G_.prototype = Object.assign(Object.create(Zm.prototype), {
        constructor: G_,
        render: function (e, t, n, r, i) {
            var a, o, s = e.autoClear;
            e.autoClear = !1, this.scene.overrideMaterial = this.overrideMaterial, this.clearColor && (a = e.getClearColor().getHex(), o = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(a, o), this.scene.overrideMaterial = null, e.autoClear = s
        },
        setCamera: function (e) {
            this.camera = e
        }
    }), k_.prototype = {
        constructor: k_,
        update: function (e) {
            var t = e.toneMapping,
                n = e.toneMappingExposure,
                r = e.getRenderTarget();
            e.toneMapping = Fe, e.toneMappingExposure = 1, e.setRenderTarget(this.renderTarget), e.render(this.scene, this.camera), e.setRenderTarget(r), e.toneMapping = t, e.toneMappingExposure = n
        },
        dispose: function () {
            this.renderTarget.dispose(), this.planeMesh.geometry.dispose(), this.planeMesh.material.dispose()
        }
    };
    var j_ = {
        renderWorldNodeMatToCubemap: function (e, t, n) {
            t.isMeshNodeMaterial || console.error("v3d.RenderUtils.renderWorldNodeMatToCubemap(): material is not an instance of MeshNodeMaterial.");
            var r = new Bn,
                i = new zi(.1, 10, n);
            i.renderTarget.texture.encoding = St, i.renderTarget.texture.generateMipmaps = !1, r.add(i);
            var a = /Firefox/.test(navigator.userAgent) && /Android/.test(navigator.userAgent),
                o = e.getContext();
            if (!a && (e.capabilities.isWebGL2 && o.getExtension("EXT_color_buffer_float") && o.getExtension("OES_texture_float_linear") || o.getExtension("OES_texture_half_float") && o.getExtension("OES_texture_half_float_linear"))) {
                i.renderTarget.texture.type = at, i.renderTarget.texture.format = lt;
                var s = window.navigator.platform,
                    l = !!window.chrome && !/Edge/.test(navigator.userAgent),
                    c = -1 !== ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].indexOf(s);
                for (var u in t.nodeTextures) {
                    var d = t.nodeTextures[u];
                    if (!(d.encoding != Et || l && c)) {
                        var h = new k_(d, at);
                        h.update(e), t.nodeTextures[u] = h.renderTarget.texture, t.updateNodeGraph()
                    }
                }
            }
            var p = t.clone();
            p.defines.WORLD_NODES = 1, p.side = Pe;
            var f = new xi(new Pi(1, 1, 1), p);
            for (var u in r.add(f), i.update(e, r), f.material.dispose(), f.material.nodeTextures) f.material.nodeTextures[u].dispose();
            return f.geometry.dispose(), i.renderTarget
        },
        assignAllLayersMask: function (e) {
            var t = e.layers.mask;
            return e.layers.set(0), e.isArrayCamera && (e.layers.enable(1), e.layers.enable(2)), e.layers.enable(3), e.layers.enable(4), e.layers.enable(5), e.layers.enable(6), t
        }
    };

    function W_(e) {
        this.data = void 0 !== e ? e : null, this.equirecInvertU = !1, this.equirecOffsetU = 0, this.useHDR = !1
    }
    Object.assign(W_.prototype, {
        isSceneBackground: !0,
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            null === e.data ? this.data = null : e.data.isColor ? this.data = e.data.clone() : e.data.isCubeTexture || e.data.isTexture ? (this.data = e.data.clone(), this.data.needsUpdate = !0) : e.data.isWebGLCubeRenderTarget ? (this.data = e.data.clone(), this.data.texture.needsUpdate = !0) : this.data = e.data, this.equirecInvertU = e.equirecInvertU, this.equirecOffsetU = e.equirecOffsetU, this.useHDR = e.useHDR
        },
        toJSON: function (e) {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "SceneBackground",
                    generator: "SceneBackground.toJSON"
                }
            };
            return null !== this.data && (t.data = this.data.toJSON(e)), !0 === this.equirecInvertU && (t.equirecInvertU = !0), 0 !== this.equirecOffsetU && (t.equirecOffsetU = this.equirecOffsetU), t
        }
    });

    function X_(e) {
        null == e && (e = Math), this.grad3 = [
            [1, 1, 0],
            [-1, 1, 0],
            [1, -1, 0],
            [-1, -1, 0],
            [1, 0, 1],
            [-1, 0, 1],
            [1, 0, -1],
            [-1, 0, -1],
            [0, 1, 1],
            [0, -1, 1],
            [0, 1, -1],
            [0, -1, -1]
        ], this.grad4 = [
            [0, 1, 1, 1],
            [0, 1, 1, -1],
            [0, 1, -1, 1],
            [0, 1, -1, -1],
            [0, -1, 1, 1],
            [0, -1, 1, -1],
            [0, -1, -1, 1],
            [0, -1, -1, -1],
            [1, 0, 1, 1],
            [1, 0, 1, -1],
            [1, 0, -1, 1],
            [1, 0, -1, -1],
            [-1, 0, 1, 1],
            [-1, 0, 1, -1],
            [-1, 0, -1, 1],
            [-1, 0, -1, -1],
            [1, 1, 0, 1],
            [1, 1, 0, -1],
            [1, -1, 0, 1],
            [1, -1, 0, -1],
            [-1, 1, 0, 1],
            [-1, 1, 0, -1],
            [-1, -1, 0, 1],
            [-1, -1, 0, -1],
            [1, 1, 1, 0],
            [1, 1, -1, 0],
            [1, -1, 1, 0],
            [1, -1, -1, 0],
            [-1, 1, 1, 0],
            [-1, 1, -1, 0],
            [-1, -1, 1, 0],
            [-1, -1, -1, 0]
        ], this.p = [];
        for (var t = 0; t < 256; t++) this.p[t] = Math.floor(256 * e.random());
        for (this.perm = [], t = 0; t < 512; t++) this.perm[t] = this.p[255 & t];
        this.simplex = [
            [0, 1, 2, 3],
            [0, 1, 3, 2],
            [0, 0, 0, 0],
            [0, 2, 3, 1],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [1, 2, 3, 0],
            [0, 2, 1, 3],
            [0, 0, 0, 0],
            [0, 3, 1, 2],
            [0, 3, 2, 1],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [1, 3, 2, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [1, 2, 0, 3],
            [0, 0, 0, 0],
            [1, 3, 0, 2],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [2, 3, 0, 1],
            [2, 3, 1, 0],
            [1, 0, 2, 3],
            [1, 0, 3, 2],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [2, 0, 3, 1],
            [0, 0, 0, 0],
            [2, 1, 3, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [2, 0, 1, 3],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [3, 0, 1, 2],
            [3, 0, 2, 1],
            [0, 0, 0, 0],
            [3, 1, 2, 0],
            [2, 1, 0, 3],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [3, 1, 0, 2],
            [0, 0, 0, 0],
            [3, 2, 0, 1],
            [3, 2, 1, 0]
        ]
    }
    var H_ = {
        createMultiMaterialObject: function (e, t) {
            for (var n = new Jo, r = 0, i = t.length; r < i; r++) n.add(new xi(e, t[r]));
            return n
        },
        detach: function (e, t, n) {
            e.applyMatrix(t.matrixWorld), t.remove(e), n.add(e)
        },
        attach: function (e, t, n) {
            e.applyMatrix((new fn).getInverse(n.matrixWorld)), t.remove(e), n.add(e)
        },
        getMaterialByName: function (e, t) {
            var n = this.getMaterialsByName(e, t);
            return n.length ? n[0] : null
        },
        getMaterialsByName: function (e, t) {
            for (var n = [], r = 0; r < e.materials.length; r++) {
                var i = e.materials[r];
                i.name == t && n.push(i)
            }
            var a = e.worldMaterial;
            return a && a.name == t && n.push(a), n
        },
        getAnimationActionByName: function (e, t) {
            for (var n = 0; n < e.actions.length; n++) {
                var r = e.actions[n];
                if (r.getClip().name == t) return r
            }
        },
        checkActionIsUsed: function (n, e) {
            return Boolean(e._propertyBindings.find(function (e) {
                var t = e.binding.node;
                return t && t.findRoot() === n
            }))
        },
        createEnvironmentMaterial: function (e, t, n) {
            var r = new Dc.DiGraph(6),
                i = {};
            if (r.node(0).originData = {
                    name: "Light Path",
                    type: "LIGHT_PATH_BL",
                    inputs: [],
                    outputs: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    is_active_output: !1
                }, r.node(1).originData = {
                    name: "Lighting Texture",
                    type: "TEX_ENVIRONMENT_BL",
                    projection: "EQUIRECTANGULAR",
                    inputs: [
                        [0, 0, 0]
                    ],
                    outputs: [
                        [0, 0, 0, 0]
                    ],
                    texture: 0,
                    is_active_output: !1
                }, i[hu.nodeTexUniName("TEX_ENVIRONMENT_BL", 0)] = t, n instanceof Pr) {
                var a = [0, 0, 0, 0];
                a[0] = n.r, a[1] = n.g, a[2] = n.b, a[3] = 1, r.node(2).originData = {
                    name: "Background Color",
                    type: "RGB_BL",
                    inputs: [],
                    outputs: [a],
                    is_active_output: !1
                }
            } else r.node(2).originData = {
                name: "Background Texture",
                type: "TEX_ENVIRONMENT_BL",
                projection: "EQUIRECTANGULAR",
                inputs: [
                    [0, 0, 0]
                ],
                outputs: [
                    [0, 0, 0, 0]
                ],
                texture: 1,
                is_active_output: !1
            }, i[hu.nodeTexUniName("TEX_ENVIRONMENT_BL", 1)] = n;
            return r.node(3).originData = {
                name: "Mix",
                type: "MIX_RGB_BL",
                blendType: "MIX",
                inputs: [0, [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                outputs: [
                    [0, 0, 0, 0]
                ],
                is_active_output: !1
            }, r.node(4).originData = {
                name: "Background",
                type: "BACKGROUND_BL",
                inputs: [
                    [0, 0, 0, 0], 1
                ],
                outputs: [
                    [0, 0, 0, 0]
                ],
                is_active_output: !1
            }, r.node(5).originData = {
                name: "Output",
                type: "OUTPUT_WORLD_BL",
                inputs: [
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                outputs: [],
                is_active_output: !0
            }, pu(r, 0, 0, 3, 0), pu(r, 1, 0, 3, 1), pu(r, 2, 0, 3, 2), pu(r, 3, 0, 4, 0), pu(r, 4, 0, 5, 0), new hu({
                name: e,
                nodeGraph: r,
                nodeTextures: i
            })
        },
        calcSceneBox: function (e) {
            var t = new Kn;
            return t.expandByObject(e), t
        },
        createDefaultCamera: function (e, t) {
            var n = new on,
                r = 2 * e.getSize(n).length(),
                i = new Bi(45, t, r / 1e4, r);
            return i.position.copy(e.max).multiplyScalar(2), i.lookAt(e.getCenter(n)), i
        },
        assignDefaultControls: function (e, t) {
            var n = new Fn;
            t.getCenter(n.position), e.controls = {
                type: "ORBIT",
                enablePan: !0,
                rotateSpeed: 1,
                moveSpeed: 1,
                orbitMinDistance: e.near,
                orbitMaxDistance: e.far,
                orbitMinPolarAngle: 0,
                orbitMaxPolarAngle: Math.PI,
                orbitMinAzimuthAngle: -1 / 0,
                orbitMaxAzimuthAngle: 1 / 0,
                orbitTarget: n
            }
        }
    };
    X_.prototype.dot = function (e, t, n) {
        return e[0] * t + e[1] * n
    }, X_.prototype.dot3 = function (e, t, n, r) {
        return e[0] * t + e[1] * n + e[2] * r
    }, X_.prototype.dot4 = function (e, t, n, r, i) {
        return e[0] * t + e[1] * n + e[2] * r + e[3] * i
    }, X_.prototype.noise = function (e, t) {
        var n, r, i = (e + t) * (.5 * (Math.sqrt(3) - 1)),
            a = Math.floor(e + i),
            o = Math.floor(t + i),
            s = (3 - Math.sqrt(3)) / 6,
            l = (a + o) * s,
            c = e - (a - l),
            u = t - (o - l);
        r = u < c ? (n = 1, 0) : (n = 0, 1);
        var d = c - n + s,
            h = u - r + s,
            p = c - 1 + 2 * s,
            f = u - 1 + 2 * s,
            m = 255 & a,
            v = 255 & o,
            g = this.perm[m + this.perm[v]] % 12,
            _ = this.perm[m + n + this.perm[v + r]] % 12,
            y = this.perm[1 + m + this.perm[1 + v]] % 12,
            x = .5 - c * c - u * u,
            b = .5 - d * d - h * h,
            w = .5 - p * p - f * f;
        return 70 * ((x < 0 ? 0 : (x *= x) * x * this.dot(this.grad3[g], c, u)) + (b < 0 ? 0 : (b *= b) * b * this.dot(this.grad3[_], d, h)) + (w < 0 ? 0 : (w *= w) * w * this.dot(this.grad3[y], p, f)))
    }, X_.prototype.noise3d = function (e, t, n) {
        var r, i, a, o, s, l, c = (e + t + n) * (1 / 3),
            u = Math.floor(e + c),
            d = Math.floor(t + c),
            h = Math.floor(n + c),
            p = (u + d + h) * (1 / 6),
            f = e - (u - p),
            m = t - (d - p),
            v = n - (h - p);
        l = m <= f ? v <= m ? (s = o = r = 1, a = i = 0) : o = v <= f ? (s = a = i = 0, r = 1) : (s = i = r = 0, a = 1) : m < v ? (o = i = r = 0, s = a = 1) : f < v ? (o = a = r = 0, s = i = 1) : (s = o = i = 1, a = r = 0);
        var g = f - r + 1 / 6,
            _ = m - i + 1 / 6,
            y = v - a + 1 / 6,
            x = f - o + 1 / 6 * 2,
            b = m - s + 1 / 6 * 2,
            w = v - l + 1 / 6 * 2,
            M = f - 1 + .5,
            A = m - 1 + .5,
            S = v - 1 + .5,
            T = 255 & u,
            E = 255 & d,
            C = 255 & h,
            P = this.perm[T + this.perm[E + this.perm[C]]] % 12,
            L = this.perm[T + r + this.perm[E + i + this.perm[C + a]]] % 12,
            R = this.perm[T + o + this.perm[E + s + this.perm[C + l]]] % 12,
            D = this.perm[1 + T + this.perm[1 + E + this.perm[1 + C]]] % 12,
            I = .6 - f * f - m * m - v * v,
            N = .6 - g * g - _ * _ - y * y,
            O = .6 - x * x - b * b - w * w,
            F = .6 - M * M - A * A - S * S;
        return 32 * ((I < 0 ? 0 : (I *= I) * I * this.dot3(this.grad3[P], f, m, v)) + (N < 0 ? 0 : (N *= N) * N * this.dot3(this.grad3[L], g, _, y)) + (O < 0 ? 0 : (O *= O) * O * this.dot3(this.grad3[R], x, b, w)) + (F < 0 ? 0 : (F *= F) * F * this.dot3(this.grad3[D], M, A, S)))
    }, X_.prototype.noise4d = function (e, t, n, r) {
        var i, a, o, s, l, c, u, d, h, p, f, m, v = this.grad4,
            g = this.simplex,
            _ = this.perm,
            y = (Math.sqrt(5) - 1) / 4,
            x = (5 - Math.sqrt(5)) / 20,
            b = (e + t + n + r) * y,
            w = Math.floor(e + b),
            M = Math.floor(t + b),
            A = Math.floor(n + b),
            S = Math.floor(r + b),
            T = (w + M + A + S) * x,
            E = e - (w - T),
            C = t - (M - T),
            P = n - (A - T),
            L = r - (S - T),
            R = (C < E ? 32 : 0) + (P < E ? 16 : 0) + (P < C ? 8 : 0) + (L < E ? 4 : 0) + (L < C ? 2 : 0) + (L < P ? 1 : 0),
            D = E - (i = 3 <= g[R][0] ? 1 : 0) + x,
            I = C - (a = 3 <= g[R][1] ? 1 : 0) + x,
            N = P - (o = 3 <= g[R][2] ? 1 : 0) + x,
            O = L - (s = 3 <= g[R][3] ? 1 : 0) + x,
            F = E - (l = 2 <= g[R][0] ? 1 : 0) + 2 * x,
            B = C - (c = 2 <= g[R][1] ? 1 : 0) + 2 * x,
            z = P - (u = 2 <= g[R][2] ? 1 : 0) + 2 * x,
            U = L - (d = 2 <= g[R][3] ? 1 : 0) + 2 * x,
            V = E - (h = 1 <= g[R][0] ? 1 : 0) + 3 * x,
            G = C - (p = 1 <= g[R][1] ? 1 : 0) + 3 * x,
            k = P - (f = 1 <= g[R][2] ? 1 : 0) + 3 * x,
            j = L - (m = 1 <= g[R][3] ? 1 : 0) + 3 * x,
            W = E - 1 + 4 * x,
            X = C - 1 + 4 * x,
            H = P - 1 + 4 * x,
            Y = L - 1 + 4 * x,
            q = 255 & w,
            Z = 255 & M,
            Q = 255 & A,
            K = 255 & S,
            J = _[q + _[Z + _[Q + _[K]]]] % 32,
            $ = _[q + i + _[Z + a + _[Q + o + _[K + s]]]] % 32,
            ee = _[q + l + _[Z + c + _[Q + u + _[K + d]]]] % 32,
            te = _[q + h + _[Z + p + _[Q + f + _[K + m]]]] % 32,
            ne = _[1 + q + _[1 + Z + _[1 + Q + _[1 + K]]]] % 32,
            re = .6 - E * E - C * C - P * P - L * L,
            ie = .6 - D * D - I * I - N * N - O * O,
            ae = .6 - F * F - B * B - z * z - U * U,
            oe = .6 - V * V - G * G - k * k - j * j,
            se = .6 - W * W - X * X - H * H - Y * Y;
        return 27 * ((re < 0 ? 0 : (re *= re) * re * this.dot4(v[J], E, C, P, L)) + (ie < 0 ? 0 : (ie *= ie) * ie * this.dot4(v[$], D, I, N, O)) + (ae < 0 ? 0 : (ae *= ae) * ae * this.dot4(v[ee], F, B, z, U)) + (oe < 0 ? 0 : (oe *= oe) * oe * this.dot4(v[te], V, G, k, j)) + (se < 0 ? 0 : (se *= se) * se * this.dot4(v[ne], W, X, H, Y)))
    };

    function Y_(e, t, n, r) {
        Zm.call(this), this.width = void 0 !== n ? n : 512, this.height = void 0 !== r ? r : 512, this.clear = !0, this.camera = t, this.scene = e, this.kernelRadius = 8, this.kernelSize = 32, this.kernel = [], this.noiseTexture = null, this.output = 0, this.minDistance = .005, this.maxDistance = .1, this.generateSampleKernel(), this.generateRandomKernelRotations();
        var i = new ol;
        i.type = nt, i.minFilter = Ze, i.maxFilter = Ze, this.beautyRenderTarget = new en(this.width, this.height, {
            minFilter: Je,
            magFilter: Je,
            format: lt,
            depthTexture: i,
            depthBuffer: !0
        }), this.normalRenderTarget = new en(this.width, this.height, {
            minFilter: Ze,
            magFilter: Ze,
            format: lt
        }), this.ssaoRenderTarget = new en(this.width, this.height, {
            minFilter: Je,
            magFilter: Je,
            format: lt
        }), this.blurRenderTarget = this.ssaoRenderTarget.clone(), this.ssaoMaterial = this.getSSAOMaterial(), this.ssaoMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.ssaoMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.ssaoMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.ssaoMaterial.uniforms.tNoise.value = this.noiseTexture, this.ssaoMaterial.uniforms.kernel.value = this.kernel, this.ssaoMaterial.uniforms.cameraNear.value = this.camera.near, this.ssaoMaterial.uniforms.cameraFar.value = this.camera.far, this.ssaoMaterial.uniforms.resolution.value.set(this.width, this.height), this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.getInverse(this.camera.projectionMatrix), this.normalMaterial = new Sc, this.normalMaterial.blending = ae, this.blurMaterial = this.getSSAOBlurMaterial(), this.blurMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture, this.blurMaterial.uniforms.resolution.value.set(this.width, this.height), this.depthRenderMaterial = this.getSSAODepthMaterial(), this.depthRenderMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near, this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far;
        var a = Ji.copy;
        this.copyMaterial = new Oi({
            type: "SSAOCopy",
            uniforms: Di.clone(a.uniforms),
            defines: Object.assign({}, a.defines),
            vertexShader: a.vertexShader,
            fragmentShader: a.fragmentShader,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1,
            blendSrc: Ae,
            blendDst: ve,
            blendEquation: de,
            blendSrcAlpha: we,
            blendDstAlpha: ve,
            blendEquationAlpha: de
        }), this.fsQuad = new Zm.FullScreenQuad(null), this.originalClearColor = new Pr
    }
    Y_.prototype = Object.assign(Object.create(Zm.prototype), {
        constructor: Y_,
        dispose: function () {
            this.beautyRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.ssaoRenderTarget.dispose(), this.blurRenderTarget.dispose(), this.normalMaterial.dispose(), this.blurMaterial.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose()
        },
        getSSAOMaterial: function () {
            return new Oi({
                type: "SSAO",
                defines: {
                    PERSPECTIVE_CAMERA: 1,
                    KERNEL_SIZE: 32
                },
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    tNormal: {
                        value: null
                    },
                    tDepth: {
                        value: null
                    },
                    tNoise: {
                        value: null
                    },
                    kernel: {
                        value: null
                    },
                    cameraNear: {
                        value: null
                    },
                    cameraFar: {
                        value: null
                    },
                    resolution: {
                        value: new qt
                    },
                    cameraProjectionMatrix: {
                        value: new fn
                    },
                    cameraInverseProjectionMatrix: {
                        value: new fn
                    },
                    kernelRadius: {
                        value: 8
                    },
                    minDistance: {
                        value: .005
                    },
                    maxDistance: {
                        value: .05
                    }
                },
                vertexShader: Ki.pp_plane_vert,
                fragmentShader: Ki.pp_ssao_frag,
                blending: ae
            })
        },
        getSSAODepthMaterial: function () {
            return new Oi({
                type: "SSAODepth",
                defines: {
                    PERSPECTIVE_CAMERA: 1
                },
                uniforms: {
                    tDepth: {
                        value: null
                    },
                    cameraNear: {
                        value: null
                    },
                    cameraFar: {
                        value: null
                    }
                },
                vertexShader: Ki.pp_plane_vert,
                fragmentShader: Ki.pp_ssao_depth_frag,
                blending: ae
            })
        },
        getSSAOBlurMaterial: function () {
            return new Oi({
                type: "SSAOBlur",
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    resolution: {
                        value: new qt
                    }
                },
                vertexShader: Ki.pp_plane_vert,
                fragmentShader: Ki.pp_ssao_blur_frag
            })
        },
        render: function (e, t, n, r, i) {
            var a = j_.assignAllLayersMask(this.camera);
            switch (e.setRenderTarget(this.beautyRenderTarget), e.clear(), e.render(this.scene, this.camera), this.renderOverride(e, this.normalMaterial, this.normalRenderTarget, 7829503, 1), this.ssaoMaterial.uniforms.kernelRadius.value = this.kernelRadius, this.ssaoMaterial.uniforms.minDistance.value = this.minDistance, this.ssaoMaterial.uniforms.maxDistance.value = this.maxDistance, this.renderPass(e, this.ssaoMaterial, this.ssaoRenderTarget), this.renderPass(e, this.blurMaterial, this.blurRenderTarget), this.output) {
                case Y_.OUTPUT.SSAO:
                    this.copyMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture, this.copyMaterial.blending = ae, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
                    break;
                case Y_.OUTPUT.Blur:
                    this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = ae, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
                    break;
                case Y_.OUTPUT.Beauty:
                    this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = ae, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
                    break;
                case Y_.OUTPUT.Depth:
                    this.renderPass(e, this.depthRenderMaterial, this.renderToScreen ? null : t);
                    break;
                case Y_.OUTPUT.Normal:
                    this.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.copyMaterial.blending = ae, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
                    break;
                case Y_.OUTPUT.Default:
                    t.disableBlit = !0, this.copyMaterial.uniforms.tDiffuse.value = n.texture, this.copyMaterial.blending = ae, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t), t.disableBlit = !1, this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = ue, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
                    break;
                default:
                    console.warn("v3d.SSAOPass: Unknown output type.")
            }
            this.camera.layers.mask = a
        },
        renderPass: function (e, t, n, r, i) {
            this.originalClearColor.copy(e.getClearColor());
            var a = e.getClearAlpha(),
                o = e.autoClear;
            e.setRenderTarget(n), e.autoClear = !1, null != r && (e.setClearColor(r), e.setClearAlpha(i || 0), e.clear()), this.fsQuad.material = t, this.fsQuad.render(e), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a)
        },
        renderOverride: function (e, t, n, r, i) {
            this.originalClearColor.copy(e.getClearColor());
            var a = e.getClearAlpha(),
                o = e.autoClear;
            e.setRenderTarget(n), e.autoClear = !1, r = t.clearColor || r, i = t.clearAlpha || i, null != r && (e.setClearColor(r), e.setClearAlpha(i || 0), e.clear()), this.scene.overrideMaterial = t, e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a)
        },
        setSize: function (e, t) {
            this.width = e, this.height = t, this.beautyRenderTarget.setSize(e, t), this.ssaoRenderTarget.setSize(e, t), this.normalRenderTarget.setSize(e, t), this.blurRenderTarget.setSize(e, t), this.ssaoMaterial.uniforms.resolution.value.set(e, t), this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.getInverse(this.camera.projectionMatrix), this.blurMaterial.uniforms.resolution.value.set(e, t)
        },
        generateSampleKernel: function () {
            for (var e = this.kernelSize, t = this.kernel, n = 0; n < e; n++) {
                var r = new on;
                r.x = 2 * Math.random() - 1, r.y = 2 * Math.random() - 1, r.z = Math.random(), r.normalize();
                var i = n / e;
                i = Yt.lerp(.1, 1, i * i), r.multiplyScalar(i), t.push(r)
            }
        },
        generateRandomKernelRotations: function () {
            for (var e = new X_, t = new Float32Array(64), n = 0; n < 16; n++) {
                var r = 4 * n,
                    i = 2 * Math.random() - 1,
                    a = 2 * Math.random() - 1,
                    o = e.noise3d(i, a, 0);
                t[r] = o, t[1 + r] = o, t[2 + r] = o, t[3 + r] = 1
            }
            this.noiseTexture = new Vi(t, 4, 4, lt, it), this.noiseTexture.wrapS = He, this.noiseTexture.wrapT = He, this.noiseTexture.needsUpdate = !0
        }
    }), Y_.OUTPUT = {
        Default: 0,
        SSAO: 1,
        Blur: 2,
        Beauty: 3,
        Depth: 4,
        Normal: 5
    };

    function q_(e, t, n) {
        Zm.call(this), this.enabled = !0, this.needsSwap = !1, n = n || {}, this.objects = n.objects || [], this.steps = xn(n.steps) || 10, this.stride = xn(n.stride) || 30, this.binarySearchSteps = xn(n.binarySearchSteps) || 4, this.renderTargetScale = xn(n.renderTargetScale) || .5, this.thickness = xn(n.thickness) || .01, this.maxDistance = xn(n.maxDistance) || 100, this.jitter = xn(n.jitter) || 1, this.useRefract = xn(n.useRefract) || !1, this.renderAfter = xn(n.renderAfter) || [], this.simpleRefraction = xn(n.simpleRefraction) || !1, this.scene = e, this.camera = t, this._prevClearColor = new Pr, this._depthBuffer = new en(256, 256, {
            minFilter: Ze,
            magFilter: Ze,
            format: lt,
            type: at
        }), this._depthBuffer.texture.name = "SSRPass.Depth", this._depthBuffer.texture.generateMipmaps = !1, this._depthMaterial = new Uo, this._depthMaterial.depthPacking = 3202, this._backfaceDepthBuffer = this._depthBuffer.clone(), this._backfaceDepthBuffer.texture.name = "SSRPass.Depth", this._backfaceDepthMaterial = new Uo, this._backfaceDepthMaterial.depthPacking = 3202, this._backfaceDepthMaterial.side = Pe, this.basic = new Fr, this.fsQuad = new Zm.FullScreenQuad(null)
    }

    function Z_(e, t, n, r) {
        Zm.call(this), this.scene = e, this.camera = t, this.sampleLevel = 4, this.unbiased = !0, this.clearColor = void 0 !== n ? n : 0, this.clearAlpha = void 0 !== r ? r : 0;
        var i = Ji.copy;
        this.copyUniformsAccum = Di.clone(i.uniforms), this.copyMaterialAccum = new Oi({
            type: "SSAACopyAccum",
            defines: i.defines,
            uniforms: this.copyUniformsAccum,
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            premultipliedAlpha: !0,
            transparent: !0,
            blending: se,
            depthTest: !1,
            depthWrite: !1
        }), this.fsQuadAccum = new v3d.Pass.FullScreenQuad(this.copyMaterialAccum), this.copyUniformsFinal = Di.clone(i.uniforms), this.copyMaterialFinal = new Oi({
            type: "SSAACopyFinal",
            defines: i.defines,
            uniforms: this.copyUniformsFinal,
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            premultipliedAlpha: !1,
            transparent: !1,
            blending: ae,
            depthTest: !1,
            depthWrite: !1
        }), this.fsQuadFinal = new v3d.Pass.FullScreenQuad(this.copyMaterialFinal), this.iterative = !1, this.iterativeFrame = 0
    }

    function Q_() {
        Jm.call(this, Ji.tonemap), this.material.type = "ToneMap"
    }
    q_.prototype = Object.assign(Object.create(Zm.prototype), {
        constructor: q_,
        _setLayer: function (e, t) {
            e.layers.set(t), e.isMesh && e.isMaterialGeneratedMesh && e.parent.layers.enable(t)
        },
        dispose: function () {
            this._depthBuffer.dispose(), this._backfaceDepthBuffer.dispose();
            for (var e = 0; e < this.objects.length; e++) {
                var t = (n = this.objects[e]).material;
                t && (this._setLayer(n, 0), delete t.defines.USE_SSR, delete t.defines.USE_SSR_REFRACT, t.needsUpdate = !0)
            }
            this.objects.splice(0);
            for (e = 0; e < this.renderAfter.length; e++) {
                var n = this.renderAfter[e];
                this._setLayer(n, 0)
            }
            this.renderAfter.splice(0)
        },
        setSize: function (e, t) {
            e *= this.renderTargetScale, t *= this.renderTargetScale, this._depthBuffer.setSize(e, t), this._backfaceDepthBuffer.setSize(e, t)
        },
        render: function (e, t, n, r, i) {
            var a = this;
            this._prevClearColor.copy(e.getClearColor());
            var o = e.getClearAlpha(),
                s = e.autoClear;
            e.autoClear = !0, e.setClearColor(new Pr(0, 0, 0), 0);
            var l = this.scene.background;
            this.scene.background = null;
            var c = this.camera.layers.mask,
                u = this.scene.overrideMaterial;
            this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(t), e.clear(), this.fsQuad.render(e), this.useRefract || (this._depthMaterial.side = ie), this.camera.layers.enable(this.useRefract ? 3 : 5), this.useRefract && this.simpleRefraction || (this.scene.overrideMaterial = this._depthMaterial, e.setRenderTarget(this._depthBuffer), e.clear(), e.render(this.scene, this.camera)), this.useRefract || (this.scene.overrideMaterial = this._backfaceDepthMaterial, e.setRenderTarget(this._backfaceDepthBuffer), e.clear(), e.render(this.scene, this.camera)), this.scene.overrideMaterial = u, this.scene.traverse(function (e) {
                e.isLight && (e.userData.v3d.oldLayersMask = e.layers.mask, e.layers.enable(a.useRefract ? 5 : 3), a.renderAfter.length && e.layers.enable(a.useRefract ? 6 : 4))
            });
            for (var d = 0; d < this.objects.length; d++) {
                var h = (p = this.objects[d]).material;
                h && h.isMeshNodeMaterial && (this._setLayer(p, this.useRefract ? 5 : 3), h.defines.USE_SSR = "", this.useRefract && (h.defines.USE_SSR_REFRACT = "", this.simpleRefraction && (h.defines.SSR_SIMPLE_REFRACT = "")), h.ssrParams = {
                    invProjectionMatrix: (new fn).getInverse(this.camera.projectionMatrix),
                    sourceBuffer: t,
                    depthBuffer: this._depthBuffer,
                    backfaceDepthBuffer: this._backfaceDepthBuffer,
                    stride: this.stride,
                    thickness: this.thickness,
                    maxDistance: this.maxDistance,
                    jitter: this.jitter
                }, h.needsUpdate = !0, h.defines.MAX_STEPS !== this.steps && (h.defines.MAX_STEPS = Math.floor(this.steps), h.needsUpdate = !0), h.defines.BINARY_SEARCH_ITERATIONS !== this.binarySearchSteps && (h.defines.BINARY_SEARCH_ITERATIONS = Math.floor(this.binarySearchSteps), h.needsUpdate = !0))
            }
            for (d = 0; d < this.renderAfter.length; d++) {
                var p = this.renderAfter[d];
                this._setLayer(p, this.useRefract ? 6 : 4)
            }
            this.camera.layers.set(this.useRefract ? 5 : 3), e.autoClear = !1, e.setRenderTarget(n), this.renderAfter.length && (n.disableBlit = !0), e.render(this.scene, this.camera), this.renderAfter.length && (this.camera.layers.set(this.useRefract ? 6 : 4), n.disableBlit = !1, e.render(this.scene, this.camera)), this.scene.background = l, this.camera.layers.mask = c, this.scene.traverse(function (e) {
                e.isLight && "oldLayersMask" in e.userData.v3d && (e.layers.mask = e.userData.v3d.oldLayersMask, delete e.userData.v3d.oldLayersMask)
            }), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), e.setClearColor(this._prevClearColor, o), e.autoClear = s
        }
    }), Z_.prototype = Object.assign(Object.create(Zm.prototype), {
        constructor: Z_,
        _getJitterOffsets: function () {
            return Z_.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))]
        },
        dispose: function () {
            this.sampleRenderTarget && (this.sampleRenderTarget.dispose(), this.sampleRenderTarget = null, this.accumRenderTarget.dispose(), this.accumRenderTarget = null)
        },
        setSize: function (e, t) {
            this.sampleRenderTarget && (this.sampleRenderTarget.setSize(e, t), this.accumRenderTarget.setSize(e, t))
        },
        render: function (e, t, n) {
            this.sampleRenderTarget || (this.sampleRenderTarget = n.clone(), this.sampleRenderTarget.texture.name = "SSAARenderPass.sample", this.accumRenderTarget = n.clone(), this.accumRenderTarget.texture.name = "SSAARenderPass.accum");
            var r = this._getJitterOffsets(),
                i = e.autoClear;
            e.autoClear = !1;
            var a = e.getClearColor().getHex(),
                o = e.getClearAlpha(),
                s = 1 / r.length;
            this.copyUniformsAccum.tDiffuse.value = this.sampleRenderTarget.texture;
            var l = n.width,
                c = n.height;
            if (this.iterative) var u = this.iterativeFrame,
                d = this.iterativeFrame + 1;
            else u = 0, d = r.length;
            for (var h = u; h < d; h++) {
                var p = r[h];
                this.camera.setViewOffset && this.camera.setViewOffset(l, c, .0625 * p[0], .0625 * p[1], l, c);
                var f = s;
                if (this.unbiased) f += 1 / 32 * ((h + .5) / r.length - .5);
                this.copyUniformsAccum.opacity.value = f, e.setClearColor(this.clearColor, this.clearAlpha), e.setRenderTarget(this.sampleRenderTarget), e.clear(), e.render(this.scene, this.camera), this.iterative ? e.setRenderTarget(this.accumRenderTarget) : e.setRenderTarget(this.renderToScreen ? null : t), 0 === h && (e.setClearColor(0, 0), e.clear()), this.fsQuadAccum.render(e)
            }
            this.iterative && (this.isLastIterativeFrame() ? (this.copyUniformsFinal.tDiffuse.value = this.accumRenderTarget.texture, e.setRenderTarget(this.renderToScreen ? null : t), this.fsQuadFinal.render(e), this.iterativeFrame = 0) : this.iterativeFrame++), this.camera.clearViewOffset && this.camera.clearViewOffset(), e.autoClear = i, e.setClearColor(a, o)
        },
        setCamera: function (e) {
            this.camera = e
        },
        isLastIterativeFrame: function () {
            var e = this._getJitterOffsets();
            return this.iterativeFrame == e.length - 1
        }
    }), Z_.JitterVectors = [
        [
            [0, 0]
        ],
        [
            [4, 4],
            [-4, -4]
        ],
        [
            [-2, -6],
            [6, -2],
            [-6, 2],
            [2, 6]
        ],
        [
            [1, -3],
            [-1, 3],
            [5, 1],
            [-3, -5],
            [-5, 5],
            [-7, -1],
            [3, 7],
            [7, -7]
        ],
        [
            [1, 1],
            [-1, -3],
            [-3, 2],
            [4, -1],
            [-5, -2],
            [2, 5],
            [5, 3],
            [3, -5],
            [-2, 6],
            [0, -7],
            [-4, -6],
            [-6, 4],
            [-8, 0],
            [7, -4],
            [6, 7],
            [-7, -8]
        ],
        [
            [-4, -7],
            [-7, -5],
            [-3, -5],
            [-5, -4],
            [-1, -4],
            [-2, -2],
            [-6, -1],
            [-4, 0],
            [-7, 1],
            [-1, 2],
            [-6, 3],
            [-3, 3],
            [-7, 6],
            [-3, 6],
            [-5, 7],
            [-1, 7],
            [5, -7],
            [1, -6],
            [6, -5],
            [4, -4],
            [2, -3],
            [7, -2],
            [1, -1],
            [4, -1],
            [2, 1],
            [6, 2],
            [0, 4],
            [4, 4],
            [2, 5],
            [7, 5],
            [5, 6],
            [3, 7]
        ]
    ], Q_.prototype = Object.assign(Object.create(Jm.prototype), {
        constructor: Q_
    });
    var K_ = ["toneMapping", "toneMappingMidTones", "toneMappingPhysicalScale", "toneMappingBrightness", "toneMappingContrast", "toneMappingChromaticAdaptation", "toneMappingWhiteColor", "toneMappingColorDifferentiation", "toneMappingExteriorDaylight", "toneMappingWhiteBalance", "toneMappingHighlights", "toneMappingShadows", "toneMappingSaturation", "toneMappingAperture", "toneMappingShutter", "toneMappingISO", "toneMappingVignetting"];

    function J_(e, t, n) {
        if (o.call(this), this.container = e instanceof HTMLElement ? e : document.getElementById(e), $o.checkWebGL()) {
            this.scene = null, this.camera = null, this.clock = new Kd, this.mixer = null, this.renderCallbacks = [], this.elapsed = 0, this.frame = 0, this.preloader = n, this.worldMaterial = null, this.worldCubemapRes = 1024, this.xrSession = null, this.xrControllers = [], void 0 === (t = t || {}).alpha && (t.alpha = !1), void 0 === t.depth && (t.depth = !0), void 0 === t.stencil && (t.stencil = !0), void 0 === t.antialias && (t.antialias = !0), void 0 === t.premultipliedAlpha && (t.premultipliedAlpha = !0), void 0 === t.preserveDrawingBuffer && (t.preserveDrawingBuffer = !1), t.xrCompatible = !0;
            var r = document.createElement("canvas"),
                i = $o.checkWebGL2();
            $o.checkIOS() && (i = !1);
            var a = r.getContext(i ? "webgl2" : "webgl", t) || r.getContext("experimental-webgl", t);
            this.renderer = new v3d.WebGLRenderer({
                canvas: r,
                context: a
            }), tv.prepareRenderer(this.renderer), this.clearBkgOnLoad = !1, this.frameRateDivider = 1, this.enableRender = !0, this.disableRenderTrigger = 0, this.ssaaOnPause = !1, this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight), this.renderer.outputEncoding = St, this.container.appendChild(this.renderer.domElement), this.container.classList.add("v3d-container"), this.renderer.domElement.classList.add("v3d-canvas"), this.loader = new bg, ni.prototype.computeBoundsTree = qf, ni.prototype.disposeBoundsTree = Zf, xi.prototype.raycast = Yf, this.actions = [], this.materials = [], this._cubeUVEnvRT = null, this._resizeCb = null, this._loadingTime = 0, this._postprocessingSave = null, qm.drawWatermark(this), qm.addToAppList(this), $o.checkIOS() && "polyfill" in window && "WebXRPolyfill" in window && polyfill instanceof WebXRPolyfill && qm.requestDeviceMotionPermissions()
        } else $o.showWebGLErrorMessage(this.container)
    }

    function $_(e, t, n) {
        return 2 * Yt.RAD2DEG * Math.atan(Math.tan(Yt.DEG2RAD * e / 2) * t / n)
    }
    J_.prototype = Object.assign(Object.create(o.prototype), {
        constructor: J_,
        _updateRendererFromGLTF: function (e) {
            var t = $o.checkHDR(this.renderer);
            if (e.renderer.shadowMap ? (this.renderer.shadowMap.enabled = e.renderer.shadowMap.enabled, this.renderer.shadowMap.type = e.renderer.shadowMap.type, t || this.renderer.shadowMap.type !== te || (this.renderer.shadowMap.type = $, e.scene.traverse(function (e) {
                    e.isLight && e.castShadow && e.shadow && (e.shadow.bias /= 100, e.shadow.isDirectionalLightShadowCSM && (e.shadow.radius *= 100 / e.shadow.mapSize.x / 2, e.shadow = (new gd).copy(e.shadow), e.shadow.camera.updateProjectionMatrix()))
                }))) : (this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = $), e.renderer.physicallyCorrectLights && (this.renderer.physicallyCorrectLights = !0), this.aaMethod = e.renderer.aaMethod || "AUTO", this.useHDR = Boolean(e.renderer.useHDR && t), this.renderer.unitsScaleFactor = e.renderer.unitsScaleFactor, e.renderer.toneMapping)
                for (var n = 0; n < K_.length; n++) {
                    var r = K_[n];
                    xn(e.renderer[r]) && (this.renderer[r] = e.renderer[r])
                }
        },
        _updateMeshesRaycastFromGLTF: function (e) {
            e.scene && e.scene.traverse(function (e) {
                var t = e.geometry;
                e.isMesh && (!t.computeBoundsTree || 0 !== Object.keys(t.morphAttributes).length || t.attributes.position.isInterleavedBufferAttribute || t.index && t.index.isInterleavedBufferAttribute || t.computeBoundsTree({
                    verbose: !1
                }))
            })
        },
        _updateMaterialsFromGLTF: function (e) {
            var n = this;
            e.scene && e.scene.traverse(function (e) {
                var t = e.material;
                t && (n.useHDR && (t.useHDR = !0, t.isMeshNodeMaterial && t.updateNodeGraph()), -1 == n.materials.indexOf(t) && n.materials.push(t))
            })
        },
        _updateAnimationsFromGLTF: function (e, r) {
            var i = this;
            !i.mixer && e.animations && e.animations.length && (i.mixer = new Ah(i.scene)), (e.animations || []).forEach(function (e) {
                var t = r.getObjectById(e.nodeId);
                if (t) {
                    if (t.id == r.id || "" !== t.name && "root" !== t.name && "." !== t.name && t.name !== r.name && t.name !== r.uuid) n = i.mixer.clipAction(e.clip, r);
                    else var n = i.mixer.clipAction(e.clip, t);
                    n.setLoop(e.loop, e.repetitions), n.startAt(e.startAt + i.mixer.time), n.clampWhenFinished = !0, e.auto ? n.play() : (n.stop(), n.paused = !0), i.actions.push(n)
                }
            })
        },
        _updateSceneCubeUVEnv: function (e) {
            var t = this;
            t._cubeUVEnvRT && t._traverseSceneForEnvUpdates(e, function (e) {
                e.material.envMap = t._cubeUVEnvRT.texture, e.material.needsUpdate = !0
            })
        },
        _traverseSceneForEnvUpdates: function (e, t) {
            e.traverse(function (e) {
                e.isMesh && e.material && (e.material.isMeshStandardMaterial || e.material.isMeshPhysicalMaterial || e.material.isMeshNodeMaterial && "PHYSICAL" in e.material.defines) && t(e)
            })
        },
        _traverseSceneForTexUniforms: function (e, n) {
            e.traverse(function (t) {
                t.material && (Array.isArray(t.material) ? t.material : [t.material]).forEach(function (e) {
                    void 0 !== e.program && n(t, e, e.program.getTexUniformCount())
                })
            })
        },
        _checkMSAA: function (e, t) {
            return Math.min(t, e.capabilities.maxSamples)
        },
        _getActiveSSAAPass: function (e) {
            return e.passes[0] instanceof Z_ ? e.passes[0] : null
        },
        _precompileSceneAsync: function (e, t, n, r) {
            var i = this,
                a = i.renderer.getRenderTarget();
            i.renderer.setRenderTarget(n), i.renderer.compileAsync(e, t, function (e) {
                1 <= e && i.renderer.setRenderTarget(a), r && r(100 * e)
            })
        },
        load: function (e, t, n, r) {
            console.warn("v3d.App.load has been deprecated. Use v3d.App.loadScene instead.");
            var i = this;
            i.loadScene(e, function (e) {
                t(e), r && i.run()
            }, null, n)
        },
        loadScene: function (e, i, a, t) {
            var o = this;
            o.renderer ? (o._loadingTime = performance.now(), this.loader.load(e, function (e) {
                o.scene = e.scene || new Bn;
                var t = null;
                e.cameras && e.cameras.length ? o.camera = e.cameras[0] : (t = H_.calcSceneBox(o.scene), o.camera = H_.createDefaultCamera(t, o.container.offsetWidth / o.container.offsetHeight), o.scene.add(o.camera)), o.camera.controls || (t = t || H_.calcSceneBox(o.scene), H_.assignDefaultControls(o.camera, H_.calcSceneBox(o.scene)), o.camera.viewportFit.type = 1), o._updateRendererFromGLTF(e), o._updateMaterialsFromGLTF(e), o._updateAnimationsFromGLTF(e, o.scene), o._updateMeshesRaycastFromGLTF(e);
                var n = e.world.material;
                n && (o.scene.background = new W_, o.updateEnvironment(n), o.worldMaterial = n), o.initPostprocessing(), o.onResize && o.onResize(), o.scene.updateMatrixWorld(), o.scene.visible = !1, o.scene.disableChildRendering = !0;
                var r = o.postprocessing ? o.postprocessing.composer.renderTarget1 : null;
                o._precompileSceneAsync(o.scene, o.camera, r, function (e) {
                    var t = 60 + .4 * e;
                    a && a(t), o.preloader && o.preloader.onUpdate(t), 100 <= t && (o._traverseSceneForTexUniforms(o.scene, function (e, t, n) {
                        8 < n && console.warn('v3d.App: Material "'.concat(t.name, '" on object ') + '"'.concat(e.name, '" exceeds iOS limit of ') + "".concat(8, " textures ") + "(has ".concat(n, ")."))
                    }), i && setTimeout(function () {
                        o.scene.visible = !0, o.scene.disableChildRendering = !1, o._loadingTime = performance.now() - o._loadingTime, o.dispatchEvent({
                            type: "loadSceneEnd"
                        }), i(o.scene)
                    }, 16))
                }), o.clearBkgOnLoad && (o.scene.background = null)
            }, function (e) {
                var t = .6 * e;
                a && a(t), o.preloader && o.preloader.onUpdate(t)
            }, function (e) {
                console.error(e), t && t(e)
            }), window.removeEventListener("resize", this._resizeCb, !1), this._resizeCb = function () {
                o.onResize && o.onResize()
            }, window.addEventListener("resize", this._resizeCb, !1)) : t && t("WebGL not found")
        },
        appendScene: function (e, a, o, t, s, l) {
            var c = this;
            c.renderer ? (void 0 === s && (s = !0), void 0 === l && (l = !0), this.loader.load(e, function (e) {
                var n = e.scene || new Bn,
                    t = [];
                n.traverse(function (e) {
                    (e.isCamera && !s || e.isLight && !l) && t.push(e)
                }), t.forEach(function (e) {
                    c.unload(e)
                }), c.scene && (c.scene.add(n), c._updateMaterialsFromGLTF(e), c._updateAnimationsFromGLTF(e, n), c._updateMeshesRaycastFromGLTF(e), c._updateSceneCubeUVEnv(n), c.scene.updateMatrixWorld());
                var r = c.postprocessing ? c.postprocessing.composer.renderTarget1 : null,
                    i = c.scene || n;
                n.visible = !1, n.disableChildRendering = !0, c._precompileSceneAsync(i, c.camera, r, function (e) {
                    var t = 60 + .4 * e;
                    o && o(t), c.preloader && c.preloader.onUpdate(t), 100 <= t && (c._traverseSceneForTexUniforms(n, function (e, t, n) {
                        8 < n && console.warn('v3d.App: Material "'.concat(t.name, '" on object ') + '"'.concat(e.name, '" exceeds iOS limit of ') + "".concat(8, " textures ") + "(has ".concat(n, ")."))
                    }), a && setTimeout(function () {
                        n.visible = !0, n.disableChildRendering = !1, a(n)
                    }, 16))
                })
            }, function (e) {
                var t = .6 * e;
                o && o(t), c.preloader && c.preloader.onUpdate(t)
            }, function (e) {
                console.error(e), t && t(e)
            })) : t && t("WebGL not found")
        },
        unload: function (e) {
            var n = this;

            function r(e) {
                if (e.isAnnotation) e.dispose();
                else if (e.isLight && e.shadow && e.shadow.isLightShadow) e.shadow.dispose();
                else if (e.isCamera && e.controls && e.controls.orbitTarget) r(e.controls.orbitTarget);
                else if (e.isMesh) {
                    e.geometry.dispose(), e.geometry.disposeBoundsTree && e.geometry.disposeBoundsTree();
                    var t = e.material;
                    Em.disposeTextures(t), t.dispose()
                }
            }
            if ((e = e || n.scene) === n.scene) {
                if (n.scene && (n.scene.traverse(r), n.disposeEnvironment()), n.scene = null, n.controls && n.controls.dispose && n.controls.dispose(), n.controls = null, n.camera = null, n.materials = [], n.mixer && (n.mixer.stopAllAction(), n.actions.forEach(function (e) {
                        n.mixer.uncacheAction(e.getClip(), e.getRoot())
                    })), n.mixer = null, n.actions = [], n.postprocessing) {
                    if (n.postprocessing.composer)
                        for (var t in n.postprocessing) {
                            var i = n.postprocessing[t];
                            (i instanceof Zm || i instanceof iv) && i.dispose()
                        }
                    n.disablePostprocessing()
                }
                n.postprocessing = null, n.renderer && n.renderer.disposeInternalCaches()
            } else if (n.scene && (e.traverse(r), e.parent && e.parent.remove(e)), n.materials = [], n.scene && n.scene.traverse(function (e) {
                    var t = e.material;
                    t && -1 == n.materials.indexOf(t) && n.materials.push(t)
                }), n.mixer)
                for (var a = n.actions.length - 1; 0 <= a; a--) {
                    var o = n.actions[a];
                    H_.checkActionIsUsed(n.scene, o) || (o.stop(), n.mixer.uncacheAction(o.getClip(), o.getRoot()), n.actions.splice(a, 1))
                }
        },
        dispose: function () {
            this.scene && this.unload(), this.renderer && (this.renderer.forceContextLoss(), this.renderer.dispose(), this.renderer.domElement.parentElement === this.container && this.container.removeChild(this.renderer.domElement)), this.renderer = null, window.removeEventListener("resize", this._resizeCb, !1), qm.removeFromAppList(this), Cu.clear(), this.dispatchEvent({
                type: "dispose"
            })
        },
        getWidth: function () {
            return this.container.offsetWidth
        },
        getHeight: function () {
            return this.container.offsetHeight
        },
        onResize: function () {
            var e = this.getWidth(),
                t = this.getHeight();
            if (this.renderer.setSize(e, t), this.postprocessing) {
                var n = this.renderer.getPixelRatio();
                this.postprocessing.composer.setSize(e * n, t * n)
            }
            if (this.scene) {
                var r = e / t,
                    i = this.camera;
                if (i.isPerspectiveCamera) switch (i.viewportFit.type) {
                    case 1:
                        i.aspect = r;
                        break;
                    case 2:
                        i.fov = $_(i.fov, i.aspect, r), i.aspect = r;
                        break;
                    case 3:
                        var a = i.aspect < i.viewportFit.initialAspect,
                            o = r < i.viewportFit.initialAspect;
                        a && o ? i.fov = $_(i.fov, i.aspect, r) : a && !o ? i.fov = $_(i.fov, i.aspect, i.viewportFit.initialAspect) : !a && o && (i.fov = $_(i.fov, i.viewportFit.initialAspect, r)), i.aspect = r
                } else if (i.isOrthographicCamera) switch (i.viewportFit.type) {
                    case 1:
                        var s = i.top * r;
                        i.left = -s, i.right = s;
                        break;
                    case 2:
                        var l = i.right / r;
                        i.bottom = -l, i.top = l;
                        break;
                    case 3:
                        a = (i.right - i.left) / (i.top - i.bottom) < i.viewportFit.initialAspect, o = r < i.viewportFit.initialAspect, s = a && o ? i.right : a && !o ? i.right * r / i.viewportFit.initialAspect : !a && o ? i.top * i.viewportFit.initialAspect : i.top * r, i.left = -s, i.right = s, i.bottom = -s / r, i.top = s / r
                }
                i.updateProjectionMatrix()
            }
        },
        run: function () {
            this.preloader && (this.preloader.onFinish(), this.preloader = null), this.animate()
        },
        animate: function () {
            var r = this;
            r.renderer.setAnimationLoop(function () {
                var e = r.clock.getDelta();
                r.elapsed = e, r.mixer && r.mixer.update(e), r.controls && !r.xrSession && r.controls.update(e);
                for (var t = r.renderCallbacks, n = 0; n < t.length; n++) t[n](e, r.clock.elapsedTime);
                r.frame % r.frameRateDivider == 0 && r.enableRender && r.render(), r.frame++, r.disableRenderTrigger && 0 == --r.disableRenderTrigger && (r.enableRender = !1)
            })
        },
        enableRendering: function () {
            this.disableRenderTrigger = 0, this.enableRender = !0, this.ssaaOnPause && this.enableSSAA(0, !0)
        },
        disableRendering: function (e) {
            ((e = e || 0) || this.ssaaOnPause) && this.enableRender && 0 == this.disableRenderTrigger ? (this.disableRenderTrigger = this.ssaaOnPause ? 16 : e, this.ssaaOnPause && this.enableSSAA(4, !0)) : 0 == e && (this.enableRender = !1)
        },
        setFrameRateDivider: function (e) {
            this.frameRateDivider = e
        },
        render: function () {
            if (this.postprocessing) {
                var e = this.postprocessing.composer,
                    t = this._getActiveSSAAPass(e);
                t && t.iterative ? t.isLastIterativeFrame() ? e.renderToScreen = !0 : e.renderToScreen = !1 : e.renderToScreen = !0, e.render(this.elapsed)
            } else this.scene && this.camera && this.renderer.render(this.scene, this.camera)
        },
        enableControls: function (e) {
            var n = this.camera;
            if (n.controls) {
                switch (n.controls.type) {
                    case "ORBIT":
                        this.controls = new Wm(n, e || this.renderer.domElement), this.controls.targetObj = n.controls.orbitTarget, this.controls.minDistance = n.controls.orbitMinDistance, this.controls.maxDistance = n.controls.orbitMaxDistance, this.controls.minPolarAngle = n.controls.orbitMinPolarAngle, this.controls.maxPolarAngle = n.controls.orbitMaxPolarAngle, this.controls.minAzimuthAngle = n.controls.orbitMinAzimuthAngle, this.controls.maxAzimuthAngle = n.controls.orbitMaxAzimuthAngle;
                        break;
                    case "FLYING":
                        this.controls = new jm(n, this.renderer.domElement), this.controls.panSpeedTouch *= n.controls.moveSpeed, this.controls.zoomSpeedKey *= n.controls.moveSpeed;
                        break;
                    case "FIRST_PERSON":
                        this.controls = new km(n, this.renderer.domElement), this.controls.collisionMeshes = [];
                        var r = this;
                        this.scene.traverse(function (e) {
                            var t = e.material;
                            t && n.controls.collisionMaterial && t.name == n.controls.collisionMaterial.name && r.controls.collisionMeshes.push(e)
                        }), r.controls.gazeLevel = n.controls.gazeLevel, r.controls.storyHeight = n.controls.storyHeight, this.controls.zoomSpeedKey *= n.controls.moveSpeed;
                        break;
                    default:
                        this.controls = null
                }
                this.controls && (this.controls.enablePan = n.controls.enablePan, this.controls.rotateSpeed *= n.controls.rotateSpeed, this.controls.rotateSpeedTouch *= n.controls.rotateSpeed, this.controls.panSpeed *= n.controls.moveSpeed, this.controls.panSpeedKey *= n.controls.moveSpeed, this.controls.zoomSpeed *= n.controls.moveSpeed, this.controls.zoomSpeedTouch *= n.controls.moveSpeed, this.controls.update())
            }
        },
        setCamera: function (e) {
            if (this.camera = e, this.postprocessing)
                for (var t = this.postprocessing.composer.passes, n = 0; n < t.length; n++) t[n].setCamera(e);
            this.controls && this.controls.dispose(), this.enableControls(), this.onResize()
        },
        getCamera: function () {
            return this.camera
        },
        cleanup: function () {
            if (console.warn("v3d.App.cleanup has been deprecated. Use v3d.App.unload or v3d.App.dispose instead."), this.container)
                for (; this.container.firstChild;) this.container.removeChild(this.container.firstChild);
            this.loader && this.mixer && this.mixer.stopAllAction()
        },
        initPostprocessing: function () {
            (this.scene.postprocessing && this.scene.postprocessing.length || this.useHDR || "AUTO" != this.aaMethod) && this.enablePostprocessing(this.scene.postprocessing || [])
        },
        enablePostprocessing: function (e) {
            var t = {
                format: lt,
                stencilBuffer: !1
            };
            if (this.useHDR ? (t.type = at, t.encoding = At) : (t.type = tt, t.encoding = St), this.postprocessing) r = this.postprocessing.composer;
            else {
                this.postprocessing = {};
                var n = new G_(this.scene, this.camera);
                this.postprocessing.renderPass = n;
                var r, i = 0;
                switch (this.aaMethod) {
                    case "AUTO":
                    case "MSAA4":
                        i = this._checkMSAA(this.renderer, 4);
                        break;
                    case "MSAA8":
                        i = this._checkMSAA(this.renderer, 8);
                        break;
                    case "MSAA16":
                        i = this._checkMSAA(this.renderer, 16)
                }
                if ($o.checkSwiftShader(this.renderer) && (i = 0, console.warn("v3d.App: disabling buggy multisampling on SwiftShader renderer")), i)(a = new tn(this.getWidth(), this.getHeight(), t)).samples = i;
                else var a = new en(this.getWidth(), this.getHeight(), t);
                if (a.texture.name = "EffectComposer.rt1", (r = new iv(this.renderer, a)).addPass(n), this.postprocessing.composer = r, this.useHDR) {
                    var o = new Q_;
                    r.addPass(o), this.postprocessing.toneMapPass = o
                }
                if (!i) {
                    var s = new av(this.scene, this.camera);
                    r.addPass(s), this.postprocessing.fxaaPass = s
                }
            }
            e.length && this.postprocessing.copyPass && (r.passes.splice(r.passes.indexOf(this.postprocessing.copyPass), 1), this.postprocessing.copyPass = null);
            for (var l = 0; l < e.length; l++) {
                var c = e[l],
                    u = r.passes.length - 1;
                switch (r.passes[u] instanceof av || u++, this.useHDR && u--, c.type) {
                    case "bloom":
                        var d = c.strength,
                            h = c.radius,
                            p = c.threshold;
                        if (this.postprocessing.bloomPass) {
                            (f = this.postprocessing.bloomPass).strength = d, f.radius = h, f.threshold = p
                        } else {
                            var f = new Km(new qt(this.getWidth(), this.getHeight()), d, h, p, t);
                            r.insertPass(f, u), this.postprocessing.bloomPass = f
                        }
                        break;
                    case "brightnessContrast":
                        if (this.postprocessing.brightnessContrastPass) m = this.postprocessing.brightnessContrastPass;
                        else {
                            var m = new $m;
                            r.insertPass(m, u), this.postprocessing.brightnessContrastPass = m
                        }
                        m.brightness = c.brightness, m.contrast = c.contrast;
                        break;
                    case "dof":
                        if (this.postprocessing.bokehPass) v = this.postprocessing.bokehPass;
                        else {
                            var v = new ev(this.scene, this.camera, {
                                width: this.getWidth(),
                                height: this.getHeight()
                            });
                            r.insertPass(v, u), this.postprocessing.bokehPass = v
                        }
                        v.focus = c.focus, v.aperture = c.aperture, v.maxblur = c.maxblur, v.depthLeakThreshold = c.depthLeakThreshold;
                        break;
                    case "grayscale":
                        if (!this.postprocessing.grayscalePass) {
                            var g = new t_;
                            r.insertPass(g, u), this.postprocessing.grayscalePass = g
                        }
                        break;
                    case "outline":
                        if (this.postprocessing.outlinePass) _ = this.postprocessing.outlinePass;
                        else {
                            var _ = new n_(new qt(this.getWidth(), this.getHeight()), this.scene, this.camera);
                            r.insertPass(_, u), this.postprocessing.outlinePass = _
                        }
                        if (_.edgeStrength = c.edgeStrength, _.edgeGlow = c.edgeGlow, _.edgeThickness = c.edgeThickness, _.pulsePeriod = c.pulsePeriod, _.visibleEdgeColor.fromArray(c.visibleEdgeColor), _.hiddenEdgeColor.fromArray(c.hiddenEdgeColor), void 0 === c.renderHiddenEdge) {
                            var y = 0 === c.hiddenEdgeColor[0] && 0 === c.hiddenEdgeColor[1] && 0 === c.hiddenEdgeColor[2];
                            _.hiddenEdgeColor.setW(Number(!y))
                        } else _.hiddenEdgeColor.setW(Number(c.renderHiddenEdge));
                        break;
                    case "ssao":
                        if (!$o.checkDepthTex(this.renderer)) {
                            console.warn("v3d.App: disabling SSAO since your hardware does not support depth textures");
                            break
                        }
                        if (this.postprocessing.ssaoPass) x = this.postprocessing.ssaoPass;
                        else {
                            var x = new Y_(this.scene, this.camera, this.getWidth(), this.getHeight());
                            r.insertPass(x, u), this.postprocessing.ssaoPass = x
                        }
                        x.kernelRadius = c.radius, x.minDistance = c.minDistance || .005, x.maxDistance = c.maxDistance || .1;
                        break;
                    case "ssr":
                        if (!$o.checkHalfFloatTex(this.renderer, !1)) {
                            console.warn("v3d.App: disabling SSR since your hardware does not support float textures");
                            break
                        }
                        if (xn(c.useRefract)) var b = c.useRefract;
                        else b = !1;
                        if (b ? this.postprocessing.ssrPassRefract : this.postprocessing.ssrPassReflect) w = b ? this.postprocessing.ssrPassRefract : this.postprocessing.ssrPassReflect;
                        else {
                            var w = new q_(this.scene, this.camera);
                            r.insertPassAfter(w, [this.postprocessing.renderPass, this.postprocessing.ssrPassRefract, this.postprocessing.ssrPassReflect]), b ? this.postprocessing.ssrPassRefract = w : this.postprocessing.ssrPassReflect = w
                        }
                        w.useRefract = b, xn(c.objects) && (w.objects = c.objects), xn(c.intensity) && (w.intensity = c.intensity), xn(c.steps) && (w.steps = c.steps), xn(c.stride) && (w.stride = c.stride), xn(c.binarySearchSteps) && (w.binarySearchSteps = c.binarySearchSteps), xn(c.renderTargetScale) && (w.renderTargetScale = c.renderTargetScale), xn(c.thickness) && (w.thickness = c.thickness), xn(c.maxDistance) && (w.maxDistance = c.maxDistance), xn(c.jitter) && (w.jitter = c.jitter), xn(c.renderAfter) && (w.renderAfter = c.renderAfter), xn(c.simpleRefraction) && (w.simpleRefraction = c.simpleRefraction), this.onResize && this.onResize();
                        break;
                    default:
                        console.error("v3d.App: wrong postprocessing effect")
                }
            }
            if (1 == r.passes.length) {
                var M = new Jm(Ji.copy);
                r.passes.push(M), this.postprocessing.copyPass = M
            }
        },
        disablePostprocessing: function (e) {
            if (this.postprocessing) {
                var t = ["bloomPass", "brightnessContrastPass", "bokehPass", "grayscalePass", "ssaoPass", "ssrPassReflect", "ssrPassRefract"];
                e || t.push("outlinePass");
                for (var n = this.postprocessing.composer, r = 0; r < t.length; r++) {
                    var i = t[r];
                    this.postprocessing[i] && (n.passes.splice(n.passes.indexOf(this.postprocessing[i]), 1), this.postprocessing[i].dispose(), this.postprocessing[i] = null)
                }!this.useHDR && "AUTO" == this.aaMethod && n.passes.length <= 2 && (this.postprocessing.renderPass.dispose(), this.postprocessing.fxaaPass && this.postprocessing.fxaaPass.dispose(), this.postprocessing.composer.dispose(), this.postprocessing = null)
            }
        },
        enableSSAA: function (e, t) {
            if (this.postprocessing || this.enablePostprocessing([]), !(0 < e && (this.postprocessing.ssrPassRefract || this.postprocessing.ssrPassReflect))) {
                var n = this.postprocessing.composer;
                if (0 < e && n.passes[0] instanceof G_) {
                    if (this.postprocessing.ssaaRenderPass) r = this.postprocessing.ssaaRenderPass;
                    else {
                        var r = new Z_(this.scene, this.camera);
                        this.postprocessing.ssaaRenderPass = r
                    }
                    r.sampleLevel = e || 4, t && (r.iterative = !0, r.iterativeFrame = 0), n.passes[0] = r, this.postprocessing.fxaaPass && n.passes.splice(n.passes.length - 1, 1)
                } else 0 < e ? (n.passes[0].sampleLevel = e || 4, t && (r.iterative = !0, r.iterativeFrame = 0)) : 0 == e && n.passes[0] instanceof Z_ && (n.passes[0] = this.postprocessing.renderPass, this.postprocessing.fxaaPass && n.passes.push(this.postprocessing.fxaaPass))
            }
        },
        updateEnvironment: function (e) {
            this.disposeEnvironment(), e.useHDR = !0;
            var t = j_.renderWorldNodeMatToCubemap(this.renderer, e, this.worldCubemapRes);
            if (e.hasNode("LIGHT_PATH_BL") || e.hasNode("LIGHT_PATH_MY")) {
                var n = e.defines.LIGHT_PATH_IS_CAM_RAY;
                e.defines.LIGHT_PATH_IS_CAM_RAY = 0;
                var r = j_.renderWorldNodeMatToCubemap(this.renderer, e, this.worldCubemapRes);
                e.defines.LIGHT_PATH_IS_CAM_RAY = n, this.initPMREM(r), r.dispose()
            } else this.initPMREM(t);
            null !== this.scene.background && this.scene.background.isSceneBackground && (this.scene.background.data = t, this.scene.background.useHDR = this.useHDR)
        },
        disposeEnvironment: function () {
            this._cubeUVEnvRT && (this._cubeUVEnvRT.dispose(), this._traverseSceneForEnvUpdates(this.scene, function (e) {
                e.material.envMap.dispose()
            })), this._cubeUVEnvRT = null;
            var e = this.scene.background;
            e && (e.isSceneBackground && (e = e.data), e && (e.isTexture || e.isWebGLRenderTarget) && e.dispose())
        },
        initPMREM: function (e) {
            if (e.isWebGLCubeRenderTarget) {
                var t = new C_(this.renderer);
                t.flipCubemapX = !1, this._cubeUVEnvRT = t.fromCubeRenderTarget(e, {
                    encoding: At
                }), this._updateSceneCubeUVEnv(this.scene), t.dispose()
            }
        },
        initWebXR: function (i, a, o, e, r) {
            o = o || function () {}, e = e || function () {}, r = r || function () {};
            var s = this;

            function l(e) {
                s.xrSession.removeEventListener("end", l), s.renderer.xr.setSession(null), r();
                for (var t = 0; t < s.xrControllers.length; t++) {
                    var n = s.xrControllers[t];
                    s.scene.remove(n)
                }
                s.xrControllers = [], s.xrSession = null, s.postprocessing = s._postprocessingSave, s._postprocessingSave = null, s.onResize()
            }

            function c(e) {
                var t = e.data,
                    n = e.target;
                if ("tracked-pointer" == t.targetRayMode) {
                    var r = new Xs((new ni).setFromPoints([new on(0, 0, 0), new on(0, 0, -1)]));
                    r.name = n.name + "_RAY", r.scale.z = 5, n.add(r)
                } else if ("gaze" == t.targetRayMode) {
                    var i = new As(new ds({
                        map: (new Uu).load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAIQXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHja7ZhZltw2DEX/uYosQSQ4LofjOdlBlp8LSqquHt12nD+X3JIKYpEg3sMDZDP/+XuZv/iIOGd8SDmWGA8+vvjiKjf5OD91n+3h93l//PWI76/s5vHAYRKucn7N8bJP7I7x7rL3a56KPTxNVOb1oL1+UK+JXL4WuOz3QmLPBY5rYlOvicRdK18utnNbRyw5PW+hX+PX9XyHgT+jJy/JxRBt8py9O1KKhfvsDp+I21BHV3dFfxfaNdGb7+Ye6vDJTbFycM7qoeC+FKmi93rGaSzCvUjY53J6ClrOHIn7csf1689Xnpvb9QvyV5A+7uwn9iekzQ7o/UDeIBQf1w/tNrzYzTOkG7enlWN8rPzKnufRXu35Rk3/1hp5rXnurvrIluO1qXsr+45xTaO1fxU5En/hyBpsPQpHJiU6PBqQrHF0W6wDxmW9HbbaZee+dttx0bvpElfnuhPbDcYMGMX1DbfXwy6XAH5IBvgOHQSre/hi97JlL9dtZuFhs4E9lsksP/lPh/nOoLU0oaw98iNW+OU00/BCkbPWHJZhIGLXFdSwA3wfbz+Kq4Bg2GHObLAeTWcA/hbsC7lkAy0MDFzPBLZpXBMQIjwIOGMFBI5oJdhoj4SwJWsJZAagiutOvGvAYkNwAyedF4mAQxawNr9Jdg91wZ1mhBAggkQjCWxITcDyPsCf5DMcqkGCDyHEkEIOJdQoUTMsxhRVUWuS5FNIMaWUU0nVZMk+hxxzyjmXXIsrguKGQj6WXEqplUUrM1d+XRlQa3NNmm+hxZZabqXV7kyX7nvosaeee+l1uCGDPB5xpJFHGXXaCZWmn2HGmWaeZdYF1ZYsv8KKK628iln1gdoF67vjJ1CzF2puI6UD0wM1rCndU1iVk6CYgZjzFsCTImDFOKeYHdl67xQ5xewoTkXQ4WRQcIZVxEDQT+vCsg/sXpALRuLvwc0AhPsdyBmF7hvIvcftI9RG3YVONkKahhrUQ8i+VdbM1eWqlfLLq/nRgO9e/0z0Z6LfNtEKlJIcBGEJdi4Y3YtQv/vMn9hbb2uO2qngQp1HkExeIqtF6sbqOjSLnimwjeScNfUo89iTZO/b7GHNot9iXc1v+ypRmpg4x9DZbZ/owSyht5CoP3X52YZQTUprFa0ItmIdx22xPvAvogdcVPyXdoNjrZpJ4+lZTtdDaj62hxnWigOhXduzQx+mQvaPZrNbk99ZfVDsDIMlgtBQLro75kMVI3Xb63P8HRXr6s2O0hI7YuI8TZLWlq8z1NZmxkfWRLdoCMcQIVAj5kCbeFkOhcg11PO8o7M6r+Z4Y/iJq4KdFVJt3w261qI9nXagWtvw6cKp96g4ZMIw/NZERidb2NYSDUzpabXiF3EzpaKqdZNqZSuTXqnN0CtBntdNmZYJStprx7kgxZCka/XWsc9qwzRVdkRnFEWjy8mRQDknXhkExoYgj6QNm96PWsKsM8EoejmdKOblTRMIQOt3ucsgJUigEUldCH5vJRCMcd1I1wWdMmKMNfyqcepalKOCefgzY9iGzOJ/Jd3Mhw9aLbrhTCyntQ44IOYBgdocpAPBbbGP1siF1bRxHYNyFKjJcD0EaAQs0EU0zcCEBBDNiuQn3CFPANTv3epZWd+CRs2zU7Og7coEZKcArFQGA8BOU5faUL/I3J0OuVAw2xqHzAHbywZiudFiNEM9XIMa3edcw7USP5WUzT5RLsA6JZ9SD/K07JoZAFUiPmdQak0CPlGYa/MptVDJT20yYguxkIT0DXQKexSrkjpz8QhlimYmdYF13enoS7Lj9CkCxcXzCa7Esl8AQBq6rDabFASNxDfMWcgaRzTRgIFeBRmje5n4GAJmnGIHE2qUtOBqhOpzOhnrHtCJiJnTPoAA9FmVwgzCETw7yqmHPwbBfIbCOxC6jSogCHVjYzWhLEk1KTQonoYhUIEbIQd4p42Wliu5ngJtT8Le6LXS6CdV5xIA+p3l6GY+dKCrHMp8mK0bSBPGK/WJ/d4U1PdiM3WhDiU9dQCRH6o4sxerpKcUyJGASZrjLVvTQ/XiJ0sAAj9ayPYW+8IbpLzW/3KkLUIvEnQKEG6FLW3OF3aksFMFtoZp+I0+giNUtd4xUutm3LTnZxLXmFQ5el3WkFEIPtPMorRGG2sfslIJ8NIaqxnbBKp7ckpOgDThLLn1kBGbnmRkvcgIlH+WkbLIoOC1LCAksc5RuviYqfE0yZeFd/2vomk+DSfceh1PLZ5k35uI3vXUvC+oKlTrUVBJ56eSyhJ5flhTzS8U1Q+v5ptF9aXK7ZuWNaXDJshY1S4xofutu27qtutxVSPSrffPqhGj39Ujan+5K9IXxXq+FPp3UhsAdw3TwQG5G3aWmEBohrt4qthpkCbBz4ntlcQXXreum5R1sbAXHs2QldBo9LOroE+gIaj52mBwabjzC2+lX17NjwbodeuhtFsPof1Q0UMOyTI0EO45g2lqG8k2i809EsB4quEkUrK1cKgW8mZb+UkcIAdcUXKyI9scHR1MY6I3jzUIZ2ODum6EgoaiEIrp9/YJmYP0QbMBnHLaCW2meqzsfm6AyYtX7S+id3W/vKle3e/OPRojdI/oDyOdRFVlrAORRx/igFKtQDte/oV654VGuvIKzMM2eCFuVB4SbD3CppXcXFE7i8guPY8i0l5XcpVqGsNjp1bjzGyCNLRgySyT5TY9R2fu2joo2cRhR6bsdCYa8P8MEJnzEqJpHiH6KEA6wXcCRHzMrwRovzykVEY/b/U/r81981+vfyb6M9H/MBF5RKaafwEjmLcIrlR0mgAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+MCAwojJyJFeN4AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAd0lEQVR42u3YUQqAIBAFwLUDdf9zdCH7lwwEI2VnPkWQfWCvigAAAAAAgDTK1wecNWq7dpX+uaP7lw7gaZi3oUb3z3BkvwICEIAW+KcFRte3DWBGO7gCAhCAAHZ9FY6IpC3QG963gGeAAASgBRb6IwQAAAAAQCY34QUtIL9dJTwAAAAASUVORK5CYII="),
                        sizeAttenuation: !1
                    }));
                    i.name = n.name + "_RETICLE", i.scale.multiplyScalar(.1), i.position.z = -5, n.add(i)
                }
                n.userData.v3d.inputSource = t
            }

            function u(e) {
                for (var t = e.target, n = t.children.length - 1; 0 <= n; n--) {
                    var r = t.children[n];
                    r.geometry.dispose(), r.material.dispose(), t.remove(r)
                }
            }
            var t = {
                optionalFeatures: [a]
            };
            "immersive-ar" == i && t.optionalFeatures.push("hit-test"), navigator.xr.requestSession(i, t).then(function (e) {
                s._postprocessingSave = s.postprocessing, s.postprocessing = null, s.renderer.xr.setReferenceSpaceType(a), (s.xrSession = e).addEventListener("end", l);
                for (var t = "immersive-vr" == i ? 2 : 1, n = 0; n < t; n++) {
                    var r = s.renderer.xr.getController(n);
                    s.scene.add(r), s.xrControllers.push(r), r.addEventListener("connected", c), r.addEventListener("disconnected", u)
                }
                "immersive-vr" == i ? 2 <= window.devicePixelRatio && s.renderer.xr.setFramebufferScaleFactor(.5) : (s.scene.background = null, s.renderer.autoClear = !1, s.onResize()), s.renderer.xr.enabled = !0, s.renderer.xr.setSession(e), o()
            }).catch(e)
        },
        endWebXR: function () {
            this.xrSession && this.xrSession.end()
        },
        printPerformanceInfo: function (s) {
            var l = this;
            s = s || 1;
            var c = l.renderer.info,
                u = c.autoReset;
            c.autoReset = !1, c.reset();
            for (var d = l.frame, e = 0; e < c.programs.length; e++) c.programs[e].profile.calcRenderTime = !0;
            setTimeout(function () {
                console.log("--- Verge3D Performance Profile (" + s + "s) ---");
                var e = l.frame - d;
                console.log("Scene Loading Time:", String(Math.round(l._loadingTime)) + "ms"), console.log("FPS:", e / s), console.log("Render Calls:", c.render.calls / e), console.log("Triangles Rendered:", c.render.triangles / e), console.log("Geometry Buffers:", c.memory.geometries), console.log("Textures & Render Buffers:", c.memory.textures), console.log("Materials and Shaders:");
                var t = c.programs.slice(0);
                t.sort(function (e, t) {
                    return t.profile.renderTime - e.profile.renderTime
                });
                for (var n = 0, r = 0; r < t.length; r++) {
                    var i = t[r];
                    i.profile.calcRenderTime = !1;
                    var a = i.profile.materials,
                        o = i.profile.renderTime;
                    console.log("   ", 0 == a.length ? "System Material" : a.join(","), "-", i.name, "-", String(Math.round(o)) + "ms"), n += o, i.profile.renderTime = 0
                }
                console.log("Total Render Time:", String(Math.round(n)) + "ms"), c.autoReset = u
            }, 1e3 * s)
        }
    });
    var ey = "SceneLoadError",
        ty = "LogicLoadError",
        ny = "EditorLoadError";

    function ry(e, t, n) {
        console.warn("v3d.AppPuzzles has been deprecated. Use v3d.PuzzlesLoader instead."), J_.call(this, e, t, n), this._editorJSFile = "puzzles.min.js", this._editorCSSFile = "puzzles.css", this._editorMediaDir = "media/", this._libraryXML = "library.xml", this.ExternalInterface = {}
    }
    ry.prototype = Object.assign(Object.create(J_.prototype), {
        constructor: ry,
        onSceneLoad: function () {},
        onEditorLoad: function () {},
        onLogicLoad: function () {},
        onLoadFinished: function (e, t, n) {
            e && this.run()
        },
        onError: function (e) {
            console.error(e)
        },
        run: function () {
            this.enableControls(), J_.prototype.run.call(this), v3d.PL && v3d.PL.init(this)
        },
        _createSceneLoadError: function (e) {
            var t = new Error(e);
            return t.name = ey, t
        },
        _createLogicLoadError: function (e) {
            var t = new Error(e);
            return t.name = ty, t
        },
        _createEditorLoadError: function (e) {
            var t = new Error(e);
            return t.name = ny, t
        },
        _getScenePromise: function (n) {
            var r = this;
            return new Promise(function (e, t) {
                J_.prototype.load.call(r, n, function () {
                    e()
                }, function () {
                    t(r._createSceneLoadError("Unable to load the scene file: '" + n + "'."))
                }, !1)
            })
        },
        _getLogicPromise: function (n) {
            var r = this;
            return new Promise(function (e, t) {
                qm.loadScript(n, document.body, function () {
                    e()
                }, function () {
                    t(r._createLogicLoadError("Unable to load the logic file: '" + n + "'."))
                })
            })
        },
        _getEditorPromise: function (r, i) {
            var a = this;
            return new Promise(function (e, t) {
                var n = document.createElement("link");
                n.rel = "stylesheet", n.type = "text/css", n.href = i, document.head.appendChild(n), qm.loadScript(r, document.body, function () {
                    e()
                }, function () {
                    t(a._createEditorLoadError("Unable to load the Puzzles Editor: '" + r + "'."))
                })
            })
        },
        _getLogicViaEditorPromise: function (i, a, o) {
            var s = this;
            return new Promise(function (t, n) {
                var e = i.match(/(.*)\.js$/);
                if (e)
                    if (v3d.PE) {
                        var r = e[1] + ".xml";
                        v3d.PE.init(a, function (e) {
                            e ? t() : n(s._createLogicLoadError("Unable to load The Puzzles Editor's XML logic file: '" + r + "'."))
                        }, s, r, o)
                    } else n(s._createLogicLoadError("Unable to load Puzzles' logic. The Puzzles Editor isn't loaded."));
                else n(s._createLogicLoadError("Unable to load Puzzles' logic. The provided file should be of type JS: '" + i + "'."))
            })
        },
        loadScene: function (e) {
            if (1 < arguments.length) J_.prototype.loadScene.call(this, e, arguments[1], arguments[2], arguments[3]);
            else {
                var t = this;
                t._getScenePromise(e).then(function () {
                    t.onSceneLoad(), t.onLoadFinished(!0, !1, !1)
                }).catch(function (e) {
                    switch (t.onError(e), e.name) {
                        case ey:
                            t.onLoadFinished(!1, !1, !1)
                    }
                })
            }
        },
        loadSceneWithLogic: function (e, t) {
            var n = this;
            n._getScenePromise(e).then(function () {
                return n.onSceneLoad(), n._getLogicPromise(t)
            }).then(function () {
                n.onLogicLoad(), n.onLoadFinished(!0, !0, !1)
            }).catch(function (e) {
                switch (n.onError(e), e.name) {
                    case ey:
                        n.onLoadFinished(!1, !1, !1);
                        break;
                    case ty:
                        n.onLoadFinished(!0, !1, !1)
                }
            })
        },
        loadSceneWithEditor: function (e, t, n) {
            var r = this,
                i = n + r._editorJSFile,
                a = n + r._editorCSSFile,
                o = n + r._editorMediaDir,
                s = n + r._libraryXML;
            r._getScenePromise(e).then(function () {
                return r.onSceneLoad(), r._getEditorPromise(i, a)
            }).then(function () {
                return r.onEditorLoad(), r._getLogicViaEditorPromise(t, o, s)
            }).then(function () {
                r.onLogicLoad(), r.onLoadFinished(!0, !0, !0)
            }).catch(function (e) {
                switch (r.onError(e), e.name) {
                    case ey:
                        r.onLoadFinished(!1, !1, !1);
                        break;
                    case ny:
                        r.onLoadFinished(!0, !1, !1);
                        break;
                    case ty:
                        r.onLoadFinished(!0, !1, !0)
                }
            })
        }
    });
    var iy = {
        normalizeDialectOptions: function (e) {
            var t = {
                delimiter: ",",
                doublequote: !0,
                lineterminator: "\n",
                quotechar: '"',
                skipinitialspace: !0,
                skipinitialrows: 0
            };
            for (var n in e) t[n.toLowerCase()] = e[n];
            return t
        }
    };
    iy.parse = function (e, t) {
        t && (!t || t.lineterminator) || (e = iy.normalizeLineTerminator(e, t));
        var n = iy.normalizeDialectOptions(t);
        e = iy.chomp(e, n.lineterminator);
        var r, i, a = "",
            o = !1,
            s = !1,
            l = "",
            c = [],
            u = [];
        for (i = function (e) {
                var t = String.prototype.trim ? function (e) {
                    return e.trim()
                } : function (e) {
                    return e.replace(/^\s*/, "").replace(/\s*$/, "")
                };
                return !0 !== s && ("" === e ? e = null : !0 === n.skipinitialspace && (e = t(e)), /^\d+$/.test(e) ? e = parseInt(e, 10) : /^\d*\.\d+$|^\d+\.\d*$/.test(e) && (e = parseFloat(e, 10))), e
            }, r = 0; r < e.length; r += 1) a = e.charAt(r), !1 !== o || a !== n.delimiter && a !== n.lineterminator ? a !== n.quotechar ? l += a : o ? e.charAt(r + 1) === n.quotechar ? (l += n.quotechar, r += 1) : o = !1 : s = o = !0 : (l = i(l), c.push(l), a === n.lineterminator && (u.push(c), c = []), l = "", s = !1);
        return l = i(l), c.push(l), u.push(c), n.skipinitialrows && (u = u.slice(n.skipinitialrows)), u
    }, iy.normalizeLineTerminator = function (e, t) {
        return (t = t || {}).lineterminator ? e : e.replace(/(\r\n|\n|\r)/gm, "\n")
    }, iy.chomp = function (e, t) {
        return e.charAt(e.length - t.length) !== t ? e : e.substring(0, e.length - t.length)
    };
    var ay, oy, sy, ly = new on(1, 0, 0);

    function cy(e, t) {
        e = void 0 !== e ? e : new Pr(1, 0, 0), t = void 0 !== t ? t : 2;
        var n = new pg;
        n.setGeometry([0, 0, 0, ly.x, ly.y, ly.z]);
        var r = new yg({
            color: e,
            lineWidth: t,
            sizeAttenuation: 0
        });
        xi.call(this, n.geometry, r), this.elemHTML = null, this.offset = 5
    }

    function uy() {}

    function dy(e) {
        for (var t in uy.call(this), e) {
            var n = e[t];
            switch (t) {
                case "container":
                    void 0 === n ? this.container = document.body : n instanceof HTMLElement ? this.container = n : this.container = document.getElementById(n)
            }
        }
        this.bar = document.createElement("div"), this.bar.setAttribute("class", "v3d-simple-preloader-bar"), this.logo = document.createElement("div"), this.logo.setAttribute("class", "v3d-simple-preloader-logo"), this.logoCont = document.createElement("div"), this.logoCont.setAttribute("id", "v3d_preloader_container"), this.logoCont.setAttribute("class", "v3d-simple-preloader-container"), this.background = document.createElement("div"), this.background.setAttribute("class", "v3d-simple-preloader-background"), this.background.appendChild(this.logoCont), this.logoCont.appendChild(this.logo), this.logoCont.appendChild(this.bar), this.container.appendChild(this.background), "none" == getComputedStyle(this.logo).backgroundImage && this.logo.setAttribute("style", 'background-image: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiCiAgIGlkPSJzdmcyNzc1IgogICB2ZXJzaW9uPSIxLjEiCiAgIHZpZXdCb3g9IjAgMCAyOS4xMDQxNjYgMzEuNzUwMDAxIgogICBoZWlnaHQ9IjEyMCIKICAgd2lkdGg9IjExMCI+CiAgPGRlZnMKICAgICBpZD0iZGVmczI3NjkiPgogICAgPGxpbmVhckdyYWRpZW50CiAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIKICAgICAgIHkyPSI1My44MDY2MTgiCiAgICAgICB4Mj0iMTkzLjc4NDciCiAgICAgICB5MT0iNzguNjg5NDA3IgogICAgICAgeDE9IjE3Mi45MTMzNiIKICAgICAgIGlkPSJsaW5lYXJHcmFkaWVudDMwNzktOCIKICAgICAgIHhsaW5rOmhyZWY9IiNsaW5lYXJHcmFkaWVudDMwNzciCiAgICAgICBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEuMTY0NzU5NCwwLDAsMS4xNTgzOTgyLC0xOTcuMTUzMTksMjAzLjUxNjUxKSIgLz4KICAgIDxsaW5lYXJHcmFkaWVudAogICAgICAgaWQ9ImxpbmVhckdyYWRpZW50MzA3NyI+CiAgICAgIDxzdG9wCiAgICAgICAgIGlkPSJzdG9wMzA3MyIKICAgICAgICAgb2Zmc2V0PSIwIgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjojMDA0OGE1O3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcAogICAgICAgICBpZD0ic3RvcDMwNzUiCiAgICAgICAgIG9mZnNldD0iMSIKICAgICAgICAgc3R5bGU9InN0b3AtY29sb3I6IzRiODZkMTtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTI3NzIiPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwtMjY1LjI0OTk2KSIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZGlzcGxheTppbmxpbmU7ZmlsbDp1cmwoI2xpbmVhckdyYWRpZW50MzA3OS04KTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC45MjA0NTI2NTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAxNC42MjI3OTMsMjY1LjI1MDA0IGMgLTEuNjgyMTUsLTAuMDA3IC0zLjM2OTMsMS4xMDUxMSAtNy4yODAyNDk3LDMuMzI3ODYgLTcuODIxOTEwMDcsNC40NDU1IC03LjI4MTA3MDA3LDMuNTIzMzggLTcuMzIwOTcwMDcsMTIuNDgzMDkgLTAuMDM5OSw4Ljk1OTcxIC0wLjU3MjQ3LDguMDMyODUgNy4yMDk1NTAwNywxMi41NDcwNyA3Ljc4MTk4OTcsNC41MTQyNCA2LjcwODYwOTcsNC41MDk1IDE0LjUzMDQ5OTcsMC4wNjM5IDcuODIxOTEsLTQuNDQ1NDkgNy4yODEwNjIsLTMuNTIzMzcgNy4zMjA5NzEsLTEyLjQ4MzA5IDAuMDM5OSwtOC45NTk3MSAwLjU3MjQ1OCwtOC4wMzI4NSAtNy4yMDk1NTEsLTEyLjU0NzA3IC0zLjg5MSwtMi4yNTcxMiAtNS41NjgxMiwtMy4zODQ0NSAtNy4yNTAyNSwtMy4zOTE4NiB6IG0gLTAuMDEzMywyLjg1MTY3IGMgMS42OTU5NCwwLjAwNyAzLjM4ODMzLDAuODEyODEgNi4xNjAxNiwyLjQyMDY5IDUuNTQzNjIsMy4yMTU3OCA2LjE1MTkzMSw0LjI3NDM4IDYuMTIzNDkxLDEwLjY1Njk2IC0wLjAyODQsNi4zODI2IC0wLjY0NjEwMSw3LjQzNTc2IC02LjIxODE1MSwxMC42MDI1OCAtNS41NzIwMywzLjE2NjgxIC02Ljc5OCwzLjE2MTM5IC0xMi4zNDE2Mzk3LC0wLjA1NDMgLTUuNTQzNjEsLTMuMjE1NzcgLTYuMTUxODksLTQuMjc0MzcgLTYuMTIzNDksLTEwLjY1Njk2IDAuMDI4NiwtNi4zODI1OCAwLjY0NjEsLTcuNDM1NzUgNi4yMTgxNiwtMTAuNjAyNTggMi43ODYwMjk3LC0xLjU4MzQgNC40ODU1Mzk3LC0yLjM3Mzc3IDYuMTgxNDY5NywtMi4zNjYzIHogbSAtMC4xNTUzNywxLjYxNzY5IGMgLTIuNzEzOTEsMC4wMzQxIC01LjcyNDk5OTcsMy4wNzAwOCAtNy4yODkzNTk3LDYuMDc1NDkgLTEuNTg5MjEsMy4wNTMxMSAtMi40OTg1Miw1Ljk0NDU2IC0yLjEyNDA1LDkuNjU3NTEgMC4xNjMwNywxLjYxNjU0IDEuNzEwODIsMy42Nzk4NCAzLjU2Mzc2LDQuNzE0MjYgLTAuMzkzODIsLTMuMjA2MiAtMC4xNzIsLTYuMzQzMDUgMC41NDM5NjEsLTguOTQ2OTIgMC43MTU5NTksLTIuNjAzODcgMi44NTI5Nzg3LC02LjgyODgxIDUuMzc2MjQ4NywtNi44MjMxNiAyLjUyMzMxLDAuMDA2IDQuNjYwMjcsNC4yMjcwNCA1LjM3NjIyLDYuODMwODkgMC43MTU5MywyLjYwMzg4IDAuOTM3NzcsNS43NDA3NSAwLjU0Mzk0LDguOTQ2OTQgMS44NTI5NCwtMS4wMzQ0MyAzLjQwMDcxLC0zLjA5Nzc4IDMuNTYzNzcsLTQuNzE0MzEgMC4zNzQ0OCwtMy43MTI5OCAtMC41MzQ3MSwtNi42MDQyNyAtMi4xMjM5MywtOS42NTc0IC0xLjU1ODkzLC0yLjk5NDk4IC00LjU1NDY1LC02LjAxOTg4IC03LjMwMTU1LC02LjA4MjY2IC0wLjA0MzEsLTkuOGUtNCAtMC4wODYsLTkuOGUtNCAtMC4xMjg5NywtNi4xZS00IHogbSAwLjEzMjY3LDguOTE4NDEgYSAyLjQ5MTI2MzEsMi40Nzc2NTczIDAgMCAwIC0xLjE5NzM0LDAuMjkxNTIgMi40OTEyNjMxLDIuNDc3NjU3MyAwIDAgMCAtMS4wMjUzNCwzLjM1MjI5IDIuNDkxMjYzMSwyLjQ3NzY1NzMgMCAwIDAgMy4zNzA2OSwxLjAxOTcxIDIuNDkxMjYzMSwyLjQ3NzY1NzMgMCAwIDAgMS4wMjUzNCwtMy4zNTIyOCAyLjQ5MTI2MzEsMi40Nzc2NTczIDAgMCAwIC0yLjE3MzM1LC0xLjMxMTI0IHoiCiAgICAgICBpZD0icGF0aDYwNDctMiIgLz4KICA8L2c+Cjwvc3ZnPgo=");'), this.clock = new Kd
    }
    cy.prototype = Object.assign(Object.create(xi.prototype), {
        constructor: cy,
        isLineHTML: !0,
        onBeforeRender: (ay = new on, oy = new on, sy = new nn, function (e, t, n, r, i, a) {
            if (xi.prototype.onBeforeRender.call(this), this.elemHTML) {
                var o = e.domElement.offsetHeight,
                    s = e.domElement.offsetWidth,
                    l = this.elemHTML.getBoundingClientRect(),
                    c = (l.left + l.right) / 2,
                    u = (l.top + l.bottom) / 2,
                    d = this.getWorldPosition(ay).project(n),
                    h = (d.x + 1) / 2 * s,
                    p = (1 - d.y) / 2 * o,
                    f = (u - p) / (c - h),
                    m = (l.height + 2 * this.offset) / (l.width + 2 * this.offset);
                if (Math.abs(f) > m) var v = ((g = u < p ? Math.min(l.bottom + this.offset, p) : Math.max(l.top - this.offset, p)) - p) / f + h;
                else var g = ((v = h < c ? Math.max(l.left - this.offset, h) : Math.min(l.right + this.offset, h)) - h) * f + p;
                var _ = 2 * v / s - 1,
                    y = 1 - 2 * g / o,
                    x = oy.set(_, y, -1);
                x.unproject(n), this.parent && this.parent.worldToLocal(x);
                var b = x.length();
                this.scale.setScalar(b), x.normalize();
                var w = sy.setFromUnitVectors(ly, x);
                this.setRotationFromQuaternion(w), this.updateMatrixWorld()
            }
        })
    }), Object.assign(uy.prototype, {
        onUpdate: function (e) {},
        onFinish: function () {}
    }), dy.prototype = Object.assign(Object.create(uy.prototype), {
        constructor: dy,
        onUpdate: function (e) {
            e = Math.round(e), this.bar.style.width = e + "%"
        },
        onFinish: function () {
            this.container.removeChild(this.background)
        }
    });
    var hy, py, fy, my;

    function vy() {}

    function gy(e) {
        xi.call(this), this.type = "CubeTextureHelper", this.geometry = new Ci(2, 2, 2, 1, 1, 1), this.geometry.computeBoundingSphere(), this.material = new Fr, this.material.envMap = e
    }

    function _y(e) {
        Fn.call(this), this.projected = new on, this.container = e, this.updatedCallback = null
    }

    function yy(e, t, n) {
        _y.call(this, e), this.type = "Annotation", this.character = t, this.dialogContents = n, this.annotation = document.createElement("div"), this.annotation.innerHTML = t, this.annotation.className = "v3d-annotation", this.container.appendChild(this.annotation), this.annotationDialogVisible = !1, this.annotationDialog = document.createElement("div"), this.annotationDialog.innerHTML = n, this.annotationDialog.className = "v3d-annotation-dialog", this.annotation.appendChild(this.annotationDialog), this.fadeObscured = !0, this.obscured = !1, this.text = this.dialogContents, this.annotationText = this.annotationDialog;
        var r = !1,
            i = this;

        function a(e) {
            e.target == i.annotation ? 0 == i.annotationDialog.innerHTML.length || i.obscured || (i.annotationDialogVisible = !i.annotationDialogVisible, i.annotationDialog.style.visibility = i.annotationDialogVisible ? "visible" : "hidden", i.annotationDialogVisible ? i.annotation.style.zIndex = "1" : i.annotation.style.zIndex = "auto") : "v3d-annotation" == e.target.className && (i.annotationDialogVisible = !1, i.annotationDialog.style.visibility = "hidden", i.annotation.style.zIndex = "auto")
        }
        this._touchstartCb = function (e) {
            a(e), r = !0
        }, document.body.addEventListener("touchstart", this._touchstartCb, !1), this._mousedownCb = function (e) {
            r || a(e), r = !1
        }, document.body.addEventListener("mousedown", this._mousedownCb, !1)
    }
    Object.assign(vy.prototype, {
        _logicFileLoadError: function (e) {
            var t = new Error(e);
            return t.name = "LogicFileLoadError", t
        },
        _editorLoadError: function (e) {
            var t = new Error(e);
            return t.name = "EditorLoadError", t
        },
        _getLogicPromise: function (n) {
            var r = this;
            return new Promise(function (e, t) {
                qm.loadScript(n, document.body, function () {
                    e()
                }, function () {
                    t(r._logicFileLoadError("Unable to load the logic file: '" + n + "'."))
                })
            })
        },
        _getEditorPromise: function (n, e) {
            var r = this;
            return new Promise(function (e, t) {
                qm.loadScript(n, document.body, function () {
                    e()
                }, function () {
                    t(r._editorLoadError("Unable to load the Puzzles Editor: '" + n + "'."))
                })
            })
        },
        _getLogicViaEditorPromise: function (i, a) {
            var o = this;
            return new Promise(function (t, n) {
                if (v3d.PE) {
                    var e = a.split(".");
                    e[e.length - 1] = "xml";
                    var r = e.join(".");
                    v3d.PE.init(i, r, function (e) {
                        e ? t() : n(o._logicFileLoadError("Unable to load the Puzzles Editor's XML logic file: '" + r + "'."))
                    })
                } else n(o._editorLoadError("Unable to load Puzzles' logic. The Puzzles Editor isn't loaded."))
            })
        },
        loadLogic: function (e, t, n) {
            this._getLogicPromise(e).then(function () {
                t && t()
            }, function (e) {
                console.error(e), n && n(e)
            })
        },
        loadEditorWithLogic: function (e, t, n, r) {
            var i = this;
            i._getEditorPromise(e + "puzzles.min.js").then(function () {
                return i._getLogicViaEditorPromise(e, t)
            }).catch(function (e) {
                return "LogicFileLoadError" === e.name ? Promise.resolve() : Promise.reject(e)
            }).then(function () {
                n && n()
            }).catch(function (e) {
                console.error(e), r && r(e)
            })
        }
    }), (gy.prototype = Object.create(xi.prototype)).constructor = gy, _y.prototype = Object.assign(Object.create(Fn.prototype), {
        constructor: _y,
        isAnnotationControl: !0,
        clone: function () {
            return new this.constructor(this.container).copy(this)
        },
        update: function (e) {
            var t = this.projected;
            this.getWorldPosition(t).project(e);
            var n = this.container.offsetWidth,
                r = this.container.offsetHeight,
                i = (.5 + t.x / 2) * n,
                a = (.5 - t.y / 2) * r;
            t.x = i, t.y = a;
            var o = t.z <= 1 && 0 <= i && i <= n && 0 <= a && a <= r;
            this.visible = o, this.updatedCallback && this.updatedCallback(t.x, t.y, o)
        }
    }), yy.prototype = Object.assign(Object.create(_y.prototype), {
        constructor: yy,
        isAnnotation: !0,
        raycast: function () {},
        clone: function () {
            return new this.constructor(this.container, this.character, this.dialogContents).copy(this)
        },
        update: (hy = new es, py = new on, fy = new on, my = new on, function (e) {
            _y.prototype.update.call(this, e);
            var t = this.projected,
                n = this.annotation;
            if (n.style.transform = "translate(" + t.x + "px, " + t.y + "px)", n.style.visibility = this.visible ? "visible" : "hidden", this.annotationDialog.style.visibility = this.visible && this.annotationDialogVisible ? "visible" : "hidden", this.fadeObscured) {
                e.getWorldPositionNU(py), this.getWorldPositionNU(fy), my.copy(fy).sub(py).normalize(), hy.set(py, my), hy.far = py.distanceTo(fy);
                var r = hy.intersectObject(this.findRoot(), !0);
                1 < r.length || 1 == r.length && r[0].object != this.parent ? (n.className = "v3d-annotation v3d-annotation-transparent", this.obscured = !0, this.annotationDialog.style.visibility = "hidden") : (n.className = "v3d-annotation", this.obscured = !1)
            }
        }),
        setDialogVisibility: function (e) {
            e ? (this.annotationDialogVisible = !0, this.annotationDialog.style.visibility = "visible", this.annotation.style.zIndex = "1") : (this.annotationDialogVisible = !1, this.annotationDialog.style.visibility = "hidden", this.annotation.style.zIndex = "auto")
        },
        dispose: function () {
            var e = this.annotation.parentElement;
            e && e.removeChild(this.annotation), document.body.removeEventListener("touchstart", this._touchstartCb, !1), document.body.removeEventListener("mousedown", this._mousedownCb, !1)
        }
    });
    var xy, by, wy = {
        translateVRCamera: function () {
            var i = new on;
            new fn;
            return function (e, t, n) {
                var r = e.parent;
                r && !r.isScene && (i.copy(t).applyQuaternion(e.quaternion).applyQuaternion(r.quaternion), r.position.add(i.multiplyScalar(n)))
            }
        }(),
        rotateVRCamera: (xy = new nn, by = new nn, function (e, t, n) {
            var r = e.parent;
            r && !r.isScene && (xy.setFromAxisAngle(t, n), xy.premultiply(e.quaternion), xy.premultiply(r.quaternion), r.quaternion.multiplyQuaternions(xy, by.copy(e.quaternion).inverse()))
        })
    };
    "undefined" != typeof __v3d_DEVTOOLS__ && __v3d_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: REVISION
        }
    }));
    var My = "undefined" != typeof window ? window : self;
    if (My.v3d && (My.THREE = v3d), "undefined" != typeof document) {
        var Ay = document.createElement("style");
        Ay.appendChild(document.createTextNode(".v3d-container {\n    \n    overflow: hidden;\n    z-index: 0;\n}\n.v3d-canvas {\n    \n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    \n    z-index: -1;\n}\n.v3d-simple-preloader-background {\n    background-color: #fff;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    z-index: 1;\n    height: 100%;\n    width: 100%;\n}\n.v3d-simple-preloader-container {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -90px;\n    margin-left: -90px;\n    width: 180px;\n    height: 180px;\n}\n.v3d-simple-preloader-bar {\n    background: linear-gradient(90deg, #1458ae, #4388e0);\n    width: 0%;\n    height: 3px;\n    margin: 15px -1px;\n    border: 1px solid;\n    border-radius: 5px;\n    border-color: #2b70c7;\n}\n.v3d-simple-preloader-logo {\n    width: 110px;\n    height: 120px;\n    background-repeat: no-repeat;\n    margin: 20px auto;\n}\n.v3d-annotation {\n    position: absolute;\n    top: -16px;\n    left: -16px;\n    width: auto;\n    min-width: 14px;\n    height: 26px;\n    padding: 2px 8px;\n    border: 1px solid #fff;\n    border-radius: 18px;\n    font-size: 16px;\n    font-family: sans-serif;\n    line-height: 26px;\n    color: #fff;\n    text-align: center;\n    user-select: none;\n    background: rgba(0, 0, 0, 0.8);\n}\n.v3d-annotation-transparent {\n    opacity: 0.5;\n}\n.v3d-annotation-dialog {\n    position: absolute;\n    top: 0;\n    left: 0;\n    margin-left: 15px;\n    margin-top: 31px;\n    font-family: sans-serif;\n    user-select: none;\n    padding: 1em;\n    min-width: 200px;\n    color: #fff;\n    background: rgba(0, 0, 0, 0.8);\n    border-radius: .5em;\n    font-size: 12px;\n    line-height: 1.2;\n    transition: opacity .5s;\n    visibility: hidden;\n}\n.v3d-webgl-error {\n    color: #015fb1;\n    background-color: white;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -44px;\n    margin-left: -256px;\n    text-align: center;\n    border-style: solid;\n    border-width: 3px;\n    border-radius: 8px;\n    border-color: #015fb1;\n    font-size: 20px;\n    font-family: sans-serif;\n    padding: 10px;\n    line-height: 30px;\n    z-index: 10;\n}\n@media only screen and (max-width: 540px) {\n    .v3d-webgl-error {\n        top: 50%;\n        left: 10px;\n        right: 10px;\n        margin-top: -58px;\n        margin-left: 0px;\n    }\n}\n.v3d-webgl-error-link {\n    color: #015fb1;\n}\n.v3d-device-motion-permissions-dialog {\n    z-index: 1;\n    position: absolute;\n    width: 100%;\n    background-color: #f00;\n    color: #000;\n    text-align: center;\n    padding: 10px;\n}\n")), document.head.insertBefore(Ay, document.head.firstChild)
    }
    t.ACESFilmicToneMapping = H, t.AVERAGE = 1, t.AddEquation = de, t.AddOperation = G, t.AdditiveBlending = se, t.AlphaFormat = h, t.AlwaysDepth = Ce, t.AlwaysStencilFunc = Ut, t.AmbientLight = xd, t.AmbientLightProbe = jd, t.AnimationClip = Tu, t.AnimationLoader = Nu, t.AnimationMixer = Ah, t.AnimationObjectGroup = wh, t.AnimationUtils = vu, t.Annotation = yy, t.AnnotationControl = _y, t.App = J_, t.AppPuzzles = ry, t.AppUtils = qm, t.ArcCurve = ku, t.ArrayCamera = Ko, t.ArrowHelper = lp, t.Audio = rh, t.AudioAnalyser = ch, t.AudioContext = zd, t.AudioListener = nh, t.AudioLoader = Ud, t.AxesHelper = cp, t.AxisHelper = function (e) {
        return console.warn("v3d.AxisHelper has been renamed to v3d.AxesHelper."), new cp(e)
    }, t.BackSide = Pe, t.BasicDepthPacking = Dt, t.BasicShadowMap = q, t.BinaryTextureLoader = function (e) {
        return console.warn("v3d.BinaryTextureLoader has been renamed to v3d.DataTextureLoader."), new Fu(e)
    }, t.BlenderCubeTextureLoader = sv, t.BloomPass = Km, t.BokehPass = ev, t.Bone = Is, t.BooleanKeyframeTrack = yu, t.BoundingBoxHelper = function (e, t) {
        return console.warn("v3d.BoundingBoxHelper has been deprecated. Creating a v3d.BoxHelper instead."), new np(e, t)
    }, t.Box2 = Ph, t.Box3 = Kn, t.Box3Helper = rp, t.BoxBufferGeometry = Pi, t.BoxGeometry = Ci, t.BoxHelper = np, t.BrightnessContrastPass = $m, t.BufferAttribute = zr, t.BufferGeometry = ni, t.BufferGeometryLoader = Td, t.ByteType = i, t.CENTER = 0, t.CSVParser = iy, t.Cache = Cu, t.Camera = Fi, t.CameraHelper = $h, t.CameraUtils = Qd, t.CanvasRenderer = function () {
        console.error("v3d.CanvasRenderer has been removed")
    }, t.CanvasTexture = al, t.CatmullRomCurve3 = qu, t.ChildOfConstraint = Lm, t.CineonToneMapping = X, t.CircleBufferGeometry = gc, t.CircleGeometry = vc, t.ClampToEdgeWrapping = Ye, t.ClearMaskPass = rv, t.Clock = Kd, t.ClosedSplineCurve3 = up, t.Color = Pr, t.ColorKeyframeTrack = xu, t.Compat = tv, t.CompressedTexture = il, t.CompressedTextureLoader = Ou, t.ConeBufferGeometry = mc, t.ConeGeometry = fc, t.Constraint = Cm, t.CopyLocationConstraint = Rm, t.CopyRotationConstraint = Dm, t.CopyScaleConstraint = Im, t.CubeCamera = zi, t.CubeGeometry = Ci, t.CubeReflectionMapping = Ue, t.CubeRefractionMapping = Ve, t.CubeTexture = ua, t.CubeTextureHelper = gy, t.CubeTextureLoader = zu, t.CubeUVReflectionMapping = We, t.CubeUVRefractionMapping = Xe, t.CubicBezierCurve = Ju, t.CubicBezierCurve3 = $u, t.CubicInterpolant = gu, t.CullFaceBack = K, t.CullFaceFront = J, t.CullFaceFrontBack = 3, t.CullFaceNone = Q, t.Curve = Vu, t.CurvePath = cd, t.CustomBlending = ue, t.CylinderBufferGeometry = pc, t.CylinderGeometry = hc, t.Cylindrical = Eh, t.DataTexture = Vi, t.DataTexture2DArray = da, t.DataTexture3D = ha, t.DataTextureLoader = Fu, t.DecrementStencilOp = 7683, t.DecrementWrapStencilOp = 34056, t.DefaultLoadingManager = Lu, t.DepthFormat = ct, t.DepthStencilFormat = ut, t.DepthTexture = ol, t.Detector = $o, t.DirectionalLight = yd, t.DirectionalLightHelper = Qh, t.DirectionalLightShadow = gd, t.DirectionalLightShadowCSM = _d, t.DiscreteInterpolant = Rc, t.DodecahedronBufferGeometry = yl, t.DodecahedronGeometry = _l, t.DoubleSide = ie, t.DstAlphaFactor = we, t.DstColorFactor = Ae, t.DynamicBufferAttribute = function (e, t) {
        return console.warn("v3d.DynamicBufferAttribute has been removed. Use new v3d.BufferAttribute().setUsage(v3d.DynamicDrawUsage) instead."), new zr(e, t).setUsage(Gt)
    }, t.DynamicCopyUsage = 35050, t.DynamicDrawUsage = Gt, t.DynamicReadUsage = 35049, t.ESMDistancePacking = Ot, t.ESMShadowMap = te, t.EdgesGeometry = dc, t.EdgesHelper = function (e, t) {
        return console.warn("v3d.EdgesHelper has been removed. Use v3d.EdgesGeometry instead."), new qs(new dc(e.geometry), new Us({
            color: void 0 !== t ? t : 16777215
        }))
    }, t.EffectComposer = iv, t.EllipseCurve = Gu, t.EqualDepth = De, t.EqualStencilFunc = 514, t.EquiCube = Xm, t.EquirectangularReflectionMapping = Ge, t.EquirectangularRefractionMapping = ke, t.Euler = gn, t.EventDispatcher = o, t.ExtrudeBufferGeometry = Kl, t.ExtrudeGeometry = Ql, t.FXAAPass = av, t.Face3 = Ir, t.Face4 = function (e, t, n, r, i, a, o) {
        return console.warn("v3d.Face4 has been removed. A v3d.Face3 will be created instead."), new Ir(e, t, n, i, a, o)
    }, t.FaceColors = 1, t.FileLoader = Iu, t.FilmicBlenderToneMapping = Y, t.FirstPersonControls = km, t.FlatShading = 1, t.Float32Attribute = function (e, t) {
        return console.warn("v3d.Float32Attribute has been removed. Use new v3d.Float32BufferAttribute() instead."), new Hr(e, t)
    }, t.Float32BufferAttribute = Hr, t.Float64Attribute = function (e, t) {
        return console.warn("v3d.Float64Attribute has been removed. Use new v3d.Float64BufferAttribute() instead."), new Yr(e, t)
    }, t.Float64BufferAttribute = Yr, t.FloatType = it, t.FloorConstraint = Nm, t.FlyingControls = jm, t.Fog = os, t.FogExp2 = as, t.Font = Od, t.FontLoader = Bd, t.FrontFaceDirectionCCW = 1, t.FrontFaceDirectionCW = 0, t.FrontSide = re, t.Frustum = ji, t.GLTFLoader = bg, t.GammaEncoding = Tt, t.Geometry = Ei, t.GeometryUtils = pp, t.GraphUtils = Dc, t.GrayscalePass = t_, t.GreaterDepth = Ne, t.GreaterEqualDepth = Ie, t.GreaterEqualStencilFunc = 518, t.GreaterStencilFunc = 516, t.GridHelper = Xh, t.Group = Jo, t.HalfFloatType = at, t.HemisphereLight = pd, t.HemisphereLightHelper = Wh, t.HemisphereLightProbe = kd, t.IcosahedronBufferGeometry = gl, t.IcosahedronGeometry = vl, t.ImageBitmapLoader = Id, t.ImageLoader = Bu, t.ImageUtils = Qt, t.ImmediateRenderObject = Ih, t.IncrementStencilOp = 7682, t.IncrementWrapStencilOp = 34055, t.InstancedBufferAttribute = Sd, t.InstancedBufferGeometry = Ad, t.InstancedInterleavedBuffer = Th, t.InstancedMesh = zs, t.Int16Attribute = function (e, t) {
        return console.warn("v3d.Int16Attribute has been removed. Use new v3d.Int16BufferAttribute() instead."), new kr(e, t)
    }, t.Int16BufferAttribute = kr, t.Int32Attribute = function (e, t) {
        return console.warn("v3d.Int32Attribute has been removed. Use new v3d.Int32BufferAttribute() instead."), new Wr(e, t)
    }, t.Int32BufferAttribute = Wr, t.Int8Attribute = function (e, t) {
        return console.warn("v3d.Int8Attribute has been removed. Use new v3d.Int8BufferAttribute() instead."), new Ur(e, t)
    }, t.Int8BufferAttribute = Ur, t.IntType = l, t.InterleavedBuffer = ss, t.InterleavedBufferAttribute = us, t.Interpolant = Lc, t.InterpolateDiscrete = _t, t.InterpolateLinear = yt, t.InterpolateSmooth = xt, t.InvertStencilOp = 5386, t.JSONLoader = function () {
        console.error("v3d.JSONLoader has been removed.")
    }, t.KeepStencilOp = zt, t.KeyframeTrack = _u, t.Keys = Vm, t.LOD = Cs, t.LatheBufferGeometry = sc, t.LatheGeometry = oc, t.Layers = _n, t.LensFlare = function () {
        console.error("v3d.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }, t.LessDepth = Le, t.LessEqualDepth = Re, t.LessEqualStencilFunc = 515, t.LessStencilFunc = 513, t.Light = hd, t.LightProbe = Gd, t.LightShadow = Ro, t.LimitLocationConstraint = Om, t.LimitRotationConstraint = Fm, t.LimitScaleConstraint = Bm, t.Line = Xs, t.Line3 = Dh, t.LineBasicMaterial = Us, t.LineCurve = ed, t.LineCurve3 = td, t.LineDashedMaterial = Cc, t.LineHTML = cy, t.LineLoop = Zs, t.LinePieces = 1, t.LineSegments = qs, t.LineStrip = 0, t.LinearDepthPacking = 3202, t.LinearEncoding = At, t.LinearFilter = Je, t.LinearInterpolant = Vc, t.LinearMipMapLinearFilter = 1008, t.LinearMipMapNearestFilter = 1007, t.LinearMipmapLinearFilter = et, t.LinearMipmapNearestFilter = $e, t.LinearToneMapping = Fe, t.Loader = Ru, t.LoaderUtils = Md, t.LoadingManager = Pu, t.LockedTrackConstraint = zm, t.LogLuvEncoding = Ct, t.LogarithmicMaxToneMapping = Be, t.LoopOnce = 2200, t.LoopPingPong = 2202, t.LoopRepeat = 2201, t.LuminanceAlphaFormat = f, t.LuminanceFormat = p, t.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    }, t.MaskPass = nv, t.Material = Or, t.MaterialLoader = wd, t.MaterialUtils = Em, t.Math = Yt, t.MathUtils = Yt, t.Matrix3 = Zt, t.Matrix4 = fn, t.MaxEquation = me, t.Mesh = xi, t.MeshBVH = zf, t.MeshBasicMaterial = Fr, t.MeshDepthMaterial = Uo, t.MeshDistanceMaterial = Vo, t.MeshFaceMaterial = function (e) {
        return console.warn("v3d.MeshFaceMaterial has been removed. Use an Array instead."), e
    }, t.MeshLambertMaterial = Tc, t.MeshLine = pg, t.MeshLineIndexed = gg, t.MeshLineMaterial = yg, t.MeshMaskMaterial = Pc, t.MeshMatcapMaterial = Ec, t.MeshNodeMaterial = hu, t.MeshNormalMaterial = Sc, t.MeshPhongMaterial = Mc, t.MeshPhysicalMaterial = wc, t.MeshStandardMaterial = bc, t.MeshToonMaterial = Ac, t.MinEquation = fe, t.MirroredRepeatWrapping = qe, t.MixOperation = V, t.MultiMaterial = function (e) {
        return void 0 === e && (e = []), console.warn("v3d.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, (e.materials = e).clone = function () {
            return e.slice()
        }, e
    }, t.MultiplyBlending = ce, t.MultiplyOperation = U, t.NearestFilter = Ze, t.NearestMipMapLinearFilter = 1005, t.NearestMipMapNearestFilter = 1004, t.NearestMipmapLinearFilter = Ke, t.NearestMipmapNearestFilter = Qe, t.NeverDepth = Ee, t.NeverStencilFunc = 512, t.NoBlending = ae, t.NoColors = s, t.NoToneMapping = k, t.NormalBlending = oe, t.NotEqualDepth = Oe, t.NotEqualStencilFunc = 517, t.NumberKeyframeTrack = bu, t.Object3D = Fn, t.ObjectLoader = Cd, t.ObjectSpaceNormalMap = Bt, t.OctahedronBufferGeometry = ml, t.OctahedronGeometry = fl, t.OneFactor = ge, t.OneMinusDstAlphaFactor = Me, t.OneMinusDstColorFactor = Se, t.OneMinusSrcAlphaFactor = be, t.OneMinusSrcColorFactor = ye, t.OrbitControls = Wm, t.OrthographicCamera = qi, t.OutlinePass = n_, t.PCFShadowMap = Z, t.PCFShadowMapPoissonDisk = ne, t.PCFSoftShadowMap = $, t.PMREMGenerator = C_, t.ParametricBufferGeometry = cl, t.ParametricGeometry = ll, t.Particle = function (e) {
        return console.warn("v3d.Particle has been renamed to v3d.Sprite."), new As(e)
    }, t.ParticleBasicMaterial = function (e) {
        return console.warn("v3d.ParticleBasicMaterial has been renamed to v3d.PointsMaterial."), new Qs(e)
    }, t.ParticleSystem = function (e, t) {
        return console.warn("v3d.ParticleSystem has been renamed to v3d.Points."), new tl(e, t)
    }, t.ParticleSystemMaterial = function (e) {
        return console.warn("v3d.ParticleSystemMaterial has been renamed to v3d.PointsMaterial."), new Qs(e)
    }, t.Pass = Zm, t.Path = ud, t.PerspectiveCamera = Bi, t.PhysicalMaxToneMapping = ze, t.Plane = fr, t.PlaneBufferGeometry = Qi, t.PlaneGeometry = Zi, t.PlaneHelper = ip, t.PointCloud = function (e, t) {
        return console.warn("v3d.PointCloud has been renamed to v3d.Points."), new tl(e, t)
    }, t.PointCloudMaterial = function (e) {
        return console.warn("v3d.PointCloudMaterial has been renamed to v3d.PointsMaterial."), new Qs(e)
    }, t.PointLight = vd, t.PointLightHelper = Vh, t.Points = tl, t.PointsMaterial = Qs, t.PolarGridHelper = Hh, t.PolyhedronBufferGeometry = dl, t.PolyhedronGeometry = ul, t.PositionalAudio = lh, t.Preloader = uy, t.PropertyBinding = bh, t.PropertyMixer = uh, t.PuzzlesLoader = vy, t.QuadraticBezierCurve = nd, t.QuadraticBezierCurve3 = rd, t.Quaternion = nn, t.QuaternionKeyframeTrack = Mu, t.QuaternionLinearInterpolant = wu, t.REVISION = r, t.RGBADepthPacking = It, t.RGBADistancePacking = Nt, t.RGBAFormat = lt, t.RGBAIntegerFormat = x, t.RGBA_ASTC_10x10_Format = mt, t.RGBA_ASTC_10x5_Format = ht, t.RGBA_ASTC_10x6_Format = pt, t.RGBA_ASTC_10x8_Format = ft, t.RGBA_ASTC_12x10_Format = vt, t.RGBA_ASTC_12x12_Format = gt, t.RGBA_ASTC_4x4_Format = R, t.RGBA_ASTC_5x4_Format = D, t.RGBA_ASTC_5x5_Format = I, t.RGBA_ASTC_6x5_Format = N, t.RGBA_ASTC_6x6_Format = O, t.RGBA_ASTC_8x5_Format = F, t.RGBA_ASTC_8x6_Format = B, t.RGBA_ASTC_8x8_Format = z, t.RGBA_PVRTC_2BPPV1_Format = P, t.RGBA_PVRTC_4BPPV1_Format = C, t.RGBA_S3TC_DXT1_Format = w, t.RGBA_S3TC_DXT3_Format = M, t.RGBA_S3TC_DXT5_Format = A, t.RGBDEncoding = Rt, t.RGBEEncoding = Et, t.RGBEFormat = S, t.RGBELoader = dg, t.RGBFormat = st, t.RGBIntegerFormat = y, t.RGBM16Encoding = Lt, t.RGBM7Encoding = Pt, t.RGB_ETC1_Format = L, t.RGB_PVRTC_2BPPV1_Format = E, t.RGB_PVRTC_4BPPV1_Format = T, t.RGB_S3TC_DXT1_Format = b, t.RGFormat = v, t.RGIntegerFormat = g, t.RawShaderMaterial = xc, t.Ray = ur, t.Raycaster = es, t.RectAreaLight = bd, t.RedFormat = dt, t.RedIntegerFormat = m, t.ReinhardToneMapping = j, t.RenderPass = G_, t.RenderUtils = j_, t.RepeatWrapping = He, t.ReplaceStencilOp = 7681, t.ReverseSubtractEquation = pe, t.RingBufferGeometry = ac, t.RingGeometry = ic, t.SAH = 2, t.SSAARenderPass = Z_, t.SSAOPass = Y_, t.Scene = Bn, t.SceneBackground = W_, t.SceneUtils = H_, t.ShaderChunk = Ki, t.ShaderLib = Ji, t.ShaderMaterial = Oi, t.ShaderPass = Jm, t.ShadowMaterial = yc, t.Shape = dd, t.ShapeBufferGeometry = cc, t.ShapeGeometry = lc, t.ShapePath = Nd, t.ShapeUtils = Yl, t.ShortType = a, t.SimplePreloader = dy, t.Skeleton = Ds, t.SkeletonHelper = Uh, t.SkinnedMesh = Ps, t.SmoothShading = 2, t.Sphere = nr, t.SphereBufferGeometry = rc, t.SphereGeometry = nc, t.Spherical = Yc, t.SphericalHarmonics3 = Vd, t.SphericalReflectionMapping = je, t.Spline = hp, t.SplineCurve = id, t.SplineCurve3 = dp, t.SpotLight = fd, t.SpotLightHelper = Oh, t.SpotLightShadow = Do, t.Sprite = As, t.SpriteMaterial = ds, t.SrcAlphaFactor = xe, t.SrcAlphaSaturateFactor = Te, t.SrcColorFactor = _e, t.StaticCopyUsage = 35046, t.StaticDrawUsage = Vt, t.StaticReadUsage = 35045, t.StereoCamera = Hd, t.StreamCopyUsage = 35042, t.StreamDrawUsage = 35040, t.StreamReadUsage = 35041, t.StringKeyframeTrack = Au, t.SubtractEquation = he, t.SubtractiveBlending = le, t.TOUCH = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    }, t.TangentSpaceNormalMap = Ft, t.TargetConstraint = Pm, t.TetrahedronBufferGeometry = pl, t.TetrahedronGeometry = hl, t.TextBufferGeometry = tc, t.TextGeometry = ec, t.Texture = Jt, t.TextureLoader = Uu, t.ToneMapPass = Q_, t.TorusBufferGeometry = Sl, t.TorusGeometry = Al, t.TorusKnotBufferGeometry = Ml, t.TorusKnotGeometry = wl, t.TrackToConstraint = Um, t.Triangle = Sr, t.TriangleFanDrawMode = 2, t.TriangleStripDrawMode = 1, t.TrianglesDrawMode = 0, t.TubeBufferGeometry = bl, t.TubeGeometry = xl, t.UVMapping = 300, t.Uint16Attribute = function (e, t) {
        return console.warn("v3d.Uint16Attribute has been removed. Use new v3d.Uint16BufferAttribute() instead."), new jr(e, t)
    }, t.Uint16BufferAttribute = jr, t.Uint32Attribute = function (e, t) {
        return console.warn("v3d.Uint32Attribute has been removed. Use new v3d.Uint32BufferAttribute() instead."), new Xr(e, t)
    }, t.Uint32BufferAttribute = Xr, t.Uint8Attribute = function (e, t) {
        return console.warn("v3d.Uint8Attribute has been removed. Use new v3d.Uint8BufferAttribute() instead."), new Vr(e, t)
    }, t.Uint8BufferAttribute = Vr, t.Uint8ClampedAttribute = function (e, t) {
        return console.warn("v3d.Uint8ClampedAttribute has been removed. Use new v3d.Uint8ClampedBufferAttribute() instead."), new Gr(e, t)
    }, t.Uint8ClampedBufferAttribute = Gr, t.Uncharted2ToneMapping = W, t.Uniform = Sh, t.UniformsLib = Wi, t.UniformsUtils = Di, t.UnsignedByteType = tt, t.UnsignedInt248Type = ot, t.UnsignedIntType = rt, t.UnsignedShort4444Type = c, t.UnsignedShort5551Type = u, t.UnsignedShort565Type = d, t.UnsignedShortType = nt, t.V3DL = kt, t.VSMShadowMap = ee, t.Vector2 = qt, t.Vector3 = on, t.Vector4 = $t, t.VectorKeyframeTrack = Su, t.Vertex = function (e, t, n) {
        return console.warn("v3d.Vertex has been removed. Use v3d.Vector3 instead."), new on(e, t, n)
    }, t.VertexColors = _, t.VideoTexture = rl, t.ViewportFitAuto = 3, t.ViewportFitHorizontal = 2, t.ViewportFitNone = jt, t.ViewportFitVertical = 1, t.Visualizer = jf, t.WebGLCubeRenderTarget = Ui, t.WebGLMultisampleRenderTarget = tn, t.WebGLRenderTarget = en, t.WebGLRenderTargetCube = function (e, t, n) {
        return console.warn("v3d.WebGLRenderTargetCube(width, height, options) is now WebGLCubeRenderTarget(size, options)."), new Ui(e, n)
    }, t.WebGLRenderer = is, t.WebGLUtils = qo, t.WebXRUtils = wy, t.WireframeGeometry = sl, t.WireframeHelper = function (e, t) {
        return console.warn("v3d.WireframeHelper has been removed. Use v3d.WireframeGeometry instead."), new qs(new sl(e.geometry), new Us({
            color: void 0 !== t ? t : 16777215
        }))
    }, t.WrapAroundEnding = Mt, t.XHRLoader = function (e) {
        return console.warn("v3d.XHRLoader has been renamed to v3d.FileLoader."), new Iu(e)
    }, t.XZ = cv, t.XZLoader = ug, t.ZeroCurvatureEnding = bt, t.ZeroFactor = ve, t.ZeroSlopeEnding = wt, t.ZeroStencilOp = 0, t.acceleratedRaycast = Yf, t.arrayMax = yn, t.arrayMin = function (e) {
        if (0 === e.length) return 1 / 0;
        for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] < t && (t = e[n]);
        return t
    }, t.clampArray = bn, t.computeBoundsTree = qf, t.disposeBoundsTree = Zf, t.isDef = xn, t.sRGBEncoding = St, Object.defineProperty(t, "__esModule", {
        value: !0
    })
});